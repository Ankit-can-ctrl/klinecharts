/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nconst Icon = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    color = \"currentColor\",\n    size = 24,\n    strokeWidth = 2,\n    absoluteStrokeWidth,\n    className = \"\",\n    children,\n    iconNode,\n    ...rest\n  }, ref) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n    \"svg\",\n    {\n      ref,\n      ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n      width: size,\n      height: size,\n      stroke: color,\n      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n      className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n      ...!children && !(0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.hasA11yProp)(rest) && { \"aria-hidden\": \"true\" },\n      ...rest\n    },\n    [\n      ...iconNode.map(([tag, attrs]) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs)),\n      ...Array.isArray(children) ? children : [children]\n    ]\n  )\n);\n\n\n//# sourceMappingURL=Icon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDSztBQUNXOztBQUVsRSxhQUFhLGlEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVSxvREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrRUFBWTtBQUM3Qix1QkFBdUIsaUVBQVcsWUFBWSx1QkFBdUI7QUFDckU7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0Msb0RBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcz9kZjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU0Mi4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCBoYXNBMTF5UHJvcCB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplID0gMjQsXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICBjaGlsZHJlbixcbiAgICBpY29uTm9kZSxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4gY3JlYXRlRWxlbWVudChcbiAgICBcInN2Z1wiLFxuICAgIHtcbiAgICAgIHJlZixcbiAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgd2lkdGg6IHNpemUsXG4gICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKFwibHVjaWRlXCIsIGNsYXNzTmFtZSksXG4gICAgICAuLi4hY2hpbGRyZW4gJiYgIWhhc0ExMXlQcm9wKHJlc3QpICYmIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgW1xuICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgLi4uQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl1cbiAgICBdXG4gIClcbik7XG5cbmV4cG9ydCB7IEljb24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n    ({ className, ...props }, ref) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n      ref,\n      iconNode,\n      className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\n        `lucide-${(0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName))}`,\n        `lucide-${iconName}`,\n        className\n      ),\n      ...props\n    })\n  );\n  Component.displayName = (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName);\n  return Component;\n};\n\n\n//# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDOEI7QUFDbkQ7O0FBRTdCO0FBQ0Esb0JBQW9CLGlEQUFVO0FBQzlCLE9BQU8scUJBQXFCLFVBQVUsb0RBQWEsQ0FBQyxnREFBSTtBQUN4RDtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFZO0FBQzdCLGtCQUFrQixpRUFBVyxDQUFDLGtFQUFZLFlBQVk7QUFDdEQsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLGtFQUFZO0FBQ3RDO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcz8wMzFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU0Mi4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSwgdG9QYXNjYWxDYXNlIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWUsIGljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoXG4gICAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcbiAgICAgICAgYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKHRvUGFzY2FsQ2FzZShpY29uTmFtZSkpfWAsXG4gICAgICAgIGBsdWNpZGUtJHtpY29uTmFtZX1gLFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gICk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IHRvUGFzY2FsQ2FzZShpY29uTmFtZSk7XG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVMdWNpZGVJY29uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n\n\n//# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzP2U1NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTQyLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/plus.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Plus; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst __iconNode = [\n  [\"path\", { d: \"M5 12h14\", key: \"1ays0h\" }],\n  [\"path\", { d: \"M12 5v14\", key: \"s699le\" }]\n];\nconst Plus = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"plus\", __iconNode);\n\n\n//# sourceMappingURL=plus.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvcGx1cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNEOztBQUV0RDtBQUNBLGFBQWEsOEJBQThCO0FBQzNDLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0EsYUFBYSxnRUFBZ0I7O0FBRVU7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9wbHVzLmpzPzYyNDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTQyLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNNSAxMmgxNFwiLCBrZXk6IFwiMWF5czBoXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiA1djE0XCIsIGtleTogXCJzNjk5bGVcIiB9XVxuXTtcbmNvbnN0IFBsdXMgPSBjcmVhdGVMdWNpZGVJY29uKFwicGx1c1wiLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IHsgX19pY29uTm9kZSwgUGx1cyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/settings.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Settings; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst __iconNode = [\n  [\n    \"path\",\n    {\n      d: \"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915\",\n      key: \"1i5ecw\"\n    }\n  ],\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"3\", key: \"1v7zrd\" }]\n];\nconst Settings = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"settings\", __iconNode);\n\n\n//# sourceMappingURL=settings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQTJDO0FBQzFEO0FBQ0EsaUJBQWlCLGdFQUFnQjs7QUFFVTtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3NldHRpbmdzLmpzPzIxMWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTQyLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNOS42NzEgNC4xMzZhMi4zNCAyLjM0IDAgMCAxIDQuNjU5IDAgMi4zNCAyLjM0IDAgMCAwIDMuMzE5IDEuOTE1IDIuMzQgMi4zNCAwIDAgMSAyLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMCAwIDMuODMxIDIuMzQgMi4zNCAwIDAgMS0yLjMzIDQuMDMzIDIuMzQgMi4zNCAwIDAgMC0zLjMxOSAxLjkxNSAyLjM0IDIuMzQgMCAwIDEtNC42NTkgMCAyLjM0IDIuMzQgMCAwIDAtMy4zMi0xLjkxNSAyLjM0IDIuMzQgMCAwIDEtMi4zMy00LjAzMyAyLjM0IDIuMzQgMCAwIDAgMC0zLjgzMUEyLjM0IDIuMzQgMCAwIDEgNi4zNSA2LjA1MWEyLjM0IDIuMzQgMCAwIDAgMy4zMTktMS45MTVcIixcbiAgICAgIGtleTogXCIxaTVlY3dcIlxuICAgIH1cbiAgXSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiMTJcIiwgcjogXCIzXCIsIGtleTogXCIxdjd6cmRcIiB9XVxuXTtcbmNvbnN0IFNldHRpbmdzID0gY3JlYXRlTHVjaWRlSWNvbihcInNldHRpbmdzXCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBTZXR0aW5ncyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trending-up.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/trending-up.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ TrendingUp; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst __iconNode = [\n  [\"path\", { d: \"M16 7h6v6\", key: \"box55l\" }],\n  [\"path\", { d: \"m22 7-8.5 8.5-5-5L2 17\", key: \"1t1m79\" }]\n];\nconst TrendingUp = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"trending-up\", __iconNode);\n\n\n//# sourceMappingURL=trending-up.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdHJlbmRpbmctdXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdEQ7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLDRDQUE0QztBQUN6RDtBQUNBLG1CQUFtQixnRUFBZ0I7O0FBRVU7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy90cmVuZGluZy11cC5qcz9mYmJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjU0Mi4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgX19pY29uTm9kZSA9IFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE2IDdoNnY2XCIsIGtleTogXCJib3g1NWxcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwibTIyIDctOC41IDguNS01LTVMMiAxN1wiLCBrZXk6IFwiMXQxbTc5XCIgfV1cbl07XG5jb25zdCBUcmVuZGluZ1VwID0gY3JlYXRlTHVjaWRlSWNvbihcInRyZW5kaW5nLXVwXCIsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgeyBfX2ljb25Ob2RlLCBUcmVuZGluZ1VwIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyZW5kaW5nLXVwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trending-up.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js":
/*!*******************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/x.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ X; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\n\n\nconst __iconNode = [\n  [\"path\", { d: \"M18 6 6 18\", key: \"1bl5f8\" }],\n  [\"path\", { d: \"m6 6 12 12\", key: \"d8bk6v\" }]\n];\nconst X = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"x\", __iconNode);\n\n\n//# sourceMappingURL=x.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNEOztBQUV0RDtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsVUFBVSxnRUFBZ0I7O0FBRVU7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy94LmpzP2VhNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTQyLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMTggNiA2IDE4XCIsIGtleTogXCIxYmw1ZjhcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwibTYgNiAxMiAxMlwiLCBrZXk6IFwiZDhiazZ2XCIgfV1cbl07XG5jb25zdCBYID0gY3JlYXRlTHVjaWRlSWNvbihcInhcIiwgX19pY29uTm9kZSk7XG5cbmV4cG9ydCB7IF9faWNvbk5vZGUsIFggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasA11yProp: function() { return /* binding */ hasA11yProp; },\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; },\n/* harmony export */   toCamelCase: function() { return /* binding */ toCamelCase; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; },\n/* harmony export */   toPascalCase: function() { return /* binding */ toPascalCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.542.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst toCamelCase = (string) => string.replace(\n  /^([A-Z])|[\\s-_]+(\\w)/g,\n  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()\n);\nconst toPascalCase = (string) => {\n  const camelCase = toCamelCase(string);\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n};\nconst mergeClasses = (...classes) => classes.filter((className, index, array) => {\n  return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n}).join(\" \").trim();\nconst hasA11yProp = (props) => {\n  for (const prop in props) {\n    if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\") {\n      return true;\n    }\n  }\n};\n\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RTtBQUM3RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanM/OTAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41NDIuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgdG9DYW1lbENhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZShcbiAgL14oW0EtWl0pfFtcXHMtX10rKFxcdykvZyxcbiAgKG1hdGNoLCBwMSwgcDIpID0+IHAyID8gcDIudG9VcHBlckNhc2UoKSA6IHAxLnRvTG93ZXJDYXNlKClcbik7XG5jb25zdCB0b1Bhc2NhbENhc2UgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKHN0cmluZyk7XG4gIHJldHVybiBjYW1lbENhc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbENhc2Uuc2xpY2UoMSk7XG59O1xuY29uc3QgbWVyZ2VDbGFzc2VzID0gKC4uLmNsYXNzZXMpID0+IGNsYXNzZXMuZmlsdGVyKChjbGFzc05hbWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjbGFzc05hbWUpICYmIGNsYXNzTmFtZS50cmltKCkgIT09IFwiXCIgJiYgYXJyYXkuaW5kZXhPZihjbGFzc05hbWUpID09PSBpbmRleDtcbn0pLmpvaW4oXCIgXCIpLnRyaW0oKTtcbmNvbnN0IGhhc0ExMXlQcm9wID0gKHByb3BzKSA9PiB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoXCJhcmlhLVwiKSB8fCBwcm9wID09PSBcInJvbGVcIiB8fCBwcm9wID09PSBcInRpdGxlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHsgaGFzQTExeVByb3AsIG1lcmdlQ2xhc3NlcywgdG9DYW1lbENhc2UsIHRvS2ViYWJDYXNlLCB0b1Bhc2NhbENhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cakpxi%5CDocuments%5Ccursor%5Cren1%5Csrc%5Ccomponents%5CBollingerBandsChart.tsx&server=false!":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cakpxi%5CDocuments%5Ccursor%5Cren1%5Csrc%5Ccomponents%5CBollingerBandsChart.tsx&server=false! ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/BollingerBandsChart.tsx */ \"(app-pages-browser)/./src/components/BollingerBandsChart.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUNha3B4aSU1Q0RvY3VtZW50cyU1Q2N1cnNvciU1Q3JlbjElNUNzcmMlNUNjb21wb25lbnRzJTVDQm9sbGluZ2VyQmFuZHNDaGFydC50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2VhOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFxha3B4aVxcXFxEb2N1bWVudHNcXFxcY3Vyc29yXFxcXHJlbjFcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcQm9sbGluZ2VyQmFuZHNDaGFydC50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cakpxi%5CDocuments%5Ccursor%5Cren1%5Csrc%5Ccomponents%5CBollingerBandsChart.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/BollingerBandsChart.tsx":
/*!************************************************!*\
  !*** ./src/components/BollingerBandsChart.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_BOLLINGER_STYLE: function() { return /* binding */ DEFAULT_BOLLINGER_STYLE; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var klinecharts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! klinecharts */ \"(app-pages-browser)/./node_modules/klinecharts/dist/index.esm.js\");\n/* harmony import */ var _barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Plus,Settings,TrendingUp,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/plus.js\");\n/* harmony import */ var _barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=Plus,Settings,TrendingUp,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/trending-up.js\");\n/* harmony import */ var _barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Plus,Settings,TrendingUp,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/settings.js\");\n/* harmony import */ var _barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Plus,Settings,TrendingUp,X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _data_sampleData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/data/sampleData */ \"(app-pages-browser)/./src/data/sampleData.ts\");\n/* harmony import */ var _utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/bollingerBands */ \"(app-pages-browser)/./src/utils/bollingerBands.ts\");\n/* harmony import */ var _BollingerBandsSettings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BollingerBandsSettings */ \"(app-pages-browser)/./src/components/BollingerBandsSettings.tsx\");\n/* __next_internal_client_entry_do_not_use__ DEFAULT_BOLLINGER_STYLE,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst DEFAULT_BOLLINGER_STYLE = {\n    basis: {\n        visible: true,\n        color: \"#3B82F6\",\n        lineWidth: 1,\n        lineStyle: \"solid\"\n    },\n    upper: {\n        visible: true,\n        color: \"#EF4444\",\n        lineWidth: 1,\n        lineStyle: \"solid\"\n    },\n    lower: {\n        visible: true,\n        color: \"#22C55E\",\n        lineWidth: 1,\n        lineStyle: \"solid\"\n    },\n    fill: {\n        visible: true,\n        opacity: 0.08\n    }\n};\n// Track if indicator is already registered\nlet isIndicatorRegistered = false;\n// Register custom Bollinger Bands indicator\nconst registerBollingerBandsIndicator = ()=>{\n    if (isIndicatorRegistered) {\n        console.log(\"BOLL indicator already registered, skipping...\");\n        return;\n    }\n    console.log(\"Registering Bollinger Bands indicator...\");\n    try {\n        (0,klinecharts__WEBPACK_IMPORTED_MODULE_2__.registerIndicator)({\n            name: \"BOLL\",\n            shortName: \"BOLL\",\n            series: klinecharts__WEBPACK_IMPORTED_MODULE_2__.IndicatorSeries.Price,\n            calcParams: [\n                20,\n                2\n            ],\n            shouldOhlc: true,\n            precision: 2,\n            figures: [\n                {\n                    key: \"up\",\n                    title: \"BOLL-UP: \",\n                    type: \"line\",\n                    baseValue: 0,\n                    attrs: (param)=>{\n                        let {} = param;\n                        return {\n                            color: \"#EF4444\",\n                            lineWidth: 2\n                        };\n                    }\n                },\n                {\n                    key: \"mid\",\n                    title: \"BOLL-MID: \",\n                    type: \"line\",\n                    baseValue: 0,\n                    attrs: (param)=>{\n                        let {} = param;\n                        return {\n                            color: \"#3B82F6\",\n                            lineWidth: 2\n                        };\n                    }\n                },\n                {\n                    key: \"dn\",\n                    title: \"BOLL-DN: \",\n                    type: \"line\",\n                    baseValue: 0,\n                    attrs: (param)=>{\n                        let {} = param;\n                        return {\n                            color: \"#22C55E\",\n                            lineWidth: 2\n                        };\n                    }\n                }\n            ],\n            calc: (dataList, indicator)=>{\n                console.log(\"Calculating Bollinger Bands for\", dataList.length, \"data points\");\n                const { calcParams } = indicator;\n                const [length, stdDevMultiplier] = calcParams;\n                const params = {\n                    length,\n                    stdDevMultiplier,\n                    offset: 0,\n                    source: \"close\",\n                    maType: \"SMA\"\n                };\n                const candleData = dataList.map((d)=>({\n                        timestamp: d.timestamp,\n                        open: d.open,\n                        high: d.high,\n                        low: d.low,\n                        close: d.close,\n                        volume: d.volume || 0\n                    }));\n                const bollingerData = (0,_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__.calculateBollingerBands)(candleData, params);\n                const result = bollingerData.map((bb)=>({\n                        up: isNaN(bb.upper) ? null : bb.upper,\n                        mid: isNaN(bb.basis) ? null : bb.basis,\n                        dn: isNaN(bb.lower) ? null : bb.lower\n                    }));\n                console.log(\"Bollinger calculation result (first 5):\", result.slice(0, 5));\n                console.log(\"Bollinger calculation result (last 5):\", result.slice(-5));\n                // Log some specific values to see if they're valid\n                const validResults = result.filter((r)=>r.up !== null && r.mid !== null && r.dn !== null);\n                console.log(\"Valid results: \".concat(validResults.length, \"/\").concat(result.length));\n                if (validResults.length > 0) {\n                    console.log(\"Sample valid result:\", validResults[0]);\n                }\n                return result;\n            }\n        });\n        isIndicatorRegistered = true;\n        console.log(\"Bollinger Bands indicator registered successfully\");\n        // Check what indicators are now available\n        const supportedIndicators = (0,klinecharts__WEBPACK_IMPORTED_MODULE_2__.getSupportedIndicators)();\n        console.log(\"Supported indicators after registration:\", supportedIndicators);\n    } catch (error) {\n        console.error(\"❌ Error registering Bollinger Bands indicator:\", error);\n    }\n};\nconst BollingerBandsChart = ()=>{\n    _s();\n    const chartContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showAddMenu, setShowAddMenu] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [indicatorAdded, setIndicatorAdded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [bollIndicatorId, setBollIndicatorId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Debug logging\n    console.log(\"BollingerBandsChart render - indicatorAdded:\", indicatorAdded, \"showAddMenu:\", showAddMenu);\n    const [bollingerParams, setBollingerParams] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BOLLINGER_PARAMS);\n    const [bollingerStyle, setBollingerStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(DEFAULT_BOLLINGER_STYLE);\n    const [bollingerData, setBollingerData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [crosshairData, setCrosshairData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Close add menu when clicking outside\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleClickOutside = (event)=>{\n            const target = event.target;\n            // Don't close if clicking on the add button or its children\n            if (target === null || target === void 0 ? void 0 : target.closest(\".add-indicator-container\")) {\n                return;\n            }\n            if (showAddMenu) {\n                setShowAddMenu(false);\n            }\n        };\n        if (showAddMenu) {\n            document.addEventListener(\"mousedown\", handleClickOutside);\n        }\n        return ()=>{\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [\n        showAddMenu\n    ]);\n    // Initialize chart\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _chartContainerRef_current;\n        if (!chartContainerRef.current) return;\n        // Register the custom Bollinger Bands indicator\n        registerBollingerBandsIndicator();\n        // Initialize KLineCharts with basic configuration\n        const chart = (0,klinecharts__WEBPACK_IMPORTED_MODULE_2__.init)(chartContainerRef.current);\n        chartRef.current = chart;\n        // Load sample data (convert to KLineData format)\n        const klineData = _data_sampleData__WEBPACK_IMPORTED_MODULE_3__.sampleData.map((item)=>({\n                timestamp: item.timestamp,\n                open: item.open,\n                high: item.high,\n                low: item.low,\n                close: item.close,\n                volume: item.volume\n            }));\n        chart === null || chart === void 0 ? void 0 : chart.applyNewData(klineData);\n        // Use mouse events for crosshair data since KLineCharts API varies\n        // Fallback to mouse events for crosshair data\n        const handleMouseMove = (event)=>{\n            if (indicatorAdded && bollIndicatorId && chartRef.current) {\n                var _chartContainerRef_current;\n                const rect = (_chartContainerRef_current = chartContainerRef.current) === null || _chartContainerRef_current === void 0 ? void 0 : _chartContainerRef_current.getBoundingClientRect();\n                if (rect) {\n                    const x = event.clientX - rect.left;\n                    // Try to get indicator data from the chart\n                    const indicators = chartRef.current.getIndicators({\n                        id: bollIndicatorId\n                    });\n                    if (indicators.length > 0) {\n                        const indicator = indicators[0];\n                        const result = indicator.result;\n                        if (result && result.length > 0) {\n                            const dataIndex = Math.floor(x / rect.width * result.length);\n                            if (dataIndex >= 0 && dataIndex < result.length) {\n                                const bbData = result[dataIndex];\n                                if (bbData && bbData.up !== null && bbData.mid !== null && bbData.dn !== null) {\n                                    var _sampleData_dataIndex;\n                                    // Get timestamp from original data\n                                    const timestamp = ((_sampleData_dataIndex = _data_sampleData__WEBPACK_IMPORTED_MODULE_3__.sampleData[dataIndex]) === null || _sampleData_dataIndex === void 0 ? void 0 : _sampleData_dataIndex.timestamp) || Date.now();\n                                    setCrosshairData({\n                                        timestamp,\n                                        basis: bbData.mid,\n                                        upper: bbData.up,\n                                        lower: bbData.dn\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        (_chartContainerRef_current = chartContainerRef.current) === null || _chartContainerRef_current === void 0 ? void 0 : _chartContainerRef_current.addEventListener(\"mousemove\", handleMouseMove);\n        // Cleanup function\n        return ()=>{\n            if (chartContainerRef.current) {\n                chartContainerRef.current.removeEventListener(\"mousemove\", handleMouseMove);\n            }\n            if (chartRef.current) {\n                (0,klinecharts__WEBPACK_IMPORTED_MODULE_2__.dispose)(chartContainerRef.current);\n                chartRef.current = null;\n            }\n        };\n    }, [\n        indicatorAdded,\n        bollIndicatorId\n    ]);\n    // Update indicator when params or style change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (indicatorAdded && bollIndicatorId && chartRef.current) {\n            // Update indicator parameters and styles\n            chartRef.current.overrideIndicator({\n                id: bollIndicatorId,\n                name: \"BOLL\",\n                calcParams: [\n                    bollingerParams.length,\n                    bollingerParams.stdDevMultiplier\n                ],\n                styles: {\n                    lines: [\n                        {\n                            color: bollingerStyle.upper.color,\n                            size: bollingerStyle.upper.lineWidth,\n                            style: bollingerStyle.upper.lineStyle === \"dashed\" ? klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Dashed : klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Solid\n                        },\n                        {\n                            color: bollingerStyle.basis.color,\n                            size: bollingerStyle.basis.lineWidth,\n                            style: bollingerStyle.basis.lineStyle === \"dashed\" ? klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Dashed : klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Solid\n                        },\n                        {\n                            color: bollingerStyle.lower.color,\n                            size: bollingerStyle.lower.lineWidth,\n                            style: bollingerStyle.lower.lineStyle === \"dashed\" ? klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Dashed : klinecharts__WEBPACK_IMPORTED_MODULE_2__.LineType.Solid\n                        }\n                    ]\n                }\n            });\n        }\n    }, [\n        bollingerParams,\n        bollingerStyle,\n        indicatorAdded,\n        bollIndicatorId\n    ]);\n    const handleParamsChange = (newParams)=>{\n        setBollingerParams(newParams);\n    };\n    const handleStyleChange = (newStyle)=>{\n        setBollingerStyle(newStyle);\n    };\n    const addBollingerBands = ()=>{\n        console.log(\"Adding Bollinger Bands indicator...\");\n        if (chartRef.current) {\n            console.log(\"Chart reference exists, creating indicator...\");\n            try {\n                // Create the indicator on the main price pane\n                console.log(\"Attempting to create BOLL indicator...\");\n                const indicatorId = chartRef.current.createIndicator(\"BOLL\");\n                console.log(\"Raw indicator ID result:\", indicatorId, \"Type:\", typeof indicatorId);\n                if (indicatorId) {\n                    setBollIndicatorId(indicatorId);\n                    setIndicatorAdded(true);\n                    console.log(\"✅ Bollinger Bands added successfully with ID:\", indicatorId);\n                    // Log the created indicator details\n                    const createdIndicator = chartRef.current.getIndicators({\n                        id: indicatorId\n                    })[0];\n                    console.log(\"Created indicator details:\", createdIndicator);\n                    // Check if the indicator has result data\n                    if (createdIndicator && createdIndicator.result) {\n                        console.log(\"Indicator result length:\", createdIndicator.result.length);\n                        console.log(\"Sample result data:\", createdIndicator.result.slice(-3));\n                    }\n                    // Log current indicators\n                    const indicators = chartRef.current.getIndicators();\n                    console.log(\"All indicators on chart:\", indicators);\n                    // Try to get the specific indicator we just created\n                    const ourIndicator = chartRef.current.getIndicators({\n                        name: \"BOLL\"\n                    });\n                    console.log(\"Our BOLL indicator:\", ourIndicator);\n                } else {\n                    console.error(\"❌ Failed to create Bollinger Bands indicator - ID is null/undefined\");\n                }\n            } catch (error) {\n                console.error(\"❌ Error creating indicator:\", error);\n            }\n        } else {\n            console.error(\"❌ Chart reference is null\");\n        }\n        setShowAddMenu(false);\n    };\n    const removeBollingerBands = ()=>{\n        if (chartRef.current && bollIndicatorId) {\n            chartRef.current.removeIndicator({\n                id: bollIndicatorId\n            });\n            setBollIndicatorId(null);\n        }\n        setIndicatorAdded(false);\n        setBollingerData([]);\n        setCrosshairData(null);\n        console.log(\"Bollinger Bands removed\");\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-screen bg-gray-900 relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chartContainerRef,\n                className: \"w-full h-full\",\n                style: {\n                    pointerEvents: \"auto\"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                lineNumber: 459,\n                columnNumber: 7\n            }, undefined),\n            crosshairData && indicatorAdded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-4 left-4 bg-gray-800 text-white p-3 rounded-lg shadow-lg text-sm border border-gray-700\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"font-semibold mb-2\",\n                        children: \"Bollinger Bands\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                        lineNumber: 468,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-1\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between gap-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-gray-400\",\n                                        children: \"Upper:\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 471,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            color: bollingerStyle.upper.color\n                                        },\n                                        children: (0,_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__.formatBollingerValue)(crosshairData.upper)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 472,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 470,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between gap-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-gray-400\",\n                                        children: \"Basis:\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 477,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            color: bollingerStyle.basis.color\n                                        },\n                                        children: (0,_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__.formatBollingerValue)(crosshairData.basis)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 478,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 476,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-between gap-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-gray-400\",\n                                        children: \"Lower:\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 483,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            color: bollingerStyle.lower.color\n                                        },\n                                        children: (0,_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_4__.formatBollingerValue)(crosshairData.lower)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 484,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 482,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                        lineNumber: 469,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                lineNumber: 467,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-4 right-4 flex gap-2 z-10\",\n                children: [\n                    !indicatorAdded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"relative add-indicator-container\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: (e)=>{\n                                    e.preventDefault();\n                                    e.stopPropagation();\n                                    console.log(\"Add Indicator button clicked!\", showAddMenu);\n                                    setShowAddMenu(!showAddMenu);\n                                },\n                                className: \"bg-green-600 hover:bg-green-700 text-white p-2 rounded-lg shadow-lg transition-colors flex items-center gap-1 cursor-pointer relative z-20\",\n                                title: \"Add Indicator\",\n                                type: \"button\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                                        size: 20\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 508,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-sm font-medium\",\n                                        children: \"Add Indicator\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                        lineNumber: 509,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 497,\n                                columnNumber: 13\n                            }, undefined),\n                            showAddMenu && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"absolute top-12 right-0 bg-gray-800 border border-gray-700 rounded-lg shadow-xl min-w-48 z-50\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"p-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-xs text-gray-400 px-2 py-1 font-medium\",\n                                            children: \"TECHNICAL INDICATORS\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                            lineNumber: 516,\n                                            columnNumber: 19\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: (e)=>{\n                                                e.preventDefault();\n                                                e.stopPropagation();\n                                                console.log(\"Bollinger Bands menu item clicked!\");\n                                                addBollingerBands();\n                                            },\n                                            className: \"w-full text-left px-3 py-2 hover:bg-gray-700 rounded flex items-center gap-2 text-white transition-colors cursor-pointer\",\n                                            type: \"button\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                    size: 16\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                                    lineNumber: 529,\n                                                    columnNumber: 21\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"font-medium\",\n                                                            children: \"Bollinger Bands\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                                            lineNumber: 531,\n                                                            columnNumber: 23\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"text-xs text-gray-400\",\n                                                            children: \"BB (20, 2)\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                                            lineNumber: 532,\n                                                            columnNumber: 23\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                                    lineNumber: 530,\n                                                    columnNumber: 21\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                            lineNumber: 519,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                    lineNumber: 515,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 514,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                        lineNumber: 496,\n                        columnNumber: 11\n                    }, undefined),\n                    indicatorAdded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setShowSettings(true),\n                                className: \"bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-lg shadow-lg transition-colors\",\n                                title: \"Bollinger Bands Settings\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                    size: 20\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                    lineNumber: 549,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 544,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: removeBollingerBands,\n                                className: \"bg-red-600 hover:bg-red-700 text-white p-2 rounded-lg shadow-lg transition-colors\",\n                                title: \"Remove Bollinger Bands\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                    size: 20\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                    lineNumber: 557,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                                lineNumber: 552,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                lineNumber: 493,\n                columnNumber: 7\n            }, undefined),\n            indicatorAdded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-4 left-4 bg-gray-800 text-white p-2 rounded-lg shadow-lg text-sm border border-gray-700\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Plus_Settings_TrendingUp_X_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                            size: 16,\n                            className: \"text-blue-400\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                            lineNumber: 567,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"font-medium\",\n                            children: \"Bollinger Bands\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                            lineNumber: 568,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"text-gray-400 text-xs\",\n                            children: [\n                                \"(\",\n                                bollingerParams.length,\n                                \", \",\n                                bollingerParams.stdDevMultiplier,\n                                \")\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                            lineNumber: 569,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                    lineNumber: 566,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                lineNumber: 565,\n                columnNumber: 9\n            }, undefined),\n            showSettings && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_BollingerBandsSettings__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                params: bollingerParams,\n                style: bollingerStyle,\n                onParamsChange: handleParamsChange,\n                onStyleChange: handleStyleChange,\n                onClose: ()=>setShowSettings(false)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n                lineNumber: 578,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsChart.tsx\",\n        lineNumber: 457,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BollingerBandsChart, \"qR5hKcXe+GgknGguwBtFiyIubic=\");\n_c = BollingerBandsChart;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BollingerBandsChart);\nvar _c;\n$RefreshReg$(_c, \"BollingerBandsChart\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0JvbGxpbmdlckJhbmRzQ2hhcnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTJEO0FBU3RDO0FBQ3dDO0FBQ2Q7QUFRZjtBQUM4QjtBQTJCdkQsTUFBTW1CLDBCQUErQztJQUMxREMsT0FBTztRQUNMQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO0lBQ2I7SUFDQUMsT0FBTztRQUNMSixTQUFTO1FBQ1RDLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO0lBQ2I7SUFDQUUsT0FBTztRQUNMTCxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsV0FBVztRQUNYQyxXQUFXO0lBQ2I7SUFDQUcsTUFBTTtRQUNKTixTQUFTO1FBQ1RPLFNBQVM7SUFDWDtBQUNGLEVBQUU7QUFFRiwyQ0FBMkM7QUFDM0MsSUFBSUMsd0JBQXdCO0FBRTVCLDRDQUE0QztBQUM1QyxNQUFNQyxrQ0FBa0M7SUFDdEMsSUFBSUQsdUJBQXVCO1FBQ3pCRSxRQUFRQyxHQUFHLENBQUM7UUFDWjtJQUNGO0lBRUFELFFBQVFDLEdBQUcsQ0FBQztJQUVaLElBQUk7UUFDRjFCLDhEQUFpQkEsQ0FBQztZQUNoQjJCLE1BQU07WUFDTkMsV0FBVztZQUNYQyxRQUFRNUIsd0RBQWVBLENBQUM2QixLQUFLO1lBQzdCQyxZQUFZO2dCQUFDO2dCQUFJO2FBQUU7WUFDbkJDLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxTQUFTO2dCQUNQO29CQUNFQyxLQUFLO29CQUNMQyxPQUFPO29CQUNQQyxNQUFNO29CQUNOQyxXQUFXO29CQUNYQyxPQUFPOzRCQUFDLEVBQUU7K0JBQU07NEJBQ2R2QixPQUFPOzRCQUNQQyxXQUFXO3dCQUNiOztnQkFDRjtnQkFDQTtvQkFDRWtCLEtBQUs7b0JBQ0xDLE9BQU87b0JBQ1BDLE1BQU07b0JBQ05DLFdBQVc7b0JBQ1hDLE9BQU87NEJBQUMsRUFBRTsrQkFBTTs0QkFDZHZCLE9BQU87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OERBQUNHOzRCQUFLSCxXQUFVO3NDQUFjOzs7Ozs7c0NBQzlCLDhEQUFDRzs0QkFBS0gsV0FBVTs7Z0NBQXdCO2dDQUNwQ3RELGdCQUFnQnZDLE1BQU07Z0NBQUM7Z0NBQUd1QyxnQkFBZ0J0QyxnQkFBZ0I7Z0NBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQU9wRThCLDhCQUNDLDhEQUFDOUQsK0RBQXNCQTtnQkFDckJpQyxRQUFRcUM7Z0JBQ1J1QyxPQUFPckM7Z0JBQ1A2RCxnQkFBZ0JyQjtnQkFDaEJzQixlQUFlcEI7Z0JBQ2ZxQixTQUFTLElBQU14RSxnQkFBZ0I7Ozs7Ozs7Ozs7OztBQUt6QztHQTFZTUo7S0FBQUE7QUE0WU4sK0RBQWVBLG1CQUFtQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Cb2xsaW5nZXJCYW5kc0NoYXJ0LnRzeD8wMjQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQge1xyXG4gIGluaXQsXHJcbiAgZGlzcG9zZSxcclxuICBDaGFydCxcclxuICByZWdpc3RlckluZGljYXRvcixcclxuICBJbmRpY2F0b3JTZXJpZXMsXHJcbiAgTGluZVR5cGUsXHJcbiAgZ2V0U3VwcG9ydGVkSW5kaWNhdG9ycyxcclxufSBmcm9tIFwia2xpbmVjaGFydHNcIjtcclxuaW1wb3J0IHsgU2V0dGluZ3MsIFBsdXMsIFgsIFRyZW5kaW5nVXAgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XHJcbmltcG9ydCB7IHNhbXBsZURhdGEgfSBmcm9tIFwiQC9kYXRhL3NhbXBsZURhdGFcIjtcclxuaW1wb3J0IHtcclxuICBjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyxcclxuICBCb2xsaW5nZXJCYW5kc1BhcmFtcyxcclxuICBCb2xsaW5nZXJCYW5kc0RhdGEsXHJcbiAgREVGQVVMVF9CT0xMSU5HRVJfUEFSQU1TLFxyXG4gIGdldEJvbGxpbmdlckJhbmRzQXRUaW1lc3RhbXAsXHJcbiAgZm9ybWF0Qm9sbGluZ2VyVmFsdWUsXHJcbn0gZnJvbSBcIkAvdXRpbHMvYm9sbGluZ2VyQmFuZHNcIjtcclxuaW1wb3J0IEJvbGxpbmdlckJhbmRzU2V0dGluZ3MgZnJvbSBcIi4vQm9sbGluZ2VyQmFuZHNTZXR0aW5nc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCb2xsaW5nZXJCYW5kc1N0eWxlIHtcclxuICBiYXNpczoge1xyXG4gICAgdmlzaWJsZTogYm9vbGVhbjtcclxuICAgIGNvbG9yOiBzdHJpbmc7XHJcbiAgICBsaW5lV2lkdGg6IG51bWJlcjtcclxuICAgIGxpbmVTdHlsZTogXCJzb2xpZFwiIHwgXCJkYXNoZWRcIjtcclxuICB9O1xyXG4gIHVwcGVyOiB7XHJcbiAgICB2aXNpYmxlOiBib29sZWFuO1xyXG4gICAgY29sb3I6IHN0cmluZztcclxuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xyXG4gICAgbGluZVN0eWxlOiBcInNvbGlkXCIgfCBcImRhc2hlZFwiO1xyXG4gIH07XHJcbiAgbG93ZXI6IHtcclxuICAgIHZpc2libGU6IGJvb2xlYW47XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgbGluZVdpZHRoOiBudW1iZXI7XHJcbiAgICBsaW5lU3R5bGU6IFwic29saWRcIiB8IFwiZGFzaGVkXCI7XHJcbiAgfTtcclxuICBmaWxsOiB7XHJcbiAgICB2aXNpYmxlOiBib29sZWFuO1xyXG4gICAgb3BhY2l0eTogbnVtYmVyO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JPTExJTkdFUl9TVFlMRTogQm9sbGluZ2VyQmFuZHNTdHlsZSA9IHtcclxuICBiYXNpczoge1xyXG4gICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgIGNvbG9yOiBcIiMzQjgyRjZcIiwgLy8gQnJpZ2h0IGJsdWUgLSBnb29kIGNvbnRyYXN0IG9uIGRhcmtcclxuICAgIGxpbmVXaWR0aDogMSxcclxuICAgIGxpbmVTdHlsZTogXCJzb2xpZFwiLFxyXG4gIH0sXHJcbiAgdXBwZXI6IHtcclxuICAgIHZpc2libGU6IHRydWUsXHJcbiAgICBjb2xvcjogXCIjRUY0NDQ0XCIsIC8vIEJyaWdodCByZWQgLSBnb29kIGNvbnRyYXN0IG9uIGRhcmtcclxuICAgIGxpbmVXaWR0aDogMSxcclxuICAgIGxpbmVTdHlsZTogXCJzb2xpZFwiLFxyXG4gIH0sXHJcbiAgbG93ZXI6IHtcclxuICAgIHZpc2libGU6IHRydWUsXHJcbiAgICBjb2xvcjogXCIjMjJDNTVFXCIsIC8vIEJyaWdodCBncmVlbiAtIGdvb2QgY29udHJhc3Qgb24gZGFya1xyXG4gICAgbGluZVdpZHRoOiAxLFxyXG4gICAgbGluZVN0eWxlOiBcInNvbGlkXCIsXHJcbiAgfSxcclxuICBmaWxsOiB7XHJcbiAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgb3BhY2l0eTogMC4wOCwgLy8gU2xpZ2h0bHkgbW9yZSBzdWJ0bGUgZmlsbFxyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBUcmFjayBpZiBpbmRpY2F0b3IgaXMgYWxyZWFkeSByZWdpc3RlcmVkXHJcbmxldCBpc0luZGljYXRvclJlZ2lzdGVyZWQgPSBmYWxzZTtcclxuXHJcbi8vIFJlZ2lzdGVyIGN1c3RvbSBCb2xsaW5nZXIgQmFuZHMgaW5kaWNhdG9yXHJcbmNvbnN0IHJlZ2lzdGVyQm9sbGluZ2VyQmFuZHNJbmRpY2F0b3IgPSAoKSA9PiB7XHJcbiAgaWYgKGlzSW5kaWNhdG9yUmVnaXN0ZXJlZCkge1xyXG4gICAgY29uc29sZS5sb2coXCJCT0xMIGluZGljYXRvciBhbHJlYWR5IHJlZ2lzdGVyZWQsIHNraXBwaW5nLi4uXCIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCJSZWdpc3RlcmluZyBCb2xsaW5nZXIgQmFuZHMgaW5kaWNhdG9yLi4uXCIpO1xyXG5cclxuICB0cnkge1xyXG4gICAgcmVnaXN0ZXJJbmRpY2F0b3Ioe1xyXG4gICAgICBuYW1lOiBcIkJPTExcIixcclxuICAgICAgc2hvcnROYW1lOiBcIkJPTExcIixcclxuICAgICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXHJcbiAgICAgIGNhbGNQYXJhbXM6IFsyMCwgMl0sIC8vIGxlbmd0aCwgc3RkRGV2TXVsdGlwbGllclxyXG4gICAgICBzaG91bGRPaGxjOiB0cnVlLFxyXG4gICAgICBwcmVjaXNpb246IDIsXHJcbiAgICAgIGZpZ3VyZXM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBrZXk6IFwidXBcIixcclxuICAgICAgICAgIHRpdGxlOiBcIkJPTEwtVVA6IFwiLFxyXG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICBiYXNlVmFsdWU6IDAsXHJcbiAgICAgICAgICBhdHRyczogKHt9KSA9PiAoe1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjRUY0NDQ0XCIsXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2V5OiBcIm1pZFwiLFxyXG4gICAgICAgICAgdGl0bGU6IFwiQk9MTC1NSUQ6IFwiLFxyXG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXHJcbiAgICAgICAgICBiYXNlVmFsdWU6IDAsXHJcbiAgICAgICAgICBhdHRyczogKHt9KSA9PiAoe1xyXG4gICAgICAgICAgICBjb2xvcjogXCIjM0I4MkY2XCIsXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2V5OiBcImRuXCIsXHJcbiAgICAgICAgICB0aXRsZTogXCJCT0xMLUROOiBcIixcclxuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxyXG4gICAgICAgICAgYmFzZVZhbHVlOiAwLFxyXG4gICAgICAgICAgYXR0cnM6ICh7fSkgPT4gKHtcclxuICAgICAgICAgICAgY29sb3I6IFwiIzIyQzU1RVwiLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBjYWxjOiAoZGF0YUxpc3QsIGluZGljYXRvcikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCJDYWxjdWxhdGluZyBCb2xsaW5nZXIgQmFuZHMgZm9yXCIsXHJcbiAgICAgICAgICBkYXRhTGlzdC5sZW5ndGgsXHJcbiAgICAgICAgICBcImRhdGEgcG9pbnRzXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHsgY2FsY1BhcmFtcyB9ID0gaW5kaWNhdG9yO1xyXG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHN0ZERldk11bHRpcGxpZXJdID0gY2FsY1BhcmFtcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG5cclxuICAgICAgICBjb25zdCBwYXJhbXM6IEJvbGxpbmdlckJhbmRzUGFyYW1zID0ge1xyXG4gICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgc3RkRGV2TXVsdGlwbGllcixcclxuICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgIHNvdXJjZTogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgbWFUeXBlOiBcIlNNQVwiLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbmRsZURhdGEgPSBkYXRhTGlzdC5tYXAoKGQpID0+ICh7XHJcbiAgICAgICAgICB0aW1lc3RhbXA6IGQudGltZXN0YW1wLFxyXG4gICAgICAgICAgb3BlbjogZC5vcGVuLFxyXG4gICAgICAgICAgaGlnaDogZC5oaWdoLFxyXG4gICAgICAgICAgbG93OiBkLmxvdyxcclxuICAgICAgICAgIGNsb3NlOiBkLmNsb3NlLFxyXG4gICAgICAgICAgdm9sdW1lOiBkLnZvbHVtZSB8fCAwLFxyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgY29uc3QgYm9sbGluZ2VyRGF0YSA9IGNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzKGNhbmRsZURhdGEsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJvbGxpbmdlckRhdGEubWFwKChiYikgPT4gKHtcclxuICAgICAgICAgIHVwOiBpc05hTihiYi51cHBlcikgPyBudWxsIDogYmIudXBwZXIsXHJcbiAgICAgICAgICBtaWQ6IGlzTmFOKGJiLmJhc2lzKSA/IG51bGwgOiBiYi5iYXNpcyxcclxuICAgICAgICAgIGRuOiBpc05hTihiYi5sb3dlcikgPyBudWxsIDogYmIubG93ZXIsXHJcbiAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIFwiQm9sbGluZ2VyIGNhbGN1bGF0aW9uIHJlc3VsdCAoZmlyc3QgNSk6XCIsXHJcbiAgICAgICAgICByZXN1bHQuc2xpY2UoMCwgNSlcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQm9sbGluZ2VyIGNhbGN1bGF0aW9uIHJlc3VsdCAobGFzdCA1KTpcIiwgcmVzdWx0LnNsaWNlKC01KSk7XHJcblxyXG4gICAgICAgIC8vIExvZyBzb21lIHNwZWNpZmljIHZhbHVlcyB0byBzZWUgaWYgdGhleSdyZSB2YWxpZFxyXG4gICAgICAgIGNvbnN0IHZhbGlkUmVzdWx0cyA9IHJlc3VsdC5maWx0ZXIoXHJcbiAgICAgICAgICAocikgPT4gci51cCAhPT0gbnVsbCAmJiByLm1pZCAhPT0gbnVsbCAmJiByLmRuICE9PSBudWxsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgVmFsaWQgcmVzdWx0czogJHt2YWxpZFJlc3VsdHMubGVuZ3RofS8ke3Jlc3VsdC5sZW5ndGh9YCk7XHJcbiAgICAgICAgaWYgKHZhbGlkUmVzdWx0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNhbXBsZSB2YWxpZCByZXN1bHQ6XCIsIHZhbGlkUmVzdWx0c1swXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgaXNJbmRpY2F0b3JSZWdpc3RlcmVkID0gdHJ1ZTtcclxuICAgIGNvbnNvbGUubG9nKFwiQm9sbGluZ2VyIEJhbmRzIGluZGljYXRvciByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuXHJcbiAgICAvLyBDaGVjayB3aGF0IGluZGljYXRvcnMgYXJlIG5vdyBhdmFpbGFibGVcclxuICAgIGNvbnN0IHN1cHBvcnRlZEluZGljYXRvcnMgPSBnZXRTdXBwb3J0ZWRJbmRpY2F0b3JzKCk7XHJcbiAgICBjb25zb2xlLmxvZyhcclxuICAgICAgXCJTdXBwb3J0ZWQgaW5kaWNhdG9ycyBhZnRlciByZWdpc3RyYXRpb246XCIsXHJcbiAgICAgIHN1cHBvcnRlZEluZGljYXRvcnNcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgcmVnaXN0ZXJpbmcgQm9sbGluZ2VyIEJhbmRzIGluZGljYXRvcjpcIiwgZXJyb3IpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IEJvbGxpbmdlckJhbmRzQ2hhcnQ6IFJlYWN0LkZDID0gKCkgPT4ge1xyXG4gIGNvbnN0IGNoYXJ0Q29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxDaGFydCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtzaG93U2V0dGluZ3MsIHNldFNob3dTZXR0aW5nc10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3Nob3dBZGRNZW51LCBzZXRTaG93QWRkTWVudV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2luZGljYXRvckFkZGVkLCBzZXRJbmRpY2F0b3JBZGRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2JvbGxJbmRpY2F0b3JJZCwgc2V0Qm9sbEluZGljYXRvcklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBEZWJ1ZyBsb2dnaW5nXHJcbiAgY29uc29sZS5sb2coXHJcbiAgICBcIkJvbGxpbmdlckJhbmRzQ2hhcnQgcmVuZGVyIC0gaW5kaWNhdG9yQWRkZWQ6XCIsXHJcbiAgICBpbmRpY2F0b3JBZGRlZCxcclxuICAgIFwic2hvd0FkZE1lbnU6XCIsXHJcbiAgICBzaG93QWRkTWVudVxyXG4gICk7XHJcbiAgY29uc3QgW2JvbGxpbmdlclBhcmFtcywgc2V0Qm9sbGluZ2VyUGFyYW1zXSA9IHVzZVN0YXRlPEJvbGxpbmdlckJhbmRzUGFyYW1zPihcclxuICAgIERFRkFVTFRfQk9MTElOR0VSX1BBUkFNU1xyXG4gICk7XHJcbiAgY29uc3QgW2JvbGxpbmdlclN0eWxlLCBzZXRCb2xsaW5nZXJTdHlsZV0gPSB1c2VTdGF0ZTxCb2xsaW5nZXJCYW5kc1N0eWxlPihcclxuICAgIERFRkFVTFRfQk9MTElOR0VSX1NUWUxFXHJcbiAgKTtcclxuICBjb25zdCBbYm9sbGluZ2VyRGF0YSwgc2V0Qm9sbGluZ2VyRGF0YV0gPSB1c2VTdGF0ZTxCb2xsaW5nZXJCYW5kc0RhdGFbXT4oW10pO1xyXG4gIGNvbnN0IFtjcm9zc2hhaXJEYXRhLCBzZXRDcm9zc2hhaXJEYXRhXSA9IHVzZVN0YXRlPHtcclxuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gICAgYmFzaXM6IG51bWJlcjtcclxuICAgIHVwcGVyOiBudW1iZXI7XHJcbiAgICBsb3dlcjogbnVtYmVyO1xyXG4gIH0gfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQ2xvc2UgYWRkIG1lbnUgd2hlbiBjbGlja2luZyBvdXRzaWRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGhhbmRsZUNsaWNrT3V0c2lkZSA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgRWxlbWVudDtcclxuICAgICAgLy8gRG9uJ3QgY2xvc2UgaWYgY2xpY2tpbmcgb24gdGhlIGFkZCBidXR0b24gb3IgaXRzIGNoaWxkcmVuXHJcbiAgICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoXCIuYWRkLWluZGljYXRvci1jb250YWluZXJcIikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNob3dBZGRNZW51KSB7XHJcbiAgICAgICAgc2V0U2hvd0FkZE1lbnUoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChzaG93QWRkTWVudSkge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGlja091dHNpZGUpO1xyXG4gICAgfTtcclxuICB9LCBbc2hvd0FkZE1lbnVdKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBjaGFydFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgY3VzdG9tIEJvbGxpbmdlciBCYW5kcyBpbmRpY2F0b3JcclxuICAgIHJlZ2lzdGVyQm9sbGluZ2VyQmFuZHNJbmRpY2F0b3IoKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIEtMaW5lQ2hhcnRzIHdpdGggYmFzaWMgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgY2hhcnQgPSBpbml0KGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpO1xyXG5cclxuICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBjaGFydDtcclxuXHJcbiAgICAvLyBMb2FkIHNhbXBsZSBkYXRhIChjb252ZXJ0IHRvIEtMaW5lRGF0YSBmb3JtYXQpXHJcbiAgICBjb25zdCBrbGluZURhdGEgPSBzYW1wbGVEYXRhLm1hcCgoaXRlbSkgPT4gKHtcclxuICAgICAgdGltZXN0YW1wOiBpdGVtLnRpbWVzdGFtcCxcclxuICAgICAgb3BlbjogaXRlbS5vcGVuLFxyXG4gICAgICBoaWdoOiBpdGVtLmhpZ2gsXHJcbiAgICAgIGxvdzogaXRlbS5sb3csXHJcbiAgICAgIGNsb3NlOiBpdGVtLmNsb3NlLFxyXG4gICAgICB2b2x1bWU6IGl0ZW0udm9sdW1lLFxyXG4gICAgfSkpO1xyXG4gICAgY2hhcnQ/LmFwcGx5TmV3RGF0YShrbGluZURhdGEpO1xyXG5cclxuICAgIC8vIFVzZSBtb3VzZSBldmVudHMgZm9yIGNyb3NzaGFpciBkYXRhIHNpbmNlIEtMaW5lQ2hhcnRzIEFQSSB2YXJpZXNcclxuXHJcbiAgICAvLyBGYWxsYmFjayB0byBtb3VzZSBldmVudHMgZm9yIGNyb3NzaGFpciBkYXRhXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgaWYgKGluZGljYXRvckFkZGVkICYmIGJvbGxJbmRpY2F0b3JJZCAmJiBjaGFydFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcclxuXHJcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGluZGljYXRvciBkYXRhIGZyb20gdGhlIGNoYXJ0XHJcbiAgICAgICAgICBjb25zdCBpbmRpY2F0b3JzID0gY2hhcnRSZWYuY3VycmVudC5nZXRJbmRpY2F0b3JzKHtcclxuICAgICAgICAgICAgaWQ6IGJvbGxJbmRpY2F0b3JJZCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKGluZGljYXRvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBpbmRpY2F0b3JzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRpY2F0b3IucmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IE1hdGguZmxvb3IoKHggLyByZWN0LndpZHRoKSAqIHJlc3VsdC5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoZGF0YUluZGV4ID49IDAgJiYgZGF0YUluZGV4IDwgcmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJEYXRhID0gcmVzdWx0W2RhdGFJbmRleF0gYXMge1xyXG4gICAgICAgICAgICAgICAgICB1cDogbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICAgICAgICAgICAgbWlkOiBudW1iZXIgfCBudWxsO1xyXG4gICAgICAgICAgICAgICAgICBkbjogbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgIGJiRGF0YSAmJlxyXG4gICAgICAgICAgICAgICAgICBiYkRhdGEudXAgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgYmJEYXRhLm1pZCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICBiYkRhdGEuZG4gIT09IG51bGxcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBHZXQgdGltZXN0YW1wIGZyb20gb3JpZ2luYWwgZGF0YVxyXG4gICAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPVxyXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZURhdGFbZGF0YUluZGV4XT8udGltZXN0YW1wIHx8IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgIHNldENyb3NzaGFpckRhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICBiYXNpczogYmJEYXRhLm1pZCxcclxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogYmJEYXRhLnVwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiBiYkRhdGEuZG4sXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XHJcblxyXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKGNoYXJ0Q29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjaGFydENvbnRhaW5lclJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICBcIm1vdXNlbW92ZVwiLFxyXG4gICAgICAgICAgaGFuZGxlTW91c2VNb3ZlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGRpc3Bvc2UoY2hhcnRDb250YWluZXJSZWYuY3VycmVudCEpO1xyXG4gICAgICAgIGNoYXJ0UmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sIFtpbmRpY2F0b3JBZGRlZCwgYm9sbEluZGljYXRvcklkXSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBpbmRpY2F0b3Igd2hlbiBwYXJhbXMgb3Igc3R5bGUgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpbmRpY2F0b3JBZGRlZCAmJiBib2xsSW5kaWNhdG9ySWQgJiYgY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICAvLyBVcGRhdGUgaW5kaWNhdG9yIHBhcmFtZXRlcnMgYW5kIHN0eWxlc1xyXG4gICAgICBjaGFydFJlZi5jdXJyZW50Lm92ZXJyaWRlSW5kaWNhdG9yKHtcclxuICAgICAgICBpZDogYm9sbEluZGljYXRvcklkLFxyXG4gICAgICAgIG5hbWU6IFwiQk9MTFwiLFxyXG4gICAgICAgIGNhbGNQYXJhbXM6IFtib2xsaW5nZXJQYXJhbXMubGVuZ3RoLCBib2xsaW5nZXJQYXJhbXMuc3RkRGV2TXVsdGlwbGllcl0sXHJcbiAgICAgICAgc3R5bGVzOiB7XHJcbiAgICAgICAgICBsaW5lczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgY29sb3I6IGJvbGxpbmdlclN0eWxlLnVwcGVyLmNvbG9yLFxyXG4gICAgICAgICAgICAgIHNpemU6IGJvbGxpbmdlclN0eWxlLnVwcGVyLmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICBzdHlsZTpcclxuICAgICAgICAgICAgICAgIGJvbGxpbmdlclN0eWxlLnVwcGVyLmxpbmVTdHlsZSA9PT0gXCJkYXNoZWRcIlxyXG4gICAgICAgICAgICAgICAgICA/IExpbmVUeXBlLkRhc2hlZFxyXG4gICAgICAgICAgICAgICAgICA6IExpbmVUeXBlLlNvbGlkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgY29sb3I6IGJvbGxpbmdlclN0eWxlLmJhc2lzLmNvbG9yLFxyXG4gICAgICAgICAgICAgIHNpemU6IGJvbGxpbmdlclN0eWxlLmJhc2lzLmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICBzdHlsZTpcclxuICAgICAgICAgICAgICAgIGJvbGxpbmdlclN0eWxlLmJhc2lzLmxpbmVTdHlsZSA9PT0gXCJkYXNoZWRcIlxyXG4gICAgICAgICAgICAgICAgICA/IExpbmVUeXBlLkRhc2hlZFxyXG4gICAgICAgICAgICAgICAgICA6IExpbmVUeXBlLlNvbGlkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgY29sb3I6IGJvbGxpbmdlclN0eWxlLmxvd2VyLmNvbG9yLFxyXG4gICAgICAgICAgICAgIHNpemU6IGJvbGxpbmdlclN0eWxlLmxvd2VyLmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICBzdHlsZTpcclxuICAgICAgICAgICAgICAgIGJvbGxpbmdlclN0eWxlLmxvd2VyLmxpbmVTdHlsZSA9PT0gXCJkYXNoZWRcIlxyXG4gICAgICAgICAgICAgICAgICA/IExpbmVUeXBlLkRhc2hlZFxyXG4gICAgICAgICAgICAgICAgICA6IExpbmVUeXBlLlNvbGlkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbYm9sbGluZ2VyUGFyYW1zLCBib2xsaW5nZXJTdHlsZSwgaW5kaWNhdG9yQWRkZWQsIGJvbGxJbmRpY2F0b3JJZF0pO1xyXG5cclxuICBjb25zdCBoYW5kbGVQYXJhbXNDaGFuZ2UgPSAobmV3UGFyYW1zOiBCb2xsaW5nZXJCYW5kc1BhcmFtcykgPT4ge1xyXG4gICAgc2V0Qm9sbGluZ2VyUGFyYW1zKG5ld1BhcmFtcyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3R5bGVDaGFuZ2UgPSAobmV3U3R5bGU6IEJvbGxpbmdlckJhbmRzU3R5bGUpID0+IHtcclxuICAgIHNldEJvbGxpbmdlclN0eWxlKG5ld1N0eWxlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBhZGRCb2xsaW5nZXJCYW5kcyA9ICgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiQWRkaW5nIEJvbGxpbmdlciBCYW5kcyBpbmRpY2F0b3IuLi5cIik7XHJcbiAgICBpZiAoY2hhcnRSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkNoYXJ0IHJlZmVyZW5jZSBleGlzdHMsIGNyZWF0aW5nIGluZGljYXRvci4uLlwiKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbmRpY2F0b3Igb24gdGhlIG1haW4gcHJpY2UgcGFuZVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBjcmVhdGUgQk9MTCBpbmRpY2F0b3IuLi5cIik7XHJcbiAgICAgICAgY29uc3QgaW5kaWNhdG9ySWQgPSBjaGFydFJlZi5jdXJyZW50LmNyZWF0ZUluZGljYXRvcihcIkJPTExcIik7XHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBcIlJhdyBpbmRpY2F0b3IgSUQgcmVzdWx0OlwiLFxyXG4gICAgICAgICAgaW5kaWNhdG9ySWQsXHJcbiAgICAgICAgICBcIlR5cGU6XCIsXHJcbiAgICAgICAgICB0eXBlb2YgaW5kaWNhdG9ySWRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoaW5kaWNhdG9ySWQpIHtcclxuICAgICAgICAgIHNldEJvbGxJbmRpY2F0b3JJZChpbmRpY2F0b3JJZCk7XHJcbiAgICAgICAgICBzZXRJbmRpY2F0b3JBZGRlZCh0cnVlKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICBcIuKchSBCb2xsaW5nZXIgQmFuZHMgYWRkZWQgc3VjY2Vzc2Z1bGx5IHdpdGggSUQ6XCIsXHJcbiAgICAgICAgICAgIGluZGljYXRvcklkXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIExvZyB0aGUgY3JlYXRlZCBpbmRpY2F0b3IgZGV0YWlsc1xyXG4gICAgICAgICAgY29uc3QgY3JlYXRlZEluZGljYXRvciA9IGNoYXJ0UmVmLmN1cnJlbnQuZ2V0SW5kaWNhdG9ycyh7XHJcbiAgICAgICAgICAgIGlkOiBpbmRpY2F0b3JJZCxcclxuICAgICAgICAgIH0pWzBdO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGVkIGluZGljYXRvciBkZXRhaWxzOlwiLCBjcmVhdGVkSW5kaWNhdG9yKTtcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5kaWNhdG9yIGhhcyByZXN1bHQgZGF0YVxyXG4gICAgICAgICAgaWYgKGNyZWF0ZWRJbmRpY2F0b3IgJiYgY3JlYXRlZEluZGljYXRvci5yZXN1bHQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgXCJJbmRpY2F0b3IgcmVzdWx0IGxlbmd0aDpcIixcclxuICAgICAgICAgICAgICBjcmVhdGVkSW5kaWNhdG9yLnJlc3VsdC5sZW5ndGhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgXCJTYW1wbGUgcmVzdWx0IGRhdGE6XCIsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEluZGljYXRvci5yZXN1bHQuc2xpY2UoLTMpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTG9nIGN1cnJlbnQgaW5kaWNhdG9yc1xyXG4gICAgICAgICAgY29uc3QgaW5kaWNhdG9ycyA9IGNoYXJ0UmVmLmN1cnJlbnQuZ2V0SW5kaWNhdG9ycygpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJBbGwgaW5kaWNhdG9ycyBvbiBjaGFydDpcIiwgaW5kaWNhdG9ycyk7XHJcblxyXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgc3BlY2lmaWMgaW5kaWNhdG9yIHdlIGp1c3QgY3JlYXRlZFxyXG4gICAgICAgICAgY29uc3Qgb3VySW5kaWNhdG9yID0gY2hhcnRSZWYuY3VycmVudC5nZXRJbmRpY2F0b3JzKHsgbmFtZTogXCJCT0xMXCIgfSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk91ciBCT0xMIGluZGljYXRvcjpcIiwgb3VySW5kaWNhdG9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgXCLinYwgRmFpbGVkIHRvIGNyZWF0ZSBCb2xsaW5nZXIgQmFuZHMgaW5kaWNhdG9yIC0gSUQgaXMgbnVsbC91bmRlZmluZWRcIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBjcmVhdGluZyBpbmRpY2F0b3I6XCIsIGVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBDaGFydCByZWZlcmVuY2UgaXMgbnVsbFwiKTtcclxuICAgIH1cclxuICAgIHNldFNob3dBZGRNZW51KGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBjb25zdCByZW1vdmVCb2xsaW5nZXJCYW5kcyA9ICgpID0+IHtcclxuICAgIGlmIChjaGFydFJlZi5jdXJyZW50ICYmIGJvbGxJbmRpY2F0b3JJZCkge1xyXG4gICAgICBjaGFydFJlZi5jdXJyZW50LnJlbW92ZUluZGljYXRvcih7IGlkOiBib2xsSW5kaWNhdG9ySWQgfSk7XHJcbiAgICAgIHNldEJvbGxJbmRpY2F0b3JJZChudWxsKTtcclxuICAgIH1cclxuICAgIHNldEluZGljYXRvckFkZGVkKGZhbHNlKTtcclxuICAgIHNldEJvbGxpbmdlckRhdGEoW10pO1xyXG4gICAgc2V0Q3Jvc3NoYWlyRGF0YShudWxsKTtcclxuICAgIGNvbnNvbGUubG9nKFwiQm9sbGluZ2VyIEJhbmRzIHJlbW92ZWRcIik7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtc2NyZWVuIGJnLWdyYXktOTAwIHJlbGF0aXZlXCI+XHJcbiAgICAgIHsvKiBDaGFydCBDb250YWluZXIgKi99XHJcbiAgICAgIDxkaXZcclxuICAgICAgICByZWY9e2NoYXJ0Q29udGFpbmVyUmVmfVxyXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIlxyXG4gICAgICAgIHN0eWxlPXt7IHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiIH19XHJcbiAgICAgIC8+XHJcblxyXG4gICAgICB7LyogQ3Jvc3NoYWlyIEluZm8gKi99XHJcbiAgICAgIHtjcm9zc2hhaXJEYXRhICYmIGluZGljYXRvckFkZGVkICYmIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC00IGxlZnQtNCBiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlIHAtMyByb3VuZGVkLWxnIHNoYWRvdy1sZyB0ZXh0LXNtIGJvcmRlciBib3JkZXItZ3JheS03MDBcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCBtYi0yXCI+Qm9sbGluZ2VyIEJhbmRzPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMVwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGdhcC00XCI+XHJcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPlVwcGVyOjwvc3Bhbj5cclxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBjb2xvcjogYm9sbGluZ2VyU3R5bGUudXBwZXIuY29sb3IgfX0+XHJcbiAgICAgICAgICAgICAgICB7Zm9ybWF0Qm9sbGluZ2VyVmFsdWUoY3Jvc3NoYWlyRGF0YS51cHBlcil9XHJcbiAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBnYXAtNFwiPlxyXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDBcIj5CYXNpczo8L3NwYW4+XHJcbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IGJvbGxpbmdlclN0eWxlLmJhc2lzLmNvbG9yIH19PlxyXG4gICAgICAgICAgICAgICAge2Zvcm1hdEJvbGxpbmdlclZhbHVlKGNyb3NzaGFpckRhdGEuYmFzaXMpfVxyXG4gICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gZ2FwLTRcIj5cclxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwXCI+TG93ZXI6PC9zcGFuPlxyXG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGNvbG9yOiBib2xsaW5nZXJTdHlsZS5sb3dlci5jb2xvciB9fT5cclxuICAgICAgICAgICAgICAgIHtmb3JtYXRCb2xsaW5nZXJWYWx1ZShjcm9zc2hhaXJEYXRhLmxvd2VyKX1cclxuICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcblxyXG4gICAgICB7LyogVG9wIENvbnRyb2wgQmFyICovfVxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC00IHJpZ2h0LTQgZmxleCBnYXAtMiB6LTEwXCI+XHJcbiAgICAgICAgey8qIEFkZCBJbmRpY2F0b3IgQnV0dG9uICovfVxyXG4gICAgICAgIHshaW5kaWNhdG9yQWRkZWQgJiYgKFxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBhZGQtaW5kaWNhdG9yLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkZCBJbmRpY2F0b3IgYnV0dG9uIGNsaWNrZWQhXCIsIHNob3dBZGRNZW51KTtcclxuICAgICAgICAgICAgICAgIHNldFNob3dBZGRNZW51KCFzaG93QWRkTWVudSk7XHJcbiAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmVlbi02MDAgaG92ZXI6YmctZ3JlZW4tNzAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQtbGcgc2hhZG93LWxnIHRyYW5zaXRpb24tY29sb3JzIGZsZXggaXRlbXMtY2VudGVyIGdhcC0xIGN1cnNvci1wb2ludGVyIHJlbGF0aXZlIHotMjBcIlxyXG4gICAgICAgICAgICAgIHRpdGxlPVwiQWRkIEluZGljYXRvclwiXHJcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8UGx1cyBzaXplPXsyMH0gLz5cclxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtXCI+QWRkIEluZGljYXRvcjwvc3Bhbj5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcblxyXG4gICAgICAgICAgICB7LyogQWRkIEluZGljYXRvciBNZW51ICovfVxyXG4gICAgICAgICAgICB7c2hvd0FkZE1lbnUgJiYgKFxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTEyIHJpZ2h0LTAgYmctZ3JheS04MDAgYm9yZGVyIGJvcmRlci1ncmF5LTcwMCByb3VuZGVkLWxnIHNoYWRvdy14bCBtaW4tdy00OCB6LTUwXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMlwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTQwMCBweC0yIHB5LTEgZm9udC1tZWRpdW1cIj5cclxuICAgICAgICAgICAgICAgICAgICBURUNITklDQUwgSU5ESUNBVE9SU1xyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCb2xsaW5nZXIgQmFuZHMgbWVudSBpdGVtIGNsaWNrZWQhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWRkQm9sbGluZ2VyQmFuZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCB0ZXh0LWxlZnQgcHgtMyBweS0yIGhvdmVyOmJnLWdyYXktNzAwIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWNvbG9ycyBjdXJzb3ItcG9pbnRlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8VHJlbmRpbmdVcCBzaXplPXsxNn0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LW1lZGl1bVwiPkJvbGxpbmdlciBCYW5kczwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDBcIj5CQiAoMjAsIDIpPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG5cclxuICAgICAgICB7LyogSW5kaWNhdG9yIENvbnRyb2xzICh3aGVuIGFkZGVkKSAqL31cclxuICAgICAgICB7aW5kaWNhdG9yQWRkZWQgJiYgKFxyXG4gICAgICAgICAgPD5cclxuICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3dTZXR0aW5ncyh0cnVlKX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkLWxnIHNoYWRvdy1sZyB0cmFuc2l0aW9uLWNvbG9yc1wiXHJcbiAgICAgICAgICAgICAgdGl0bGU9XCJCb2xsaW5nZXIgQmFuZHMgU2V0dGluZ3NcIlxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgPFNldHRpbmdzIHNpemU9ezIwfSAvPlxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICBvbkNsaWNrPXtyZW1vdmVCb2xsaW5nZXJCYW5kc31cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1yZWQtNjAwIGhvdmVyOmJnLXJlZC03MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZC1sZyBzaGFkb3ctbGcgdHJhbnNpdGlvbi1jb2xvcnNcIlxyXG4gICAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIEJvbGxpbmdlciBCYW5kc1wiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8WCBzaXplPXsyMH0gLz5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICA8Lz5cclxuICAgICAgICApfVxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIHsvKiBBY3RpdmUgSW5kaWNhdG9ycyBMaXN0ICovfVxyXG4gICAgICB7aW5kaWNhdG9yQWRkZWQgJiYgKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTQgbGVmdC00IGJnLWdyYXktODAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQtbGcgc2hhZG93LWxnIHRleHQtc20gYm9yZGVyIGJvcmRlci1ncmF5LTcwMFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxyXG4gICAgICAgICAgICA8VHJlbmRpbmdVcCBzaXplPXsxNn0gY2xhc3NOYW1lPVwidGV4dC1ibHVlLTQwMFwiIC8+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtXCI+Qm9sbGluZ2VyIEJhbmRzPC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwIHRleHQteHNcIj5cclxuICAgICAgICAgICAgICAoe2JvbGxpbmdlclBhcmFtcy5sZW5ndGh9LCB7Ym9sbGluZ2VyUGFyYW1zLnN0ZERldk11bHRpcGxpZXJ9KVxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKX1cclxuXHJcbiAgICAgIHsvKiBTZXR0aW5ncyBNb2RhbCAqL31cclxuICAgICAge3Nob3dTZXR0aW5ncyAmJiAoXHJcbiAgICAgICAgPEJvbGxpbmdlckJhbmRzU2V0dGluZ3NcclxuICAgICAgICAgIHBhcmFtcz17Ym9sbGluZ2VyUGFyYW1zfVxyXG4gICAgICAgICAgc3R5bGU9e2JvbGxpbmdlclN0eWxlfVxyXG4gICAgICAgICAgb25QYXJhbXNDaGFuZ2U9e2hhbmRsZVBhcmFtc0NoYW5nZX1cclxuICAgICAgICAgIG9uU3R5bGVDaGFuZ2U9e2hhbmRsZVN0eWxlQ2hhbmdlfVxyXG4gICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0U2hvd1NldHRpbmdzKGZhbHNlKX1cclxuICAgICAgICAvPlxyXG4gICAgICApfVxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJvbGxpbmdlckJhbmRzQ2hhcnQ7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiaW5pdCIsImRpc3Bvc2UiLCJyZWdpc3RlckluZGljYXRvciIsIkluZGljYXRvclNlcmllcyIsIkxpbmVUeXBlIiwiZ2V0U3VwcG9ydGVkSW5kaWNhdG9ycyIsIlNldHRpbmdzIiwiUGx1cyIsIlgiLCJUcmVuZGluZ1VwIiwic2FtcGxlRGF0YSIsImNhbGN1bGF0ZUJvbGxpbmdlckJhbmRzIiwiREVGQVVMVF9CT0xMSU5HRVJfUEFSQU1TIiwiZm9ybWF0Qm9sbGluZ2VyVmFsdWUiLCJCb2xsaW5nZXJCYW5kc1NldHRpbmdzIiwiREVGQVVMVF9CT0xMSU5HRVJfU1RZTEUiLCJiYXNpcyIsInZpc2libGUiLCJjb2xvciIsImxpbmVXaWR0aCIsImxpbmVTdHlsZSIsInVwcGVyIiwibG93ZXIiLCJmaWxsIiwib3BhY2l0eSIsImlzSW5kaWNhdG9yUmVnaXN0ZXJlZCIsInJlZ2lzdGVyQm9sbGluZ2VyQmFuZHNJbmRpY2F0b3IiLCJjb25zb2xlIiwibG9nIiwibmFtZSIsInNob3J0TmFtZSIsInNlcmllcyIsIlByaWNlIiwiY2FsY1BhcmFtcyIsInNob3VsZE9obGMiLCJwcmVjaXNpb24iLCJmaWd1cmVzIiwia2V5IiwidGl0bGUiLCJ0eXBlIiwiYmFzZVZhbHVlIiwiYXR0cnMiLCJjYWxjIiwiZGF0YUxpc3QiLCJpbmRpY2F0b3IiLCJsZW5ndGgiLCJzdGREZXZNdWx0aXBsaWVyIiwicGFyYW1zIiwib2Zmc2V0Iiwic291cmNlIiwibWFUeXBlIiwiY2FuZGxlRGF0YSIsIm1hcCIsImQiLCJ0aW1lc3RhbXAiLCJvcGVuIiwiaGlnaCIsImxvdyIsImNsb3NlIiwidm9sdW1lIiwiYm9sbGluZ2VyRGF0YSIsInJlc3VsdCIsImJiIiwidXAiLCJpc05hTiIsIm1pZCIsImRuIiwic2xpY2UiLCJ2YWxpZFJlc3VsdHMiLCJmaWx0ZXIiLCJyIiwic3VwcG9ydGVkSW5kaWNhdG9ycyIsImVycm9yIiwiQm9sbGluZ2VyQmFuZHNDaGFydCIsImNoYXJ0Q29udGFpbmVyUmVmIiwiY2hhcnRSZWYiLCJzaG93U2V0dGluZ3MiLCJzZXRTaG93U2V0dGluZ3MiLCJzaG93QWRkTWVudSIsInNldFNob3dBZGRNZW51IiwiaW5kaWNhdG9yQWRkZWQiLCJzZXRJbmRpY2F0b3JBZGRlZCIsImJvbGxJbmRpY2F0b3JJZCIsInNldEJvbGxJbmRpY2F0b3JJZCIsImJvbGxpbmdlclBhcmFtcyIsInNldEJvbGxpbmdlclBhcmFtcyIsImJvbGxpbmdlclN0eWxlIiwic2V0Qm9sbGluZ2VyU3R5bGUiLCJzZXRCb2xsaW5nZXJEYXRhIiwiY3Jvc3NoYWlyRGF0YSIsInNldENyb3NzaGFpckRhdGEiLCJoYW5kbGVDbGlja091dHNpZGUiLCJldmVudCIsInRhcmdldCIsImNsb3Nlc3QiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3VycmVudCIsImNoYXJ0Iiwia2xpbmVEYXRhIiwiaXRlbSIsImFwcGx5TmV3RGF0YSIsImhhbmRsZU1vdXNlTW92ZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwiY2xpZW50WCIsImxlZnQiLCJpbmRpY2F0b3JzIiwiZ2V0SW5kaWNhdG9ycyIsImlkIiwiZGF0YUluZGV4IiwiTWF0aCIsImZsb29yIiwid2lkdGgiLCJiYkRhdGEiLCJEYXRlIiwibm93Iiwib3ZlcnJpZGVJbmRpY2F0b3IiLCJzdHlsZXMiLCJsaW5lcyIsInNpemUiLCJzdHlsZSIsIkRhc2hlZCIsIlNvbGlkIiwiaGFuZGxlUGFyYW1zQ2hhbmdlIiwibmV3UGFyYW1zIiwiaGFuZGxlU3R5bGVDaGFuZ2UiLCJuZXdTdHlsZSIsImFkZEJvbGxpbmdlckJhbmRzIiwiaW5kaWNhdG9ySWQiLCJjcmVhdGVJbmRpY2F0b3IiLCJjcmVhdGVkSW5kaWNhdG9yIiwib3VySW5kaWNhdG9yIiwicmVtb3ZlQm9sbGluZ2VyQmFuZHMiLCJyZW1vdmVJbmRpY2F0b3IiLCJkaXYiLCJjbGFzc05hbWUiLCJyZWYiLCJwb2ludGVyRXZlbnRzIiwic3BhbiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvblBhcmFtc0NoYW5nZSIsIm9uU3R5bGVDaGFuZ2UiLCJvbkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/BollingerBandsChart.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/BollingerBandsSettings.tsx":
/*!***************************************************!*\
  !*** ./src/components/BollingerBandsSettings.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=X!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/x.js\");\n/* harmony import */ var _utils_bollingerBands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/bollingerBands */ \"(app-pages-browser)/./src/utils/bollingerBands.ts\");\n/* harmony import */ var _BollingerBandsChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BollingerBandsChart */ \"(app-pages-browser)/./src/components/BollingerBandsChart.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst BollingerBandsSettings = (param)=>{\n    let { params, style, onParamsChange, onStyleChange, onClose } = param;\n    _s();\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"inputs\");\n    const [localParams, setLocalParams] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(params);\n    const [localStyle, setLocalStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(style);\n    const handleParamChange = (key, value)=>{\n        const newParams = {\n            ...localParams,\n            [key]: value\n        };\n        setLocalParams(newParams);\n        onParamsChange(newParams);\n    };\n    const handleStyleChange = (band, property, value)=>{\n        const newStyle = {\n            ...localStyle,\n            [band]: {\n                ...localStyle[band],\n                [property]: value\n            }\n        };\n        setLocalStyle(newStyle);\n        onStyleChange(newStyle);\n    };\n    const resetToDefaults = ()=>{\n        if (activeTab === \"inputs\") {\n            setLocalParams(_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BOLLINGER_PARAMS);\n            onParamsChange(_utils_bollingerBands__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BOLLINGER_PARAMS);\n        } else {\n            setLocalStyle(_BollingerBandsChart__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BOLLINGER_STYLE);\n            onStyleChange(_BollingerBandsChart__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BOLLINGER_STYLE);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"bg-gray-800 rounded-lg shadow-2xl w-96 max-h-[80vh] overflow-hidden\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between p-4 border-b border-gray-700\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: \"text-lg font-semibold text-white\",\n                            children: \"Bollinger Bands Settings\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 75,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: onClose,\n                            className: \"text-gray-400 hover:text-white transition-colors\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_X_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                size: 20\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 82,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                    lineNumber: 74,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex border-b border-gray-700\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: ()=>setActiveTab(\"inputs\"),\n                            className: \"flex-1 py-3 px-4 text-sm font-medium transition-colors \".concat(activeTab === \"inputs\" ? \"text-blue-400 border-b-2 border-blue-400 bg-gray-750\" : \"text-gray-400 hover:text-white\"),\n                            children: \"Inputs\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 88,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: ()=>setActiveTab(\"style\"),\n                            className: \"flex-1 py-3 px-4 text-sm font-medium transition-colors \".concat(activeTab === \"style\" ? \"text-blue-400 border-b-2 border-blue-400 bg-gray-750\" : \"text-gray-400 hover:text-white\"),\n                            children: \"Style\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 98,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                    lineNumber: 87,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-4 max-h-96 overflow-y-auto\",\n                    children: activeTab === \"inputs\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"block text-sm font-medium text-gray-300 mb-2\",\n                                        children: \"Length\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 116,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"number\",\n                                        min: \"1\",\n                                        max: \"200\",\n                                        value: localParams.length,\n                                        onChange: (e)=>handleParamChange(\"length\", parseInt(e.target.value) || 20),\n                                        className: \"w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 119,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 115,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"block text-sm font-medium text-gray-300 mb-2\",\n                                        children: \"Basic MA Type\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 133,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                        value: localParams.maType,\n                                        onChange: (e)=>handleParamChange(\"maType\", e.target.value),\n                                        className: \"w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                            value: \"SMA\",\n                                            children: \"SMA\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                            lineNumber: 143,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 136,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 132,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"block text-sm font-medium text-gray-300 mb-2\",\n                                        children: \"Source\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 149,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                        value: localParams.source,\n                                        onChange: (e)=>handleParamChange(\"source\", e.target.value),\n                                        className: \"w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: \"close\",\n                                                children: \"Close\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 162,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: \"open\",\n                                                children: \"Open\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 163,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: \"high\",\n                                                children: \"High\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 164,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: \"low\",\n                                                children: \"Low\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 165,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 152,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 148,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"block text-sm font-medium text-gray-300 mb-2\",\n                                        children: \"StdDev (multiplier)\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 171,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"number\",\n                                        min: \"0.1\",\n                                        max: \"10\",\n                                        step: \"0.1\",\n                                        value: localParams.stdDevMultiplier,\n                                        onChange: (e)=>handleParamChange(\"stdDevMultiplier\", parseFloat(e.target.value) || 2),\n                                        className: \"w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 174,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 170,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"block text-sm font-medium text-gray-300 mb-2\",\n                                        children: \"Offset\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 192,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"number\",\n                                        min: \"-50\",\n                                        max: \"50\",\n                                        value: localParams.offset,\n                                        onChange: (e)=>handleParamChange(\"offset\", parseInt(e.target.value) || 0),\n                                        className: \"w-full px-3 py-2 bg-gray-700 text-white rounded border border-gray-600 focus:border-blue-500 focus:outline-none\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 195,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 191,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                        lineNumber: 113,\n                        columnNumber: 13\n                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border border-gray-600 rounded p-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-sm font-medium text-gray-300 mb-3\",\n                                        children: \"Basic (Middle Band)\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 211,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Visible\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 216,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"checkbox\",\n                                                        checked: localStyle.basis.visible,\n                                                        onChange: (e)=>handleStyleChange(\"basis\", \"visible\", e.target.checked),\n                                                        className: \"w-4 h-4\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 217,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 215,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Color\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 227,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"color\",\n                                                        value: localStyle.basis.color,\n                                                        onChange: (e)=>handleStyleChange(\"basis\", \"color\", e.target.value),\n                                                        className: \"w-8 h-8 rounded border border-gray-600\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 228,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 226,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Width\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 238,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"number\",\n                                                        min: \"1\",\n                                                        max: \"5\",\n                                                        value: localStyle.basis.lineWidth,\n                                                        onChange: (e)=>handleStyleChange(\"basis\", \"lineWidth\", parseInt(e.target.value) || 1),\n                                                        className: \"w-16 px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 239,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 237,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Style\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 255,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                                        value: localStyle.basis.lineStyle,\n                                                        onChange: (e)=>handleStyleChange(\"basis\", \"lineStyle\", e.target.value),\n                                                        className: \"px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"solid\",\n                                                                children: \"Solid\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 263,\n                                                                columnNumber: 23\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"dashed\",\n                                                                children: \"Dashed\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 264,\n                                                                columnNumber: 23\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 256,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 254,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 214,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 210,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border border-gray-600 rounded p-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-sm font-medium text-gray-300 mb-3\",\n                                        children: \"Upper Band\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 272,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Visible\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 277,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"checkbox\",\n                                                        checked: localStyle.upper.visible,\n                                                        onChange: (e)=>handleStyleChange(\"upper\", \"visible\", e.target.checked),\n                                                        className: \"w-4 h-4\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 278,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 276,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Color\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 288,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"color\",\n                                                        value: localStyle.upper.color,\n                                                        onChange: (e)=>handleStyleChange(\"upper\", \"color\", e.target.value),\n                                                        className: \"w-8 h-8 rounded border border-gray-600\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 289,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 287,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Width\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 299,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"number\",\n                                                        min: \"1\",\n                                                        max: \"5\",\n                                                        value: localStyle.upper.lineWidth,\n                                                        onChange: (e)=>handleStyleChange(\"upper\", \"lineWidth\", parseInt(e.target.value) || 1),\n                                                        className: \"w-16 px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 300,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 298,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Style\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 316,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                                        value: localStyle.upper.lineStyle,\n                                                        onChange: (e)=>handleStyleChange(\"upper\", \"lineStyle\", e.target.value),\n                                                        className: \"px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"solid\",\n                                                                children: \"Solid\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 324,\n                                                                columnNumber: 23\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"dashed\",\n                                                                children: \"Dashed\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 325,\n                                                                columnNumber: 23\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 317,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 315,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 275,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 271,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border border-gray-600 rounded p-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-sm font-medium text-gray-300 mb-3\",\n                                        children: \"Lower Band\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 333,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Visible\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 338,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"checkbox\",\n                                                        checked: localStyle.lower.visible,\n                                                        onChange: (e)=>handleStyleChange(\"lower\", \"visible\", e.target.checked),\n                                                        className: \"w-4 h-4\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 339,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 337,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Color\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 349,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"color\",\n                                                        value: localStyle.lower.color,\n                                                        onChange: (e)=>handleStyleChange(\"lower\", \"color\", e.target.value),\n                                                        className: \"w-8 h-8 rounded border border-gray-600\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 350,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 348,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Width\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 360,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"number\",\n                                                        min: \"1\",\n                                                        max: \"5\",\n                                                        value: localStyle.lower.lineWidth,\n                                                        onChange: (e)=>handleStyleChange(\"lower\", \"lineWidth\", parseInt(e.target.value) || 1),\n                                                        className: \"w-16 px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 361,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 359,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Line Style\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 377,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                                        value: localStyle.lower.lineStyle,\n                                                        onChange: (e)=>handleStyleChange(\"lower\", \"lineStyle\", e.target.value),\n                                                        className: \"px-2 py-1 bg-gray-700 text-white rounded border border-gray-600 text-sm\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"solid\",\n                                                                children: \"Solid\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 385,\n                                                                columnNumber: 23\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                                value: \"dashed\",\n                                                                children: \"Dashed\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                                lineNumber: 386,\n                                                                columnNumber: 23\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 378,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 376,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 336,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 332,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"border border-gray-600 rounded p-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-sm font-medium text-gray-300 mb-3\",\n                                        children: \"Background Fill\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 394,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Visible\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 399,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"checkbox\",\n                                                        checked: localStyle.fill.visible,\n                                                        onChange: (e)=>handleStyleChange(\"fill\", \"visible\", e.target.checked),\n                                                        className: \"w-4 h-4\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 400,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 398,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center justify-between\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-sm text-gray-400\",\n                                                        children: \"Opacity\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 410,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"range\",\n                                                        min: \"0\",\n                                                        max: \"1\",\n                                                        step: \"0.1\",\n                                                        value: localStyle.fill.opacity,\n                                                        onChange: (e)=>handleStyleChange(\"fill\", \"opacity\", parseFloat(e.target.value)),\n                                                        className: \"w-24\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 411,\n                                                        columnNumber: 21\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-xs text-gray-500 w-8\",\n                                                        children: [\n                                                            Math.round(localStyle.fill.opacity * 100),\n                                                            \"%\"\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                        lineNumber: 426,\n                                                        columnNumber: 21\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                                lineNumber: 409,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                        lineNumber: 397,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                                lineNumber: 393,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                        lineNumber: 208,\n                        columnNumber: 13\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                    lineNumber: 111,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between p-4 border-t border-gray-700\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: resetToDefaults,\n                            className: \"px-4 py-2 text-sm text-gray-400 hover:text-white transition-colors\",\n                            children: \"Reset to Defaults\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 438,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: onClose,\n                            className: \"px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors\",\n                            children: \"Done\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                            lineNumber: 444,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n                    lineNumber: 437,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n            lineNumber: 72,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\akpxi\\\\Documents\\\\cursor\\\\ren1\\\\src\\\\components\\\\BollingerBandsSettings.tsx\",\n        lineNumber: 71,\n        columnNumber: 5\n    }, undefined);\n};\n_s(BollingerBandsSettings, \"sRxabEq42LVRLwr9IRvIs7Y0hXA=\");\n_c = BollingerBandsSettings;\n/* harmony default export */ __webpack_exports__[\"default\"] = (BollingerBandsSettings);\nvar _c;\n$RefreshReg$(_c, \"BollingerBandsSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0JvbGxpbmdlckJhbmRzU2V0dGluZ3MudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUV3QztBQUNQO0FBSUQ7QUFJRDtBQVkvQixNQUFNSyx5QkFBZ0U7UUFBQyxFQUNyRUMsTUFBTSxFQUNOQyxLQUFLLEVBQ0xDLGNBQWMsRUFDZEMsYUFBYSxFQUNiQyxPQUFPLEVBQ1I7O0lBQ0MsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdYLCtDQUFRQSxDQUFVO0lBQ3BELE1BQU0sQ0FBQ1ksYUFBYUMsZUFBZSxHQUFHYiwrQ0FBUUEsQ0FBdUJLO0lBQ3JFLE1BQU0sQ0FBQ1MsWUFBWUMsY0FBYyxHQUFHZiwrQ0FBUUEsQ0FBc0JNO0lBRWxFLE1BQU1VLG9CQUFvQixDQUN4QkMsS0FDQUM7UUFFQSxNQUFNQyxZQUFZO1lBQUUsR0FBR1AsV0FBVztZQUFFLENBQUNLLElBQUksRUFBRUM7UUFBTTtRQUNqREwsZUFBZU07UUFDZlosZUFBZVk7SUFDakI7SUFFQSxNQUFNQyxvQkFBb0IsQ0FDeEJDLE1BQ0FDLFVBQ0FKO1FBRUEsTUFBTUssV0FBVztZQUNmLEdBQUdULFVBQVU7WUFDYixDQUFDTyxLQUFLLEVBQUU7Z0JBQ04sR0FBR1AsVUFBVSxDQUFDTyxLQUFLO2dCQUNuQixDQUFDQyxTQUFTLEVBQUVKO1lBQ2Q7UUFDRjtRQUNBSCxjQUFjUTtRQUNkZixjQUFjZTtJQUNoQjtJQUVBLE1BQU1DLGtCQUFrQjtRQUN0QixJQUFJZCxjQUFjLFVBQVU7WUFDMUJHLGVBQWVYLDJFQUF3QkE7WUFDdkNLLGVBQWVMLDJFQUF3QkE7UUFDekMsT0FBTztZQUNMYSxjQUFjWix5RUFBdUJBO1lBQ3JDSyxjQUFjTCx5RUFBdUJBO1FBQ3ZDO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ3NCO1FBQUlDLFdBQVU7a0JBQ2IsNEVBQUNEO1lBQUlDLFdBQVU7OzhCQUViLDhEQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ2IsOERBQUNDOzRC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Q0FBQ0MsT0FBTzt3REFDOUJ2QixVQUFVLENBQUNDLElBQ1RsQixrQkFDRSxRQUNBLFdBQ0EyQixXQUFXVCxFQUFFRSxNQUFNLENBQUN0QixLQUFLO3dEQUc3QlEsV0FBVTs7Ozs7O2tFQUVaLDhEQUFDd0I7d0RBQUt4QixXQUFVOzs0REFDYm1DLEtBQUtDLEtBQUssQ0FBQ2hELFdBQVc2QyxJQUFJLENBQUNDLE9BQU8sR0FBRzs0REFBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQVV6RCw4REFBQ25DO29CQUFJQyxXQUFVOztzQ0FDYiw4REFBQ0U7NEJBQ0NDLFNBQVNMOzRCQUNURSxXQUFVO3NDQUNYOzs7Ozs7c0NBR0QsOERBQUNFOzRCQUNDQyxTQUFTcEI7NEJBQ1RpQixXQUFVO3NDQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9YO0dBOWFNdEI7S0FBQUE7QUFnYk4sK0RBQWVBLHNCQUFzQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Cb2xsaW5nZXJCYW5kc1NldHRpbmdzLnRzeD9jNTJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IFggfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XHJcbmltcG9ydCB7XHJcbiAgQm9sbGluZ2VyQmFuZHNQYXJhbXMsXHJcbiAgREVGQVVMVF9CT0xMSU5HRVJfUEFSQU1TLFxyXG59IGZyb20gXCJAL3V0aWxzL2JvbGxpbmdlckJhbmRzXCI7XHJcbmltcG9ydCB7XHJcbiAgQm9sbGluZ2VyQmFuZHNTdHlsZSxcclxuICBERUZBVUxUX0JPTExJTkdFUl9TVFlMRSxcclxufSBmcm9tIFwiLi9Cb2xsaW5nZXJCYW5kc0NoYXJ0XCI7XHJcblxyXG5pbnRlcmZhY2UgQm9sbGluZ2VyQmFuZHNTZXR0aW5nc1Byb3BzIHtcclxuICBwYXJhbXM6IEJvbGxpbmdlckJhbmRzUGFyYW1zO1xyXG4gIHN0eWxlOiBCb2xsaW5nZXJCYW5kc1N0eWxlO1xyXG4gIG9uUGFyYW1zQ2hhbmdlOiAocGFyYW1zOiBCb2xsaW5nZXJCYW5kc1BhcmFtcykgPT4gdm9pZDtcclxuICBvblN0eWxlQ2hhbmdlOiAoc3R5bGU6IEJvbGxpbmdlckJhbmRzU3R5bGUpID0+IHZvaWQ7XHJcbiAgb25DbG9zZTogKCkgPT4gdm9pZDtcclxufVxyXG5cclxudHlwZSBUYWJUeXBlID0gXCJpbnB1dHNcIiB8IFwic3R5bGVcIjtcclxuXHJcbmNvbnN0IEJvbGxpbmdlckJhbmRzU2V0dGluZ3M6IFJlYWN0LkZDPEJvbGxpbmdlckJhbmRzU2V0dGluZ3NQcm9wcz4gPSAoe1xyXG4gIHBhcmFtcyxcclxuICBzdHlsZSxcclxuICBvblBhcmFtc0NoYW5nZSxcclxuICBvblN0eWxlQ2hhbmdlLFxyXG4gIG9uQ2xvc2UsXHJcbn0pID0+IHtcclxuICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGU8VGFiVHlwZT4oXCJpbnB1dHNcIik7XHJcbiAgY29uc3QgW2xvY2FsUGFyYW1zLCBzZXRMb2NhbFBhcmFtc10gPSB1c2VTdGF0ZTxCb2xsaW5nZXJCYW5kc1BhcmFtcz4ocGFyYW1zKTtcclxuICBjb25zdCBbbG9jYWxTdHlsZSwgc2V0TG9jYWxTdHlsZV0gPSB1c2VTdGF0ZTxCb2xsaW5nZXJCYW5kc1N0eWxlPihzdHlsZSk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZVBhcmFtQ2hhbmdlID0gPEsgZXh0ZW5kcyBrZXlvZiBCb2xsaW5nZXJCYW5kc1BhcmFtcz4oXHJcbiAgICBrZXk6IEssXHJcbiAgICB2YWx1ZTogQm9sbGluZ2VyQmFuZHNQYXJhbXNbS11cclxuICApID0+IHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHsgLi4ubG9jYWxQYXJhbXMsIFtrZXldOiB2YWx1ZSB9O1xyXG4gICAgc2V0TG9jYWxQYXJhbXMobmV3UGFyYW1zKTtcclxuICAgIG9uUGFyYW1zQ2hhbmdlKG5ld1BhcmFtcyk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3R5bGVDaGFuZ2UgPSAoXHJcbiAgICBiYW5kOiBrZXlvZiBCb2xsaW5nZXJCYW5kc1N0eWxlLFxyXG4gICAgcHJvcGVydHk6IHN0cmluZyxcclxuICAgIHZhbHVlOiBhbnlcclxuICApID0+IHtcclxuICAgIGNvbnN0IG5ld1N0eWxlID0ge1xyXG4gICAgICAuLi5sb2NhbFN0eWxlLFxyXG4gICAgICBbYmFuZF06IHtcclxuICAgICAgICAuLi5sb2NhbFN0eWxlW2JhbmRdLFxyXG4gICAgICAgIFtwcm9wZXJ0eV06IHZhbHVlLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICAgIHNldExvY2FsU3R5bGUobmV3U3R5bGUpO1xyXG4gICAgb25TdHlsZUNoYW5nZShuZXdTdHlsZSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVzZXRUb0RlZmF1bHRzID0gKCkgPT4ge1xyXG4gICAgaWYgKGFjdGl2ZVRhYiA9PT0gXCJpbnB1dHNcIikge1xyXG4gICAgICBzZXRMb2NhbFBhcmFtcyhERUZBVUxUX0JPTExJTkdFUl9QQVJBTVMpO1xyXG4gICAgICBvblBhcmFtc0NoYW5nZShERUZBVUxUX0JPTExJTkdFUl9QQVJBTVMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0TG9jYWxTdHlsZShERUZBVUxUX0JPTExJTkdFUl9TVFlMRSk7XHJcbiAgICAgIG9uU3R5bGVDaGFuZ2UoREVGQVVMVF9CT0xMSU5HRVJfU1RZTEUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgYmctYmxhY2sgYmctb3BhY2l0eS01MCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB6LTUwXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS04MDAgcm91bmRlZC1sZyBzaGFkb3ctMnhsIHctOTYgbWF4LWgtWzgwdmhdIG92ZXJmbG93LWhpZGRlblwiPlxyXG4gICAgICAgIHsvKiBIZWFkZXIgKi99XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcC00IGJvcmRlci1iIGJvcmRlci1ncmF5LTcwMFwiPlxyXG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlXCI+XHJcbiAgICAgICAgICAgIEJvbGxpbmdlciBCYW5kcyBTZXR0aW5nc1xyXG4gICAgICAgICAgPC9oMj5cclxuICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCBob3Zlcjp0ZXh0LXdoaXRlIHRyYW5zaXRpb24tY29sb3JzXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPFggc2l6ZT17MjB9IC8+XHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgey8qIFRhYnMgKi99XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGJvcmRlci1iIGJvcmRlci1ncmF5LTcwMFwiPlxyXG4gICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBY3RpdmVUYWIoXCJpbnB1dHNcIil9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXgtMSBweS0zIHB4LTQgdGV4dC1zbSBmb250LW1lZGl1bSB0cmFuc2l0aW9uLWNvbG9ycyAke1xyXG4gICAgICAgICAgICAgIGFjdGl2ZVRhYiA9PT0gXCJpbnB1dHNcIlxyXG4gICAgICAgICAgICAgICAgPyBcInRleHQtYmx1ZS00MDAgYm9yZGVyLWItMiBib3JkZXItYmx1ZS00MDAgYmctZ3JheS03NTBcIlxyXG4gICAgICAgICAgICAgICAgOiBcInRleHQtZ3JheS00MDAgaG92ZXI6dGV4dC13aGl0ZVwiXHJcbiAgICAgICAgICAgIH1gfVxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBJbnB1dHNcclxuICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBY3RpdmVUYWIoXCJzdHlsZVwiKX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgZmxleC0xIHB5LTMgcHgtNCB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRyYW5zaXRpb24tY29sb3JzICR7XHJcbiAgICAgICAgICAgICAgYWN0aXZlVGFiID09PSBcInN0eWxlXCJcclxuICAgICAgICAgICAgICAgID8gXCJ0ZXh0LWJsdWUtNDAwIGJvcmRlci1iLTIgYm9yZGVyLWJsdWUtNDAwIGJnLWdyYXktNzUwXCJcclxuICAgICAgICAgICAgICAgIDogXCJ0ZXh0LWdyYXktNDAwIGhvdmVyOnRleHQtd2hpdGVcIlxyXG4gICAgICAgICAgICB9YH1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgU3R5bGVcclxuICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogQ29udGVudCAqL31cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBtYXgtaC05NiBvdmVyZmxvdy15LWF1dG9cIj5cclxuICAgICAgICAgIHthY3RpdmVUYWIgPT09IFwiaW5wdXRzXCIgPyAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+XHJcbiAgICAgICAgICAgICAgey8qIExlbmd0aCAqL31cclxuICAgICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImJsb2NrIHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTMwMCBtYi0yXCI+XHJcbiAgICAgICAgICAgICAgICAgIExlbmd0aFxyXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgbWluPVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgIG1heD1cIjIwMFwiXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFBhcmFtcy5sZW5ndGh9XHJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJhbUNoYW5nZShcImxlbmd0aFwiLCBwYXJzZUludChlLnRhcmdldC52YWx1ZSkgfHwgMjApXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHB4LTMgcHktMiBiZy1ncmF5LTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCBmb2N1czpib3JkZXItYmx1ZS01MDAgZm9jdXM6b3V0bGluZS1ub25lXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgIHsvKiBNQSBUeXBlICovfVxyXG4gICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktMzAwIG1iLTJcIj5cclxuICAgICAgICAgICAgICAgICAgQmFzaWMgTUEgVHlwZVxyXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3RcclxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2xvY2FsUGFyYW1zLm1hVHlwZX1cclxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhcmFtQ2hhbmdlKFwibWFUeXBlXCIsIGUudGFyZ2V0LnZhbHVlIGFzIFwiU01BXCIpXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHB4LTMgcHktMiBiZy1ncmF5LTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCBmb2N1czpib3JkZXItYmx1ZS01MDAgZm9jdXM6b3V0bGluZS1ub25lXCJcclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlNNQVwiPlNNQTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgIHsvKiBTb3VyY2UgKi99XHJcbiAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS0zMDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgICBTb3VyY2VcclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8c2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFBhcmFtcy5zb3VyY2V9XHJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJhbUNoYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgIFwic291cmNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSBhcyBcIm9wZW5cIiB8IFwiaGlnaFwiIHwgXCJsb3dcIiB8IFwiY2xvc2VcIlxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgcHgtMyBweS0yIGJnLWdyYXktNzAwIHRleHQtd2hpdGUgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktNjAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY2xvc2VcIj5DbG9zZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwib3BlblwiPk9wZW48L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImhpZ2hcIj5IaWdoPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJsb3dcIj5Mb3c8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICB7LyogU3RkRGV2IE11bHRpcGxpZXIgKi99XHJcbiAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS0zMDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgICBTdGREZXYgKG11bHRpcGxpZXIpXHJcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICBtaW49XCIwLjFcIlxyXG4gICAgICAgICAgICAgICAgICBtYXg9XCIxMFwiXHJcbiAgICAgICAgICAgICAgICAgIHN0ZXA9XCIwLjFcIlxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17bG9jYWxQYXJhbXMuc3RkRGV2TXVsdGlwbGllcn1cclxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhcmFtQ2hhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJzdGREZXZNdWx0aXBsaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKSB8fCAyXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBweC0zIHB5LTIgYmctZ3JheS03MDAgdGV4dC13aGl0ZSByb3VuZGVkIGJvcmRlciBib3JkZXItZ3JheS02MDAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwIGZvY3VzOm91dGxpbmUtbm9uZVwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICB7LyogT2Zmc2V0ICovfVxyXG4gICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktMzAwIG1iLTJcIj5cclxuICAgICAgICAgICAgICAgICAgT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICBtaW49XCItNTBcIlxyXG4gICAgICAgICAgICAgICAgICBtYXg9XCI1MFwiXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFBhcmFtcy5vZmZzZXR9XHJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXJhbUNoYW5nZShcIm9mZnNldFwiLCBwYXJzZUludChlLnRhcmdldC52YWx1ZSkgfHwgMClcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgcHgtMyBweS0yIGJnLWdyYXktNzAwIHRleHQtd2hpdGUgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktNjAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMCBmb2N1czpvdXRsaW5lLW5vbmVcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxyXG4gICAgICAgICAgICAgIHsvKiBCYXNpYyAoTWlkZGxlIEJhbmQpICovfVxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyIGJvcmRlci1ncmF5LTYwMCByb3VuZGVkIHAtM1wiPlxyXG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTMwMCBtYi0zXCI+XHJcbiAgICAgICAgICAgICAgICAgIEJhc2ljIChNaWRkbGUgQmFuZClcclxuICAgICAgICAgICAgICAgIDwvaDM+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktM1wiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMFwiPlZpc2libGU8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17bG9jYWxTdHlsZS5iYXNpcy52aXNpYmxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZUNoYW5nZShcImJhc2lzXCIsIFwidmlzaWJsZVwiLCBlLnRhcmdldC5jaGVja2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy00IGgtNFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+Q29sb3I8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2xvY2FsU3R5bGUuYmFzaXMuY29sb3J9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0eWxlQ2hhbmdlKFwiYmFzaXNcIiwgXCJjb2xvclwiLCBlLnRhcmdldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctOCBoLTggcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktNjAwXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5MaW5lIFdpZHRoPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBtaW49XCIxXCJcclxuICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2xvY2FsU3R5bGUuYmFzaXMubGluZVdpZHRofVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZUNoYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhc2lzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lV2lkdGhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChlLnRhcmdldC52YWx1ZSkgfHwgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTE2IHB4LTIgcHktMSBiZy1ncmF5LTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCB0ZXh0LXNtXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5MaW5lIFN0eWxlPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzZWxlY3RcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFN0eWxlLmJhc2lzLmxpbmVTdHlsZX1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGVDaGFuZ2UoXCJiYXNpc1wiLCBcImxpbmVTdHlsZVwiLCBlLnRhcmdldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmF5LTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCB0ZXh0LXNtXCJcclxuICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic29saWRcIj5Tb2xpZDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImRhc2hlZFwiPkRhc2hlZDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICB7LyogVXBwZXIgQmFuZCAqL31cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlciBib3JkZXItZ3JheS02MDAgcm91bmRlZCBwLTNcIj5cclxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS0zMDAgbWItM1wiPlxyXG4gICAgICAgICAgICAgICAgICBVcHBlciBCYW5kXHJcbiAgICAgICAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTNcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5WaXNpYmxlPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2xvY2FsU3R5bGUudXBwZXIudmlzaWJsZX1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGVDaGFuZ2UoXCJ1cHBlclwiLCBcInZpc2libGVcIiwgZS50YXJnZXQuY2hlY2tlZClcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMFwiPkNvbG9yPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNvbG9yXCJcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFN0eWxlLnVwcGVyLmNvbG9yfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZUNoYW5nZShcInVwcGVyXCIsIFwiY29sb3JcIiwgZS50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTggaC04IHJvdW5kZWQgYm9yZGVyIGJvcmRlci1ncmF5LTYwMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+TGluZSBXaWR0aDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgbWluPVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXg9XCI1XCJcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFN0eWxlLnVwcGVyLmxpbmVXaWR0aH1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGVDaGFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1cHBlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVdpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZS50YXJnZXQudmFsdWUpIHx8IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy0xNiBweC0yIHB5LTEgYmctZ3JheS03MDAgdGV4dC13aGl0ZSByb3VuZGVkIGJvcmRlciBib3JkZXItZ3JheS02MDAgdGV4dC1zbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+TGluZSBTdHlsZTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8c2VsZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bG9jYWxTdHlsZS51cHBlci5saW5lU3R5bGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0eWxlQ2hhbmdlKFwidXBwZXJcIiwgXCJsaW5lU3R5bGVcIiwgZS50YXJnZXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctZ3JheS03MDAgdGV4dC13aGl0ZSByb3VuZGVkIGJvcmRlciBib3JkZXItZ3JheS02MDAgdGV4dC1zbVwiXHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbGlkXCI+U29saWQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJkYXNoZWRcIj5EYXNoZWQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgey8qIExvd2VyIEJhbmQgKi99XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgYm9yZGVyLWdyYXktNjAwIHJvdW5kZWQgcC0zXCI+XHJcbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktMzAwIG1iLTNcIj5cclxuICAgICAgICAgICAgICAgICAgTG93ZXIgQmFuZFxyXG4gICAgICAgICAgICAgICAgPC9oMz5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0zXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+VmlzaWJsZTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtsb2NhbFN0eWxlLmxvd2VyLnZpc2libGV9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0eWxlQ2hhbmdlKFwibG93ZXJcIiwgXCJ2aXNpYmxlXCIsIGUudGFyZ2V0LmNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5Db2xvcjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bG9jYWxTdHlsZS5sb3dlci5jb2xvcn1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGVDaGFuZ2UoXCJsb3dlclwiLCBcImNvbG9yXCIsIGUudGFyZ2V0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy04IGgtOCByb3VuZGVkIGJvcmRlciBib3JkZXItZ3JheS02MDBcIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMFwiPkxpbmUgV2lkdGg8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgbWF4PVwiNVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17bG9jYWxTdHlsZS5sb3dlci5saW5lV2lkdGh9XHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0eWxlQ2hhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibG93ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVXaWR0aFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSB8fCAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctMTYgcHgtMiBweS0xIGJnLWdyYXktNzAwIHRleHQtd2hpdGUgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktNjAwIHRleHQtc21cIlxyXG4gICAgICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMFwiPkxpbmUgU3R5bGU8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2xvY2FsU3R5bGUubG93ZXIubGluZVN0eWxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZUNoYW5nZShcImxvd2VyXCIsIFwibGluZVN0eWxlXCIsIGUudGFyZ2V0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJnLWdyYXktNzAwIHRleHQtd2hpdGUgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktNjAwIHRleHQtc21cIlxyXG4gICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzb2xpZFwiPlNvbGlkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZGFzaGVkXCI+RGFzaGVkPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgIHsvKiBCYWNrZ3JvdW5kIEZpbGwgKi99XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgYm9yZGVyLWdyYXktNjAwIHJvdW5kZWQgcC0zXCI+XHJcbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktMzAwIG1iLTNcIj5cclxuICAgICAgICAgICAgICAgICAgQmFja2dyb3VuZCBGaWxsXHJcbiAgICAgICAgICAgICAgICA8L2gzPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTNcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5WaXNpYmxlPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2xvY2FsU3R5bGUuZmlsbC52aXNpYmxlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVTdHlsZUNoYW5nZShcImZpbGxcIiwgXCJ2aXNpYmxlXCIsIGUudGFyZ2V0LmNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS00MDBcIj5PcGFjaXR5PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcclxuICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMC4xXCJcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFN0eWxlLmZpbGwub3BhY2l0eX1cclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3R5bGVDaGFuZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcGFjaXR5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy0yNFwiXHJcbiAgICAgICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDAgdy04XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7TWF0aC5yb3VuZChsb2NhbFN0eWxlLmZpbGwub3BhY2l0eSAqIDEwMCl9JVxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogRm9vdGVyICovfVxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHAtNCBib3JkZXItdCBib3JkZXItZ3JheS03MDBcIj5cclxuICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgb25DbGljaz17cmVzZXRUb0RlZmF1bHRzfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgdGV4dC1zbSB0ZXh0LWdyYXktNDAwIGhvdmVyOnRleHQtd2hpdGUgdHJhbnNpdGlvbi1jb2xvcnNcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBSZXNldCB0byBEZWZhdWx0c1xyXG4gICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdHJhbnNpdGlvbi1jb2xvcnNcIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICBEb25lXHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQm9sbGluZ2VyQmFuZHNTZXR0aW5ncztcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJYIiwiREVGQVVMVF9CT0xMSU5HRVJfUEFSQU1TIiwiREVGQVVMVF9CT0xMSU5HRVJfU1RZTEUiLCJCb2xsaW5nZXJCYW5kc1NldHRpbmdzIiwicGFyYW1zIiwic3R5bGUiLCJvblBhcmFtc0NoYW5nZSIsIm9uU3R5bGVDaGFuZ2UiLCJvbkNsb3NlIiwiYWN0aXZlVGFiIiwic2V0QWN0aXZlVGFiIiwibG9jYWxQYXJhbXMiLCJzZXRMb2NhbFBhcmFtcyIsImxvY2FsU3R5bGUiLCJzZXRMb2NhbFN0eWxlIiwiaGFuZGxlUGFyYW1DaGFuZ2UiLCJrZXkiLCJ2YWx1ZSIsIm5ld1BhcmFtcyIsImhhbmRsZVN0eWxlQ2hhbmdlIiwiYmFuZCIsInByb3BlcnR5IiwibmV3U3R5bGUiLCJyZXNldFRvRGVmYXVsdHMiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzaXplIiwibGFiZWwiLCJpbnB1dCIsInR5cGUiLCJtaW4iLCJtYXgiLCJsZW5ndGgiLCJvbkNoYW5nZSIsImUiLCJwYXJzZUludCIsInRhcmdldCIsInNlbGVjdCIsIm1hVHlwZSIsIm9wdGlvbiIsInNvdXJjZSIsInN0ZXAiLCJzdGREZXZNdWx0aXBsaWVyIiwicGFyc2VGbG9hdCIsIm9mZnNldCIsImgzIiwic3BhbiIsImNoZWNrZWQiLCJiYXNpcyIsInZpc2libGUiLCJjb2xvciIsImxpbmVXaWR0aCIsImxpbmVTdHlsZSIsInVwcGVyIiwibG93ZXIiLCJmaWxsIiwib3BhY2l0eSIsIk1hdGgiLCJyb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/BollingerBandsSettings.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/data/sampleData.ts":
/*!********************************!*\
  !*** ./src/data/sampleData.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToKLineFormat: function() { return /* binding */ convertToKLineFormat; },\n/* harmony export */   generateSampleData: function() { return /* binding */ generateSampleData; },\n/* harmony export */   sampleData: function() { return /* binding */ sampleData; }\n/* harmony export */ });\n// Generate realistic OHLCV data for demo purposes\nfunction generateSampleData() {\n    let count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;\n    const data = [];\n    let currentPrice = 100; // Starting price\n    const baseTime = Date.now() - count * 24 * 60 * 60 * 1000; // Start from 'count' days ago\n    for(let i = 0; i < count; i++){\n        const timestamp = baseTime + i * 24 * 60 * 60 * 1000; // Daily candles\n        // Generate realistic price movements with some trend and volatility\n        const trend = Math.sin(i / 20) * 0.5; // Long-term trend\n        const volatility = (Math.random() - 0.5) * 4; // Random volatility\n        const priceChange = trend + volatility;\n        currentPrice = Math.max(1, currentPrice + priceChange); // Ensure price stays positive\n        // Generate OHLC values\n        const open = currentPrice;\n        const rangeFactor = Math.random() * 0.1 + 0.02; // 2-12% range\n        const range = open * rangeFactor;\n        const high = open + Math.random() * range;\n        const low = open - Math.random() * range;\n        // Close price influences next candle's open\n        const closeDirection = Math.random() - 0.5;\n        const close = open + closeDirection * range * 0.7;\n        currentPrice = close;\n        // Ensure OHLC logic is maintained\n        const actualHigh = Math.max(open, high, low, close);\n        const actualLow = Math.min(open, high, low, close);\n        // Generate volume (higher volume on bigger price moves)\n        const volumeBase = 1000000;\n        const volumeVariation = Math.abs(priceChange) * 500000;\n        const volume = Math.floor(volumeBase + volumeVariation + Math.random() * 2000000);\n        data.push({\n            timestamp,\n            open: Math.round(open * 100) / 100,\n            high: Math.round(actualHigh * 100) / 100,\n            low: Math.round(actualLow * 100) / 100,\n            close: Math.round(close * 100) / 100,\n            volume\n        });\n    }\n    return data;\n}\n// Convert to KLineCharts format\nfunction convertToKLineFormat(data) {\n    return data.map((candle)=>({\n            timestamp: candle.timestamp,\n            open: candle.open,\n            high: candle.high,\n            low: candle.low,\n            close: candle.close,\n            volume: candle.volume\n        }));\n}\n// Sample data instance\nconst sampleData = generateSampleData(250);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL3NhbXBsZURhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBU0Esa0RBQWtEO0FBQzNDLFNBQVNBO1FBQW1CQyxRQUFBQSxpRUFBZ0I7SUFDakQsTUFBTUMsT0FBcUIsRUFBRTtJQUM3QixJQUFJQyxlQUFlLEtBQUssaUJBQWlCO0lBQ3pDLE1BQU1DLFdBQVdDLEtBQUtDLEdBQUcsS0FBS0wsUUFBUSxLQUFLLEtBQUssS0FBSyxNQUFNLDhCQUE4QjtJQUV6RixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSU4sT0FBT00sSUFBSztRQUM5QixNQUFNQyxZQUFZSixXQUFXRyxJQUFJLEtBQUssS0FBSyxLQUFLLE1BQU0sZ0JBQWdCO1FBRXRFLG9FQUFvRTtRQUNwRSxNQUFNRSxRQUFRQyxLQUFLQyxHQUFHLENBQUNKLElBQUksTUFBTSxLQUFLLGtCQUFrQjtRQUN4RCxNQUFNSyxhQUFhLENBQUNGLEtBQUtHLE1BQU0sS0FBSyxHQUFFLElBQUssR0FBRyxvQkFBb0I7UUFDbEUsTUFBTUMsY0FBY0wsUUFBUUc7UUFFNUJULGVBQWVPLEtBQUtLLEdBQUcsQ0FBQyxHQUFHWixlQUFlVyxjQUFjLDhCQUE4QjtRQUV0Rix1QkFBdUI7UUFDdkIsTUFBTUUsT0FBT2I7UUFDYixNQUFNYyxjQUFjUCxLQUFLRyxNQUFNLEtBQUssTUFBTSxNQUFNLGNBQWM7UUFDOUQsTUFBTUssUUFBUUYsT0FBT0M7UUFFckIsTUFBTUUsT0FBT0gsT0FBT04sS0FBS0csTUFBTSxLQUFLSztRQUNwQyxNQUFNRSxNQUFNSixPQUFPTixLQUFLRyxNQUFNLEtBQUtLO1FBRW5DLDRDQUE0QztRQUM1QyxNQUFNRyxpQkFBaUJYLEtBQUtHLE1BQU0sS0FBSztRQUN2QyxNQUFNUyxRQUFRTixPQUFPSyxpQkFBaUJILFFBQVE7UUFDOUNmLGVBQWVtQjtRQUVmLGtDQUFrQztRQUNsQyxNQUFNQyxhQUFhYixLQUFLSyxHQUFHLENBQUNDLE1BQU1HLE1BQU1DLEtBQUtFO1FBQzdDLE1BQU1FLFlBQVlkLEtBQUtlLEdBQUcsQ0FBQ1QsTUFBTUcsTUFBTUMsS0FBS0U7UUFFNUMsd0RBQXdEO1FBQ3hELE1BQU1JLGFBQWE7UUFDbkIsTUFBTUMsa0JBQWtCakIsS0FBS2tCLEdBQUcsQ0FBQ2QsZUFBZTtRQUNoRCxNQUFNZSxTQUFTbkIsS0FBS29CLEtBQUssQ0FDdkJKLGFBQWFDLGtCQUFrQmpCLEtBQUtHLE1BQU0sS0FBSztRQUdqRFgsS0FBSzZCLElBQUksQ0FBQztZQUNSdkI7WUFDQVEsTUFBTU4sS0FBS3NCLEtBQUssQ0FBQ2hCLE9BQU8sT0FBTztZQUMvQkcsTUFBTVQsS0FBS3NCLEtBQUssQ0FBQ1QsYUFBYSxPQUFPO1lBQ3JDSCxLQUFLVixLQUFLc0IsS0FBSyxDQUFDUixZQUFZLE9BQU87WUFDbkNGLE9BQU9aLEtBQUtzQixLQUFLLENBQUNWLFFBQVEsT0FBTztZQUNqQ087UUFDRjtJQUNGO0lBRUEsT0FBTzNCO0FBQ1Q7QUFFQSxnQ0FBZ0M7QUFDekIsU0FBUytCLHFCQUFxQi9CLElBQWtCO0lBQ3JELE9BQU9BLEtBQUtnQyxHQUFHLENBQUMsQ0FBQ0MsU0FBWTtZQUMzQjNCLFdBQVcyQixPQUFPM0IsU0FBUztZQUMzQlEsTUFBTW1CLE9BQU9uQixJQUFJO1lBQ2pCRyxNQUFNZ0IsT0FBT2hCLElBQUk7WUFDakJDLEtBQUtlLE9BQU9mLEdBQUc7WUFDZkUsT0FBT2EsT0FBT2IsS0FBSztZQUNuQk8sUUFBUU0sT0FBT04sTUFBTTtRQUN2QjtBQUNGO0FBRUEsdUJBQXVCO0FBQ2hCLE1BQU1PLGFBQWFwQyxtQkFBbUIsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZGF0YS9zYW1wbGVEYXRhLnRzP2Q0MTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBDYW5kbGVEYXRhIHtcclxuICB0aW1lc3RhbXA6IG51bWJlcjtcclxuICBvcGVuOiBudW1iZXI7XHJcbiAgaGlnaDogbnVtYmVyO1xyXG4gIGxvdzogbnVtYmVyO1xyXG4gIGNsb3NlOiBudW1iZXI7XHJcbiAgdm9sdW1lOiBudW1iZXI7XHJcbn1cclxuXHJcbi8vIEdlbmVyYXRlIHJlYWxpc3RpYyBPSExDViBkYXRhIGZvciBkZW1vIHB1cnBvc2VzXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNhbXBsZURhdGEoY291bnQ6IG51bWJlciA9IDI1MCk6IENhbmRsZURhdGFbXSB7XHJcbiAgY29uc3QgZGF0YTogQ2FuZGxlRGF0YVtdID0gW107XHJcbiAgbGV0IGN1cnJlbnRQcmljZSA9IDEwMDsgLy8gU3RhcnRpbmcgcHJpY2VcclxuICBjb25zdCBiYXNlVGltZSA9IERhdGUubm93KCkgLSBjb3VudCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIFN0YXJ0IGZyb20gJ2NvdW50JyBkYXlzIGFnb1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGJhc2VUaW1lICsgaSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIERhaWx5IGNhbmRsZXNcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSByZWFsaXN0aWMgcHJpY2UgbW92ZW1lbnRzIHdpdGggc29tZSB0cmVuZCBhbmQgdm9sYXRpbGl0eVxyXG4gICAgY29uc3QgdHJlbmQgPSBNYXRoLnNpbihpIC8gMjApICogMC41OyAvLyBMb25nLXRlcm0gdHJlbmRcclxuICAgIGNvbnN0IHZvbGF0aWxpdHkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA0OyAvLyBSYW5kb20gdm9sYXRpbGl0eVxyXG4gICAgY29uc3QgcHJpY2VDaGFuZ2UgPSB0cmVuZCArIHZvbGF0aWxpdHk7XHJcblxyXG4gICAgY3VycmVudFByaWNlID0gTWF0aC5tYXgoMSwgY3VycmVudFByaWNlICsgcHJpY2VDaGFuZ2UpOyAvLyBFbnN1cmUgcHJpY2Ugc3RheXMgcG9zaXRpdmVcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBPSExDIHZhbHVlc1xyXG4gICAgY29uc3Qgb3BlbiA9IGN1cnJlbnRQcmljZTtcclxuICAgIGNvbnN0IHJhbmdlRmFjdG9yID0gTWF0aC5yYW5kb20oKSAqIDAuMSArIDAuMDI7IC8vIDItMTIlIHJhbmdlXHJcbiAgICBjb25zdCByYW5nZSA9IG9wZW4gKiByYW5nZUZhY3RvcjtcclxuXHJcbiAgICBjb25zdCBoaWdoID0gb3BlbiArIE1hdGgucmFuZG9tKCkgKiByYW5nZTtcclxuICAgIGNvbnN0IGxvdyA9IG9wZW4gLSBNYXRoLnJhbmRvbSgpICogcmFuZ2U7XHJcblxyXG4gICAgLy8gQ2xvc2UgcHJpY2UgaW5mbHVlbmNlcyBuZXh0IGNhbmRsZSdzIG9wZW5cclxuICAgIGNvbnN0IGNsb3NlRGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAtIDAuNTtcclxuICAgIGNvbnN0IGNsb3NlID0gb3BlbiArIGNsb3NlRGlyZWN0aW9uICogcmFuZ2UgKiAwLjc7XHJcbiAgICBjdXJyZW50UHJpY2UgPSBjbG9zZTtcclxuXHJcbiAgICAvLyBFbnN1cmUgT0hMQyBsb2dpYyBpcyBtYWludGFpbmVkXHJcbiAgICBjb25zdCBhY3R1YWxIaWdoID0gTWF0aC5tYXgob3BlbiwgaGlnaCwgbG93LCBjbG9zZSk7XHJcbiAgICBjb25zdCBhY3R1YWxMb3cgPSBNYXRoLm1pbihvcGVuLCBoaWdoLCBsb3csIGNsb3NlKTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSB2b2x1bWUgKGhpZ2hlciB2b2x1bWUgb24gYmlnZ2VyIHByaWNlIG1vdmVzKVxyXG4gICAgY29uc3Qgdm9sdW1lQmFzZSA9IDEwMDAwMDA7XHJcbiAgICBjb25zdCB2b2x1bWVWYXJpYXRpb24gPSBNYXRoLmFicyhwcmljZUNoYW5nZSkgKiA1MDAwMDA7XHJcbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLmZsb29yKFxyXG4gICAgICB2b2x1bWVCYXNlICsgdm9sdW1lVmFyaWF0aW9uICsgTWF0aC5yYW5kb20oKSAqIDIwMDAwMDBcclxuICAgICk7XHJcblxyXG4gICAgZGF0YS5wdXNoKHtcclxuICAgICAgdGltZXN0YW1wLFxyXG4gICAgICBvcGVuOiBNYXRoLnJvdW5kKG9wZW4gKiAxMDApIC8gMTAwLFxyXG4gICAgICBoaWdoOiBNYXRoLnJvdW5kKGFjdHVhbEhpZ2ggKiAxMDApIC8gMTAwLFxyXG4gICAgICBsb3c6IE1hdGgucm91bmQoYWN0dWFsTG93ICogMTAwKSAvIDEwMCxcclxuICAgICAgY2xvc2U6IE1hdGgucm91bmQoY2xvc2UgKiAxMDApIC8gMTAwLFxyXG4gICAgICB2b2x1bWUsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG4vLyBDb252ZXJ0IHRvIEtMaW5lQ2hhcnRzIGZvcm1hdFxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvS0xpbmVGb3JtYXQoZGF0YTogQ2FuZGxlRGF0YVtdKSB7XHJcbiAgcmV0dXJuIGRhdGEubWFwKChjYW5kbGUpID0+ICh7XHJcbiAgICB0aW1lc3RhbXA6IGNhbmRsZS50aW1lc3RhbXAsXHJcbiAgICBvcGVuOiBjYW5kbGUub3BlbixcclxuICAgIGhpZ2g6IGNhbmRsZS5oaWdoLFxyXG4gICAgbG93OiBjYW5kbGUubG93LFxyXG4gICAgY2xvc2U6IGNhbmRsZS5jbG9zZSxcclxuICAgIHZvbHVtZTogY2FuZGxlLnZvbHVtZSxcclxuICB9KSk7XHJcbn1cclxuXHJcbi8vIFNhbXBsZSBkYXRhIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBzYW1wbGVEYXRhID0gZ2VuZXJhdGVTYW1wbGVEYXRhKDI1MCk7XHJcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZVNhbXBsZURhdGEiLCJjb3VudCIsImRhdGEiLCJjdXJyZW50UHJpY2UiLCJiYXNlVGltZSIsIkRhdGUiLCJub3ciLCJpIiwidGltZXN0YW1wIiwidHJlbmQiLCJNYXRoIiwic2luIiwidm9sYXRpbGl0eSIsInJhbmRvbSIsInByaWNlQ2hhbmdlIiwibWF4Iiwib3BlbiIsInJhbmdlRmFjdG9yIiwicmFuZ2UiLCJoaWdoIiwibG93IiwiY2xvc2VEaXJlY3Rpb24iLCJjbG9zZSIsImFjdHVhbEhpZ2giLCJhY3R1YWxMb3ciLCJtaW4iLCJ2b2x1bWVCYXNlIiwidm9sdW1lVmFyaWF0aW9uIiwiYWJzIiwidm9sdW1lIiwiZmxvb3IiLCJwdXNoIiwicm91bmQiLCJjb252ZXJ0VG9LTGluZUZvcm1hdCIsIm1hcCIsImNhbmRsZSIsInNhbXBsZURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/sampleData.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/bollingerBands.ts":
/*!*************************************!*\
  !*** ./src/utils/bollingerBands.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_BOLLINGER_PARAMS: function() { return /* binding */ DEFAULT_BOLLINGER_PARAMS; },\n/* harmony export */   calculateBollingerBands: function() { return /* binding */ calculateBollingerBands; },\n/* harmony export */   formatBollingerValue: function() { return /* binding */ formatBollingerValue; },\n/* harmony export */   getBollingerBandsAtTimestamp: function() { return /* binding */ getBollingerBandsAtTimestamp; }\n/* harmony export */ });\nconst DEFAULT_BOLLINGER_PARAMS = {\n    length: 20,\n    stdDevMultiplier: 2,\n    offset: 0,\n    source: \"close\",\n    maType: \"SMA\"\n};\n/**\r\n * Calculate Simple Moving Average (SMA)\r\n * @param values Array of values\r\n * @param period Period for SMA calculation\r\n * @returns Array of SMA values\r\n */ function calculateSMA(values, period) {\n    const sma = [];\n    for(let i = 0; i < values.length; i++){\n        if (i < period - 1) {\n            sma.push(NaN); // Not enough data points\n        } else {\n            const sum = values.slice(i - period + 1, i + 1).reduce((acc, val)=>acc + val, 0);\n            sma.push(sum / period);\n        }\n    }\n    return sma;\n}\n/**\r\n * Calculate Standard Deviation using sample standard deviation formula\r\n * Note: Using sample standard deviation (n-1 denominator) for consistency with most trading platforms\r\n * @param values Array of values\r\n * @param period Period for standard deviation calculation\r\n * @param smaValues Corresponding SMA values to use as mean\r\n * @returns Array of standard deviation values\r\n */ function calculateStandardDeviation(values, period, smaValues) {\n    const stdDev = [];\n    for(let i = 0; i < values.length; i++){\n        if (i < period - 1 || isNaN(smaValues[i])) {\n            stdDev.push(NaN);\n        } else {\n            const periodValues = values.slice(i - period + 1, i + 1);\n            const mean = smaValues[i];\n            // Calculate variance using sample standard deviation (n-1)\n            const squaredDifferences = periodValues.map((val)=>Math.pow(val - mean, 2));\n            const variance = squaredDifferences.reduce((acc, val)=>acc + val, 0) / (period - 1);\n            const standardDeviation = Math.sqrt(variance);\n            stdDev.push(standardDeviation);\n        }\n    }\n    return stdDev;\n}\n/**\r\n * Apply offset to data array\r\n * Positive offset shifts data forward (future), negative shifts backward (past)\r\n * @param data Array of data points\r\n * @param offset Number of periods to shift\r\n * @returns Shifted array\r\n */ function applyOffset(data, offset) {\n    if (offset === 0) return data;\n    const result = new Array(data.length);\n    if (offset > 0) {\n        // Shift forward: move data to the right, fill beginning with NaN\n        for(let i = 0; i < data.length; i++){\n            if (i < offset) {\n                result[i] = NaN;\n            } else {\n                result[i] = data[i - offset];\n            }\n        }\n    } else {\n        // Shift backward: move data to the left, fill end with NaN\n        const absOffset = Math.abs(offset);\n        for(let i = 0; i < data.length; i++){\n            if (i >= data.length - absOffset) {\n                result[i] = NaN;\n            } else {\n                result[i] = data[i + absOffset];\n            }\n        }\n    }\n    return result;\n}\n/**\r\n * Calculate Bollinger Bands for given candle data\r\n * @param candleData Array of OHLCV candle data\r\n * @param params Bollinger Bands parameters\r\n * @returns Array of Bollinger Bands data points\r\n */ function calculateBollingerBands(candleData) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_BOLLINGER_PARAMS;\n    if (candleData.length === 0) return [];\n    // Extract source values (close, open, high, low)\n    const sourceValues = candleData.map((candle)=>candle[params.source]);\n    // Calculate SMA (basis/middle band)\n    const smaValues = calculateSMA(sourceValues, params.length);\n    // Calculate Standard Deviation\n    const stdDevValues = calculateStandardDeviation(sourceValues, params.length, smaValues);\n    // Calculate upper and lower bands\n    const upperValues = smaValues.map((sma, i)=>isNaN(sma) || isNaN(stdDevValues[i]) ? NaN : sma + params.stdDevMultiplier * stdDevValues[i]);\n    const lowerValues = smaValues.map((sma, i)=>isNaN(sma) || isNaN(stdDevValues[i]) ? NaN : sma - params.stdDevMultiplier * stdDevValues[i]);\n    // Apply offset if specified\n    const offsetSMA = applyOffset(smaValues, params.offset);\n    const offsetUpper = applyOffset(upperValues, params.offset);\n    const offsetLower = applyOffset(lowerValues, params.offset);\n    const offsetStdDev = applyOffset(stdDevValues, params.offset);\n    // Combine into result format\n    const result = candleData.map((candle, i)=>({\n            timestamp: candle.timestamp,\n            basis: offsetSMA[i],\n            upper: offsetUpper[i],\n            lower: offsetLower[i],\n            stdDev: offsetStdDev[i]\n        }));\n    return result;\n}\n/**\r\n * Get Bollinger Bands value for a specific timestamp\r\n * @param bollingerData Array of Bollinger Bands data\r\n * @param timestamp Target timestamp\r\n * @returns Bollinger Bands data for the timestamp or null if not found\r\n */ function getBollingerBandsAtTimestamp(bollingerData, timestamp) {\n    return bollingerData.find((data)=>data.timestamp === timestamp) || null;\n}\n/**\r\n * Format Bollinger Bands value for display\r\n * @param value Numeric value\r\n * @param decimals Number of decimal places\r\n * @returns Formatted string\r\n */ function formatBollingerValue(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;\n    if (isNaN(value)) return \"--\";\n    return value.toFixed(decimals);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9ib2xsaW5nZXJCYW5kcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBa0JPLE1BQU1BLDJCQUFpRDtJQUM1REMsUUFBUTtJQUNSQyxrQkFBa0I7SUFDbEJDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0FBQ1YsRUFBRTtBQUVGOzs7OztDQUtDLEdBQ0QsU0FBU0MsYUFBYUMsTUFBZ0IsRUFBRUMsTUFBYztJQUNwRCxNQUFNQyxNQUFnQixFQUFFO0lBRXhCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxPQUFPTixNQUFNLEVBQUVTLElBQUs7UUFDdEMsSUFBSUEsSUFBSUYsU0FBUyxHQUFHO1lBQ2xCQyxJQUFJRSxJQUFJLENBQUNDLE1BQU0seUJBQXlCO1FBQzFDLE9BQU87WUFDTCxNQUFNQyxNQUFNTixPQUNUTyxLQUFLLENBQUNKLElBQUlGLFNBQVMsR0FBR0UsSUFBSSxHQUMxQkssTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU1DLEtBQUs7WUFDbkNSLElBQUlFLElBQUksQ0FBQ0UsTUFBTUw7UUFDakI7SUFDRjtJQUVBLE9BQU9DO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1MsMkJBQ1BYLE1BQWdCLEVBQ2hCQyxNQUFjLEVBQ2RXLFNBQW1CO0lBRW5CLE1BQU1DLFNBQW1CLEVBQUU7SUFFM0IsSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlILE9BQU9OLE1BQU0sRUFBRVMsSUFBSztRQUN0QyxJQUFJQSxJQUFJRixTQUFTLEtBQUthLE1BQU1GLFNBQVMsQ0FBQ1QsRUFBRSxHQUFHO1lBQ3pDVSxPQUFPVCxJQUFJLENBQUNDO1FBQ2QsT0FBTztZQUNMLE1BQU1VLGVBQWVmLE9BQU9PLEtBQUssQ0FBQ0osSUFBSUYsU0FBUyxHQUFHRSxJQUFJO1lBQ3RELE1BQU1hLE9BQU9KLFNBQVMsQ0FBQ1QsRUFBRTtZQUV6QiwyREFBMkQ7WUFDM0QsTUFBTWMscUJBQXFCRixhQUFh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QyxPQUFPTCxXQUFXLENBQUNwQyxFQUFFO1lBQ3JCMEMsT0FBT0wsV0FBVyxDQUFDckMsRUFBRTtZQUNyQlUsUUFBUTRCLFlBQVksQ0FBQ3RDLEVBQUU7UUFDekI7SUFFQSxPQUFPdUI7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU29CLDZCQUNkQyxhQUFtQyxFQUNuQ0wsU0FBaUI7SUFFakIsT0FBT0ssY0FBY0MsSUFBSSxDQUFDLENBQUN2QixPQUFTQSxLQUFLaUIsU0FBUyxLQUFLQSxjQUFjO0FBQ3ZFO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTTyxxQkFDZEMsS0FBYTtRQUNiQyxXQUFBQSxpRUFBbUI7SUFFbkIsSUFBSXJDLE1BQU1vQyxRQUFRLE9BQU87SUFDekIsT0FBT0EsTUFBTUUsT0FBTyxDQUFDRDtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvYm9sbGluZ2VyQmFuZHMudHM/ZTIwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW5kbGVEYXRhIH0gZnJvbSBcIkAvZGF0YS9zYW1wbGVEYXRhXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJvbGxpbmdlckJhbmRzUGFyYW1zIHtcclxuICBsZW5ndGg6IG51bWJlcjtcclxuICBzdGREZXZNdWx0aXBsaWVyOiBudW1iZXI7XHJcbiAgb2Zmc2V0OiBudW1iZXI7XHJcbiAgc291cmNlOiBcIm9wZW5cIiB8IFwiaGlnaFwiIHwgXCJsb3dcIiB8IFwiY2xvc2VcIjtcclxuICBtYVR5cGU6IFwiU01BXCI7IC8vIE9ubHkgU01BIGZvciB0aGlzIGFzc2lnbm1lbnRcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCb2xsaW5nZXJCYW5kc0RhdGEge1xyXG4gIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIGJhc2lzOiBudW1iZXI7IC8vIE1pZGRsZSBiYW5kIChTTUEpXHJcbiAgdXBwZXI6IG51bWJlcjsgLy8gVXBwZXIgYmFuZFxyXG4gIGxvd2VyOiBudW1iZXI7IC8vIExvd2VyIGJhbmRcclxuICBzdGREZXY6IG51bWJlcjsgLy8gU3RhbmRhcmQgZGV2aWF0aW9uIHZhbHVlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JPTExJTkdFUl9QQVJBTVM6IEJvbGxpbmdlckJhbmRzUGFyYW1zID0ge1xyXG4gIGxlbmd0aDogMjAsXHJcbiAgc3RkRGV2TXVsdGlwbGllcjogMixcclxuICBvZmZzZXQ6IDAsXHJcbiAgc291cmNlOiBcImNsb3NlXCIsXHJcbiAgbWFUeXBlOiBcIlNNQVwiLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBTaW1wbGUgTW92aW5nIEF2ZXJhZ2UgKFNNQSlcclxuICogQHBhcmFtIHZhbHVlcyBBcnJheSBvZiB2YWx1ZXNcclxuICogQHBhcmFtIHBlcmlvZCBQZXJpb2QgZm9yIFNNQSBjYWxjdWxhdGlvblxyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBTTUEgdmFsdWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVTTUEodmFsdWVzOiBudW1iZXJbXSwgcGVyaW9kOiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgY29uc3Qgc21hOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKGkgPCBwZXJpb2QgLSAxKSB7XHJcbiAgICAgIHNtYS5wdXNoKE5hTik7IC8vIE5vdCBlbm91Z2ggZGF0YSBwb2ludHNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHN1bSA9IHZhbHVlc1xyXG4gICAgICAgIC5zbGljZShpIC0gcGVyaW9kICsgMSwgaSArIDEpXHJcbiAgICAgICAgLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XHJcbiAgICAgIHNtYS5wdXNoKHN1bSAvIHBlcmlvZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc21hO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIFN0YW5kYXJkIERldmlhdGlvbiB1c2luZyBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIGZvcm11bGFcclxuICogTm90ZTogVXNpbmcgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiAobi0xIGRlbm9taW5hdG9yKSBmb3IgY29uc2lzdGVuY3kgd2l0aCBtb3N0IHRyYWRpbmcgcGxhdGZvcm1zXHJcbiAqIEBwYXJhbSB2YWx1ZXMgQXJyYXkgb2YgdmFsdWVzXHJcbiAqIEBwYXJhbSBwZXJpb2QgUGVyaW9kIGZvciBzdGFuZGFyZCBkZXZpYXRpb24gY2FsY3VsYXRpb25cclxuICogQHBhcmFtIHNtYVZhbHVlcyBDb3JyZXNwb25kaW5nIFNNQSB2YWx1ZXMgdG8gdXNlIGFzIG1lYW5cclxuICogQHJldHVybnMgQXJyYXkgb2Ygc3RhbmRhcmQgZGV2aWF0aW9uIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhbmRhcmREZXZpYXRpb24oXHJcbiAgdmFsdWVzOiBudW1iZXJbXSxcclxuICBwZXJpb2Q6IG51bWJlcixcclxuICBzbWFWYWx1ZXM6IG51bWJlcltdXHJcbik6IG51bWJlcltdIHtcclxuICBjb25zdCBzdGREZXY6IG51bWJlcltdID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaSA8IHBlcmlvZCAtIDEgfHwgaXNOYU4oc21hVmFsdWVzW2ldKSkge1xyXG4gICAgICBzdGREZXYucHVzaChOYU4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgcGVyaW9kVmFsdWVzID0gdmFsdWVzLnNsaWNlKGkgLSBwZXJpb2QgKyAxLCBpICsgMSk7XHJcbiAgICAgIGNvbnN0IG1lYW4gPSBzbWFWYWx1ZXNbaV07XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdmFyaWFuY2UgdXNpbmcgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiAobi0xKVxyXG4gICAgICBjb25zdCBzcXVhcmVkRGlmZmVyZW5jZXMgPSBwZXJpb2RWYWx1ZXMubWFwKCh2YWwpID0+XHJcbiAgICAgICAgTWF0aC5wb3codmFsIC0gbWVhbiwgMilcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgdmFyaWFuY2UgPVxyXG4gICAgICAgIHNxdWFyZWREaWZmZXJlbmNlcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApIC8gKHBlcmlvZCAtIDEpO1xyXG4gICAgICBjb25zdCBzdGFuZGFyZERldmlhdGlvbiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XHJcblxyXG4gICAgICBzdGREZXYucHVzaChzdGFuZGFyZERldmlhdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RkRGV2O1xyXG59XHJcblxyXG4vKipcclxuICogQXBwbHkgb2Zmc2V0IHRvIGRhdGEgYXJyYXlcclxuICogUG9zaXRpdmUgb2Zmc2V0IHNoaWZ0cyBkYXRhIGZvcndhcmQgKGZ1dHVyZSksIG5lZ2F0aXZlIHNoaWZ0cyBiYWNrd2FyZCAocGFzdClcclxuICogQHBhcmFtIGRhdGEgQXJyYXkgb2YgZGF0YSBwb2ludHNcclxuICogQHBhcmFtIG9mZnNldCBOdW1iZXIgb2YgcGVyaW9kcyB0byBzaGlmdFxyXG4gKiBAcmV0dXJucyBTaGlmdGVkIGFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseU9mZnNldDxUPihkYXRhOiBUW10sIG9mZnNldDogbnVtYmVyKTogVFtdIHtcclxuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gZGF0YTtcclxuXHJcbiAgY29uc3QgcmVzdWx0OiBUW10gPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG5cclxuICBpZiAob2Zmc2V0ID4gMCkge1xyXG4gICAgLy8gU2hpZnQgZm9yd2FyZDogbW92ZSBkYXRhIHRvIHRoZSByaWdodCwgZmlsbCBiZWdpbm5pbmcgd2l0aCBOYU5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoaSA8IG9mZnNldCkge1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IE5hTiBhcyB1bmtub3duIGFzIFQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gZGF0YVtpIC0gb2Zmc2V0XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBTaGlmdCBiYWNrd2FyZDogbW92ZSBkYXRhIHRvIHRoZSBsZWZ0LCBmaWxsIGVuZCB3aXRoIE5hTlxyXG4gICAgY29uc3QgYWJzT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoaSA+PSBkYXRhLmxlbmd0aCAtIGFic09mZnNldCkge1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IE5hTiBhcyB1bmtub3duIGFzIFQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gZGF0YVtpICsgYWJzT2Zmc2V0XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBCb2xsaW5nZXIgQmFuZHMgZm9yIGdpdmVuIGNhbmRsZSBkYXRhXHJcbiAqIEBwYXJhbSBjYW5kbGVEYXRhIEFycmF5IG9mIE9ITENWIGNhbmRsZSBkYXRhXHJcbiAqIEBwYXJhbSBwYXJhbXMgQm9sbGluZ2VyIEJhbmRzIHBhcmFtZXRlcnNcclxuICogQHJldHVybnMgQXJyYXkgb2YgQm9sbGluZ2VyIEJhbmRzIGRhdGEgcG9pbnRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQm9sbGluZ2VyQmFuZHMoXHJcbiAgY2FuZGxlRGF0YTogQ2FuZGxlRGF0YVtdLFxyXG4gIHBhcmFtczogQm9sbGluZ2VyQmFuZHNQYXJhbXMgPSBERUZBVUxUX0JPTExJTkdFUl9QQVJBTVNcclxuKTogQm9sbGluZ2VyQmFuZHNEYXRhW10ge1xyXG4gIGlmIChjYW5kbGVEYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xyXG5cclxuICAvLyBFeHRyYWN0IHNvdXJjZSB2YWx1ZXMgKGNsb3NlLCBvcGVuLCBoaWdoLCBsb3cpXHJcbiAgY29uc3Qgc291cmNlVmFsdWVzID0gY2FuZGxlRGF0YS5tYXAoKGNhbmRsZSkgPT4gY2FuZGxlW3BhcmFtcy5zb3VyY2VdKTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIFNNQSAoYmFzaXMvbWlkZGxlIGJhbmQpXHJcbiAgY29uc3Qgc21hVmFsdWVzID0gY2FsY3VsYXRlU01BKHNvdXJjZVZhbHVlcywgcGFyYW1zLmxlbmd0aCk7XHJcblxyXG4gIC8vIENhbGN1bGF0ZSBTdGFuZGFyZCBEZXZpYXRpb25cclxuICBjb25zdCBzdGREZXZWYWx1ZXMgPSBjYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbihcclxuICAgIHNvdXJjZVZhbHVlcyxcclxuICAgIHBhcmFtcy5sZW5ndGgsXHJcbiAgICBzbWFWYWx1ZXNcclxuICApO1xyXG5cclxuICAvLyBDYWxjdWxhdGUgdXBwZXIgYW5kIGxvd2VyIGJhbmRzXHJcbiAgY29uc3QgdXBwZXJWYWx1ZXMgPSBzbWFWYWx1ZXMubWFwKChzbWEsIGkpID0+XHJcbiAgICBpc05hTihzbWEpIHx8IGlzTmFOKHN0ZERldlZhbHVlc1tpXSlcclxuICAgICAgPyBOYU5cclxuICAgICAgOiBzbWEgKyBwYXJhbXMuc3RkRGV2TXVsdGlwbGllciAqIHN0ZERldlZhbHVlc1tpXVxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGxvd2VyVmFsdWVzID0gc21hVmFsdWVzLm1hcCgoc21hLCBpKSA9PlxyXG4gICAgaXNOYU4oc21hKSB8fCBpc05hTihzdGREZXZWYWx1ZXNbaV0pXHJcbiAgICAgID8gTmFOXHJcbiAgICAgIDogc21hIC0gcGFyYW1zLnN0ZERldk11bHRpcGxpZXIgKiBzdGREZXZWYWx1ZXNbaV1cclxuICApO1xyXG5cclxuICAvLyBBcHBseSBvZmZzZXQgaWYgc3BlY2lmaWVkXHJcbiAgY29uc3Qgb2Zmc2V0U01BID0gYXBwbHlPZmZzZXQoc21hVmFsdWVzLCBwYXJhbXMub2Zmc2V0KTtcclxuICBjb25zdCBvZmZzZXRVcHBlciA9IGFwcGx5T2Zmc2V0KHVwcGVyVmFsdWVzLCBwYXJhbXMub2Zmc2V0KTtcclxuICBjb25zdCBvZmZzZXRMb3dlciA9IGFwcGx5T2Zmc2V0KGxvd2VyVmFsdWVzLCBwYXJhbXMub2Zmc2V0KTtcclxuICBjb25zdCBvZmZzZXRTdGREZXYgPSBhcHBseU9mZnNldChzdGREZXZWYWx1ZXMsIHBhcmFtcy5vZmZzZXQpO1xyXG5cclxuICAvLyBDb21iaW5lIGludG8gcmVzdWx0IGZvcm1hdFxyXG4gIGNvbnN0IHJlc3VsdDogQm9sbGluZ2VyQmFuZHNEYXRhW10gPSBjYW5kbGVEYXRhLm1hcCgoY2FuZGxlLCBpKSA9PiAoe1xyXG4gICAgdGltZXN0YW1wOiBjYW5kbGUudGltZXN0YW1wLFxyXG4gICAgYmFzaXM6IG9mZnNldFNNQVtpXSxcclxuICAgIHVwcGVyOiBvZmZzZXRVcHBlcltpXSxcclxuICAgIGxvd2VyOiBvZmZzZXRMb3dlcltpXSxcclxuICAgIHN0ZERldjogb2Zmc2V0U3RkRGV2W2ldLFxyXG4gIH0pKTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBCb2xsaW5nZXIgQmFuZHMgdmFsdWUgZm9yIGEgc3BlY2lmaWMgdGltZXN0YW1wXHJcbiAqIEBwYXJhbSBib2xsaW5nZXJEYXRhIEFycmF5IG9mIEJvbGxpbmdlciBCYW5kcyBkYXRhXHJcbiAqIEBwYXJhbSB0aW1lc3RhbXAgVGFyZ2V0IHRpbWVzdGFtcFxyXG4gKiBAcmV0dXJucyBCb2xsaW5nZXIgQmFuZHMgZGF0YSBmb3IgdGhlIHRpbWVzdGFtcCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvbGxpbmdlckJhbmRzQXRUaW1lc3RhbXAoXHJcbiAgYm9sbGluZ2VyRGF0YTogQm9sbGluZ2VyQmFuZHNEYXRhW10sXHJcbiAgdGltZXN0YW1wOiBudW1iZXJcclxuKTogQm9sbGluZ2VyQmFuZHNEYXRhIHwgbnVsbCB7XHJcbiAgcmV0dXJuIGJvbGxpbmdlckRhdGEuZmluZCgoZGF0YSkgPT4gZGF0YS50aW1lc3RhbXAgPT09IHRpbWVzdGFtcCkgfHwgbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBCb2xsaW5nZXIgQmFuZHMgdmFsdWUgZm9yIGRpc3BsYXlcclxuICogQHBhcmFtIHZhbHVlIE51bWVyaWMgdmFsdWVcclxuICogQHBhcmFtIGRlY2ltYWxzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xyXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qm9sbGluZ2VyVmFsdWUoXHJcbiAgdmFsdWU6IG51bWJlcixcclxuICBkZWNpbWFsczogbnVtYmVyID0gMlxyXG4pOiBzdHJpbmcge1xyXG4gIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiBcIi0tXCI7XHJcbiAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoZGVjaW1hbHMpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0JPTExJTkdFUl9QQVJBTVMiLCJsZW5ndGgiLCJzdGREZXZNdWx0aXBsaWVyIiwib2Zmc2V0Iiwic291cmNlIiwibWFUeXBlIiwiY2FsY3VsYXRlU01BIiwidmFsdWVzIiwicGVyaW9kIiwic21hIiwiaSIsInB1c2giLCJOYU4iLCJzdW0iLCJzbGljZSIsInJlZHVjZSIsImFjYyIsInZhbCIsImNhbGN1bGF0ZVN0YW5kYXJkRGV2aWF0aW9uIiwic21hVmFsdWVzIiwic3RkRGV2IiwiaXNOYU4iLCJwZXJpb2RWYWx1ZXMiLCJtZWFuIiwic3F1YXJlZERpZmZlcmVuY2VzIiwibWFwIiwiTWF0aCIsInBvdyIsInZhcmlhbmNlIiwic3RhbmRhcmREZXZpYXRpb24iLCJzcXJ0IiwiYXBwbHlPZmZzZXQiLCJkYXRhIiwicmVzdWx0IiwiQXJyYXkiLCJhYnNPZmZzZXQiLCJhYnMiLCJjYWxjdWxhdGVCb2xsaW5nZXJCYW5kcyIsImNhbmRsZURhdGEiLCJwYXJhbXMiLCJzb3VyY2VWYWx1ZXMiLCJjYW5kbGUiLCJzdGREZXZWYWx1ZXMiLCJ1cHBlclZhbHVlcyIsImxvd2VyVmFsdWVzIiwib2Zmc2V0U01BIiwib2Zmc2V0VXBwZXIiLCJvZmZzZXRMb3dlciIsIm9mZnNldFN0ZERldiIsInRpbWVzdGFtcCIsImJhc2lzIiwidXBwZXIiLCJsb3dlciIsImdldEJvbGxpbmdlckJhbmRzQXRUaW1lc3RhbXAiLCJib2xsaW5nZXJEYXRhIiwiZmluZCIsImZvcm1hdEJvbGxpbmdlclZhbHVlIiwidmFsdWUiLCJkZWNpbWFscyIsInRvRml4ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/bollingerBands.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FB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bW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz80ZDVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/OGJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/klinecharts/dist/index.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/klinecharts/dist/index.esm.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionType: function() { return /* binding */ ActionType; },\n/* harmony export */   CandleTooltipRectPosition: function() { return /* binding */ CandleTooltipRectPosition; },\n/* harmony export */   CandleType: function() { return /* binding */ CandleType; },\n/* harmony export */   DomPosition: function() { return /* binding */ DomPosition; },\n/* harmony export */   FormatDateType: function() { return /* binding */ FormatDateType; },\n/* harmony export */   IndicatorSeries: function() { return /* binding */ IndicatorSeries; },\n/* harmony export */   LineType: function() { return /* binding */ LineType; },\n/* harmony export */   OverlayMode: function() { return /* binding */ OverlayMode; },\n/* harmony export */   PolygonType: function() { return /* binding */ PolygonType; },\n/* harmony export */   TooltipFeaturePosition: function() { return /* binding */ TooltipFeaturePosition; },\n/* harmony export */   TooltipFeatureType: function() { return /* binding */ TooltipFeatureType; },\n/* harmony export */   TooltipShowRule: function() { return /* binding */ TooltipShowRule; },\n/* harmony export */   TooltipShowType: function() { return /* binding */ TooltipShowType; },\n/* harmony export */   dispose: function() { return /* binding */ dispose; },\n/* harmony export */   getFigureClass: function() { return /* binding */ getFigureClass; },\n/* harmony export */   getOverlayClass: function() { return /* binding */ getOverlayClass; },\n/* harmony export */   getSupportedFigures: function() { return /* binding */ getSupportedFigures; },\n/* harmony export */   getSupportedIndicators: function() { return /* binding */ getSupportedIndicators; },\n/* harmony export */   getSupportedLocales: function() { return /* binding */ getSupportedLocales; },\n/* harmony export */   getSupportedOverlays: function() { return /* binding */ getSupportedOverlays; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   registerFigure: function() { return /* binding */ registerFigure; },\n/* harmony export */   registerIndicator: function() { return /* binding */ registerIndicator; },\n/* harmony export */   registerLocale: function() { return /* binding */ registerLocale; },\n/* harmony export */   registerOverlay: function() { return /* binding */ registerOverlay; },\n/* harmony export */   registerStyles: function() { return /* binding */ registerStyles; },\n/* harmony export */   registerXAxis: function() { return /* binding */ registerXAxis; },\n/* harmony export */   registerYAxis: function() { return /* binding */ registerYAxis; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/**\n     * @license\n     * KLineChart v10.0.0-alpha5\n     * Copyright (c) 2019 lihu.\n     * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n     */\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore\nfunction merge(target, source) {\n    if ((!isObject(target) && !isObject(source))) {\n        return;\n    }\n    for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n            var targetProp = target[key];\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n            var sourceProp = source[key];\n            if (isObject(sourceProp) &&\n                isObject(targetProp)) {\n                merge(targetProp, sourceProp);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                if (isValid(source[key])) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n                    target[key] = clone(source[key]);\n                }\n            }\n        }\n    }\n}\nfunction clone(target) {\n    if (!isObject(target)) {\n        return target;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore\n    var copy = null;\n    if (isArray(target)) {\n        copy = [];\n    }\n    else {\n        copy = {};\n    }\n    for (var key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n            var v = target[key];\n            if (isObject(v)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                copy[key] = clone(v);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                copy[key] = v;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- ignore\n    return copy;\n}\nfunction isArray(value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n}\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters -- ignore\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction isObject(value) {\n    return (typeof value === 'object') && isValid(value);\n}\nfunction isNumber(value) {\n    return typeof value === 'number' && Number.isFinite(value);\n}\nfunction isValid(value) {\n    return value !== null && value !== undefined;\n}\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isTransparent(color) {\n    return color === 'transparent' ||\n        color === 'none' ||\n        /^[rR][gG][Bb][Aa]\\(([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){3}[\\s]*0[\\s]*\\)$/.test(color) ||\n        /^[hH][Ss][Ll][Aa]\\(([\\s]*(360｜3[0-5][0-9]|[012]?[0-9][0-9]?)[\\s]*,)([\\s]*((100|[0-9][0-9]?)%|0)[\\s]*,){2}([\\s]*0[\\s]*)\\)$/.test(color);\n}\nfunction hexToRgb(hex, alpha) {\n    var h = hex.replace(/^#/, '');\n    var i = parseInt(h, 16);\n    var r = (i >> 16) & 255;\n    var g = (i >> 8) & 255;\n    var b = i & 255;\n    return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(alpha !== null && alpha !== void 0 ? alpha : 1, \")\");\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * line type\n */\nvar LineType;\n(function (LineType) {\n    LineType[\"Dashed\"] = \"dashed\";\n    LineType[\"Solid\"] = \"solid\";\n})(LineType || (LineType = {}));\nvar PathType;\n(function (PathType) {\n    PathType[\"Stroke\"] = \"stroke\";\n    PathType[\"Fill\"] = \"fill\";\n})(PathType || (PathType = {}));\nvar PolygonType;\n(function (PolygonType) {\n    PolygonType[\"Stroke\"] = \"stroke\";\n    PolygonType[\"Fill\"] = \"fill\";\n    PolygonType[\"StrokeFill\"] = \"stroke_fill\";\n})(PolygonType || (PolygonType = {}));\nvar TooltipShowRule;\n(function (TooltipShowRule) {\n    TooltipShowRule[\"Always\"] = \"always\";\n    TooltipShowRule[\"FollowCross\"] = \"follow_cross\";\n    TooltipShowRule[\"None\"] = \"none\";\n})(TooltipShowRule || (TooltipShowRule = {}));\nvar TooltipShowType;\n(function (TooltipShowType) {\n    TooltipShowType[\"Standard\"] = \"standard\";\n    TooltipShowType[\"Rect\"] = \"rect\";\n})(TooltipShowType || (TooltipShowType = {}));\nvar TooltipFeatureType;\n(function (TooltipFeatureType) {\n    TooltipFeatureType[\"Path\"] = \"path\";\n    TooltipFeatureType[\"IconFont\"] = \"icon_font\";\n})(TooltipFeatureType || (TooltipFeatureType = {}));\nvar TooltipFeaturePosition;\n(function (TooltipFeaturePosition) {\n    TooltipFeaturePosition[\"Left\"] = \"left\";\n    TooltipFeaturePosition[\"Middle\"] = \"middle\";\n    TooltipFeaturePosition[\"Right\"] = \"right\";\n})(TooltipFeaturePosition || (TooltipFeaturePosition = {}));\nvar CandleTooltipRectPosition;\n(function (CandleTooltipRectPosition) {\n    CandleTooltipRectPosition[\"Fixed\"] = \"fixed\";\n    CandleTooltipRectPosition[\"Pointer\"] = \"pointer\";\n})(CandleTooltipRectPosition || (CandleTooltipRectPosition = {}));\nvar CandleType;\n(function (CandleType) {\n    CandleType[\"CandleSolid\"] = \"candle_solid\";\n    CandleType[\"CandleStroke\"] = \"candle_stroke\";\n    CandleType[\"CandleUpStroke\"] = \"candle_up_stroke\";\n    CandleType[\"CandleDownStroke\"] = \"candle_down_stroke\";\n    CandleType[\"Ohlc\"] = \"ohlc\";\n    CandleType[\"Area\"] = \"area\";\n})(CandleType || (CandleType = {}));\nvar CandleColorCompareRule;\n(function (CandleColorCompareRule) {\n    CandleColorCompareRule[\"CurrentOpen\"] = \"current_open\";\n    CandleColorCompareRule[\"PreviousClose\"] = \"previous_close\";\n})(CandleColorCompareRule || (CandleColorCompareRule = {}));\nvar Color = {\n    RED: '#F92855',\n    GREEN: '#2DC08E',\n    WHITE: '#FFFFFF',\n    GREY: '#76808F',\n    BLUE: '#1677FF'\n};\nfunction getDefaultGridStyle() {\n    return {\n        show: true,\n        horizontal: {\n            show: true,\n            size: 1,\n            color: '#EDEDED',\n            style: LineType.Dashed,\n            dashedValue: [2, 2]\n        },\n        vertical: {\n            show: true,\n            size: 1,\n            color: '#EDEDED',\n            style: LineType.Dashed,\n            dashedValue: [2, 2]\n        }\n    };\n}\n/**\n * Get default candle style\n * @type {{area: {backgroundColor: [{offset: number, color: string}, {offset: number, color: string}], lineColor: string, lineSize: number, value: string}, bar: {noChangeColor: string, upColor: string, downColor: string}, tooltip: {rect: {offsetTop: number, fillColor: string, borderColor: string, paddingBottom: number, borderRadius: number, paddingRight: number, borderSize: number, offsetLeft: number, paddingTop: number, paddingLeft: number, offsetRight: number}, showRule: string, values: null, showType: string, text: {marginRight: number, size: number, color: string, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}, labels: string[]}, type: string, priceMark: {high: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, last: {noChangeColor: string, upColor: string, line: {dashValue: number[], size: number, show: boolean, style: string}, show: boolean, text: {paddingBottom: number, size: number, color: string, paddingRight: number, show: boolean, weight: string, paddingTop: number, family: string, paddingLeft: number}, downColor: string}, low: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, show: boolean}}}\n */\nfunction getDefaultCandleStyle() {\n    var highLow = {\n        show: true,\n        color: Color.GREY,\n        textOffset: 5,\n        textSize: 10,\n        textFamily: 'Helvetica Neue',\n        textWeight: 'normal'\n    };\n    return {\n        type: CandleType.CandleSolid,\n        bar: {\n            compareRule: CandleColorCompareRule.CurrentOpen,\n            upColor: Color.GREEN,\n            downColor: Color.RED,\n            noChangeColor: Color.GREY,\n            upBorderColor: Color.GREEN,\n            downBorderColor: Color.RED,\n            noChangeBorderColor: Color.GREY,\n            upWickColor: Color.GREEN,\n            downWickColor: Color.RED,\n            noChangeWickColor: Color.GREY\n        },\n        area: {\n            lineSize: 2,\n            lineColor: Color.BLUE,\n            smooth: false,\n            value: 'close',\n            backgroundColor: [{\n                    offset: 0,\n                    color: hexToRgb(Color.BLUE, 0.01)\n                }, {\n                    offset: 1,\n                    color: hexToRgb(Color.BLUE, 0.2)\n                }],\n            point: {\n                show: true,\n                color: Color.BLUE,\n                radius: 4,\n                rippleColor: hexToRgb(Color.BLUE, 0.3),\n                rippleRadius: 8,\n                animation: true,\n                animationDuration: 1000\n            }\n        },\n        priceMark: {\n            show: true,\n            high: __assign({}, highLow),\n            low: __assign({}, highLow),\n            last: {\n                show: true,\n                compareRule: CandleColorCompareRule.CurrentOpen,\n                upColor: Color.GREEN,\n                downColor: Color.RED,\n                noChangeColor: Color.GREY,\n                line: {\n                    show: true,\n                    style: LineType.Dashed,\n                    dashedValue: [4, 4],\n                    size: 1\n                },\n                text: {\n                    show: true,\n                    style: PolygonType.Fill,\n                    size: 12,\n                    paddingLeft: 4,\n                    paddingTop: 4,\n                    paddingRight: 4,\n                    paddingBottom: 4,\n                    borderColor: 'transparent',\n                    borderStyle: LineType.Solid,\n                    borderSize: 0,\n                    borderDashedValue: [2, 2],\n                    color: Color.WHITE,\n                    family: 'Helvetica Neue',\n                    weight: 'normal',\n                    borderRadius: 2\n                }\n            }\n        },\n        tooltip: {\n            offsetLeft: 4,\n            offsetTop: 6,\n            offsetRight: 4,\n            offsetBottom: 6,\n            showRule: TooltipShowRule.Always,\n            showType: TooltipShowType.Standard,\n            custom: [\n                { title: 'time', value: '{time}' },\n                { title: 'open', value: '{open}' },\n                { title: 'high', value: '{high}' },\n                { title: 'low', value: '{low}' },\n                { title: 'close', value: '{close}' },\n                { title: 'volume', value: '{volume}' }\n            ],\n            defaultValue: 'n/a',\n            rect: {\n                position: CandleTooltipRectPosition.Fixed,\n                paddingLeft: 4,\n                paddingRight: 4,\n                paddingTop: 4,\n                paddingBottom: 4,\n                offsetLeft: 4,\n                offsetTop: 4,\n                offsetRight: 4,\n                offsetBottom: 4,\n                borderRadius: 4,\n                borderSize: 1,\n                borderColor: '#F2F3F5',\n                color: '#FEFEFE'\n            },\n            text: {\n                size: 12,\n                family: 'Helvetica Neue',\n                weight: 'normal',\n                color: Color.GREY,\n                marginLeft: 8,\n                marginTop: 4,\n                marginRight: 8,\n                marginBottom: 4\n            },\n            features: []\n        }\n    };\n}\n/**\n * Get default indicator style\n */\nfunction getDefaultIndicatorStyle() {\n    var alphaGreen = hexToRgb(Color.GREEN, 0.7);\n    var alphaRed = hexToRgb(Color.RED, 0.7);\n    return {\n        ohlc: {\n            compareRule: CandleColorCompareRule.CurrentOpen,\n            upColor: alphaGreen,\n            downColor: alphaRed,\n            noChangeColor: Color.GREY\n        },\n        bars: [{\n                style: PolygonType.Fill,\n                borderStyle: LineType.Solid,\n                borderSize: 1,\n                borderDashedValue: [2, 2],\n                upColor: alphaGreen,\n                downColor: alphaRed,\n                noChangeColor: Color.GREY\n            }],\n        lines: ['#FF9600', '#935EBD', Color.BLUE, '#E11D74', '#01C5C4'].map(function (color) { return ({\n            style: LineType.Solid,\n            smooth: false,\n            size: 1,\n            dashedValue: [2, 2],\n            color: color\n        }); }),\n        circles: [{\n                style: PolygonType.Fill,\n                borderStyle: LineType.Solid,\n                borderSize: 1,\n                borderDashedValue: [2, 2],\n                upColor: alphaGreen,\n                downColor: alphaRed,\n                noChangeColor: Color.GREY\n            }],\n        lastValueMark: {\n            show: false,\n            text: {\n                show: false,\n                style: PolygonType.Fill,\n                color: Color.WHITE,\n                size: 12,\n                family: 'Helvetica Neue',\n                weight: 'normal',\n                borderStyle: LineType.Solid,\n                borderColor: 'transparent',\n                borderSize: 0,\n                borderDashedValue: [2, 2],\n                paddingLeft: 4,\n                paddingTop: 4,\n                paddingRight: 4,\n                paddingBottom: 4,\n                borderRadius: 2\n            }\n        },\n        tooltip: {\n            offsetLeft: 4,\n            offsetTop: 6,\n            offsetRight: 4,\n            offsetBottom: 6,\n            showRule: TooltipShowRule.Always,\n            showType: TooltipShowType.Standard,\n            showName: true,\n            showParams: true,\n            defaultValue: 'n/a',\n            text: {\n                size: 12,\n                family: 'Helvetica Neue',\n                weight: 'normal',\n                color: Color.GREY,\n                marginLeft: 8,\n                marginTop: 4,\n                marginRight: 8,\n                marginBottom: 4\n            },\n            features: []\n        }\n    };\n}\nfunction getDefaultAxisStyle() {\n    return {\n        show: true,\n        size: 'auto',\n        axisLine: {\n            show: true,\n            color: '#DDDDDD',\n            size: 1\n        },\n        tickText: {\n            show: true,\n            color: Color.GREY,\n            size: 12,\n            family: 'Helvetica Neue',\n            weight: 'normal',\n            marginStart: 4,\n            marginEnd: 6\n        },\n        tickLine: {\n            show: true,\n            size: 1,\n            length: 3,\n            color: '#DDDDDD'\n        }\n    };\n}\nfunction getDefaultCrosshairStyle() {\n    function item() {\n        return {\n            show: true,\n            line: {\n                show: true,\n                style: LineType.Dashed,\n                dashedValue: [4, 2],\n                size: 1,\n                color: Color.GREY\n            },\n            text: {\n                show: true,\n                style: PolygonType.Fill,\n                color: Color.WHITE,\n                size: 12,\n                family: 'Helvetica Neue',\n                weight: 'normal',\n                borderStyle: LineType.Solid,\n                borderDashedValue: [2, 2],\n                borderSize: 1,\n                borderColor: Color.GREY,\n                borderRadius: 2,\n                paddingLeft: 4,\n                paddingRight: 4,\n                paddingTop: 4,\n                paddingBottom: 4,\n                backgroundColor: Color.GREY\n            }\n        };\n    }\n    return {\n        show: true,\n        horizontal: item(),\n        vertical: item()\n    };\n}\nfunction getDefaultOverlayStyle() {\n    var pointBorderColor = hexToRgb(Color.BLUE, 0.35);\n    var alphaBg = hexToRgb(Color.BLUE, 0.25);\n    function text() {\n        return {\n            style: PolygonType.Fill,\n            color: Color.WHITE,\n            size: 12,\n            family: 'Helvetica Neue',\n            weight: 'normal',\n            borderStyle: LineType.Solid,\n            borderDashedValue: [2, 2],\n            borderSize: 1,\n            borderRadius: 2,\n            borderColor: Color.BLUE,\n            paddingLeft: 4,\n            paddingRight: 4,\n            paddingTop: 4,\n            paddingBottom: 4,\n            backgroundColor: Color.BLUE\n        };\n    }\n    return {\n        point: {\n            color: Color.BLUE,\n            borderColor: pointBorderColor,\n            borderSize: 1,\n            radius: 5,\n            activeColor: Color.BLUE,\n            activeBorderColor: pointBorderColor,\n            activeBorderSize: 3,\n            activeRadius: 5\n        },\n        line: {\n            style: LineType.Solid,\n            smooth: false,\n            color: Color.BLUE,\n            size: 1,\n            dashedValue: [2, 2]\n        },\n        rect: {\n            style: PolygonType.Fill,\n            color: alphaBg,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderRadius: 0,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [2, 2]\n        },\n        polygon: {\n            style: PolygonType.Fill,\n            color: Color.BLUE,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [2, 2]\n        },\n        circle: {\n            style: PolygonType.Fill,\n            color: alphaBg,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [2, 2]\n        },\n        arc: {\n            style: LineType.Solid,\n            color: Color.BLUE,\n            size: 1,\n            dashedValue: [2, 2]\n        },\n        text: text()\n    };\n}\nfunction getDefaultSeparatorStyle() {\n    return {\n        size: 1,\n        color: '#DDDDDD',\n        fill: true,\n        activeBackgroundColor: hexToRgb(Color.BLUE, 0.08)\n    };\n}\nfunction getDefaultStyles() {\n    return {\n        grid: getDefaultGridStyle(),\n        candle: getDefaultCandleStyle(),\n        indicator: getDefaultIndicatorStyle(),\n        xAxis: getDefaultAxisStyle(),\n        yAxis: getDefaultAxisStyle(),\n        separator: getDefaultSeparatorStyle(),\n        crosshair: getDefaultCrosshairStyle(),\n        overlay: getDefaultOverlayStyle()\n    };\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEV = \"development\" === 'development';\nfunction log(templateText, tagStyle, messageStyle, api, invalidParam, append) {\n    if (DEV) {\n        var apiStr = api !== '' ? \"Call api `\".concat(api, \"`\").concat(invalidParam !== '' || append !== '' ? ', ' : '.') : '';\n        var invalidParamStr = invalidParam !== '' ? \"invalid parameter `\".concat(invalidParam, \"`\").concat(append !== '' ? ', ' : '.') : '';\n        var appendStr = append !== '' ? append : '';\n        console.log(templateText, tagStyle, messageStyle, apiStr, invalidParamStr, appendStr);\n    }\n}\nfunction logWarn(api, invalidParam, append) {\n    log('%c😑 klinecharts warning%c %s%s%s', 'padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#FF9600', 'color:#FF9600', api, invalidParam, append !== null && append !== void 0 ? append : '');\n}\nfunction logError(api, invalidParam, append) {\n    log('%c😟 klinecharts error%c %s%s%s', 'padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#F92855;', 'color:#F92855;', api, invalidParam, append );\n}\nfunction logTag() {\n    log('%c❤️ Welcome to klinecharts. Version is 10.0.0-alpha5', 'border-radius:4px;border:dashed 1px #1677FF;line-height:70px;padding:0 20px;margin:16px 0;font-size:14px;color:#1677FF;', '', '', '', '');\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp('[^.[\\\\]]+' + '|' +\n    '\\\\[(?:' +\n    '([^\"\\'][^[]*)' + '|' +\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n    ')\\\\]' + '|' +\n    '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nfunction formatValue(data, key, defaultValue) {\n    if (isValid(data)) {\n        var path_1 = [];\n        key.replace(rePropName, function (subString) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var k = subString;\n            if (isValid(args[1])) {\n                k = args[2].replace(reEscapeChar, '$1');\n            }\n            else if (isValid(args[0])) {\n                k = args[0].trim();\n            }\n            path_1.push(k);\n            return '';\n        });\n        var value = data;\n        var index = 0;\n        var length_1 = path_1.length;\n        while (isValid(value) && index < length_1) {\n            value = value === null || value === void 0 ? void 0 : value[path_1[index++]];\n        }\n        return isValid(value) ? value : (defaultValue !== null && defaultValue !== void 0 ? defaultValue : '--');\n    }\n    return defaultValue !== null && defaultValue !== void 0 ? defaultValue : '--';\n}\nfunction formatTimestampToDateTime(dateTimeFormat, timestamp) {\n    var date = {};\n    dateTimeFormat.formatToParts(new Date(timestamp)).forEach(function (_a) {\n        var type = _a.type, value = _a.value;\n        switch (type) {\n            case 'year': {\n                date.YYYY = value;\n                break;\n            }\n            case 'month': {\n                date.MM = value;\n                break;\n            }\n            case 'day': {\n                date.DD = value;\n                break;\n            }\n            case 'hour': {\n                date.HH = value === '24' ? '00' : value;\n                break;\n            }\n            case 'minute': {\n                date.mm = value;\n                break;\n            }\n            case 'second': {\n                date.ss = value;\n                break;\n            }\n        }\n    });\n    return date;\n}\nfunction formatTimestampToString(dateTimeFormat, timestamp, format) {\n    var date = formatTimestampToDateTime(dateTimeFormat, timestamp);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- ignore\n    return format.replace(/YYYY|MM|DD|HH|mm|ss/g, function (key) { return date[key]; });\n}\nfunction formatPrecision(value, precision) {\n    var v = +value;\n    if (isNumber(v)) {\n        return v.toFixed(precision !== null && precision !== void 0 ? precision : 2);\n    }\n    return \"\".concat(value);\n}\nfunction formatBigNumber(value) {\n    var v = +value;\n    if (isNumber(v)) {\n        if (v > 1000000000) {\n            return \"\".concat(+((v / 1000000000).toFixed(3)), \"B\");\n        }\n        if (v > 1000000) {\n            return \"\".concat(+((v / 1000000).toFixed(3)), \"M\");\n        }\n        if (v > 1000) {\n            return \"\".concat(+((v / 1000).toFixed(3)), \"K\");\n        }\n    }\n    return \"\".concat(value);\n}\nfunction formatThousands(value, sign) {\n    var vl = \"\".concat(value);\n    if (sign.length === 0) {\n        return vl;\n    }\n    if (vl.includes('.')) {\n        var arr = vl.split('.');\n        return \"\".concat(arr[0].replace(/(\\d)(?=(\\d{3})+$)/g, function ($1) { return \"\".concat($1).concat(sign); }), \".\").concat(arr[1]);\n    }\n    return vl.replace(/(\\d)(?=(\\d{3})+$)/g, function ($1) { return \"\".concat($1).concat(sign); });\n}\nfunction formatFoldDecimal(value, threshold) {\n    var vl = \"\".concat(value);\n    var reg = new RegExp('\\\\.0{' + threshold + ',}[1-9][0-9]*$');\n    if (reg.test(vl)) {\n        var result = vl.split('.');\n        var lastIndex = result.length - 1;\n        var v = result[lastIndex];\n        var match = /0*/.exec(v);\n        if (isValid(match)) {\n            var count = match[0].length;\n            result[lastIndex] = v.replace(/0*/, \"0{\".concat(count, \"}\"));\n            return result.join('.');\n        }\n    }\n    return vl;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar measureCtx = null;\n/**\n * Get pixel ratio\n * @param canvas\n * @returns {number}\n */\nfunction getPixelRatio(canvas) {\n    var _a, _b;\n    return (_b = (_a = canvas.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;\n}\nfunction createFont(size, weight, family) {\n    return \"\".concat(weight !== null && weight !== void 0 ? weight : 'normal', \" \").concat(size !== null && size !== void 0 ? size : 12, \"px \").concat(family !== null && family !== void 0 ? family : 'Helvetica Neue');\n}\n/**\n * Measure the width of text\n * @param text\n * @returns {number}\n */\nfunction calcTextWidth(text, size, weight, family) {\n    if (!isValid(measureCtx)) {\n        var canvas = document.createElement('canvas');\n        var pixelRatio = getPixelRatio(canvas);\n        measureCtx = canvas.getContext('2d');\n        measureCtx.scale(pixelRatio, pixelRatio);\n    }\n    measureCtx.font = createFont(size, weight, family);\n    return Math.round(measureCtx.measureText(text).width);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ActionType;\n(function (ActionType) {\n    ActionType[\"OnZoom\"] = \"onZoom\";\n    ActionType[\"OnScroll\"] = \"onScroll\";\n    ActionType[\"OnVisibleRangeChange\"] = \"onVisibleRangeChange\";\n    ActionType[\"OnCandleTooltipFeatureClick\"] = \"onCandleTooltipFeatureClick\";\n    ActionType[\"OnCrosshairChange\"] = \"onCrosshairChange\";\n    ActionType[\"OnCandleBarClick\"] = \"onCandleBarClick\";\n    ActionType[\"OnPaneDrag\"] = \"onPaneDrag\";\n})(ActionType || (ActionType = {}));\nvar Action = /** @class */ (function () {\n    function Action() {\n        this._callbacks = [];\n    }\n    Action.prototype.subscribe = function (callback) {\n        var index = this._callbacks.indexOf(callback);\n        if (index < 0) {\n            this._callbacks.push(callback);\n        }\n    };\n    Action.prototype.unsubscribe = function (callback) {\n        if (isFunction(callback)) {\n            var index = this._callbacks.indexOf(callback);\n            if (index > -1) {\n                this._callbacks.splice(index, 1);\n            }\n        }\n        else {\n            this._callbacks = [];\n        }\n    };\n    Action.prototype.execute = function (data) {\n        this._callbacks.forEach(function (callback) {\n            callback(data);\n        });\n    };\n    Action.prototype.isEmpty = function () {\n        return this._callbacks.length === 0;\n    };\n    return Action;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorSeries;\n(function (IndicatorSeries) {\n    IndicatorSeries[\"Normal\"] = \"normal\";\n    IndicatorSeries[\"Price\"] = \"price\";\n    IndicatorSeries[\"Volume\"] = \"volume\";\n})(IndicatorSeries || (IndicatorSeries = {}));\nvar IndicatorEventTarget;\n(function (IndicatorEventTarget) {\n    IndicatorEventTarget[\"Feature\"] = \"feature\";\n})(IndicatorEventTarget || (IndicatorEventTarget = {}));\nvar IndicatorDataState;\n(function (IndicatorDataState) {\n    IndicatorDataState[\"Loading\"] = \"loading\";\n    IndicatorDataState[\"Error\"] = \"error\";\n    IndicatorDataState[\"Ready\"] = \"ready\";\n})(IndicatorDataState || (IndicatorDataState = {}));\nfunction eachFigures(indicator, dataIndex, defaultStyles, eachFigureCallback) {\n    var result = indicator.result;\n    var figures = indicator.figures;\n    var styles = indicator.styles;\n    var circleStyles = formatValue(styles, 'circles', defaultStyles.circles);\n    var circleStyleCount = circleStyles.length;\n    var barStyles = formatValue(styles, 'bars', defaultStyles.bars);\n    var barStyleCount = barStyles.length;\n    var lineStyles = formatValue(styles, 'lines', defaultStyles.lines);\n    var lineStyleCount = lineStyles.length;\n    var circleCount = 0;\n    var barCount = 0;\n    var lineCount = 0;\n    // eslint-disable-next-line @typescript-eslint/init-declarations  -- ignore\n    var defaultFigureStyles;\n    var figureIndex = 0;\n    figures.forEach(function (figure) {\n        var _a;\n        switch (figure.type) {\n            case 'circle': {\n                figureIndex = circleCount;\n                var styles_1 = circleStyles[circleCount % circleStyleCount];\n                defaultFigureStyles = __assign(__assign({}, styles_1), { color: styles_1.noChangeColor });\n                circleCount++;\n                break;\n            }\n            case 'bar': {\n                figureIndex = barCount;\n                var styles_2 = barStyles[barCount % barStyleCount];\n                defaultFigureStyles = __assign(__assign({}, styles_2), { color: styles_2.noChangeColor });\n                barCount++;\n                break;\n            }\n            case 'line': {\n                figureIndex = lineCount;\n                defaultFigureStyles = lineStyles[lineCount % lineStyleCount];\n                lineCount++;\n                break;\n            }\n        }\n        if (isValid(figure.type)) {\n            var ss = (_a = figure.styles) === null || _a === void 0 ? void 0 : _a.call(figure, {\n                data: {\n                    prev: result[dataIndex - 1],\n                    current: result[dataIndex],\n                    next: result[dataIndex + 1]\n                },\n                indicator: indicator,\n                defaultStyles: defaultStyles\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            eachFigureCallback(figure, __assign(__assign({}, defaultFigureStyles), ss), figureIndex);\n        }\n    });\n}\nvar IndicatorImp = /** @class */ (function () {\n    function IndicatorImp(indicator) {\n        this.precision = 4;\n        this.calcParams = [];\n        this.shouldOhlc = false;\n        this.shouldFormatBigNumber = false;\n        this.visible = true;\n        this.zLevel = 0;\n        this.series = IndicatorSeries.Normal;\n        this.figures = [];\n        this.minValue = null;\n        this.maxValue = null;\n        this.styles = null;\n        this.shouldUpdate = function (prev, current) {\n            var calc = JSON.stringify(prev.calcParams) !== JSON.stringify(current.calcParams) ||\n                prev.figures !== current.figures ||\n                prev.calc !== current.calc;\n            var draw = calc ||\n                prev.shortName !== current.shortName ||\n                prev.series !== current.series ||\n                prev.minValue !== current.minValue ||\n                prev.maxValue !== current.maxValue ||\n                prev.precision !== current.precision ||\n                prev.shouldOhlc !== current.shouldOhlc ||\n                prev.shouldFormatBigNumber !== current.shouldFormatBigNumber ||\n                prev.visible !== current.visible ||\n                prev.zLevel !== current.zLevel ||\n                prev.extendData !== current.extendData ||\n                prev.regenerateFigures !== current.regenerateFigures ||\n                prev.createTooltipDataSource !== current.createTooltipDataSource ||\n                prev.draw !== current.draw;\n            return { calc: calc, draw: draw };\n        };\n        this.calc = function () { return []; };\n        this.regenerateFigures = null;\n        this.createTooltipDataSource = null;\n        this.draw = null;\n        this.onClick = null;\n        this.onDataStateChange = null;\n        this.result = [];\n        this._lockSeriesPrecision = false;\n        this.override(indicator);\n        this._lockSeriesPrecision = false;\n    }\n    IndicatorImp.prototype.override = function (indicator) {\n        var _a, _b;\n        var _c = this, result = _c.result, currentOthers = __rest(_c, [\"result\"]);\n        this._prevIndicator = __assign(__assign({}, clone(currentOthers)), { result: result });\n        var id = indicator.id, name = indicator.name, shortName = indicator.shortName, precision = indicator.precision, styles = indicator.styles, figures = indicator.figures, calcParams = indicator.calcParams, others = __rest(indicator, [\"id\", \"name\", \"shortName\", \"precision\", \"styles\", \"figures\", \"calcParams\"]);\n        if (!isString(this.id) && isString(id)) {\n            this.id = id;\n        }\n        if (!isString(this.name)) {\n            this.name = name !== null && name !== void 0 ? name : '';\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition  -- ignore\n        this.shortName = (_a = shortName !== null && shortName !== void 0 ? shortName : this.shortName) !== null && _a !== void 0 ? _a : this.name;\n        if (isNumber(precision)) {\n            this.precision = precision;\n            this._lockSeriesPrecision = true;\n        }\n        if (isValid(styles)) {\n            (_b = this.styles) !== null && _b !== void 0 ? _b : (this.styles = {});\n            merge(this.styles, styles);\n        }\n        merge(this, others);\n        if (isValid(calcParams)) {\n            this.calcParams = calcParams;\n            if (isFunction(this.regenerateFigures)) {\n                this.figures = this.regenerateFigures(this.calcParams);\n            }\n        }\n        this.figures = figures !== null && figures !== void 0 ? figures : this.figures;\n    };\n    IndicatorImp.prototype.setSeriesPrecision = function (precision) {\n        if (!this._lockSeriesPrecision) {\n            this.precision = precision;\n        }\n    };\n    IndicatorImp.prototype.shouldUpdateImp = function () {\n        var sort = this._prevIndicator.zLevel !== this.zLevel;\n        var result = this.shouldUpdate(this._prevIndicator, this);\n        if (isBoolean(result)) {\n            return { calc: result, draw: result, sort: sort };\n        }\n        return __assign(__assign({}, result), { sort: sort });\n    };\n    IndicatorImp.prototype.calcImp = function (dataList) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.calc(dataList, this)];\n                    case 1:\n                        result = _a.sent();\n                        this.result = result;\n                        return [2 /*return*/, true];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, false];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    IndicatorImp.extend = function (template) {\n        var Custom = /** @class */ (function (_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super.call(this, template) || this;\n            }\n            return Custom;\n        }(IndicatorImp));\n        return Custom;\n    };\n    return IndicatorImp;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OverlayMode;\n(function (OverlayMode) {\n    OverlayMode[\"Normal\"] = \"normal\";\n    OverlayMode[\"WeakMagnet\"] = \"weak_magnet\";\n    OverlayMode[\"StrongMagnet\"] = \"strong_magnet\";\n})(OverlayMode || (OverlayMode = {}));\nfunction checkOverlayFigureEvent(targetEventType, figure) {\n    var _a;\n    var ignoreEvent = (_a = figure === null || figure === void 0 ? void 0 : figure.ignoreEvent) !== null && _a !== void 0 ? _a : false;\n    if (isBoolean(ignoreEvent)) {\n        return !ignoreEvent;\n    }\n    return !ignoreEvent.includes(targetEventType);\n}\nvar OVERLAY_DRAW_STEP_START = 1;\nvar OVERLAY_DRAW_STEP_FINISHED = -1;\nvar OVERLAY_ID_PREFIX = 'overlay_';\nvar OVERLAY_FIGURE_KEY_PREFIX = 'overlay_figure_';\nvar OverlayImp = /** @class */ (function () {\n    function OverlayImp(overlay) {\n        this.groupId = '';\n        this.totalStep = 1;\n        this.currentStep = OVERLAY_DRAW_STEP_START;\n        this.lock = false;\n        this.visible = true;\n        this.zLevel = 0;\n        this.needDefaultPointFigure = false;\n        this.needDefaultXAxisFigure = false;\n        this.needDefaultYAxisFigure = false;\n        this.mode = OverlayMode.Normal;\n        this.modeSensitivity = 8;\n        this.points = [];\n        this.styles = null;\n        this.createPointFigures = null;\n        this.createXAxisFigures = null;\n        this.createYAxisFigures = null;\n        this.performEventPressedMove = null;\n        this.performEventMoveForDrawing = null;\n        this.onDrawStart = null;\n        this.onDrawing = null;\n        this.onDrawEnd = null;\n        this.onClick = null;\n        this.onDoubleClick = null;\n        this.onRightClick = null;\n        this.onPressedMoveStart = null;\n        this.onPressedMoving = null;\n        this.onPressedMoveEnd = null;\n        this.onMouseEnter = null;\n        this.onMouseLeave = null;\n        this.onRemoved = null;\n        this.onSelected = null;\n        this.onDeselected = null;\n        this._prevZLevel = 0;\n        this._prevPressedPoint = null;\n        this._prevPressedPoints = [];\n        this.override(overlay);\n    }\n    OverlayImp.prototype.override = function (overlay) {\n        var _a, _b;\n        this._prevOverlay = clone(this);\n        var id = overlay.id, name = overlay.name; overlay.currentStep; var points = overlay.points, styles = overlay.styles, others = __rest(overlay, [\"id\", \"name\", \"currentStep\", \"points\", \"styles\"]);\n        merge(this, others);\n        if (!isString(this.name)) {\n            this.name = name !== null && name !== void 0 ? name : '';\n        }\n        if (!isString(this.id) && isString(id)) {\n            this.id = id;\n        }\n        if (isValid(styles)) {\n            (_a = this.styles) !== null && _a !== void 0 ? _a : (this.styles = {});\n            merge(this.styles, styles);\n        }\n        if (isArray(points) && points.length > 0) {\n            var repeatTotalStep = 0;\n            this.points = __spreadArray([], __read(points), false);\n            if (points.length >= this.totalStep - 1) {\n                this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n                repeatTotalStep = this.totalStep - 1;\n            }\n            else {\n                this.currentStep = points.length + 1;\n                repeatTotalStep = points.length;\n            }\n            // Prevent wrong drawing due to wrong points\n            if (isFunction(this.performEventMoveForDrawing)) {\n                for (var i = 0; i < repeatTotalStep; i++) {\n                    this.performEventMoveForDrawing({\n                        currentStep: i + 2,\n                        mode: this.mode,\n                        points: this.points,\n                        performPointIndex: i,\n                        performPoint: this.points[i]\n                    });\n                }\n            }\n            if (this.currentStep === OVERLAY_DRAW_STEP_FINISHED) {\n                (_b = this.performEventPressedMove) === null || _b === void 0 ? void 0 : _b.call(this, {\n                    currentStep: this.currentStep,\n                    mode: this.mode,\n                    points: this.points,\n                    performPointIndex: this.points.length - 1,\n                    performPoint: this.points[this.points.length - 1]\n                });\n            }\n        }\n    };\n    OverlayImp.prototype.getPrevZLevel = function () { return this._prevZLevel; };\n    OverlayImp.prototype.setPrevZLevel = function (zLevel) { this._prevZLevel = zLevel; };\n    OverlayImp.prototype.shouldUpdate = function () {\n        var sort = this._prevOverlay.zLevel !== this.zLevel;\n        var draw = sort ||\n            JSON.stringify(this._prevOverlay) !== JSON.stringify(this.points) ||\n            this._prevOverlay.visible !== this.visible ||\n            this._prevOverlay.extendData !== this.extendData ||\n            this._prevOverlay.styles !== this.styles;\n        return { sort: sort, draw: draw };\n    };\n    OverlayImp.prototype.nextStep = function () {\n        if (this.currentStep === this.totalStep - 1) {\n            this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n        }\n        else {\n            this.currentStep++;\n        }\n    };\n    OverlayImp.prototype.forceComplete = function () {\n        this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n    };\n    OverlayImp.prototype.isDrawing = function () {\n        return this.currentStep !== OVERLAY_DRAW_STEP_FINISHED;\n    };\n    OverlayImp.prototype.isStart = function () {\n        return this.currentStep === OVERLAY_DRAW_STEP_START;\n    };\n    OverlayImp.prototype.eventMoveForDrawing = function (point) {\n        var _a;\n        var pointIndex = this.currentStep - 1;\n        var newPoint = {};\n        if (isNumber(point.timestamp)) {\n            newPoint.timestamp = point.timestamp;\n        }\n        if (isNumber(point.dataIndex)) {\n            newPoint.dataIndex = point.dataIndex;\n        }\n        if (isNumber(point.value)) {\n            newPoint.value = point.value;\n        }\n        this.points[pointIndex] = newPoint;\n        (_a = this.performEventMoveForDrawing) === null || _a === void 0 ? void 0 : _a.call(this, {\n            currentStep: this.currentStep,\n            mode: this.mode,\n            points: this.points,\n            performPointIndex: pointIndex,\n            performPoint: newPoint\n        });\n    };\n    OverlayImp.prototype.eventPressedPointMove = function (point, pointIndex) {\n        var _a;\n        this.points[pointIndex].timestamp = point.timestamp;\n        if (isNumber(point.value)) {\n            this.points[pointIndex].value = point.value;\n        }\n        (_a = this.performEventPressedMove) === null || _a === void 0 ? void 0 : _a.call(this, {\n            currentStep: this.currentStep,\n            points: this.points,\n            mode: this.mode,\n            performPointIndex: pointIndex,\n            performPoint: this.points[pointIndex]\n        });\n    };\n    OverlayImp.prototype.startPressedMove = function (point) {\n        this._prevPressedPoint = __assign({}, point);\n        this._prevPressedPoints = clone(this.points);\n    };\n    OverlayImp.prototype.eventPressedOtherMove = function (point, chartStore) {\n        if (this._prevPressedPoint !== null) {\n            var difDataIndex_1 = null;\n            if (isNumber(point.dataIndex) && isNumber(this._prevPressedPoint.dataIndex)) {\n                difDataIndex_1 = point.dataIndex - this._prevPressedPoint.dataIndex;\n            }\n            var difValue_1 = null;\n            if (isNumber(point.value) && isNumber(this._prevPressedPoint.value)) {\n                difValue_1 = point.value - this._prevPressedPoint.value;\n            }\n            this.points = this._prevPressedPoints.map(function (p) {\n                var _a;\n                if (isNumber(p.timestamp)) {\n                    p.dataIndex = chartStore.timestampToDataIndex(p.timestamp);\n                }\n                var newPoint = __assign({}, p);\n                if (isNumber(difDataIndex_1) && isNumber(p.dataIndex)) {\n                    newPoint.dataIndex = p.dataIndex + difDataIndex_1;\n                    newPoint.timestamp = (_a = chartStore.dataIndexToTimestamp(newPoint.dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (isNumber(difValue_1) && isNumber(p.value)) {\n                    newPoint.value = p.value + difValue_1;\n                }\n                return newPoint;\n            });\n        }\n    };\n    OverlayImp.extend = function (template) {\n        var Custom = /** @class */ (function (_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super.call(this, template) || this;\n            }\n            return Custom;\n        }(OverlayImp));\n        return Custom;\n    };\n    return OverlayImp;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar FormatDateType;\n(function (FormatDateType) {\n    FormatDateType[FormatDateType[\"Tooltip\"] = 0] = \"Tooltip\";\n    FormatDateType[FormatDateType[\"Crosshair\"] = 1] = \"Crosshair\";\n    FormatDateType[FormatDateType[\"XAxis\"] = 2] = \"XAxis\";\n})(FormatDateType || (FormatDateType = {}));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createDefaultBounding(bounding) {\n    var defaultBounding = {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    if (isValid(bounding)) {\n        merge(defaultBounding, bounding);\n    }\n    return defaultBounding;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_REQUEST_ID = -1;\nfunction requestAnimationFrame(fn) {\n    if (isFunction(window.requestAnimationFrame)) {\n        return window.requestAnimationFrame(fn);\n    }\n    return window.setTimeout(fn, 20);\n}\nfunction cancelAnimationFrame(id) {\n    if (isFunction(window.cancelAnimationFrame)) {\n        window.cancelAnimationFrame(id);\n    }\n    else {\n        window.clearTimeout(id);\n    }\n}\nfunction requestIdleCallback(fn) {\n    if (isFunction(window.requestIdleCallback)) {\n        return window.requestIdleCallback(fn);\n    }\n    var startTime = performance.now();\n    return window.setTimeout(function () {\n        fn({\n            didTimeout: false,\n            timeRemaining: function () {\n                return Math.max(0, 50 - (performance.now() - startTime));\n            }\n        });\n    }, 1);\n}\nfunction cancelIdleCallback(id) {\n    if (isFunction(window.cancelIdleCallback)) {\n        window.cancelIdleCallback(id);\n    }\n    else {\n        window.clearTimeout(id);\n    }\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Animation = /** @class */ (function () {\n    function Animation(options) {\n        this._options = { duration: 500, iterationCount: 1 };\n        this._currentIterationCount = 0;\n        this._running = false;\n        this._time = 0;\n        merge(this._options, options);\n    }\n    Animation.prototype._loop = function () {\n        var _this = this;\n        this._running = true;\n        var step = function () {\n            var _a;\n            if (_this._running) {\n                var diffTime = new Date().getTime() - _this._time;\n                if (diffTime < _this._options.duration) {\n                    (_a = _this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(_this, diffTime);\n                    requestAnimationFrame(step);\n                }\n                else {\n                    _this.stop();\n                    _this._currentIterationCount++;\n                    if (_this._currentIterationCount < _this._options.iterationCount) {\n                        _this.start();\n                    }\n                }\n            }\n        };\n        requestAnimationFrame(step);\n    };\n    Animation.prototype.doFrame = function (callback) {\n        this._doFrameCallback = callback;\n        return this;\n    };\n    Animation.prototype.setDuration = function (duration) {\n        this._options.duration = duration;\n        return this;\n    };\n    Animation.prototype.setIterationCount = function (iterationCount) {\n        this._options.iterationCount = iterationCount;\n        return this;\n    };\n    Animation.prototype.start = function () {\n        if (!this._running) {\n            this._time = new Date().getTime();\n            this._loop();\n        }\n    };\n    Animation.prototype.stop = function () {\n        var _a;\n        if (this._running) {\n            (_a = this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(this, this._options.duration);\n        }\n        this._running = false;\n    };\n    return Animation;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar baseId = 1;\nvar prevIdTimestamp = new Date().getTime();\nfunction createId(prefix) {\n    var timestamp = new Date().getTime();\n    if (timestamp === prevIdTimestamp) {\n        ++baseId;\n    }\n    else {\n        baseId = 1;\n    }\n    prevIdTimestamp = timestamp;\n    return \"\".concat(prefix !== null && prefix !== void 0 ? prefix : '').concat(timestamp, \"_\").concat(baseId);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create dom\n * @param tagName\n * @param styles\n * @return {*}\n */\nfunction createDom(tagName, styles) {\n    var _a;\n    var dom = document.createElement(tagName);\n    var s = styles !== null && styles !== void 0 ? styles : {};\n    // eslint-disable-next-line guard-for-in -- ignore\n    for (var key in s) {\n        (dom.style)[key] = (_a = s[key]) !== null && _a !== void 0 ? _a : '';\n    }\n    return dom;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Binary search for the nearest result\n * @param dataList\n * @param valueKey\n * @param targetValue\n * @return {number}\n */\nfunction binarySearchNearest(dataList, valueKey, targetValue) {\n    var left = 0;\n    var right = 0;\n    for (right = dataList.length - 1; left !== right;) {\n        var midIndex = Math.floor((right + left) / 2);\n        var mid = right - left;\n        var midValue = dataList[midIndex][valueKey];\n        if (targetValue === dataList[left][valueKey]) {\n            return left;\n        }\n        if (targetValue === dataList[right][valueKey]) {\n            return right;\n        }\n        if (targetValue === midValue) {\n            return midIndex;\n        }\n        if (targetValue > midValue) {\n            left = midIndex;\n        }\n        else {\n            right = midIndex;\n        }\n        if (mid <= 2) {\n            break;\n        }\n    }\n    return left;\n}\n/**\n * 优化数字\n * @param value\n * @return {number|number}\n */\nfunction nice(value) {\n    var exponent = Math.floor(log10(value));\n    var exp10 = index10(exponent);\n    var f = value / exp10; // 1 <= f < 10\n    var nf = 0;\n    if (f < 1.5) {\n        nf = 1;\n    }\n    else if (f < 2.5) {\n        nf = 2;\n    }\n    else if (f < 3.5) {\n        nf = 3;\n    }\n    else if (f < 4.5) {\n        nf = 4;\n    }\n    else if (f < 5.5) {\n        nf = 5;\n    }\n    else if (f < 6.5) {\n        nf = 6;\n    }\n    else {\n        nf = 8;\n    }\n    value = nf * exp10;\n    return +value.toFixed(Math.abs(exponent));\n}\n/**\n * Round\n * @param value\n * @param precision\n * @return {number}\n */\nfunction round(value, precision) {\n    precision = Math.max(0, precision !== null && precision !== void 0 ? precision : 0);\n    var pow = Math.pow(10, precision);\n    return Math.round(value * pow) / pow;\n}\n/**\n * Get precision\n * @param value\n * @return {number|number}\n */\nfunction getPrecision(value) {\n    var str = value.toString();\n    var eIndex = str.indexOf('e');\n    if (eIndex > 0) {\n        var precision = +str.slice(eIndex + 1);\n        return precision < 0 ? -precision : 0;\n    }\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n}\nfunction getMaxMin(dataList, maxKey, minKey) {\n    var _a, _b;\n    var maxMin = [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER];\n    var dataLength = dataList.length;\n    var index = 0;\n    while (index < dataLength) {\n        var data = dataList[index];\n        maxMin[0] = Math.max(((_a = data[maxKey]) !== null && _a !== void 0 ? _a : Number.MIN_SAFE_INTEGER), maxMin[0]);\n        maxMin[1] = Math.min(((_b = data[minKey]) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER), maxMin[1]);\n        ++index;\n    }\n    return maxMin;\n}\n/**\n * log10\n * @param value\n * @return {number}\n */\nfunction log10(value) {\n    if (value === 0) {\n        return 0;\n    }\n    return Math.log10(value);\n}\n/**\n * index 10\n * @param value\n * @return {number}\n */\nfunction index10(value) {\n    return Math.pow(10, value);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar LoadDataType;\n(function (LoadDataType) {\n    LoadDataType[\"Init\"] = \"init\";\n    LoadDataType[\"Forward\"] = \"forward\";\n    LoadDataType[\"Backward\"] = \"backward\";\n    LoadDataType[\"Update\"] = \"update\";\n})(LoadDataType || (LoadDataType = {}));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getDefaultVisibleRange() {\n    return { from: 0, to: 0, realFrom: 0, realTo: 0 };\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction generateTaskId() {\n    var params = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        params[_i] = arguments[_i];\n    }\n    return params.join('_');\n}\nvar TaskScheduler = /** @class */ (function () {\n    function TaskScheduler(tasks) {\n        this._requestIdleCallbackId = DEFAULT_REQUEST_ID;\n        this._tasks = tasks !== null && tasks !== void 0 ? tasks : [];\n        this._operateTasks();\n    }\n    TaskScheduler.prototype._operateTasks = function (fn) {\n        var _this = this;\n        if (this._requestIdleCallbackId !== DEFAULT_REQUEST_ID) {\n            cancelIdleCallback(this._requestIdleCallbackId);\n            this._requestIdleCallbackId = DEFAULT_REQUEST_ID;\n        }\n        fn === null || fn === void 0 ? void 0 : fn();\n        this._requestIdleCallbackId = requestIdleCallback(function (deadline) { _this._runTasks(deadline); });\n    };\n    TaskScheduler.prototype._runTasks = function (deadline) {\n        var _this = this;\n        while (deadline.timeRemaining() > 0 && this._tasks.length > 0) {\n            var task = this._tasks.shift();\n            task === null || task === void 0 ? void 0 : task.handler();\n        }\n        if (this._tasks.length > 0) {\n            this._requestIdleCallbackId = requestIdleCallback(function (deadline) { _this._runTasks(deadline); });\n        }\n    };\n    TaskScheduler.prototype.addTask = function (task) {\n        var _this = this;\n        this._operateTasks(function () {\n            var index = _this._tasks.findIndex(function (t) { return t.id === task.id; });\n            if (index > -1) {\n                _this._tasks[index] = task;\n            }\n            else {\n                _this._tasks.push(task);\n            }\n        });\n        return this;\n    };\n    TaskScheduler.prototype.removeTask = function (id) {\n        var _this = this;\n        this._operateTasks(function () {\n            var index = _this._tasks.findIndex(function (t) { return t.id === id; });\n            if (index > -1) {\n                _this._tasks.splice(index, 1);\n            }\n        });\n        return this;\n    };\n    return TaskScheduler;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TimeWeightConstants = {\n    Year: 365 * 24 * 3600,\n    Month: 30 * 24 * 3600,\n    Day: 24 * 3600,\n    Hour: 3600,\n    Minute: 60,\n    Second: 1\n};\nfunction classifyTimeWeightTicks(map, dataList, dateTimeFormat, baseDataIndex, minTimeSpan, startTimestamp) {\n    var _a;\n    if (baseDataIndex === void 0) { baseDataIndex = 0; }\n    var prevDateTime = null;\n    var prevTimestamp = startTimestamp !== null && startTimestamp !== void 0 ? startTimestamp : null;\n    for (var i = 0; i < dataList.length; i++) {\n        var timestamp = dataList[i].timestamp;\n        var weight = TimeWeightConstants.Minute;\n        var dateTime = formatTimestampToDateTime(dateTimeFormat, timestamp);\n        if (isValid(prevDateTime)) {\n            if (dateTime.YYYY !== prevDateTime.YYYY) {\n                weight = TimeWeightConstants.Year;\n            }\n            else if (dateTime.MM !== prevDateTime.MM) {\n                weight = TimeWeightConstants.Month;\n            }\n            else if (dateTime.DD !== prevDateTime.DD) {\n                weight = TimeWeightConstants.Day;\n            }\n            else if (dateTime.HH !== prevDateTime.HH) {\n                weight = TimeWeightConstants.Hour;\n            }\n            else if (dateTime.mm !== prevDateTime.mm) {\n                weight = TimeWeightConstants.Minute;\n            }\n            else {\n                weight = TimeWeightConstants.Second;\n            }\n        }\n        if (isNumber(prevTimestamp) && isNumber(minTimeSpan === null || minTimeSpan === void 0 ? void 0 : minTimeSpan.compare)) {\n            minTimeSpan.compare = Math.min(minTimeSpan.compare, timestamp - prevTimestamp);\n        }\n        var currentTimeWeightList = (_a = map.get(weight)) !== null && _a !== void 0 ? _a : [];\n        currentTimeWeightList.push({ dataIndex: i + baseDataIndex, weight: weight, timestamp: timestamp });\n        map.set(weight, currentTimeWeightList);\n        prevDateTime = dateTime;\n        prevTimestamp = timestamp;\n    }\n}\nfunction calcBetweenTimeWeightTickBarCount(barSpace, textStyles) {\n    var space = Math.max(calcTextWidth('0000-00-00 00:00:00', textStyles.size, textStyles.weight, textStyles.family), 146);\n    return Math.ceil(space / barSpace);\n}\nfunction createTimeWeightTickList(map, barSpace, textStyles) {\n    var barCount = calcBetweenTimeWeightTickBarCount(barSpace, textStyles);\n    var optTimeWeightTickList = [];\n    Array.from(map.keys()).sort(function (w1, w2) { return w2 - w1; }).forEach(function (weight) {\n        var currentTimeWeightTickList = map.get(weight);\n        var prevOptTimeWeightTickList = optTimeWeightTickList;\n        optTimeWeightTickList = [];\n        var prevOptTimeWeightTickListLength = prevOptTimeWeightTickList.length;\n        var prevOptTimeWeightTickListPointer = 0;\n        var currentTimeWeightTickListLength = currentTimeWeightTickList.length;\n        var rightIndex = Infinity;\n        var leftIndex = -Infinity;\n        for (var i = 0; i < currentTimeWeightTickListLength; i++) {\n            var timeWeightTick = currentTimeWeightTickList[i];\n            var currentIndex = timeWeightTick.dataIndex;\n            while (prevOptTimeWeightTickListPointer < prevOptTimeWeightTickListLength) {\n                var lastTimeWeightTick = prevOptTimeWeightTickList[prevOptTimeWeightTickListPointer];\n                var lastIndex = lastTimeWeightTick.dataIndex;\n                if (lastIndex < currentIndex) {\n                    prevOptTimeWeightTickListPointer++;\n                    optTimeWeightTickList.push(lastTimeWeightTick);\n                    leftIndex = lastIndex;\n                    rightIndex = Infinity;\n                }\n                else {\n                    rightIndex = lastIndex;\n                    break;\n                }\n            }\n            if (rightIndex - currentIndex >= barCount && currentIndex - leftIndex >= barCount) {\n                optTimeWeightTickList.push(timeWeightTick);\n                leftIndex = currentIndex;\n            }\n        }\n        for (; prevOptTimeWeightTickListPointer < prevOptTimeWeightTickListLength; prevOptTimeWeightTickListPointer++) {\n            optTimeWeightTickList.push(prevOptTimeWeightTickList[prevOptTimeWeightTickListPointer]);\n        }\n    });\n    return optTimeWeightTickList;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * average price\n */\nvar averagePrice = {\n    name: 'AVP',\n    shortName: 'AVP',\n    series: IndicatorSeries.Price,\n    precision: 2,\n    figures: [\n        { key: 'avp', title: 'AVP: ', type: 'line' }\n    ],\n    calc: function (dataList) {\n        var totalTurnover = 0;\n        var totalVolume = 0;\n        return dataList.map(function (kLineData) {\n            var _a, _b;\n            var avp = {};\n            var turnover = (_a = kLineData.turnover) !== null && _a !== void 0 ? _a : 0;\n            var volume = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;\n            totalTurnover += turnover;\n            totalVolume += volume;\n            if (totalVolume !== 0) {\n                avp.avp = totalTurnover / totalVolume;\n            }\n            return avp;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar awesomeOscillator = {\n    name: 'AO',\n    shortName: 'AO',\n    calcParams: [5, 34],\n    figures: [{\n            key: 'ao',\n            title: 'AO: ',\n            type: 'bar',\n            baseValue: 0,\n            styles: function (_a) {\n                var _b, _c;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var prev = data.prev, current = data.current;\n                var prevAo = (_b = prev === null || prev === void 0 ? void 0 : prev.ao) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var currentAo = (_c = current === null || current === void 0 ? void 0 : current.ao) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;\n                var color = '';\n                if (currentAo > prevAo) {\n                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);\n                }\n                else {\n                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);\n                }\n                var style = currentAo > prevAo ? PolygonType.Stroke : PolygonType.Fill;\n                return { color: color, style: style, borderColor: color };\n            }\n        }],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max(params[0], params[1]);\n        var shortSum = 0;\n        var longSum = 0;\n        var short = 0;\n        var long = 0;\n        return dataList.map(function (kLineData, i) {\n            var ao = {};\n            var middle = (kLineData.low + kLineData.high) / 2;\n            shortSum += middle;\n            longSum += middle;\n            if (i >= params[0] - 1) {\n                short = shortSum / params[0];\n                var agoKLineData = dataList[i - (params[0] - 1)];\n                shortSum -= ((agoKLineData.low + agoKLineData.high) / 2);\n            }\n            if (i >= params[1] - 1) {\n                long = longSum / params[1];\n                var agoKLineData = dataList[i - (params[1] - 1)];\n                longSum -= ((agoKLineData.low + agoKLineData.high) / 2);\n            }\n            if (i >= maxPeriod - 1) {\n                ao.ao = short - long;\n            }\n            return ao;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * BIAS\n * 乖离率=[(当日收盘价-N日平均价)/N日平均价]*100%\n */\nvar bias = {\n    name: 'BIAS',\n    shortName: 'BIAS',\n    calcParams: [6, 12, 24],\n    figures: [\n        { key: 'bias1', title: 'BIAS6: ', type: 'line' },\n        { key: 'bias2', title: 'BIAS12: ', type: 'line' },\n        { key: 'bias3', title: 'BIAS24: ', type: 'line' }\n    ],\n    regenerateFigures: function (params) { return params.map(function (p, i) { return ({ key: \"bias\".concat(i + 1), title: \"BIAS\".concat(p, \": \"), type: 'line' }); }); },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSums = [];\n        return dataList.map(function (kLineData, i) {\n            var bias = {};\n            var close = kLineData.close;\n            params.forEach(function (p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    var mean = closeSums[index] / params[index];\n                    bias[figures[index].key] = (close - mean) / mean * 100;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            return bias;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * 计算布林指标中的标准差\n * @param dataList\n * @param ma\n * @return {number}\n */\nfunction getBollMd(dataList, ma) {\n    var dataSize = dataList.length;\n    var sum = 0;\n    dataList.forEach(function (data) {\n        var closeMa = data.close - ma;\n        sum += closeMa * closeMa;\n    });\n    sum = Math.abs(sum);\n    return Math.sqrt(sum / dataSize);\n}\n/**\n * BOLL\n */\nvar bollingerBands = {\n    name: 'BOLL',\n    shortName: 'BOLL',\n    series: IndicatorSeries.Price,\n    calcParams: [20, 2],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        { key: 'up', title: 'UP: ', type: 'line' },\n        { key: 'mid', title: 'MID: ', type: 'line' },\n        { key: 'dn', title: 'DN: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var p = params[0] - 1;\n        var closeSum = 0;\n        return dataList.map(function (kLineData, i) {\n            var close = kLineData.close;\n            var boll = {};\n            closeSum += close;\n            if (i >= p) {\n                boll.mid = closeSum / params[0];\n                var md = getBollMd(dataList.slice(i - p, i + 1), boll.mid);\n                boll.up = boll.mid + params[1] * md;\n                boll.dn = boll.mid - params[1] * md;\n                closeSum -= dataList[i - p].close;\n            }\n            return boll;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * BRAR\n * 默认参数是26。\n * 公式N日BR=N日内（H－CY）之和除以N日内（CY－L）之和*100，\n * 其中，H为当日最高价，L为当日最低价，CY为前一交易日的收盘价，N为设定的时间参数。\n * N日AR=(N日内（H－O）之和除以N日内（O－L）之和)*100，\n * 其中，H为当日最高价，L为当日最低价，O为当日开盘价，N为设定的时间参数\n *\n */\nvar brar = {\n    name: 'BRAR',\n    shortName: 'BRAR',\n    calcParams: [26],\n    figures: [\n        { key: 'br', title: 'BR: ', type: 'line' },\n        { key: 'ar', title: 'AR: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var hcy = 0;\n        var cyl = 0;\n        var ho = 0;\n        var ol = 0;\n        return dataList.map(function (kLineData, i) {\n            var _a, _b;\n            var brar = {};\n            var high = kLineData.high;\n            var low = kLineData.low;\n            var open = kLineData.open;\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            ho += (high - open);\n            ol += (open - low);\n            hcy += (high - prevClose);\n            cyl += (prevClose - low);\n            if (i >= params[0] - 1) {\n                if (ol !== 0) {\n                    brar.ar = ho / ol * 100;\n                }\n                else {\n                    brar.ar = 0;\n                }\n                if (cyl !== 0) {\n                    brar.br = hcy / cyl * 100;\n                }\n                else {\n                    brar.br = 0;\n                }\n                var agoKLineData = dataList[i - (params[0] - 1)];\n                var agoHigh = agoKLineData.high;\n                var agoLow = agoKLineData.low;\n                var agoOpen = agoKLineData.open;\n                var agoPreClose = ((_b = dataList[i - params[0]]) !== null && _b !== void 0 ? _b : dataList[i - (params[0] - 1)]).close;\n                hcy -= (agoHigh - agoPreClose);\n                cyl -= (agoPreClose - agoLow);\n                ho -= (agoHigh - agoOpen);\n                ol -= (agoOpen - agoLow);\n            }\n            return brar;\n        });\n    }\n};\n\n/**\n * 多空指标\n * 公式: BBI = (MA(CLOSE, M) + MA(CLOSE, N) + MA(CLOSE, O) + MA(CLOSE, P)) / 4\n *\n */\nvar bullAndBearIndex = {\n    name: 'BBI',\n    shortName: 'BBI',\n    series: IndicatorSeries.Price,\n    precision: 2,\n    calcParams: [3, 6, 12, 24],\n    shouldOhlc: true,\n    figures: [\n        { key: 'bbi', title: 'BBI: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max.apply(Math, __spreadArray([], __read(params), false));\n        var closeSums = [];\n        var mas = [];\n        return dataList.map(function (kLineData, i) {\n            var bbi = {};\n            var close = kLineData.close;\n            params.forEach(function (p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    mas[index] = closeSums[index] / p;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            if (i >= maxPeriod - 1) {\n                var maSum_1 = 0;\n                mas.forEach(function (ma) {\n                    maSum_1 += ma;\n                });\n                bbi.bbi = maSum_1 / 4;\n            }\n            return bbi;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * CCI\n * CCI（N日）=（TP－MA）÷MD÷0.015\n * 其中，TP=（最高价+最低价+收盘价）÷3\n * MA=近N日TP价的累计之和÷N\n * MD=近N日TP - 当前MA绝对值的累计之和÷N\n *\n */\nvar commodityChannelIndex = {\n    name: 'CCI',\n    shortName: 'CCI',\n    calcParams: [20],\n    figures: [\n        { key: 'cci', title: 'CCI: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var p = params[0] - 1;\n        var tpSum = 0;\n        var tpList = [];\n        return dataList.map(function (kLineData, i) {\n            var cci = {};\n            var tp = (kLineData.high + kLineData.low + kLineData.close) / 3;\n            tpSum += tp;\n            tpList.push(tp);\n            if (i >= p) {\n                var maTp_1 = tpSum / params[0];\n                var sliceTpList = tpList.slice(i - p, i + 1);\n                var sum_1 = 0;\n                sliceTpList.forEach(function (tp) {\n                    sum_1 += Math.abs(tp - maTp_1);\n                });\n                var md = sum_1 / params[0];\n                cci.cci = md !== 0 ? (tp - maTp_1) / md / 0.015 : 0;\n                var agoTp = (dataList[i - p].high + dataList[i - p].low + dataList[i - p].close) / 3;\n                tpSum -= agoTp;\n            }\n            return cci;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http:*www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * MID:=REF(HIGH+LOW,1)/2;\n * CR:SUM(MAX(0,HIGH-MID),N)/SUM(MAX(0,MID-LOW),N)*100;\n * MA1:REF(MA(CR,M1),M1/2.5+1);\n * MA2:REF(MA(CR,M2),M2/2.5+1);\n * MA3:REF(MA(CR,M3),M3/2.5+1);\n * MA4:REF(MA(CR,M4),M4/2.5+1);\n * MID赋值:(昨日最高价+昨日最低价)/2\n * 输出带状能量线:0和最高价-MID的较大值的N日累和/0和MID-最低价的较大值的N日累和*100\n * 输出MA1:M1(5)/2.5+1日前的CR的M1(5)日简单移动平均\n * 输出MA2:M2(10)/2.5+1日前的CR的M2(10)日简单移动平均\n * 输出MA3:M3(20)/2.5+1日前的CR的M3(20)日简单移动平均\n * 输出MA4:M4/2.5+1日前的CR的M4日简单移动平均\n *\n */\nvar currentRatio = {\n    name: 'CR',\n    shortName: 'CR',\n    calcParams: [26, 10, 20, 40, 60],\n    figures: [\n        { key: 'cr', title: 'CR: ', type: 'line' },\n        { key: 'ma1', title: 'MA1: ', type: 'line' },\n        { key: 'ma2', title: 'MA2: ', type: 'line' },\n        { key: 'ma3', title: 'MA3: ', type: 'line' },\n        { key: 'ma4', title: 'MA4: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var ma1ForwardPeriod = Math.ceil(params[1] / 2.5 + 1);\n        var ma2ForwardPeriod = Math.ceil(params[2] / 2.5 + 1);\n        var ma3ForwardPeriod = Math.ceil(params[3] / 2.5 + 1);\n        var ma4ForwardPeriod = Math.ceil(params[4] / 2.5 + 1);\n        var ma1Sum = 0;\n        var ma1List = [];\n        var ma2Sum = 0;\n        var ma2List = [];\n        var ma3Sum = 0;\n        var ma3List = [];\n        var ma4Sum = 0;\n        var ma4List = [];\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b, _c, _d, _e;\n            var cr = {};\n            var prevData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            var prevMid = (prevData.high + prevData.close + prevData.low + prevData.open) / 4;\n            var highSubPreMid = Math.max(0, kLineData.high - prevMid);\n            var preMidSubLow = Math.max(0, prevMid - kLineData.low);\n            if (i >= params[0] - 1) {\n                if (preMidSubLow !== 0) {\n                    cr.cr = highSubPreMid / preMidSubLow * 100;\n                }\n                else {\n                    cr.cr = 0;\n                }\n                ma1Sum += cr.cr;\n                ma2Sum += cr.cr;\n                ma3Sum += cr.cr;\n                ma4Sum += cr.cr;\n                if (i >= params[0] + params[1] - 2) {\n                    ma1List.push(ma1Sum / params[1]);\n                    if (i >= params[0] + params[1] + ma1ForwardPeriod - 3) {\n                        cr.ma1 = ma1List[ma1List.length - 1 - ma1ForwardPeriod];\n                    }\n                    ma1Sum -= ((_b = result[i - (params[1] - 1)].cr) !== null && _b !== void 0 ? _b : 0);\n                }\n                if (i >= params[0] + params[2] - 2) {\n                    ma2List.push(ma2Sum / params[2]);\n                    if (i >= params[0] + params[2] + ma2ForwardPeriod - 3) {\n                        cr.ma2 = ma2List[ma2List.length - 1 - ma2ForwardPeriod];\n                    }\n                    ma2Sum -= ((_c = result[i - (params[2] - 1)].cr) !== null && _c !== void 0 ? _c : 0);\n                }\n                if (i >= params[0] + params[3] - 2) {\n                    ma3List.push(ma3Sum / params[3]);\n                    if (i >= params[0] + params[3] + ma3ForwardPeriod - 3) {\n                        cr.ma3 = ma3List[ma3List.length - 1 - ma3ForwardPeriod];\n                    }\n                    ma3Sum -= ((_d = result[i - (params[3] - 1)].cr) !== null && _d !== void 0 ? _d : 0);\n                }\n                if (i >= params[0] + params[4] - 2) {\n                    ma4List.push(ma4Sum / params[4]);\n                    if (i >= params[0] + params[4] + ma4ForwardPeriod - 3) {\n                        cr.ma4 = ma4List[ma4List.length - 1 - ma4ForwardPeriod];\n                    }\n                    ma4Sum -= ((_e = result[i - (params[4] - 1)].cr) !== null && _e !== void 0 ? _e : 0);\n                }\n            }\n            result.push(cr);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DMA\n * 公式：DIF:MA(CLOSE,N1)-MA(CLOSE,N2);DIFMA:MA(DIF,M)\n */\nvar differentOfMovingAverage = {\n    name: 'DMA',\n    shortName: 'DMA',\n    calcParams: [10, 50, 10],\n    figures: [\n        { key: 'dma', title: 'DMA: ', type: 'line' },\n        { key: 'ama', title: 'AMA: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max(params[0], params[1]);\n        var closeSum1 = 0;\n        var closeSum2 = 0;\n        var dmaSum = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a;\n            var dma = {};\n            var close = kLineData.close;\n            closeSum1 += close;\n            closeSum2 += close;\n            var ma1 = 0;\n            var ma2 = 0;\n            if (i >= params[0] - 1) {\n                ma1 = closeSum1 / params[0];\n                closeSum1 -= dataList[i - (params[0] - 1)].close;\n            }\n            if (i >= params[1] - 1) {\n                ma2 = closeSum2 / params[1];\n                closeSum2 -= dataList[i - (params[1] - 1)].close;\n            }\n            if (i >= maxPeriod - 1) {\n                var dif = ma1 - ma2;\n                dma.dma = dif;\n                dmaSum += dif;\n                if (i >= maxPeriod + params[2] - 2) {\n                    dma.ama = dmaSum / params[2];\n                    dmaSum -= ((_a = result[i - (params[2] - 1)].dma) !== null && _a !== void 0 ? _a : 0);\n                }\n            }\n            result.push(dma);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * DMI\n *\n * MTR:=EXPMEMA(MAX(MAX(HIGH-LOW,ABS(HIGH-REF(CLOSE,1))),ABS(REF(CLOSE,1)-LOW)),N)\n * HD :=HIGH-REF(HIGH,1);\n * LD :=REF(LOW,1)-LOW;\n * DMP:=EXPMEMA(IF(HD>0&&HD>LD,HD,0),N);\n * DMM:=EXPMEMA(IF(LD>0&&LD>HD,LD,0),N);\n *\n * PDI: DMP*100/MTR;\n * MDI: DMM*100/MTR;\n * ADX: EXPMEMA(ABS(MDI-PDI)/(MDI+PDI)*100,MM);\n * ADXR:EXPMEMA(ADX,MM);\n * 公式含义：\n * MTR赋值:最高价-最低价和最高价-昨收的绝对值的较大值和昨收-最低价的绝对值的较大值的N日指数平滑移动平均\n * HD赋值:最高价-昨日最高价\n * LD赋值:昨日最低价-最低价\n * DMP赋值:如果HD>0并且HD>LD,返回HD,否则返回0的N日指数平滑移动平均\n * DMM赋值:如果LD>0并且LD>HD,返回LD,否则返回0的N日指数平滑移动平均\n * 输出PDI:DMP*100/MTR\n * 输出MDI:DMM*100/MTR\n * 输出ADX:MDI-PDI的绝对值/(MDI+PDI)*100的MM日指数平滑移动平均\n * 输出ADXR:ADX的MM日指数平滑移动平均\n *\n */\nvar directionalMovementIndex = {\n    name: 'DMI',\n    shortName: 'DMI',\n    calcParams: [14, 6],\n    figures: [\n        { key: 'pdi', title: 'PDI: ', type: 'line' },\n        { key: 'mdi', title: 'MDI: ', type: 'line' },\n        { key: 'adx', title: 'ADX: ', type: 'line' },\n        { key: 'adxr', title: 'ADXR: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var trSum = 0;\n        var hSum = 0;\n        var lSum = 0;\n        var mtr = 0;\n        var dmp = 0;\n        var dmm = 0;\n        var dxSum = 0;\n        var adx = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b;\n            var dmi = {};\n            var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            var preClose = prevKLineData.close;\n            var high = kLineData.high;\n            var low = kLineData.low;\n            var hl = high - low;\n            var hcy = Math.abs(high - preClose);\n            var lcy = Math.abs(preClose - low);\n            var hhy = high - prevKLineData.high;\n            var lyl = prevKLineData.low - low;\n            var tr = Math.max(Math.max(hl, hcy), lcy);\n            var h = (hhy > 0 && hhy > lyl) ? hhy : 0;\n            var l = (lyl > 0 && lyl > hhy) ? lyl : 0;\n            trSum += tr;\n            hSum += h;\n            lSum += l;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    mtr = mtr - mtr / params[0] + tr;\n                    dmp = dmp - dmp / params[0] + h;\n                    dmm = dmm - dmm / params[0] + l;\n                }\n                else {\n                    mtr = trSum;\n                    dmp = hSum;\n                    dmm = lSum;\n                }\n                var pdi = 0;\n                var mdi = 0;\n                if (mtr !== 0) {\n                    pdi = dmp * 100 / mtr;\n                    mdi = dmm * 100 / mtr;\n                }\n                dmi.pdi = pdi;\n                dmi.mdi = mdi;\n                var dx = 0;\n                if (mdi + pdi !== 0) {\n                    dx = Math.abs((mdi - pdi)) / (mdi + pdi) * 100;\n                }\n                dxSum += dx;\n                if (i >= params[0] * 2 - 2) {\n                    if (i > params[0] * 2 - 2) {\n                        adx = (adx * (params[0] - 1) + dx) / params[0];\n                    }\n                    else {\n                        adx = dxSum / params[0];\n                    }\n                    dmi.adx = adx;\n                    if (i >= params[0] * 2 + params[1] - 3) {\n                        dmi.adxr = (((_b = result[i - (params[1] - 1)].adx) !== null && _b !== void 0 ? _b : 0) + adx) / 2;\n                    }\n                }\n            }\n            result.push(dmi);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n *\n * EMV 简易波动指标\n * 公式：\n * A=（今日最高+今日最低）/2\n * B=（前日最高+前日最低）/2\n * C=今日最高-今日最低\n * EM=（A-B）*C/今日成交额\n * EMV=N日内EM的累和\n * MAEMV=EMV的M日的简单移动平均\n *\n */\nvar easeOfMovementValue = {\n    name: 'EMV',\n    shortName: 'EMV',\n    calcParams: [14, 9],\n    figures: [\n        { key: 'emv', title: 'EMV: ', type: 'line' },\n        { key: 'maEmv', title: 'MAEMV: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var emvValueSum = 0;\n        var emvValueList = [];\n        return dataList.map(function (kLineData, i) {\n            var _a;\n            var emv = {};\n            if (i > 0) {\n                var prevKLineData = dataList[i - 1];\n                var high = kLineData.high;\n                var low = kLineData.low;\n                var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;\n                var distanceMoved = (high + low) / 2 - (prevKLineData.high + prevKLineData.low) / 2;\n                if (volume === 0 || high - low === 0) {\n                    emv.emv = 0;\n                }\n                else {\n                    var ratio = volume / 100000000 / (high - low);\n                    emv.emv = distanceMoved / ratio;\n                }\n                emvValueSum += emv.emv;\n                emvValueList.push(emv.emv);\n                if (i >= params[0]) {\n                    emv.maEmv = emvValueSum / params[0];\n                    emvValueSum -= emvValueList[i - params[0]];\n                }\n            }\n            return emv;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * EMA 指数移动平均\n */\nvar exponentialMovingAverage = {\n    name: 'EMA',\n    shortName: 'EMA',\n    series: IndicatorSeries.Price,\n    calcParams: [6, 12, 20],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        { key: 'ema1', title: 'EMA6: ', type: 'line' },\n        { key: 'ema2', title: 'EMA12: ', type: 'line' },\n        { key: 'ema3', title: 'EMA20: ', type: 'line' }\n    ],\n    regenerateFigures: function (params) { return params.map(function (p, i) { return ({ key: \"ema\".concat(i + 1), title: \"EMA\".concat(p, \": \"), type: 'line' }); }); },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSum = 0;\n        var emaValues = [];\n        return dataList.map(function (kLineData, i) {\n            var ema = {};\n            var close = kLineData.close;\n            closeSum += close;\n            params.forEach(function (p, index) {\n                if (i >= p - 1) {\n                    if (i > p - 1) {\n                        emaValues[index] = (2 * close + (p - 1) * emaValues[index]) / (p + 1);\n                    }\n                    else {\n                        emaValues[index] = closeSum / p;\n                    }\n                    ema[figures[index].key] = emaValues[index];\n                }\n            });\n            return ema;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * mtm\n * 公式 MTM（N日）=C－CN\n */\nvar momentum = {\n    name: 'MTM',\n    shortName: 'MTM',\n    calcParams: [12, 6],\n    figures: [\n        { key: 'mtm', title: 'MTM: ', type: 'line' },\n        { key: 'maMtm', title: 'MAMTM: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var mtmSum = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a;\n            var mtm = {};\n            if (i >= params[0]) {\n                var close_1 = kLineData.close;\n                var agoClose = dataList[i - params[0]].close;\n                mtm.mtm = close_1 - agoClose;\n                mtmSum += mtm.mtm;\n                if (i >= params[0] + params[1] - 1) {\n                    mtm.maMtm = mtmSum / params[1];\n                    mtmSum -= ((_a = result[i - (params[1] - 1)].mtm) !== null && _a !== void 0 ? _a : 0);\n                }\n            }\n            result.push(mtm);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * MA 移动平均\n */\nvar movingAverage = {\n    name: 'MA',\n    shortName: 'MA',\n    series: IndicatorSeries.Price,\n    calcParams: [5, 10, 30, 60],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        { key: 'ma1', title: 'MA5: ', type: 'line' },\n        { key: 'ma2', title: 'MA10: ', type: 'line' },\n        { key: 'ma3', title: 'MA30: ', type: 'line' },\n        { key: 'ma4', title: 'MA60: ', type: 'line' }\n    ],\n    regenerateFigures: function (params) { return params.map(function (p, i) { return ({ key: \"ma\".concat(i + 1), title: \"MA\".concat(p, \": \"), type: 'line' }); }); },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSums = [];\n        return dataList.map(function (kLineData, i) {\n            var ma = {};\n            var close = kLineData.close;\n            params.forEach(function (p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    ma[figures[index].key] = closeSums[index] / p;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            return ma;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * MACD：参数快线移动平均、慢线移动平均、移动平均，\n * 默认参数值12、26、9。\n * 公式：⒈首先分别计算出收盘价12日指数平滑移动平均线与26日指数平滑移动平均线，分别记为EMA(12）与EMA(26）。\n * ⒉求这两条指数平滑移动平均线的差，即：DIFF = EMA(SHORT) － EMA(LONG)。\n * ⒊再计算DIFF的M日的平均的指数平滑移动平均线，记为DEA。\n * ⒋最后用DIFF减DEA，得MACD。MACD通常绘制成围绕零轴线波动的柱形图。MACD柱状大于0涨颜色，小于0跌颜色。\n */\nvar movingAverageConvergenceDivergence = {\n    name: 'MACD',\n    shortName: 'MACD',\n    calcParams: [12, 26, 9],\n    figures: [\n        { key: 'dif', title: 'DIF: ', type: 'line' },\n        { key: 'dea', title: 'DEA: ', type: 'line' },\n        {\n            key: 'macd',\n            title: 'MACD: ',\n            type: 'bar',\n            baseValue: 0,\n            styles: function (_a) {\n                var _b, _c;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var prev = data.prev, current = data.current;\n                var prevMacd = (_b = prev === null || prev === void 0 ? void 0 : prev.macd) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var currentMacd = (_c = current === null || current === void 0 ? void 0 : current.macd) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;\n                var color = '';\n                if (currentMacd > 0) {\n                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);\n                }\n                else if (currentMacd < 0) {\n                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);\n                }\n                else {\n                    color = formatValue(indicator.styles, 'bars[0].noChangeColor', (defaultStyles.bars)[0].noChangeColor);\n                }\n                var style = prevMacd < currentMacd ? PolygonType.Stroke : PolygonType.Fill;\n                return { style: style, color: color, borderColor: color };\n            }\n        }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var emaShort = 0;\n        var emaLong = 0;\n        var dif = 0;\n        var difSum = 0;\n        var dea = 0;\n        var maxPeriod = Math.max(params[0], params[1]);\n        return dataList.map(function (kLineData, i) {\n            var macd = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    emaShort = (2 * close + (params[0] - 1) * emaShort) / (params[0] + 1);\n                }\n                else {\n                    emaShort = closeSum / params[0];\n                }\n            }\n            if (i >= params[1] - 1) {\n                if (i > params[1] - 1) {\n                    emaLong = (2 * close + (params[1] - 1) * emaLong) / (params[1] + 1);\n                }\n                else {\n                    emaLong = closeSum / params[1];\n                }\n            }\n            if (i >= maxPeriod - 1) {\n                dif = emaShort - emaLong;\n                macd.dif = dif;\n                difSum += dif;\n                if (i >= maxPeriod + params[2] - 2) {\n                    if (i > maxPeriod + params[2] - 2) {\n                        dea = (dif * 2 + dea * (params[2] - 1)) / (params[2] + 1);\n                    }\n                    else {\n                        dea = difSum / params[2];\n                    }\n                    macd.macd = (dif - dea) * 2;\n                    macd.dea = dea;\n                }\n            }\n            return macd;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * OBV\n * OBV = REF(OBV) + sign * V\n */\nvar onBalanceVolume = {\n    name: 'OBV',\n    shortName: 'OBV',\n    calcParams: [30],\n    figures: [\n        { key: 'obv', title: 'OBV: ', type: 'line' },\n        { key: 'maObv', title: 'MAOBV: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var obvSum = 0;\n        var oldObv = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b, _c, _d;\n            var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            if (kLineData.close < prevKLineData.close) {\n                oldObv -= ((_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0);\n            }\n            else if (kLineData.close > prevKLineData.close) {\n                oldObv += ((_c = kLineData.volume) !== null && _c !== void 0 ? _c : 0);\n            }\n            var obv = { obv: oldObv };\n            obvSum += oldObv;\n            if (i >= params[0] - 1) {\n                obv.maObv = obvSum / params[0];\n                obvSum -= ((_d = result[i - (params[0] - 1)].obv) !== null && _d !== void 0 ? _d : 0);\n            }\n            result.push(obv);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * 价量趋势指标\n * 公式:\n * X = (CLOSE - REF(CLOSE, 1)) / REF(CLOSE, 1) * VOLUME\n * PVT = SUM(X)\n *\n */\nvar priceAndVolumeTrend = {\n    name: 'PVT',\n    shortName: 'PVT',\n    figures: [\n        { key: 'pvt', title: 'PVT: ', type: 'line' }\n    ],\n    calc: function (dataList) {\n        var sum = 0;\n        return dataList.map(function (kLineData, i) {\n            var _a, _b;\n            var pvt = {};\n            var close = kLineData.close;\n            var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 1;\n            var prevClose = ((_b = dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData).close;\n            var x = 0;\n            var total = prevClose * volume;\n            if (total !== 0) {\n                x = (close - prevClose) / total;\n            }\n            sum += x;\n            pvt.pvt = sum;\n            return pvt;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * PSY\n * 公式：PSY=N日内的上涨天数/N×100%。\n */\nvar psychologicalLine = {\n    name: 'PSY',\n    shortName: 'PSY',\n    calcParams: [12, 6],\n    figures: [\n        { key: 'psy', title: 'PSY: ', type: 'line' },\n        { key: 'maPsy', title: 'MAPSY: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var upCount = 0;\n        var psySum = 0;\n        var upList = [];\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b;\n            var psy = {};\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var upFlag = kLineData.close - prevClose > 0 ? 1 : 0;\n            upList.push(upFlag);\n            upCount += upFlag;\n            if (i >= params[0] - 1) {\n                psy.psy = upCount / params[0] * 100;\n                psySum += psy.psy;\n                if (i >= params[0] + params[1] - 2) {\n                    psy.maPsy = psySum / params[1];\n                    psySum -= ((_b = result[i - (params[1] - 1)].psy) !== null && _b !== void 0 ? _b : 0);\n                }\n                upCount -= upList[i - (params[0] - 1)];\n            }\n            result.push(psy);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * 变动率指标\n * 公式：ROC = (CLOSE - REF(CLOSE, N)) / REF(CLOSE, N)\n */\nvar rateOfChange = {\n    name: 'ROC',\n    shortName: 'ROC',\n    calcParams: [12, 6],\n    figures: [\n        { key: 'roc', title: 'ROC: ', type: 'line' },\n        { key: 'maRoc', title: 'MAROC: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var result = [];\n        var rocSum = 0;\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b;\n            var roc = {};\n            if (i >= params[0] - 1) {\n                var close_1 = kLineData.close;\n                var agoClose = ((_a = dataList[i - params[0]]) !== null && _a !== void 0 ? _a : dataList[i - (params[0] - 1)]).close;\n                if (agoClose !== 0) {\n                    roc.roc = (close_1 - agoClose) / agoClose * 100;\n                }\n                else {\n                    roc.roc = 0;\n                }\n                rocSum += roc.roc;\n                if (i >= params[0] - 1 + params[1] - 1) {\n                    roc.maRoc = rocSum / params[1];\n                    rocSum -= ((_b = result[i - (params[1] - 1)].roc) !== null && _b !== void 0 ? _b : 0);\n                }\n            }\n            result.push(roc);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * RSI\n * RSI = SUM(MAX(CLOSE - REF(CLOSE,1),0),N) / SUM(ABS(CLOSE - REF(CLOSE,1)),N) × 100\n */\nvar relativeStrengthIndex = {\n    name: 'RSI',\n    shortName: 'RSI',\n    calcParams: [6, 12, 24],\n    figures: [\n        { key: 'rsi1', title: 'RSI1: ', type: 'line' },\n        { key: 'rsi2', title: 'RSI2: ', type: 'line' },\n        { key: 'rsi3', title: 'RSI3: ', type: 'line' }\n    ],\n    regenerateFigures: function (params) { return params.map(function (_, index) {\n        var num = index + 1;\n        return { key: \"rsi\".concat(num), title: \"RSI\".concat(num, \": \"), type: 'line' };\n    }); },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var sumCloseAs = [];\n        var sumCloseBs = [];\n        return dataList.map(function (kLineData, i) {\n            var _a;\n            var rsi = {};\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var tmp = kLineData.close - prevClose;\n            params.forEach(function (p, index) {\n                var _a, _b, _c;\n                if (tmp > 0) {\n                    sumCloseAs[index] = ((_a = sumCloseAs[index]) !== null && _a !== void 0 ? _a : 0) + tmp;\n                }\n                else {\n                    sumCloseBs[index] = ((_b = sumCloseBs[index]) !== null && _b !== void 0 ? _b : 0) + Math.abs(tmp);\n                }\n                if (i >= p - 1) {\n                    if (sumCloseBs[index] !== 0) {\n                        rsi[figures[index].key] = 100 - (100.0 / (1 + sumCloseAs[index] / sumCloseBs[index]));\n                    }\n                    else {\n                        rsi[figures[index].key] = 0;\n                    }\n                    var agoData = dataList[i - (p - 1)];\n                    var agoPreData = (_c = dataList[i - p]) !== null && _c !== void 0 ? _c : agoData;\n                    var agoTmp = agoData.close - agoPreData.close;\n                    if (agoTmp > 0) {\n                        sumCloseAs[index] -= agoTmp;\n                    }\n                    else {\n                        sumCloseBs[index] -= Math.abs(agoTmp);\n                    }\n                }\n            });\n            return rsi;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * sma\n */\nvar simpleMovingAverage = {\n    name: 'SMA',\n    shortName: 'SMA',\n    series: IndicatorSeries.Price,\n    calcParams: [12, 2],\n    precision: 2,\n    figures: [\n        { key: 'sma', title: 'SMA: ', type: 'line' }\n    ],\n    shouldOhlc: true,\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var smaValue = 0;\n        return dataList.map(function (kLineData, i) {\n            var sma = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    smaValue = (close * params[1] + smaValue * (params[0] - params[1] + 1)) / (params[0] + 1);\n                }\n                else {\n                    smaValue = closeSum / params[0];\n                }\n                sma.sma = smaValue;\n            }\n            return sma;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * KDJ\n *\n * 当日K值=2/3×前一日K值+1/3×当日RSV\n * 当日D值=2/3×前一日D值+1/3×当日K值\n * 若无前一日K 值与D值，则可分别用50来代替。\n * J值=3*当日K值-2*当日D值\n */\nvar stoch = {\n    name: 'KDJ',\n    shortName: 'KDJ',\n    calcParams: [9, 3, 3],\n    figures: [\n        { key: 'k', title: 'K: ', type: 'line' },\n        { key: 'd', title: 'D: ', type: 'line' },\n        { key: 'j', title: 'J: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b, _c, _d;\n            var kdj = {};\n            var close = kLineData.close;\n            if (i >= params[0] - 1) {\n                var lhn = getMaxMin(dataList.slice(i - (params[0] - 1), i + 1), 'high', 'low');\n                var hn = lhn[0];\n                var ln = lhn[1];\n                var hnSubLn = hn - ln;\n                var rsv = (close - ln) / (hnSubLn === 0 ? 1 : hnSubLn) * 100;\n                kdj.k = ((params[1] - 1) * ((_b = (_a = result[i - 1]) === null || _a === void 0 ? void 0 : _a.k) !== null && _b !== void 0 ? _b : 50) + rsv) / params[1];\n                kdj.d = ((params[2] - 1) * ((_d = (_c = result[i - 1]) === null || _c === void 0 ? void 0 : _c.d) !== null && _d !== void 0 ? _d : 50) + kdj.k) / params[2];\n                kdj.j = 3.0 * kdj.k - 2.0 * kdj.d;\n            }\n            result.push(kdj);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar stopAndReverse = {\n    name: 'SAR',\n    shortName: 'SAR',\n    series: IndicatorSeries.Price,\n    calcParams: [2, 2, 20],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        {\n            key: 'sar',\n            title: 'SAR: ',\n            type: 'circle',\n            styles: function (_a) {\n                var _b, _c, _d;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var current = data.current;\n                var sar = (_b = current === null || current === void 0 ? void 0 : current.sar) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var halfHL = (((_c = current === null || current === void 0 ? void 0 : current.high) !== null && _c !== void 0 ? _c : 0) + ((_d = current === null || current === void 0 ? void 0 : current.low) !== null && _d !== void 0 ? _d : 0)) / 2;\n                var color = sar < halfHL\n                    ? formatValue(indicator.styles, 'circles[0].upColor', (defaultStyles.circles)[0].upColor)\n                    : formatValue(indicator.styles, 'circles[0].downColor', (defaultStyles.circles)[0].downColor);\n                return { color: color };\n            }\n        }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var startAf = params[0] / 100;\n        var step = params[1] / 100;\n        var maxAf = params[2] / 100;\n        // 加速因子\n        var af = startAf;\n        // 极值\n        var ep = -100;\n        // 判断是上涨还是下跌  false：下跌\n        var isIncreasing = false;\n        var sar = 0;\n        return dataList.map(function (kLineData, i) {\n            // 上一个周期的sar\n            var preSar = sar;\n            var high = kLineData.high;\n            var low = kLineData.low;\n            if (isIncreasing) {\n                // 上涨\n                if (ep === -100 || ep < high) {\n                    // 重新初始化值\n                    ep = high;\n                    af = Math.min(af + step, maxAf);\n                }\n                sar = preSar + af * (ep - preSar);\n                var lowMin = Math.min(dataList[Math.max(1, i) - 1].low, low);\n                if (sar > kLineData.low) {\n                    sar = ep;\n                    // 重新初始化值\n                    af = startAf;\n                    ep = -100;\n                    isIncreasing = !isIncreasing;\n                }\n                else if (sar > lowMin) {\n                    sar = lowMin;\n                }\n            }\n            else {\n                if (ep === -100 || ep > low) {\n                    // 重新初始化值\n                    ep = low;\n                    af = Math.min(af + step, maxAf);\n                }\n                sar = preSar + af * (ep - preSar);\n                var highMax = Math.max(dataList[Math.max(1, i) - 1].high, high);\n                if (sar < kLineData.high) {\n                    sar = ep;\n                    // 重新初始化值\n                    af = 0;\n                    ep = -100;\n                    isIncreasing = !isIncreasing;\n                }\n                else if (sar < highMax) {\n                    sar = highMax;\n                }\n            }\n            return { high: high, low: low, sar: sar };\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http:*www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * trix\n *\n * TR=收盘价的N日指数移动平均的N日指数移动平均的N日指数移动平均；\n * TRIX=(TR-昨日TR)/昨日TR*100；\n * MATRIX=TRIX的M日简单移动平均；\n * 默认参数N设为12，默认参数M设为9；\n * 默认参数12、9\n * 公式：MTR:=EMA(EMA(EMA(CLOSE,N),N),N)\n * TRIX:(MTR-REF(MTR,1))/REF(MTR,1)*100;\n * TRMA:MA(TRIX,M)\n *\n */\nvar tripleExponentiallySmoothedAverage = {\n    name: 'TRIX',\n    shortName: 'TRIX',\n    calcParams: [12, 9],\n    figures: [\n        { key: 'trix', title: 'TRIX: ', type: 'line' },\n        { key: 'maTrix', title: 'MATRIX: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var ema1 = 0;\n        var ema2 = 0;\n        var oldTr = 0;\n        var ema1Sum = 0;\n        var ema2Sum = 0;\n        var trixSum = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a;\n            var trix = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    ema1 = (2 * close + (params[0] - 1) * ema1) / (params[0] + 1);\n                }\n                else {\n                    ema1 = closeSum / params[0];\n                }\n                ema1Sum += ema1;\n                if (i >= params[0] * 2 - 2) {\n                    if (i > params[0] * 2 - 2) {\n                        ema2 = (2 * ema1 + (params[0] - 1) * ema2) / (params[0] + 1);\n                    }\n                    else {\n                        ema2 = ema1Sum / params[0];\n                    }\n                    ema2Sum += ema2;\n                    if (i >= params[0] * 3 - 3) {\n                        var tr = 0;\n                        var trixValue = 0;\n                        if (i > params[0] * 3 - 3) {\n                            tr = (2 * ema2 + (params[0] - 1) * oldTr) / (params[0] + 1);\n                            trixValue = (tr - oldTr) / oldTr * 100;\n                        }\n                        else {\n                            tr = ema2Sum / params[0];\n                        }\n                        oldTr = tr;\n                        trix.trix = trixValue;\n                        trixSum += trixValue;\n                        if (i >= params[0] * 3 + params[1] - 4) {\n                            trix.maTrix = trixSum / params[1];\n                            trixSum -= ((_a = result[i - (params[1] - 1)].trix) !== null && _a !== void 0 ? _a : 0);\n                        }\n                    }\n                }\n            }\n            result.push(trix);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getVolumeFigure() {\n    return {\n        key: 'volume',\n        title: 'VOLUME: ',\n        type: 'bar',\n        baseValue: 0,\n        styles: function (_a) {\n            var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n            var current = data.current;\n            var color = formatValue(indicator.styles, 'bars[0].noChangeColor', (defaultStyles.bars)[0].noChangeColor);\n            if (isValid(current)) {\n                if (current.close > current.open) {\n                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);\n                }\n                else if (current.close < current.open) {\n                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);\n                }\n            }\n            return { color: color };\n        }\n    };\n}\nvar volume = {\n    name: 'VOL',\n    shortName: 'VOL',\n    series: IndicatorSeries.Volume,\n    calcParams: [5, 10, 20],\n    shouldFormatBigNumber: true,\n    precision: 0,\n    minValue: 0,\n    figures: [\n        { key: 'ma1', title: 'MA5: ', type: 'line' },\n        { key: 'ma2', title: 'MA10: ', type: 'line' },\n        { key: 'ma3', title: 'MA20: ', type: 'line' },\n        getVolumeFigure()\n    ],\n    regenerateFigures: function (params) {\n        var figures = params.map(function (p, i) { return ({ key: \"ma\".concat(i + 1), title: \"MA\".concat(p, \": \"), type: 'line' }); });\n        figures.push(getVolumeFigure());\n        return figures;\n    },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var volSums = [];\n        return dataList.map(function (kLineData, i) {\n            var _a;\n            var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;\n            var vol = { volume: volume, open: kLineData.open, close: kLineData.close };\n            params.forEach(function (p, index) {\n                var _a, _b;\n                volSums[index] = ((_a = volSums[index]) !== null && _a !== void 0 ? _a : 0) + volume;\n                if (i >= p - 1) {\n                    vol[figures[index].key] = volSums[index] / p;\n                    volSums[index] -= ((_b = dataList[i - (p - 1)].volume) !== null && _b !== void 0 ? _b : 0);\n                }\n            });\n            return vol;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * VR\n * VR=（UVS+1/2PVS）/（DVS+1/2PVS）\n * 24天以来凡是股价上涨那一天的成交量都称为AV，将24天内的AV总和相加后称为UVS\n * 24天以来凡是股价下跌那一天的成交量都称为BV，将24天内的BV总和相加后称为DVS\n * 24天以来凡是股价不涨不跌，则那一天的成交量都称为CV，将24天内的CV总和相加后称为PVS\n *\n */\nvar volumeRatio = {\n    name: 'VR',\n    shortName: 'VR',\n    calcParams: [26, 6],\n    figures: [\n        { key: 'vr', title: 'VR: ', type: 'line' },\n        { key: 'maVr', title: 'MAVR: ', type: 'line' }\n    ],\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams;\n        var uvs = 0;\n        var dvs = 0;\n        var pvs = 0;\n        var vrSum = 0;\n        var result = [];\n        dataList.forEach(function (kLineData, i) {\n            var _a, _b, _c, _d, _e;\n            var vr = {};\n            var close = kLineData.close;\n            var preClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var volume = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;\n            if (close > preClose) {\n                uvs += volume;\n            }\n            else if (close < preClose) {\n                dvs += volume;\n            }\n            else {\n                pvs += volume;\n            }\n            if (i >= params[0] - 1) {\n                var halfPvs = pvs / 2;\n                if (dvs + halfPvs === 0) {\n                    vr.vr = 0;\n                }\n                else {\n                    vr.vr = (uvs + halfPvs) / (dvs + halfPvs) * 100;\n                }\n                vrSum += vr.vr;\n                if (i >= params[0] + params[1] - 2) {\n                    vr.maVr = vrSum / params[1];\n                    vrSum -= ((_c = result[i - (params[1] - 1)].vr) !== null && _c !== void 0 ? _c : 0);\n                }\n                var agoData = dataList[i - (params[0] - 1)];\n                var agoPreData = (_d = dataList[i - params[0]]) !== null && _d !== void 0 ? _d : agoData;\n                var agoClose = agoData.close;\n                var agoVolume = (_e = agoData.volume) !== null && _e !== void 0 ? _e : 0;\n                if (agoClose > agoPreData.close) {\n                    uvs -= agoVolume;\n                }\n                else if (agoClose < agoPreData.close) {\n                    dvs -= agoVolume;\n                }\n                else {\n                    pvs -= agoVolume;\n                }\n            }\n            result.push(vr);\n        });\n        return result;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * WR\n * 公式 WR(N) = 100 * [ C - HIGH(N) ] / [ HIGH(N)-LOW(N) ]\n */\nvar williamsR = {\n    name: 'WR',\n    shortName: 'WR',\n    calcParams: [6, 10, 14],\n    figures: [\n        { key: 'wr1', title: 'WR1: ', type: 'line' },\n        { key: 'wr2', title: 'WR2: ', type: 'line' },\n        { key: 'wr3', title: 'WR3: ', type: 'line' }\n    ],\n    regenerateFigures: function (params) { return params.map(function (_, i) { return ({ key: \"wr\".concat(i + 1), title: \"WR\".concat(i + 1, \": \"), type: 'line' }); }); },\n    calc: function (dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        return dataList.map(function (kLineData, i) {\n            var wr = {};\n            var close = kLineData.close;\n            params.forEach(function (param, index) {\n                var p = param - 1;\n                if (i >= p) {\n                    var hln = getMaxMin(dataList.slice(i - p, i + 1), 'high', 'low');\n                    var hn = hln[0];\n                    var ln = hln[1];\n                    var hnSubLn = hn - ln;\n                    wr[figures[index].key] = hnSubLn === 0 ? 0 : (close - hn) / hnSubLn * 100;\n                }\n            });\n            return wr;\n        });\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar indicators = {};\nvar extensions$2 = [\n    averagePrice, awesomeOscillator, bias, bollingerBands, brar,\n    bullAndBearIndex, commodityChannelIndex, currentRatio, differentOfMovingAverage,\n    directionalMovementIndex, easeOfMovementValue, exponentialMovingAverage, momentum,\n    movingAverage, movingAverageConvergenceDivergence, onBalanceVolume, priceAndVolumeTrend,\n    psychologicalLine, rateOfChange, relativeStrengthIndex, simpleMovingAverage,\n    stoch, stopAndReverse, tripleExponentiallySmoothedAverage, volume, volumeRatio, williamsR\n];\nextensions$2.forEach(function (indicator) {\n    indicators[indicator.name] = IndicatorImp.extend(indicator);\n});\nfunction registerIndicator(indicator) {\n    indicators[indicator.name] = IndicatorImp.extend(indicator);\n}\nfunction getIndicatorClass(name) {\n    var _a;\n    return (_a = indicators[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getSupportedIndicators() {\n    return Object.keys(indicators);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar fibonacciLine = {\n    name: 'fibonacciLine',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var _b;\n        var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;\n        var points = overlay.points;\n        if (coordinates.length > 0) {\n            var precision_1 = 0;\n            if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {\n                precision_1 = chart.getPrecision().price;\n            }\n            else {\n                var indicators = chart.getIndicators({ paneId: overlay.paneId });\n                indicators.forEach(function (indicator) {\n                    precision_1 = Math.max(precision_1, indicator.precision);\n                });\n            }\n            var lines_1 = [];\n            var texts_1 = [];\n            var startX_1 = 0;\n            var endX_1 = bounding.width;\n            if (coordinates.length > 1 && isNumber(points[0].value) && isNumber(points[1].value)) {\n                var percents = [1, 0.786, 0.618, 0.5, 0.382, 0.236, 0];\n                var yDif_1 = coordinates[0].y - coordinates[1].y;\n                var valueDif_1 = points[0].value - points[1].value;\n                percents.forEach(function (percent) {\n                    var _a;\n                    var y = coordinates[1].y + yDif_1 * percent;\n                    var value = chart.getDecimalFold().format(chart.getThousandsSeparator().format((((_a = points[1].value) !== null && _a !== void 0 ? _a : 0) + valueDif_1 * percent).toFixed(precision_1)));\n                    lines_1.push({ coordinates: [{ x: startX_1, y: y }, { x: endX_1, y: y }] });\n                    texts_1.push({\n                        x: startX_1,\n                        y: y,\n                        text: \"\".concat(value, \" (\").concat((percent * 100).toFixed(1), \"%)\"),\n                        baseline: 'bottom'\n                    });\n                });\n            }\n            return [\n                {\n                    type: 'line',\n                    attrs: lines_1\n                }, {\n                    type: 'text',\n                    isCheckEvent: false,\n                    attrs: texts_1\n                }\n            ];\n        }\n        return [];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar horizontalRayLine = {\n    name: 'horizontalRayLine',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        var coordinate = { x: 0, y: coordinates[0].y };\n        if (isValid(coordinates[1]) && coordinates[0].x < coordinates[1].x) {\n            coordinate.x = bounding.width;\n        }\n        return [\n            {\n                type: 'line',\n                attrs: { coordinates: [coordinates[0], coordinate] }\n            }\n        ];\n    },\n    performEventPressedMove: function (_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].value = performPoint.value;\n        points[1].value = performPoint.value;\n    },\n    performEventMoveForDrawing: function (_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].value = performPoint.value;\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar horizontalSegment = {\n    name: 'horizontalSegment',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates;\n        var lines = [];\n        if (coordinates.length === 2) {\n            lines.push({ coordinates: coordinates });\n        }\n        return [\n            {\n                type: 'line',\n                attrs: lines\n            }\n        ];\n    },\n    performEventPressedMove: function (_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].value = performPoint.value;\n        points[1].value = performPoint.value;\n    },\n    performEventMoveForDrawing: function (_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].value = performPoint.value;\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar horizontalStraightLine = {\n    name: 'horizontalStraightLine',\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [{\n                type: 'line',\n                attrs: {\n                    coordinates: [\n                        {\n                            x: 0,\n                            y: coordinates[0].y\n                        }, {\n                            x: bounding.width,\n                            y: coordinates[0].y\n                        }\n                    ]\n                }\n            }];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Eventful = /** @class */ (function () {\n    function Eventful() {\n        this._children = [];\n        this._callbacks = new Map();\n    }\n    Eventful.prototype.registerEvent = function (name, callback) {\n        this._callbacks.set(name, callback);\n        return this;\n    };\n    Eventful.prototype.onEvent = function (name, event, other) {\n        var callback = this._callbacks.get(name);\n        if (isValid(callback) && this.checkEventOn(event)) {\n            return callback(event, other);\n        }\n        return false;\n    };\n    Eventful.prototype.checkEventOn = function (event) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var ful = _c.value;\n                if (ful.checkEventOn(event)) {\n                    return true;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return false;\n    };\n    Eventful.prototype.dispatchEvent = function (name, event, other) {\n        var start = this._children.length - 1;\n        if (start > -1) {\n            for (var i = start; i > -1; i--) {\n                if (this._children[i].dispatchEvent(name, event, other)) {\n                    return true;\n                }\n            }\n        }\n        return this.onEvent(name, event, other);\n    };\n    Eventful.prototype.addChild = function (eventful) {\n        this._children.push(eventful);\n        return this;\n    };\n    Eventful.prototype.clear = function () {\n        this._children = [];\n    };\n    return Eventful;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEVIATION = 2;\nvar FigureImp = /** @class */ (function (_super) {\n    __extends(FigureImp, _super);\n    function FigureImp(figure) {\n        var _this = _super.call(this) || this;\n        _this.attrs = figure.attrs;\n        _this.styles = figure.styles;\n        return _this;\n    }\n    FigureImp.prototype.checkEventOn = function (event) {\n        return this.checkEventOnImp(event, this.attrs, this.styles);\n    };\n    FigureImp.prototype.setAttrs = function (attrs) {\n        this.attrs = attrs;\n        return this;\n    };\n    FigureImp.prototype.setStyles = function (styles) {\n        this.styles = styles;\n        return this;\n    };\n    FigureImp.prototype.draw = function (ctx) {\n        this.drawImp(ctx, this.attrs, this.styles);\n    };\n    FigureImp.extend = function (figure) {\n        var Custom = /** @class */ (function (_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            Custom.prototype.checkEventOnImp = function (coordinate, attrs, styles) {\n                return figure.checkEventOn(coordinate, attrs, styles);\n            };\n            Custom.prototype.drawImp = function (ctx, attrs, styles) {\n                figure.draw(ctx, attrs, styles);\n            };\n            return Custom;\n        }(FigureImp));\n        return Custom;\n    };\n    return FigureImp;\n}(Eventful));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction checkCoordinateOnLine(coordinate, attrs) {\n    var e_1, _a;\n    var lines = [];\n    lines = lines.concat(attrs);\n    try {\n        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {\n            var line_1 = lines_1_1.value;\n            var coordinates = line_1.coordinates;\n            if (coordinates.length > 1) {\n                for (var i = 1; i < coordinates.length; i++) {\n                    var prevCoordinate = coordinates[i - 1];\n                    var currentCoordinate = coordinates[i];\n                    if (prevCoordinate.x === currentCoordinate.x) {\n                        if (Math.abs(prevCoordinate.y - coordinate.y) + Math.abs(currentCoordinate.y - coordinate.y) - Math.abs(prevCoordinate.y - currentCoordinate.y) < DEVIATION + DEVIATION &&\n                            Math.abs(coordinate.x - prevCoordinate.x) < DEVIATION) {\n                            return true;\n                        }\n                    }\n                    else {\n                        var kb = getLinearSlopeIntercept(prevCoordinate, currentCoordinate);\n                        var y = getLinearYFromSlopeIntercept(kb, coordinate);\n                        var yDif = Math.abs(y - coordinate.y);\n                        if (Math.abs(prevCoordinate.x - coordinate.x) + Math.abs(currentCoordinate.x - coordinate.x) - Math.abs(prevCoordinate.x - currentCoordinate.x) < DEVIATION + DEVIATION &&\n                            yDif * yDif / (kb[0] * kb[0] + 1) < DEVIATION * DEVIATION) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction getLinearYFromSlopeIntercept(kb, coordinate) {\n    if (kb !== null) {\n        return coordinate.x * kb[0] + kb[1];\n    }\n    return coordinate.y;\n}\n/**\n * 获取点在两点决定的一次函数上的y值\n * @param coordinate1\n * @param coordinate2\n * @param targetCoordinate\n */\nfunction getLinearYFromCoordinates(coordinate1, coordinate2, targetCoordinate) {\n    var kb = getLinearSlopeIntercept(coordinate1, coordinate2);\n    return getLinearYFromSlopeIntercept(kb, targetCoordinate);\n}\nfunction getLinearSlopeIntercept(coordinate1, coordinate2) {\n    var difX = coordinate1.x - coordinate2.x;\n    if (difX !== 0) {\n        var k = (coordinate1.y - coordinate2.y) / difX;\n        var b = coordinate1.y - k * coordinate1.x;\n        return [k, b];\n    }\n    return null;\n}\nfunction lineTo(ctx, coordinates, smooth) {\n    var length = coordinates.length;\n    var smoothParam = isNumber(smooth) ? (smooth > 0 && smooth < 1 ? smooth : 0) : (smooth ? 0.5 : 0);\n    if ((smoothParam > 0) && length > 2) {\n        var cpx0 = coordinates[0].x;\n        var cpy0 = coordinates[0].y;\n        for (var i = 1; i < length - 1; i++) {\n            var prevCoordinate = coordinates[i - 1];\n            var coordinate = coordinates[i];\n            var nextCoordinate = coordinates[i + 1];\n            var dx01 = coordinate.x - prevCoordinate.x;\n            var dy01 = coordinate.y - prevCoordinate.y;\n            var dx12 = nextCoordinate.x - coordinate.x;\n            var dy12 = nextCoordinate.y - coordinate.y;\n            var dx02 = nextCoordinate.x - prevCoordinate.x;\n            var dy02 = nextCoordinate.y - prevCoordinate.y;\n            var prevSegmentLength = Math.sqrt(dx01 * dx01 + dy01 * dy01);\n            var nextSegmentLength = Math.sqrt(dx12 * dx12 + dy12 * dy12);\n            var segmentLengthRatio = nextSegmentLength / (nextSegmentLength + prevSegmentLength);\n            var nextCpx = coordinate.x + dx02 * smoothParam * segmentLengthRatio;\n            var nextCpy = coordinate.y + dy02 * smoothParam * segmentLengthRatio;\n            nextCpx = Math.min(nextCpx, Math.max(nextCoordinate.x, coordinate.x));\n            nextCpy = Math.min(nextCpy, Math.max(nextCoordinate.y, coordinate.y));\n            nextCpx = Math.max(nextCpx, Math.min(nextCoordinate.x, coordinate.x));\n            nextCpy = Math.max(nextCpy, Math.min(nextCoordinate.y, coordinate.y));\n            dx02 = nextCpx - coordinate.x;\n            dy02 = nextCpy - coordinate.y;\n            var cpx1 = coordinate.x - dx02 * prevSegmentLength / nextSegmentLength;\n            var cpy1 = coordinate.y - dy02 * prevSegmentLength / nextSegmentLength;\n            cpx1 = Math.min(cpx1, Math.max(prevCoordinate.x, coordinate.x));\n            cpy1 = Math.min(cpy1, Math.max(prevCoordinate.y, coordinate.y));\n            cpx1 = Math.max(cpx1, Math.min(prevCoordinate.x, coordinate.x));\n            cpy1 = Math.max(cpy1, Math.min(prevCoordinate.y, coordinate.y));\n            dx02 = coordinate.x - cpx1;\n            dy02 = coordinate.y - cpy1;\n            nextCpx = coordinate.x + dx02 * nextSegmentLength / prevSegmentLength;\n            nextCpy = coordinate.y + dy02 * nextSegmentLength / prevSegmentLength;\n            ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, coordinate.x, coordinate.y);\n            cpx0 = nextCpx;\n            cpy0 = nextCpy;\n        }\n        var lastCoordinate = coordinates[length - 1];\n        ctx.bezierCurveTo(cpx0, cpy0, lastCoordinate.x, lastCoordinate.y, lastCoordinate.x, lastCoordinate.y);\n    }\n    else {\n        for (var i = 1; i < length; i++) {\n            ctx.lineTo(coordinates[i].x, coordinates[i].y);\n        }\n    }\n}\nfunction drawLine(ctx, attrs, styles) {\n    var lines = [];\n    lines = lines.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? LineType.Solid : _a, _b = styles.smooth, smooth = _b === void 0 ? false : _b, _c = styles.size, size = _c === void 0 ? 1 : _c, _d = styles.color, color = _d === void 0 ? 'currentColor' : _d, _e = styles.dashedValue, dashedValue = _e === void 0 ? [2, 2] : _e;\n    ctx.lineWidth = size;\n    ctx.strokeStyle = color;\n    if (style === LineType.Dashed) {\n        ctx.setLineDash(dashedValue);\n    }\n    else {\n        ctx.setLineDash([]);\n    }\n    var correction = size % 2 === 1 ? 0.5 : 0;\n    lines.forEach(function (_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length > 1) {\n            if (coordinates.length === 2 &&\n                (coordinates[0].x === coordinates[1].x ||\n                    coordinates[0].y === coordinates[1].y)) {\n                ctx.beginPath();\n                if (coordinates[0].x === coordinates[1].x) {\n                    ctx.moveTo(coordinates[0].x + correction, coordinates[0].y);\n                    ctx.lineTo(coordinates[1].x + correction, coordinates[1].y);\n                }\n                else {\n                    ctx.moveTo(coordinates[0].x, coordinates[0].y + correction);\n                    ctx.lineTo(coordinates[1].x, coordinates[1].y + correction);\n                }\n                ctx.stroke();\n                ctx.closePath();\n            }\n            else {\n                ctx.save();\n                if (size % 2 === 1) {\n                    ctx.translate(0.5, 0.5);\n                }\n                ctx.beginPath();\n                ctx.moveTo(coordinates[0].x, coordinates[0].y);\n                lineTo(ctx, coordinates, smooth);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n    });\n}\nvar line = {\n    name: 'line',\n    checkEventOn: checkCoordinateOnLine,\n    draw: function (ctx, attrs, styles) {\n        drawLine(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * 获取平行线\n * @param coordinates\n * @param bounding\n * @param extendParallelLineCount\n * @returns {Array}\n */\nfunction getParallelLines(coordinates, bounding, extendParallelLineCount) {\n    var count = extendParallelLineCount !== null && extendParallelLineCount !== void 0 ? extendParallelLineCount : 0;\n    var lines = [];\n    if (coordinates.length > 1) {\n        if (coordinates[0].x === coordinates[1].x) {\n            var startY = 0;\n            var endY = bounding.height;\n            lines.push({ coordinates: [{ x: coordinates[0].x, y: startY }, { x: coordinates[0].x, y: endY }] });\n            if (coordinates.length > 2) {\n                lines.push({ coordinates: [{ x: coordinates[2].x, y: startY }, { x: coordinates[2].x, y: endY }] });\n                var distance = coordinates[0].x - coordinates[2].x;\n                for (var i = 0; i < count; i++) {\n                    var d = distance * (i + 1);\n                    lines.push({ coordinates: [{ x: coordinates[0].x + d, y: startY }, { x: coordinates[0].x + d, y: endY }] });\n                }\n            }\n        }\n        else {\n            var startX = 0;\n            var endX = bounding.width;\n            var kb = getLinearSlopeIntercept(coordinates[0], coordinates[1]);\n            var k = kb[0];\n            var b = kb[1];\n            lines.push({ coordinates: [{ x: startX, y: startX * k + b }, { x: endX, y: endX * k + b }] });\n            if (coordinates.length > 2) {\n                var b1 = coordinates[2].y - k * coordinates[2].x;\n                lines.push({ coordinates: [{ x: startX, y: startX * k + b1 }, { x: endX, y: endX * k + b1 }] });\n                var distance = b - b1;\n                for (var i = 0; i < count; i++) {\n                    var b2 = b + distance * (i + 1);\n                    lines.push({ coordinates: [{ x: startX, y: startX * k + b2 }, { x: endX, y: endX * k + b2 }] });\n                }\n            }\n        }\n    }\n    return lines;\n}\nvar parallelStraightLine = {\n    name: 'parallelStraightLine',\n    totalStep: 4,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: 'line',\n                attrs: getParallelLines(coordinates, bounding)\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar priceChannelLine = {\n    name: 'priceChannelLine',\n    totalStep: 4,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: 'line',\n                attrs: getParallelLines(coordinates, bounding, 1)\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar priceLine = {\n    name: 'priceLine',\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var _b;\n        var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;\n        var precision = 0;\n        if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {\n            precision = chart.getPrecision().price;\n        }\n        else {\n            var indicators = chart.getIndicators({ paneId: overlay.paneId });\n            indicators.forEach(function (indicator) {\n                precision = Math.max(precision, indicator.precision);\n            });\n        }\n        var _c = (overlay.points)[0].value, value = _c === void 0 ? 0 : _c;\n        return [\n            {\n                type: 'line',\n                attrs: { coordinates: [coordinates[0], { x: bounding.width, y: coordinates[0].y }] }\n            },\n            {\n                type: 'text',\n                ignoreEvent: true,\n                attrs: {\n                    x: coordinates[0].x,\n                    y: coordinates[0].y,\n                    text: chart.getDecimalFold().format(chart.getThousandsSeparator().format(value.toFixed(precision))),\n                    baseline: 'bottom'\n                }\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getRayLine(coordinates, bounding) {\n    if (coordinates.length > 1) {\n        var coordinate = { x: 0, y: 0 };\n        if (coordinates[0].x === coordinates[1].x && coordinates[0].y !== coordinates[1].y) {\n            if (coordinates[0].y < coordinates[1].y) {\n                coordinate = {\n                    x: coordinates[0].x,\n                    y: bounding.height\n                };\n            }\n            else {\n                coordinate = {\n                    x: coordinates[0].x,\n                    y: 0\n                };\n            }\n        }\n        else if (coordinates[0].x > coordinates[1].x) {\n            coordinate = {\n                x: 0,\n                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })\n            };\n        }\n        else {\n            coordinate = {\n                x: bounding.width,\n                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })\n            };\n        }\n        return { coordinates: [coordinates[0], coordinate] };\n    }\n    return [];\n}\nvar rayLine = {\n    name: 'rayLine',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: 'line',\n                attrs: getRayLine(coordinates, bounding)\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar segment = {\n    name: 'segment',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length === 2) {\n            return [\n                {\n                    type: 'line',\n                    attrs: { coordinates: coordinates }\n                }\n            ];\n        }\n        return [];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar straightLine = {\n    name: 'straightLine',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        if (coordinates.length === 2) {\n            if (coordinates[0].x === coordinates[1].x) {\n                return [\n                    {\n                        type: 'line',\n                        attrs: {\n                            coordinates: [\n                                {\n                                    x: coordinates[0].x,\n                                    y: 0\n                                }, {\n                                    x: coordinates[0].x,\n                                    y: bounding.height\n                                }\n                            ]\n                        }\n                    }\n                ];\n            }\n            return [\n                {\n                    type: 'line',\n                    attrs: {\n                        coordinates: [\n                            {\n                                x: 0,\n                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })\n                            }, {\n                                x: bounding.width,\n                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })\n                            }\n                        ]\n                    }\n                }\n            ];\n        }\n        return [];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar verticalRayLine = {\n    name: 'verticalRayLine',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        if (coordinates.length === 2) {\n            var coordinate = { x: coordinates[0].x, y: 0 };\n            if (coordinates[0].y < coordinates[1].y) {\n                coordinate.y = bounding.height;\n            }\n            return [\n                {\n                    type: 'line',\n                    attrs: { coordinates: [coordinates[0], coordinate] }\n                }\n            ];\n        }\n        return [];\n    },\n    performEventPressedMove: function (_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].timestamp = performPoint.timestamp;\n        points[0].dataIndex = performPoint.dataIndex;\n        points[1].timestamp = performPoint.timestamp;\n        points[1].dataIndex = performPoint.dataIndex;\n    },\n    performEventMoveForDrawing: function (_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].timestamp = performPoint.timestamp;\n            points[0].dataIndex = performPoint.dataIndex;\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar verticalSegment = {\n    name: 'verticalSegment',\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length === 2) {\n            return [\n                {\n                    type: 'line',\n                    attrs: { coordinates: coordinates }\n                }\n            ];\n        }\n        return [];\n    },\n    performEventPressedMove: function (_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].timestamp = performPoint.timestamp;\n        points[0].dataIndex = performPoint.dataIndex;\n        points[1].timestamp = performPoint.timestamp;\n        points[1].dataIndex = performPoint.dataIndex;\n    },\n    performEventMoveForDrawing: function (_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].timestamp = performPoint.timestamp;\n            points[0].dataIndex = performPoint.dataIndex;\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar verticalStraightLine = {\n    name: 'verticalStraightLine',\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function (_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: 'line',\n                attrs: {\n                    coordinates: [\n                        {\n                            x: coordinates[0].x,\n                            y: 0\n                        }, {\n                            x: coordinates[0].x,\n                            y: bounding.height\n                        }\n                    ]\n                }\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar simpleAnnotation = {\n    name: 'simpleAnnotation',\n    totalStep: 2,\n    styles: {\n        line: { style: LineType.Dashed }\n    },\n    createPointFigures: function (_a) {\n        var _b;\n        var overlay = _a.overlay, coordinates = _a.coordinates;\n        var text = '';\n        if (isValid(overlay.extendData)) {\n            if (!isFunction(overlay.extendData)) {\n                text = ((_b = overlay.extendData) !== null && _b !== void 0 ? _b : '');\n            }\n            else {\n                text = (overlay.extendData(overlay));\n            }\n        }\n        var startX = coordinates[0].x;\n        var startY = coordinates[0].y - 6;\n        var lineEndY = startY - 50;\n        var arrowEndY = lineEndY - 5;\n        return [\n            {\n                type: 'line',\n                attrs: { coordinates: [{ x: startX, y: startY }, { x: startX, y: lineEndY }] },\n                ignoreEvent: true\n            },\n            {\n                type: 'polygon',\n                attrs: { coordinates: [{ x: startX, y: lineEndY }, { x: startX - 4, y: arrowEndY }, { x: startX + 4, y: arrowEndY }] },\n                ignoreEvent: true\n            },\n            {\n                type: 'text',\n                attrs: { x: startX, y: arrowEndY, text: text, align: 'center', baseline: 'bottom' },\n                ignoreEvent: true\n            }\n        ];\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar simpleTag = {\n    name: 'simpleTag',\n    totalStep: 2,\n    styles: {\n        line: { style: LineType.Dashed }\n    },\n    createPointFigures: function (_a) {\n        var bounding = _a.bounding, coordinates = _a.coordinates;\n        return ({\n            type: 'line',\n            attrs: {\n                coordinates: [\n                    { x: 0, y: coordinates[0].y },\n                    { x: bounding.width, y: coordinates[0].y }\n                ]\n            },\n            ignoreEvent: true\n        });\n    },\n    createYAxisFigures: function (_a) {\n        var _b, _c;\n        var chart = _a.chart, overlay = _a.overlay, coordinates = _a.coordinates, bounding = _a.bounding, yAxis = _a.yAxis;\n        var isFromZero = (_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isFromZero()) !== null && _b !== void 0 ? _b : false;\n        var textAlign = 'left';\n        var x = 0;\n        if (isFromZero) {\n            textAlign = 'left';\n            x = 0;\n        }\n        else {\n            textAlign = 'right';\n            x = bounding.width;\n        }\n        var text = '';\n        if (isValid(overlay.extendData)) {\n            if (!isFunction(overlay.extendData)) {\n                text = ((_c = overlay.extendData) !== null && _c !== void 0 ? _c : '');\n            }\n            else {\n                text = overlay.extendData(overlay);\n            }\n        }\n        if (!isValid(text) && isNumber(overlay.points[0].value)) {\n            text = formatPrecision(overlay.points[0].value, chart.getPrecision().price);\n        }\n        return { type: 'text', attrs: { x: x, y: coordinates[0].y, text: text, align: textAlign, baseline: 'middle' } };\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar overlays = {};\nvar extensions$1 = [\n    fibonacciLine, horizontalRayLine, horizontalSegment, horizontalStraightLine,\n    parallelStraightLine, priceChannelLine, priceLine, rayLine, segment,\n    straightLine, verticalRayLine, verticalSegment, verticalStraightLine,\n    simpleAnnotation, simpleTag\n];\nextensions$1.forEach(function (template) {\n    overlays[template.name] = OverlayImp.extend(template);\n});\nfunction registerOverlay(template) {\n    overlays[template.name] = OverlayImp.extend(template);\n}\nfunction getOverlayInnerClass(name) {\n    var _a;\n    return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getOverlayClass(name) {\n    var _a;\n    return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getSupportedOverlays() {\n    return Object.keys(overlays);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar light = {\n    grid: {\n        horizontal: {\n            color: '#EDEDED'\n        },\n        vertical: {\n            color: '#EDEDED'\n        }\n    },\n    candle: {\n        priceMark: {\n            high: {\n                color: '#76808F'\n            },\n            low: {\n                color: '#76808F'\n            }\n        },\n        tooltip: {\n            rect: {\n                color: '#FEFEFE',\n                borderColor: '#F2F3F5'\n            },\n            text: {\n                color: '#76808F'\n            }\n        }\n    },\n    indicator: {\n        tooltip: {\n            text: {\n                color: '#76808F'\n            }\n        }\n    },\n    xAxis: {\n        axisLine: {\n            color: '#DDDDDD'\n        },\n        tickText: {\n            color: '#76808F'\n        },\n        tickLine: {\n            color: '#DDDDDD'\n        }\n    },\n    yAxis: {\n        axisLine: {\n            color: '#DDDDDD'\n        },\n        tickText: {\n            color: '#76808F'\n        },\n        tickLine: {\n            color: '#DDDDDD'\n        }\n    },\n    separator: {\n        color: '#DDDDDD'\n    },\n    crosshair: {\n        horizontal: {\n            line: {\n                color: '#76808F'\n            },\n            text: {\n                borderColor: '#686D76',\n                backgroundColor: '#686D76'\n            }\n        },\n        vertical: {\n            line: {\n                color: '#76808F'\n            },\n            text: {\n                borderColor: '#686D76',\n                backgroundColor: '#686D76'\n            }\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar dark = {\n    grid: {\n        horizontal: {\n            color: '#292929'\n        },\n        vertical: {\n            color: '#292929'\n        }\n    },\n    candle: {\n        priceMark: {\n            high: {\n                color: '#929AA5'\n            },\n            low: {\n                color: '#929AA5'\n            }\n        },\n        tooltip: {\n            rect: {\n                color: 'rgba(10, 10, 10, .6)',\n                borderColor: 'rgba(10, 10, 10, .6)'\n            },\n            text: {\n                color: '#929AA5'\n            }\n        }\n    },\n    indicator: {\n        tooltip: {\n            text: {\n                color: '#929AA5'\n            }\n        }\n    },\n    xAxis: {\n        axisLine: {\n            color: '#333333'\n        },\n        tickText: {\n            color: '#929AA5'\n        },\n        tickLine: {\n            color: '#333333'\n        }\n    },\n    yAxis: {\n        axisLine: {\n            color: '#333333'\n        },\n        tickText: {\n            color: '#929AA5'\n        },\n        tickLine: {\n            color: '#333333'\n        }\n    },\n    separator: {\n        color: '#333333'\n    },\n    crosshair: {\n        horizontal: {\n            line: {\n                color: '#929AA5'\n            },\n            text: {\n                borderColor: '#373a40',\n                backgroundColor: '#373a40'\n            }\n        },\n        vertical: {\n            line: {\n                color: '#929AA5'\n            },\n            text: {\n                borderColor: '#373a40',\n                backgroundColor: '#373a40'\n            }\n        }\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar styles = {\n    light: light,\n    dark: dark\n};\nfunction registerStyles(name, ss) {\n    styles[name] = ss;\n}\nfunction getStyles(name) {\n    var _a;\n    return (_a = styles[name]) !== null && _a !== void 0 ? _a : null;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar PANE_MIN_HEIGHT = 30;\nvar PANE_DEFAULT_HEIGHT = 100;\nvar PaneIdConstants = {\n    CANDLE: 'candle_pane',\n    INDICATOR: 'indicator_pane_',\n    X_AXIS: 'x_axis_pane'\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar BarSpaceLimitConstants = {\n    MIN: 1,\n    MAX: 50\n};\nvar DEFAULT_BAR_SPACE = 10;\nvar DEFAULT_OFFSET_RIGHT_DISTANCE = 80;\nvar BAR_GAP_RATIO = 0.2;\nvar SCALE_MULTIPLIER = 10;\nvar DEFAULT_MIN_TIME_SPAN = 15 * 60 * 1000;\nvar StoreImp = /** @class */ (function () {\n    function StoreImp(chart, options) {\n        var _this = this;\n        /**\n         * Styles\n         */\n        this._styles = getDefaultStyles();\n        /**\n         * Custom api\n         */\n        this._customApi = {\n            formatDate: function (timestamp, format) { return formatTimestampToString(_this._dateTimeFormat, timestamp, format); },\n            formatBigNumber: formatBigNumber\n        };\n        /**\n         * Locale\n         */\n        this._locale = 'en-US';\n        /**\n         * Thousands separator\n         */\n        this._thousandsSeparator = {\n            sign: ',',\n            format: function (value) { return formatThousands(value, _this._thousandsSeparator.sign); }\n        };\n        /**\n         * Decimal fold\n         */\n        this._decimalFold = {\n            threshold: 3,\n            format: function (value) { return formatFoldDecimal(value, _this._decimalFold.threshold); }\n        };\n        /**\n         * Price and volume precision\n         */\n        this._precision = { price: 2, volume: 0 };\n        /**\n         * Data source\n         */\n        this._dataList = [];\n        /**\n         * Load more data callback\n         */\n        this._loadMoreDataCallback = null;\n        /**\n         * Is loading data flag\n         */\n        this._loading = true;\n        /**\n        * Whether there are forward and backward more flag\n         */\n        this._loadDataMore = { forward: false, backward: false };\n        /**\n         * Scale enabled flag\n         */\n        this._zoomEnabled = true;\n        /**\n         * Scroll enabled flag\n         */\n        this._scrollEnabled = true;\n        /**\n         * Total space of drawing area\n         */\n        this._totalBarSpace = 0;\n        /**\n         * Space occupied by a single piece of data\n         */\n        this._barSpace = DEFAULT_BAR_SPACE;\n        /**\n         * Distance from the last data to the right of the drawing area\n         */\n        this._offsetRightDistance = DEFAULT_OFFSET_RIGHT_DISTANCE;\n        /**\n         * The number of bar to the right of the drawing area from the last data when scrolling starts\n         */\n        this._startLastBarRightSideDiffBarCount = 0;\n        /**\n         * Scroll limit role\n         */\n        this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */;\n        /**\n         * Scroll to the leftmost and rightmost visible bar\n         */\n        this._minVisibleBarCount = { left: 2, right: 2 };\n        /**\n         * Scroll to the leftmost and rightmost distance\n         */\n        this._maxOffsetDistance = { left: 50, right: 50 };\n        /**\n         * Start and end points of visible area data index\n         */\n        this._visibleRange = getDefaultVisibleRange();\n        this._timeWeightTickMap = new Map();\n        this._timeWeightTickList = [];\n        this._minTimeSpan = { compare: Number.MAX_SAFE_INTEGER, calc: DEFAULT_MIN_TIME_SPAN };\n        /**\n         * Visible data array\n         */\n        this._visibleRangeDataList = [];\n        /**\n         * Visible highest lowest price data\n         */\n        this._visibleRangeHighLowPrice = [\n            { x: 0, price: Number.MIN_SAFE_INTEGER },\n            { x: 0, price: Number.MAX_SAFE_INTEGER }\n        ];\n        /**\n         * Crosshair info\n         */\n        this._crosshair = {};\n        /**\n         * Active tooltip icon info\n         */\n        this._activeTooltipFeatureInfo = null;\n        /**\n         * Actions\n         */\n        this._actions = new Map();\n        /**\n         * Indicator\n         */\n        this._indicators = new Map();\n        /**\n         * Task scheduler\n         */\n        this._taskScheduler = new TaskScheduler();\n        /**\n         * Overlay\n         */\n        this._overlays = new Map();\n        /**\n         * Overlay information in painting\n         */\n        this._progressOverlayInfo = null;\n        /**\n         * Overlay information by the mouse pressed\n         */\n        this._pressedOverlayInfo = {\n            paneId: '',\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */,\n            figureIndex: -1,\n            figure: null\n        };\n        /**\n         * Overlay information by hover\n         */\n        this._hoverOverlayInfo = {\n            paneId: '',\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */,\n            figureIndex: -1,\n            figure: null\n        };\n        /**\n         * Overlay information by the mouse click\n         */\n        this._clickOverlayInfo = {\n            paneId: '',\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */,\n            figureIndex: -1,\n            figure: null\n        };\n        this._chart = chart;\n        this._calcOptimalBarSpace();\n        this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;\n        var _a = options !== null && options !== void 0 ? options : {}, styles = _a.styles, locale = _a.locale, timezone = _a.timezone, customApi = _a.customApi, thousandsSeparator = _a.thousandsSeparator, decimalFold = _a.decimalFold;\n        if (isValid(styles)) {\n            this.setStyles(styles);\n        }\n        if (isString(locale)) {\n            this.setLocale(locale);\n        }\n        this.setTimezone(timezone !== null && timezone !== void 0 ? timezone : '');\n        if (isValid(customApi)) {\n            this.setCustomApi(customApi);\n        }\n        if (isValid(thousandsSeparator)) {\n            this.setThousandsSeparator(thousandsSeparator);\n        }\n        if (isValid(decimalFold)) {\n            this.setDecimalFold(decimalFold);\n        }\n    }\n    StoreImp.prototype.setStyles = function (value) {\n        var _a, _b;\n        var styles = null;\n        if (isString(value)) {\n            styles = getStyles(value);\n        }\n        else {\n            styles = value;\n        }\n        merge(this._styles, styles);\n        // `candle.tooltip.custom` should override\n        if (isArray((_b = (_a = styles === null || styles === void 0 ? void 0 : styles.candle) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.custom)) {\n            this._styles.candle.tooltip.custom = styles.candle.tooltip.custom;\n        }\n    };\n    StoreImp.prototype.getStyles = function () { return this._styles; };\n    StoreImp.prototype.setCustomApi = function (api) {\n        merge(this._customApi, api);\n    };\n    StoreImp.prototype.getCustomApi = function () { return this._customApi; };\n    StoreImp.prototype.setLocale = function (locale) { this._locale = locale; };\n    StoreImp.prototype.getLocale = function () { return this._locale; };\n    StoreImp.prototype.setTimezone = function (timezone) {\n        if (!isValid(this._dateTimeFormat) ||\n            (this.getTimezone() !== timezone)) {\n            var options = {\n                hour12: false,\n                year: 'numeric',\n                month: '2-digit',\n                day: '2-digit',\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit'\n            };\n            if (timezone.length > 0) {\n                options.timeZone = timezone;\n            }\n            var dateTimeFormat = null;\n            try {\n                dateTimeFormat = new Intl.DateTimeFormat('en', options);\n            }\n            catch (e) {\n                logWarn('', '', 'Timezone is error!!!');\n            }\n            if (dateTimeFormat !== null) {\n                this._classifyTimeWeightTicks(this._dataList);\n                this._dateTimeFormat = dateTimeFormat;\n            }\n        }\n    };\n    StoreImp.prototype.getTimezone = function () { return this._dateTimeFormat.resolvedOptions().timeZone; };\n    StoreImp.prototype.getDateTimeFormat = function () {\n        return this._dateTimeFormat;\n    };\n    StoreImp.prototype.setThousandsSeparator = function (thousandsSeparator) {\n        merge(this._thousandsSeparator, thousandsSeparator);\n    };\n    StoreImp.prototype.getThousandsSeparator = function () { return this._thousandsSeparator; };\n    StoreImp.prototype.setDecimalFold = function (decimalFold) { merge(this._decimalFold, decimalFold); };\n    StoreImp.prototype.getDecimalFold = function () { return this._decimalFold; };\n    StoreImp.prototype.getPrecision = function () {\n        return this._precision;\n    };\n    StoreImp.prototype.setPrecision = function (precision) {\n        merge(this._precision, precision);\n        this._synchronizeIndicatorSeriesPrecision();\n    };\n    StoreImp.prototype.getDataList = function () {\n        return this._dataList;\n    };\n    StoreImp.prototype.getVisibleRangeDataList = function () {\n        return this._visibleRangeDataList;\n    };\n    StoreImp.prototype.getVisibleRangeHighLowPrice = function () {\n        return this._visibleRangeHighLowPrice;\n    };\n    StoreImp.prototype.addData = function (data, type, more) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        var success = false;\n        var adjustFlag = false;\n        var dataLengthChange = 0;\n        if (isArray(data)) {\n            dataLengthChange = data.length;\n            switch (type) {\n                case LoadDataType.Init: {\n                    this.clearData();\n                    this._dataList = data;\n                    this._loadDataMore.backward = (_a = more === null || more === void 0 ? void 0 : more.backward) !== null && _a !== void 0 ? _a : false;\n                    this._loadDataMore.forward = (_b = more === null || more === void 0 ? void 0 : more.forward) !== null && _b !== void 0 ? _b : false;\n                    this._classifyTimeWeightTicks(this._dataList);\n                    this.setOffsetRightDistance(this._offsetRightDistance);\n                    adjustFlag = true;\n                    break;\n                }\n                case LoadDataType.Backward: {\n                    this._classifyTimeWeightTicks(data, true);\n                    this._dataList = this._dataList.concat(data);\n                    this._loadDataMore.backward = (_c = more === null || more === void 0 ? void 0 : more.backward) !== null && _c !== void 0 ? _c : false;\n                    adjustFlag = dataLengthChange > 0;\n                    break;\n                }\n                case LoadDataType.Forward: {\n                    this._dataList = data.concat(this._dataList);\n                    this._classifyTimeWeightTicks(this._dataList);\n                    this._loadDataMore.forward = (_d = more === null || more === void 0 ? void 0 : more.forward) !== null && _d !== void 0 ? _d : false;\n                    adjustFlag = dataLengthChange > 0;\n                    break;\n                }\n            }\n            this._loading = false;\n            success = true;\n        }\n        else {\n            var dataCount = this._dataList.length;\n            // Determine where individual data should be added\n            var timestamp = data.timestamp;\n            var lastDataTimestamp = formatValue(this._dataList[dataCount - 1], 'timestamp', 0);\n            if (timestamp > lastDataTimestamp) {\n                this._classifyTimeWeightTicks([data], true);\n                this._dataList.push(data);\n                var lastBarRightSideDiffBarCount = this.getLastBarRightSideDiffBarCount();\n                if (lastBarRightSideDiffBarCount < 0) {\n                    this.setLastBarRightSideDiffBarCount(--lastBarRightSideDiffBarCount);\n                }\n                dataLengthChange = 1;\n                success = true;\n                adjustFlag = true;\n            }\n            else if (timestamp === lastDataTimestamp) {\n                this._dataList[dataCount - 1] = data;\n                success = true;\n                adjustFlag = true;\n            }\n        }\n        if (success) {\n            if (adjustFlag) {\n                this._adjustVisibleRange();\n                this.setCrosshair(this._crosshair, { notInvalidate: true });\n                var filterIndicators = this.getIndicatorsByFilter({});\n                filterIndicators.forEach(function (indicator) {\n                    _this._addIndicatorCalcTask(indicator, type);\n                });\n                this._chart.layout({\n                    measureWidth: true,\n                    update: true,\n                    buildYAxisTick: true\n                });\n            }\n        }\n    };\n    StoreImp.prototype.setLoadMoreDataCallback = function (callback) {\n        this._loadMoreDataCallback = callback;\n    };\n    StoreImp.prototype._calcOptimalBarSpace = function () {\n        var specialBarSpace = 4;\n        var ratio = 1 - BAR_GAP_RATIO * Math.atan(Math.max(specialBarSpace, this._barSpace) - specialBarSpace) / (Math.PI * 0.5);\n        var gapBarSpace = Math.min(Math.floor(this._barSpace * ratio), Math.floor(this._barSpace));\n        if (gapBarSpace % 2 === 0 && gapBarSpace + 2 >= this._barSpace) {\n            --gapBarSpace;\n        }\n        this._gapBarSpace = Math.max(1, gapBarSpace);\n    };\n    StoreImp.prototype._classifyTimeWeightTicks = function (newDataList, isUpdate) {\n        var baseDataIndex = 0;\n        var prevTimestamp = null;\n        if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {\n            baseDataIndex = this._dataList.length;\n            prevTimestamp = this._dataList[baseDataIndex - 1].timestamp;\n        }\n        else {\n            this._timeWeightTickMap.clear();\n            this._minTimeSpan = { compare: Number.MAX_SAFE_INTEGER, calc: DEFAULT_MIN_TIME_SPAN };\n        }\n        classifyTimeWeightTicks(this._timeWeightTickMap, newDataList, this._dateTimeFormat, baseDataIndex, this._minTimeSpan, prevTimestamp);\n        if (this._minTimeSpan.compare !== Number.MAX_SAFE_INTEGER) {\n            this._minTimeSpan.calc = this._minTimeSpan.compare;\n        }\n        this._timeWeightTickList = createTimeWeightTickList(this._timeWeightTickMap, this._barSpace, this._styles.xAxis.tickText);\n    };\n    StoreImp.prototype.getTimeWeightTickList = function () {\n        return this._timeWeightTickList;\n    };\n    StoreImp.prototype._adjustVisibleRange = function () {\n        var _this = this;\n        var _a, _b, _c, _d;\n        var totalBarCount = this._dataList.length;\n        var visibleBarCount = this._totalBarSpace / this._barSpace;\n        var leftMinVisibleBarCount = 0;\n        var rightMinVisibleBarCount = 0;\n        if (this._scrollLimitRole === 1 /* ScrollLimitRole.Distance */) {\n            leftMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.right) / this._barSpace;\n            rightMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.left) / this._barSpace;\n        }\n        else {\n            leftMinVisibleBarCount = this._minVisibleBarCount.left;\n            rightMinVisibleBarCount = this._minVisibleBarCount.right;\n        }\n        leftMinVisibleBarCount = Math.max(0, leftMinVisibleBarCount);\n        rightMinVisibleBarCount = Math.max(0, rightMinVisibleBarCount);\n        var maxRightOffsetBarCount = visibleBarCount - Math.min(leftMinVisibleBarCount, totalBarCount);\n        if (this._lastBarRightSideDiffBarCount > maxRightOffsetBarCount) {\n            this._lastBarRightSideDiffBarCount = maxRightOffsetBarCount;\n        }\n        var minRightOffsetBarCount = -totalBarCount + Math.min(rightMinVisibleBarCount, totalBarCount);\n        if (this._lastBarRightSideDiffBarCount < minRightOffsetBarCount) {\n            this._lastBarRightSideDiffBarCount = minRightOffsetBarCount;\n        }\n        var to = Math.round(this._lastBarRightSideDiffBarCount + totalBarCount + 0.5);\n        var realTo = to;\n        if (to > totalBarCount) {\n            to = totalBarCount;\n        }\n        var from = Math.round(to - visibleBarCount) - 1;\n        if (from < 0) {\n            from = 0;\n        }\n        var realFrom = this._lastBarRightSideDiffBarCount > 0 ? Math.round(totalBarCount + this._lastBarRightSideDiffBarCount - visibleBarCount) - 1 : from;\n        this._visibleRange = { from: from, to: to, realFrom: realFrom, realTo: realTo };\n        this.executeAction(ActionType.OnVisibleRangeChange, this._visibleRange);\n        this._visibleRangeDataList = [];\n        this._visibleRangeHighLowPrice = [\n            { x: 0, price: Number.MIN_SAFE_INTEGER },\n            { x: 0, price: Number.MAX_SAFE_INTEGER }\n        ];\n        for (var i = realFrom; i < realTo; i++) {\n            var kLineData = this._dataList[i];\n            var x = this.dataIndexToCoordinate(i);\n            this._visibleRangeDataList.push({\n                dataIndex: i,\n                x: x,\n                data: {\n                    prev: (_a = this._dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData,\n                    current: kLineData,\n                    next: (_b = this._dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData\n                }\n            });\n            if (isValid(kLineData)) {\n                if (this._visibleRangeHighLowPrice[0].price < kLineData.high) {\n                    this._visibleRangeHighLowPrice[0].price = kLineData.high;\n                    this._visibleRangeHighLowPrice[0].x = x;\n                }\n                if (this._visibleRangeHighLowPrice[1].price > kLineData.low) {\n                    this._visibleRangeHighLowPrice[1].price = kLineData.low;\n                    this._visibleRangeHighLowPrice[1].x = x;\n                }\n            }\n        }\n        // More processing and loading, more loading if there are callback methods and no data is being loaded\n        if (!this._loading && isValid(this._loadMoreDataCallback)) {\n            var params = null;\n            if (from === 0) {\n                if (this._loadDataMore.forward) {\n                    this._loading = true;\n                    params = {\n                        type: LoadDataType.Forward,\n                        data: (_c = this._dataList[0]) !== null && _c !== void 0 ? _c : null,\n                        callback: function (data, more) {\n                            _this.addData(data, LoadDataType.Forward, { forward: more !== null && more !== void 0 ? more : false, backward: more !== null && more !== void 0 ? more : false });\n                        }\n                    };\n                }\n            }\n            else if (to === totalBarCount) {\n                if (this._loadDataMore.backward) {\n                    this._loading = true;\n                    params = {\n                        type: LoadDataType.Backward,\n                        data: (_d = this._dataList[totalBarCount - 1]) !== null && _d !== void 0 ? _d : null,\n                        callback: function (data, more) {\n                            _this.addData(data, LoadDataType.Backward, { forward: more !== null && more !== void 0 ? more : false, backward: more !== null && more !== void 0 ? more : false });\n                        }\n                    };\n                }\n            }\n            if (isValid(params)) {\n                this._loadMoreDataCallback(params);\n            }\n        }\n    };\n    StoreImp.prototype.getBarSpace = function () {\n        return {\n            bar: this._barSpace,\n            halfBar: this._barSpace / 2,\n            gapBar: this._gapBarSpace,\n            halfGapBar: Math.floor(this._gapBarSpace / 2)\n        };\n    };\n    StoreImp.prototype.setBarSpace = function (barSpace, adjustBeforeFunc) {\n        if (barSpace < BarSpaceLimitConstants.MIN || barSpace > BarSpaceLimitConstants.MAX || this._barSpace === barSpace) {\n            return;\n        }\n        this._barSpace = barSpace;\n        this._timeWeightTickList = createTimeWeightTickList(this._timeWeightTickMap, this._barSpace, this._styles.xAxis.tickText);\n        this._calcOptimalBarSpace();\n        adjustBeforeFunc === null || adjustBeforeFunc === void 0 ? void 0 : adjustBeforeFunc();\n        this._adjustVisibleRange();\n        this.setCrosshair(this._crosshair, { notInvalidate: true });\n        this._chart.layout({\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true\n        });\n    };\n    StoreImp.prototype.setTotalBarSpace = function (totalSpace) {\n        if (this._totalBarSpace !== totalSpace) {\n            this._totalBarSpace = totalSpace;\n            this._adjustVisibleRange();\n            this.setCrosshair(this._crosshair, { notInvalidate: true });\n        }\n    };\n    StoreImp.prototype.setOffsetRightDistance = function (distance, isUpdate) {\n        this._offsetRightDistance = this._scrollLimitRole === 1 /* ScrollLimitRole.Distance */ ? Math.min(this._maxOffsetDistance.right, distance) : distance;\n        this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;\n        if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {\n            this._adjustVisibleRange();\n            this.setCrosshair(this._crosshair, { notInvalidate: true });\n            this._chart.layout({\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true\n            });\n        }\n        return this;\n    };\n    StoreImp.prototype.getInitialOffsetRightDistance = function () {\n        return this._offsetRightDistance;\n    };\n    StoreImp.prototype.getOffsetRightDistance = function () {\n        return Math.max(0, this._lastBarRightSideDiffBarCount * this._barSpace);\n    };\n    StoreImp.prototype.getLastBarRightSideDiffBarCount = function () {\n        return this._lastBarRightSideDiffBarCount;\n    };\n    StoreImp.prototype.setLastBarRightSideDiffBarCount = function (barCount) {\n        this._lastBarRightSideDiffBarCount = barCount;\n    };\n    StoreImp.prototype.setMaxOffsetLeftDistance = function (distance) {\n        this._scrollLimitRole = 1 /* ScrollLimitRole.Distance */;\n        this._maxOffsetDistance.left = distance;\n    };\n    StoreImp.prototype.setMaxOffsetRightDistance = function (distance) {\n        this._scrollLimitRole = 1 /* ScrollLimitRole.Distance */;\n        this._maxOffsetDistance.right = distance;\n    };\n    StoreImp.prototype.setLeftMinVisibleBarCount = function (barCount) {\n        this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */;\n        this._minVisibleBarCount.left = barCount;\n    };\n    StoreImp.prototype.setRightMinVisibleBarCount = function (barCount) {\n        this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */;\n        this._minVisibleBarCount.right = barCount;\n    };\n    StoreImp.prototype.getVisibleRange = function () {\n        return this._visibleRange;\n    };\n    StoreImp.prototype.startScroll = function () {\n        this._startLastBarRightSideDiffBarCount = this._lastBarRightSideDiffBarCount;\n    };\n    StoreImp.prototype.scroll = function (distance) {\n        if (!this._scrollEnabled) {\n            return;\n        }\n        var distanceBarCount = distance / this._barSpace;\n        var prevLastBarRightSideDistance = this._lastBarRightSideDiffBarCount * this._barSpace;\n        this._lastBarRightSideDiffBarCount = this._startLastBarRightSideDiffBarCount - distanceBarCount;\n        this._adjustVisibleRange();\n        this.setCrosshair(this._crosshair, { notInvalidate: true });\n        this._chart.layout({\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true\n        });\n        var realDistance = Math.round(prevLastBarRightSideDistance - this._lastBarRightSideDiffBarCount * this._barSpace);\n        if (realDistance !== 0) {\n            this.executeAction(ActionType.OnScroll, { distance: realDistance });\n        }\n    };\n    StoreImp.prototype.getDataByDataIndex = function (dataIndex) {\n        var _a;\n        return (_a = this._dataList[dataIndex]) !== null && _a !== void 0 ? _a : null;\n    };\n    StoreImp.prototype.coordinateToFloatIndex = function (x) {\n        var dataCount = this._dataList.length;\n        var deltaFromRight = (this._totalBarSpace - x) / this._barSpace;\n        var index = dataCount + this._lastBarRightSideDiffBarCount - deltaFromRight;\n        return Math.round(index * 1000000) / 1000000;\n    };\n    StoreImp.prototype.dataIndexToTimestamp = function (dataIndex) {\n        var length = this._dataList.length;\n        if (length === 0) {\n            return null;\n        }\n        var data = this.getDataByDataIndex(dataIndex);\n        if (isValid(data)) {\n            return data.timestamp;\n        }\n        var lastIndex = length - 1;\n        if (dataIndex > lastIndex) {\n            return this._dataList[lastIndex].timestamp + this._minTimeSpan.calc * (dataIndex - lastIndex);\n        }\n        if (dataIndex < 0) {\n            return this._dataList[0].timestamp - this._minTimeSpan.calc * Math.abs(dataIndex);\n        }\n        return null;\n    };\n    StoreImp.prototype.timestampToDataIndex = function (timestamp) {\n        var length = this._dataList.length;\n        if (length === 0) {\n            return 0;\n        }\n        var lastIndex = length - 1;\n        var lastTimestamp = this._dataList[lastIndex].timestamp;\n        if (timestamp > lastTimestamp) {\n            return lastIndex + Math.floor((timestamp - lastTimestamp) / this._minTimeSpan.calc);\n        }\n        var firstTimestamp = this._dataList[0].timestamp;\n        if (timestamp < firstTimestamp) {\n            return Math.floor((timestamp - firstTimestamp) / this._minTimeSpan.calc);\n        }\n        return binarySearchNearest(this._dataList, 'timestamp', timestamp);\n    };\n    StoreImp.prototype.dataIndexToCoordinate = function (dataIndex) {\n        var dataCount = this._dataList.length;\n        var deltaFromRight = dataCount + this._lastBarRightSideDiffBarCount - dataIndex;\n        return Math.floor(this._totalBarSpace - (deltaFromRight - 0.5) * this._barSpace + 0.5);\n    };\n    StoreImp.prototype.coordinateToDataIndex = function (x) {\n        return Math.ceil(this.coordinateToFloatIndex(x)) - 1;\n    };\n    StoreImp.prototype.zoom = function (scale, coordinate) {\n        var _this = this;\n        var _a;\n        if (!this._zoomEnabled) {\n            return;\n        }\n        var zoomCoordinate = coordinate !== null && coordinate !== void 0 ? coordinate : null;\n        if (!isNumber(zoomCoordinate === null || zoomCoordinate === void 0 ? void 0 : zoomCoordinate.x)) {\n            zoomCoordinate = { x: (_a = this._crosshair.x) !== null && _a !== void 0 ? _a : this._totalBarSpace / 2 };\n        }\n        var x = zoomCoordinate.x;\n        var floatIndex = this.coordinateToFloatIndex(x);\n        var prevBarSpace = this._barSpace;\n        var barSpace = this._barSpace + scale * (this._barSpace / SCALE_MULTIPLIER);\n        this.setBarSpace(barSpace, function () {\n            _this._lastBarRightSideDiffBarCount += (floatIndex - _this.coordinateToFloatIndex(x));\n        });\n        var realScale = this._barSpace / prevBarSpace;\n        if (realScale !== 1) {\n            this.executeAction(ActionType.OnZoom, { scale: realScale });\n        }\n    };\n    StoreImp.prototype.setZoomEnabled = function (enabled) {\n        this._zoomEnabled = enabled;\n    };\n    StoreImp.prototype.isZoomEnabled = function () {\n        return this._zoomEnabled;\n    };\n    StoreImp.prototype.setScrollEnabled = function (enabled) {\n        this._scrollEnabled = enabled;\n    };\n    StoreImp.prototype.isScrollEnabled = function () {\n        return this._scrollEnabled;\n    };\n    StoreImp.prototype.setCrosshair = function (crosshair, options) {\n        var _a;\n        var _b = options !== null && options !== void 0 ? options : {}, notInvalidate = _b.notInvalidate, notExecuteAction = _b.notExecuteAction, forceInvalidate = _b.forceInvalidate;\n        var cr = crosshair !== null && crosshair !== void 0 ? crosshair : {};\n        var realDataIndex = 0;\n        var dataIndex = 0;\n        if (isNumber(cr.x)) {\n            realDataIndex = this.coordinateToDataIndex(cr.x);\n            if (realDataIndex < 0) {\n                dataIndex = 0;\n            }\n            else if (realDataIndex > this._dataList.length - 1) {\n                dataIndex = this._dataList.length - 1;\n            }\n            else {\n                dataIndex = realDataIndex;\n            }\n        }\n        else {\n            realDataIndex = this._dataList.length - 1;\n            dataIndex = realDataIndex;\n        }\n        var kLineData = this._dataList[dataIndex];\n        var realX = this.dataIndexToCoordinate(realDataIndex);\n        var prevCrosshair = { x: this._crosshair.x, y: this._crosshair.y, paneId: this._crosshair.paneId };\n        this._crosshair = __assign(__assign({}, cr), { realX: realX, kLineData: kLineData, realDataIndex: realDataIndex, dataIndex: dataIndex, timestamp: (_a = this.dataIndexToTimestamp(realDataIndex)) !== null && _a !== void 0 ? _a : undefined });\n        if (prevCrosshair.x !== cr.x ||\n            prevCrosshair.y !== cr.y ||\n            prevCrosshair.paneId !== cr.paneId ||\n            (forceInvalidate !== null && forceInvalidate !== void 0 ? forceInvalidate : false)) {\n            if (isValid(kLineData) && !(notExecuteAction !== null && notExecuteAction !== void 0 ? notExecuteAction : false)) {\n                this._chart.crosshairChange(this._crosshair);\n            }\n            if (!(notInvalidate !== null && notInvalidate !== void 0 ? notInvalidate : false)) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n            }\n        }\n    };\n    /**\n     * 获取crosshair信息\n     * @returns\n     */\n    StoreImp.prototype.getCrosshair = function () {\n        return this._crosshair;\n    };\n    StoreImp.prototype.setActiveTooltipFeatureInfo = function (info) {\n        this._activeTooltipFeatureInfo = info !== null && info !== void 0 ? info : null;\n    };\n    StoreImp.prototype.getActiveTooltipFeatureInfo = function () {\n        return this._activeTooltipFeatureInfo;\n    };\n    StoreImp.prototype.executeAction = function (type, data) {\n        var _a;\n        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.execute(data);\n    };\n    StoreImp.prototype.subscribeAction = function (type, callback) {\n        var _a;\n        if (!this._actions.has(type)) {\n            this._actions.set(type, new Action());\n        }\n        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.subscribe(callback);\n    };\n    StoreImp.prototype.unsubscribeAction = function (type, callback) {\n        var action = this._actions.get(type);\n        if (isValid(action)) {\n            action.unsubscribe(callback);\n            if (action.isEmpty()) {\n                this._actions.delete(type);\n            }\n        }\n    };\n    StoreImp.prototype.hasAction = function (type) {\n        var action = this._actions.get(type);\n        return isValid(action) && !action.isEmpty();\n    };\n    StoreImp.prototype._sortIndicators = function (paneId) {\n        var _a;\n        if (isString(paneId)) {\n            (_a = this._indicators.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function (i1, i2) { return i1.zLevel - i2.zLevel; });\n        }\n        else {\n            this._indicators.forEach(function (paneIndicators) {\n                paneIndicators.sort(function (i1, i2) { return i1.zLevel - i2.zLevel; });\n            });\n        }\n    };\n    StoreImp.prototype._addIndicatorCalcTask = function (indicator, loadDataType) {\n        var _this = this;\n        this._taskScheduler.addTask({\n            id: generateTaskId(indicator.id),\n            handler: function () {\n                var _a;\n                (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                    state: IndicatorDataState.Loading,\n                    type: loadDataType,\n                    indicator: indicator\n                });\n                indicator.calcImp(_this._dataList).then(function (result) {\n                    var _a;\n                    if (result) {\n                        _this._chart.layout({\n                            measureWidth: true,\n                            update: true,\n                            buildYAxisTick: true\n                        });\n                        (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                            state: IndicatorDataState.Ready,\n                            type: loadDataType,\n                            indicator: indicator\n                        });\n                    }\n                }).catch(function () {\n                    var _a;\n                    (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                        state: IndicatorDataState.Error,\n                        type: loadDataType,\n                        indicator: indicator\n                    });\n                });\n            }\n        });\n    };\n    StoreImp.prototype.addIndicator = function (create, paneId, isStack) {\n        var name = create.name;\n        var filterIndicators = this.getIndicatorsByFilter(create);\n        if (filterIndicators.length > 0) {\n            return false;\n        }\n        var paneIndicators = this.getIndicatorsByPaneId(paneId);\n        var IndicatorClazz = getIndicatorClass(name);\n        var indicator = new IndicatorClazz();\n        this._synchronizeIndicatorSeriesPrecision(indicator);\n        indicator.paneId = paneId;\n        indicator.override(create);\n        if (!isStack) {\n            this.removeIndicator({ paneId: paneId });\n            paneIndicators = [];\n        }\n        paneIndicators.push(indicator);\n        this._indicators.set(paneId, paneIndicators);\n        this._sortIndicators(paneId);\n        this._addIndicatorCalcTask(indicator, LoadDataType.Init);\n        return true;\n    };\n    StoreImp.prototype.getIndicatorsByPaneId = function (paneId) {\n        var _a;\n        return (_a = this._indicators.get(paneId)) !== null && _a !== void 0 ? _a : [];\n    };\n    StoreImp.prototype.getIndicatorsByFilter = function (filter) {\n        var paneId = filter.paneId, name = filter.name, id = filter.id;\n        var match = function (indicator) {\n            if (isValid(id)) {\n                return indicator.id === id;\n            }\n            return !isValid(name) || indicator.name === name;\n        };\n        var indicators = [];\n        if (isValid(paneId)) {\n            indicators = indicators.concat(this.getIndicatorsByPaneId(paneId).filter(match));\n        }\n        else {\n            this._indicators.forEach(function (paneIndicators) {\n                indicators = indicators.concat(paneIndicators.filter(match));\n            });\n        }\n        return indicators;\n    };\n    StoreImp.prototype.removeIndicator = function (filter) {\n        var _this = this;\n        var removed = false;\n        var filterIndicators = this.getIndicatorsByFilter(filter);\n        filterIndicators.forEach(function (indicator) {\n            var paneIndicators = _this.getIndicatorsByPaneId(indicator.paneId);\n            var index = paneIndicators.findIndex(function (ins) { return ins.id === indicator.id; });\n            if (index > -1) {\n                _this._taskScheduler.removeTask(generateTaskId(indicator.id));\n                paneIndicators.splice(index, 1);\n                removed = true;\n            }\n            if (paneIndicators.length === 0) {\n                _this._indicators.delete(indicator.paneId);\n            }\n        });\n        return removed;\n    };\n    StoreImp.prototype.hasIndicators = function (paneId) {\n        return this._indicators.has(paneId);\n    };\n    StoreImp.prototype._synchronizeIndicatorSeriesPrecision = function (indicator) {\n        var _a = this._precision, pricePrecision = _a.price, volumePrecision = _a.volume;\n        var synchronize = function (indicator) {\n            switch (indicator.series) {\n                case IndicatorSeries.Price: {\n                    indicator.setSeriesPrecision(pricePrecision);\n                    break;\n                }\n                case IndicatorSeries.Volume: {\n                    indicator.setSeriesPrecision(volumePrecision);\n                    break;\n                }\n            }\n        };\n        if (isValid(indicator)) {\n            synchronize(indicator);\n        }\n        else {\n            this._indicators.forEach(function (paneIndicators) {\n                paneIndicators.forEach(function (indicator) {\n                    synchronize(indicator);\n                });\n            });\n        }\n    };\n    StoreImp.prototype.overrideIndicator = function (override) {\n        var _this = this;\n        var updateFlag = false;\n        var sortFlag = false;\n        var filterIndicators = this.getIndicatorsByFilter(override);\n        filterIndicators.forEach(function (indicator) {\n            indicator.override(override);\n            var _a = indicator.shouldUpdateImp(), calc = _a.calc, draw = _a.draw, sort = _a.sort;\n            if (sort) {\n                sortFlag = true;\n            }\n            if (calc) {\n                _this._addIndicatorCalcTask(indicator, LoadDataType.Update);\n            }\n            else {\n                if (draw) {\n                    updateFlag = true;\n                }\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (sortFlag) {\n            this._sortIndicators();\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (updateFlag) {\n            this._chart.layout({ update: true });\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.getOverlaysByFilter = function (filter) {\n        var _a;\n        var id = filter.id, groupId = filter.groupId, paneId = filter.paneId, name = filter.name;\n        var match = function (overlay) {\n            if (isValid(id)) {\n                return overlay.id === id;\n            }\n            else {\n                if (isValid(groupId)) {\n                    return overlay.groupId === groupId && (!isValid(name) || overlay.name === name);\n                }\n            }\n            return !isValid(name) || overlay.name === name;\n        };\n        var overlays = [];\n        if (isValid(paneId)) {\n            overlays = overlays.concat(this.getOverlaysByPaneId(paneId).filter(match));\n        }\n        else {\n            this._overlays.forEach(function (paneOverlays) {\n                overlays = overlays.concat(paneOverlays.filter(match));\n            });\n        }\n        var progressOverlay = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay;\n        if (isValid(progressOverlay) && match(progressOverlay)) {\n            overlays.push(progressOverlay);\n        }\n        return overlays;\n    };\n    StoreImp.prototype.getOverlaysByPaneId = function (paneId) {\n        var _a;\n        if (!isString(paneId)) {\n            var overlays_1 = [];\n            this._overlays.forEach(function (paneOverlays) {\n                overlays_1 = overlays_1.concat(paneOverlays);\n            });\n            return overlays_1;\n        }\n        return (_a = this._overlays.get(paneId)) !== null && _a !== void 0 ? _a : [];\n    };\n    StoreImp.prototype._sortOverlays = function (paneId) {\n        var _a;\n        if (isString(paneId)) {\n            (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function (o1, o2) { return o1.zLevel - o2.zLevel; });\n        }\n        else {\n            this._overlays.forEach(function (paneOverlays) {\n                paneOverlays.sort(function (o1, o2) { return o1.zLevel - o2.zLevel; });\n            });\n        }\n    };\n    StoreImp.prototype.addOverlays = function (os, appointPaneFlags) {\n        var _this = this;\n        var updatePaneIds = [];\n        var ids = os.map(function (create, index) {\n            var e_1, _a;\n            var _b, _c, _d, _e, _f, _g;\n            if (isValid(create.id)) {\n                var findOverlay = null;\n                try {\n                    for (var _h = __values(_this._overlays), _j = _h.next(); !_j.done; _j = _h.next()) {\n                        var _k = __read(_j.value, 2), overlays = _k[1];\n                        var overlay = overlays.find(function (o) { return o.id === create.id; });\n                        if (isValid(overlay)) {\n                            findOverlay = overlay;\n                            break;\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                if (isValid(findOverlay)) {\n                    return create.id;\n                }\n            }\n            var OverlayClazz = getOverlayInnerClass(create.name);\n            if (isValid(OverlayClazz)) {\n                var id = (_b = create.id) !== null && _b !== void 0 ? _b : createId(OVERLAY_ID_PREFIX);\n                var overlay = new OverlayClazz();\n                var paneId = (_c = create.paneId) !== null && _c !== void 0 ? _c : PaneIdConstants.CANDLE;\n                create.id = id;\n                (_d = create.groupId) !== null && _d !== void 0 ? _d : (create.groupId = id);\n                var zLevel = _this.getOverlaysByPaneId(paneId).length;\n                (_e = create.zLevel) !== null && _e !== void 0 ? _e : (create.zLevel = zLevel);\n                overlay.override(create);\n                if (!updatePaneIds.includes(paneId)) {\n                    updatePaneIds.push(paneId);\n                }\n                if (overlay.isDrawing()) {\n                    _this._progressOverlayInfo = { paneId: paneId, overlay: overlay, appointPaneFlag: appointPaneFlags[index] };\n                }\n                else {\n                    if (!_this._overlays.has(paneId)) {\n                        _this._overlays.set(paneId, []);\n                    }\n                    (_f = _this._overlays.get(paneId)) === null || _f === void 0 ? void 0 : _f.push(overlay);\n                }\n                if (overlay.isStart()) {\n                    (_g = overlay.onDrawStart) === null || _g === void 0 ? void 0 : _g.call(overlay, ({ overlay: overlay, chart: _this._chart }));\n                }\n                return id;\n            }\n            return null;\n        });\n        if (updatePaneIds.length > 0) {\n            this._sortOverlays();\n            updatePaneIds.forEach(function (paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */, paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */, PaneIdConstants.X_AXIS);\n        }\n        return ids;\n    };\n    StoreImp.prototype.getProgressOverlayInfo = function () {\n        return this._progressOverlayInfo;\n    };\n    StoreImp.prototype.progressOverlayComplete = function () {\n        var _a;\n        if (this._progressOverlayInfo !== null) {\n            var _b = this._progressOverlayInfo, overlay = _b.overlay, paneId = _b.paneId;\n            if (!overlay.isDrawing()) {\n                if (!this._overlays.has(paneId)) {\n                    this._overlays.set(paneId, []);\n                }\n                (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.push(overlay);\n                this._sortOverlays(paneId);\n                this._progressOverlayInfo = null;\n            }\n        }\n    };\n    StoreImp.prototype.updateProgressOverlayInfo = function (paneId, appointPaneFlag) {\n        if (this._progressOverlayInfo !== null) {\n            if (isBoolean(appointPaneFlag) && appointPaneFlag) {\n                this._progressOverlayInfo.appointPaneFlag = appointPaneFlag;\n            }\n            this._progressOverlayInfo.paneId = paneId;\n            this._progressOverlayInfo.overlay.override({ paneId: paneId });\n        }\n    };\n    StoreImp.prototype.overrideOverlay = function (override) {\n        var _this = this;\n        var sortFlag = false;\n        var updatePaneIds = [];\n        var filterOverlays = this.getOverlaysByFilter(override);\n        filterOverlays.forEach(function (overlay) {\n            overlay.override(override);\n            var _a = overlay.shouldUpdate(), sort = _a.sort, draw = _a.draw;\n            if (sort) {\n                sortFlag = true;\n            }\n            if (sort || draw) {\n                if (!updatePaneIds.includes(overlay.paneId)) {\n                    updatePaneIds.push(overlay.paneId);\n                }\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (sortFlag) {\n            this._sortOverlays();\n        }\n        if (updatePaneIds.length > 0) {\n            updatePaneIds.forEach(function (paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */, paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */, PaneIdConstants.X_AXIS);\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.removeOverlay = function (filter) {\n        var _this = this;\n        var updatePaneIds = [];\n        var filterOverlays = this.getOverlaysByFilter(filter);\n        filterOverlays.forEach(function (overlay) {\n            var _a;\n            var paneId = overlay.paneId;\n            var paneOverlays = _this.getOverlaysByPaneId(overlay.paneId);\n            (_a = overlay.onRemoved) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay: overlay, chart: _this._chart });\n            if (!updatePaneIds.includes(paneId)) {\n                updatePaneIds.push(paneId);\n            }\n            if (overlay.isDrawing()) {\n                _this._progressOverlayInfo = null;\n            }\n            else {\n                var index = paneOverlays.findIndex(function (o) { return o.id === overlay.id; });\n                if (index > -1) {\n                    paneOverlays.splice(index, 1);\n                }\n            }\n            if (paneOverlays.length === 0) {\n                _this._overlays.delete(paneId);\n            }\n        });\n        if (updatePaneIds.length > 0) {\n            updatePaneIds.forEach(function (paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */, paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */, PaneIdConstants.X_AXIS);\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.setPressedOverlayInfo = function (info) {\n        this._pressedOverlayInfo = info;\n    };\n    StoreImp.prototype.getPressedOverlayInfo = function () {\n        return this._pressedOverlayInfo;\n    };\n    StoreImp.prototype.setHoverOverlayInfo = function (info, event) {\n        var _a;\n        var _b = this._hoverOverlayInfo, overlay = _b.overlay, figureType = _b.figureType, figureIndex = _b.figureIndex, figure = _b.figure;\n        var infoOverlay = info.overlay;\n        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) ||\n            figureType !== info.figureType ||\n            figureIndex !== info.figureIndex) {\n            this._hoverOverlayInfo = info;\n            if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {\n                var ignoreUpdateFlag = false;\n                var sortFlag = false;\n                if (overlay !== null) {\n                    overlay.override({ zLevel: overlay.getPrevZLevel() });\n                    sortFlag = true;\n                    if (isFunction(overlay.onMouseLeave) && checkOverlayFigureEvent('onMouseLeave', figure)) {\n                        overlay.onMouseLeave(__assign({ chart: this._chart, overlay: overlay, figure: figure !== null && figure !== void 0 ? figure : undefined }, event));\n                        ignoreUpdateFlag = true;\n                    }\n                }\n                if (infoOverlay !== null) {\n                    infoOverlay.setPrevZLevel(infoOverlay.zLevel);\n                    infoOverlay.override({ zLevel: Number.MAX_SAFE_INTEGER });\n                    sortFlag = true;\n                    if (isFunction(infoOverlay.onMouseEnter) && checkOverlayFigureEvent('onMouseEnter', info.figure)) {\n                        infoOverlay.onMouseEnter(__assign({ chart: this._chart, overlay: infoOverlay, figure: (_a = info.figure) !== null && _a !== void 0 ? _a : undefined }, event));\n                        ignoreUpdateFlag = true;\n                    }\n                }\n                if (sortFlag) {\n                    this._sortOverlays();\n                }\n                if (!ignoreUpdateFlag) {\n                    this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n                }\n            }\n        }\n    };\n    StoreImp.prototype.getHoverOverlayInfo = function () {\n        return this._hoverOverlayInfo;\n    };\n    StoreImp.prototype.setClickOverlayInfo = function (info, event) {\n        var _a, _b, _c, _d, _e, _f;\n        var _g = this._clickOverlayInfo, paneId = _g.paneId, overlay = _g.overlay, figureType = _g.figureType, figure = _g.figure, figureIndex = _g.figureIndex;\n        var infoOverlay = info.overlay;\n        if ((!((_a = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.isDrawing()) !== null && _a !== void 0 ? _a : false)) && checkOverlayFigureEvent('onClick', info.figure)) {\n            (_b = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.onClick) === null || _b === void 0 ? void 0 : _b.call(infoOverlay, __assign({ chart: this._chart, overlay: infoOverlay, figure: (_c = info.figure) !== null && _c !== void 0 ? _c : undefined }, event));\n        }\n        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {\n            this._clickOverlayInfo = info;\n            if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {\n                if (checkOverlayFigureEvent('onDeselected', figure)) {\n                    (_d = overlay === null || overlay === void 0 ? void 0 : overlay.onDeselected) === null || _d === void 0 ? void 0 : _d.call(overlay, __assign({ chart: this._chart, overlay: overlay, figure: figure !== null && figure !== void 0 ? figure : undefined }, event));\n                }\n                if (checkOverlayFigureEvent('onSelected', info.figure)) {\n                    (_e = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.onSelected) === null || _e === void 0 ? void 0 : _e.call(infoOverlay, __assign({ chart: this._chart, overlay: infoOverlay, figure: (_f = info.figure) !== null && _f !== void 0 ? _f : undefined }, event));\n                }\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */, info.paneId);\n                if (paneId !== info.paneId) {\n                    this._chart.updatePane(1 /* UpdateLevel.Overlay */, paneId);\n                }\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */, PaneIdConstants.X_AXIS);\n            }\n        }\n    };\n    StoreImp.prototype.getClickOverlayInfo = function () {\n        return this._clickOverlayInfo;\n    };\n    StoreImp.prototype.isOverlayEmpty = function () {\n        return this._overlays.size === 0 && this._progressOverlayInfo === null;\n    };\n    StoreImp.prototype.isOverlayDrawing = function () {\n        var _a, _b;\n        return (_b = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay.isDrawing()) !== null && _b !== void 0 ? _b : false;\n    };\n    StoreImp.prototype.clearData = function () {\n        this._loadDataMore.backward = false;\n        this._loadDataMore.forward = false;\n        this._loading = true;\n        this._dataList = [];\n        this._visibleRangeDataList = [];\n        this._visibleRangeHighLowPrice = [\n            { x: 0, price: Number.MIN_SAFE_INTEGER },\n            { x: 0, price: Number.MAX_SAFE_INTEGER }\n        ];\n        this._visibleRange = getDefaultVisibleRange();\n        this._timeWeightTickMap.clear();\n        this._timeWeightTickList = [];\n        this._crosshair = {};\n        this._activeTooltipFeatureInfo = null;\n    };\n    StoreImp.prototype.getChart = function () {\n        return this._chart;\n    };\n    return StoreImp;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar WidgetNameConstants = {\n    MAIN: 'main',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    SEPARATOR: 'separator'\n};\nvar REAL_SEPARATOR_HEIGHT = 7;\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isSupportedDevicePixelContentBox() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, new Promise(function (resolve) {\n                        var ro = new ResizeObserver(function (entries) {\n                            resolve(entries.every(function (entry) { return 'devicePixelContentBoxSize' in entry; }));\n                            ro.disconnect();\n                        });\n                        ro.observe(document.body, { box: 'device-pixel-content-box' });\n                    }).catch(function () { return false; })];\n                case 1: \n                // eslint-disable-next-line promise/avoid-new -- ignore\n                return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\nvar Canvas = /** @class */ (function () {\n    function Canvas(style, listener) {\n        var _this = this;\n        this._supportedDevicePixelContentBox = false;\n        this._width = 0;\n        this._height = 0;\n        this._pixelWidth = 0;\n        this._pixelHeight = 0;\n        this._nextPixelWidth = 0;\n        this._nextPixelHeight = 0;\n        this._requestAnimationId = DEFAULT_REQUEST_ID;\n        this._mediaQueryListener = function () {\n            var pixelRatio = getPixelRatio(_this._element);\n            _this._nextPixelWidth = Math.round(_this._element.clientWidth * pixelRatio);\n            _this._nextPixelHeight = Math.round(_this._element.clientHeight * pixelRatio);\n            _this._resetPixelRatio();\n        };\n        this._listener = listener;\n        this._element = createDom('canvas', style);\n        this._ctx = this._element.getContext('2d');\n        isSupportedDevicePixelContentBox().then(function (result) {\n            _this._supportedDevicePixelContentBox = result;\n            if (result) {\n                _this._resizeObserver = new ResizeObserver(function (entries) {\n                    var entry = entries.find(function (entry) { return entry.target === _this._element; });\n                    var size = entry === null || entry === void 0 ? void 0 : entry.devicePixelContentBoxSize[0];\n                    if (isValid(size)) {\n                        _this._nextPixelWidth = size.inlineSize;\n                        _this._nextPixelHeight = size.blockSize;\n                        if (_this._pixelWidth !== _this._nextPixelWidth || _this._pixelHeight !== _this._nextPixelHeight) {\n                            _this._resetPixelRatio();\n                        }\n                    }\n                });\n                _this._resizeObserver.observe(_this._element, { box: 'device-pixel-content-box' });\n            }\n            else {\n                _this._mediaQueryList = window.matchMedia(\"(resolution: \".concat(getPixelRatio(_this._element), \"dppx)\"));\n                // eslint-disable-next-line @typescript-eslint/no-deprecated -- ignore\n                _this._mediaQueryList.addListener(_this._mediaQueryListener);\n            }\n        }).catch(function (_) { return false; });\n    }\n    Canvas.prototype._resetPixelRatio = function () {\n        var _this = this;\n        this._executeListener(function () {\n            var width = _this._element.clientWidth;\n            var height = _this._element.clientHeight;\n            _this._width = width;\n            _this._height = height;\n            _this._pixelWidth = _this._nextPixelWidth;\n            _this._pixelHeight = _this._nextPixelHeight;\n            _this._element.width = _this._nextPixelWidth;\n            _this._element.height = _this._nextPixelHeight;\n            var horizontalPixelRatio = _this._nextPixelWidth / width;\n            var verticalPixelRatio = _this._nextPixelHeight / height;\n            _this._ctx.scale(horizontalPixelRatio, verticalPixelRatio);\n        });\n    };\n    Canvas.prototype._executeListener = function (fn) {\n        var _this = this;\n        if (this._requestAnimationId === DEFAULT_REQUEST_ID) {\n            this._requestAnimationId = requestAnimationFrame(function () {\n                _this._ctx.clearRect(0, 0, _this._width, _this._height);\n                fn === null || fn === void 0 ? void 0 : fn();\n                _this._listener();\n                _this._requestAnimationId = DEFAULT_REQUEST_ID;\n            });\n        }\n    };\n    Canvas.prototype.update = function (w, h) {\n        if (this._width !== w || this._height !== h) {\n            this._element.style.width = \"\".concat(w, \"px\");\n            this._element.style.height = \"\".concat(h, \"px\");\n            if (!this._supportedDevicePixelContentBox) {\n                var pixelRatio = getPixelRatio(this._element);\n                this._nextPixelWidth = Math.round(w * pixelRatio);\n                this._nextPixelHeight = Math.round(h * pixelRatio);\n                this._resetPixelRatio();\n            }\n        }\n        else {\n            this._executeListener();\n        }\n    };\n    Canvas.prototype.getElement = function () {\n        return this._element;\n    };\n    Canvas.prototype.getContext = function () {\n        return this._ctx;\n    };\n    Canvas.prototype.destroy = function () {\n        if (isValid(this._resizeObserver)) {\n            this._resizeObserver.unobserve(this._element);\n        }\n        if (isValid(this._mediaQueryList)) {\n            // eslint-disable-next-line @typescript-eslint/no-deprecated -- ignore\n            this._mediaQueryList.removeListener(this._mediaQueryListener);\n        }\n    };\n    return Canvas;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Widget = /** @class */ (function (_super) {\n    __extends(Widget, _super);\n    function Widget(rootContainer, pane) {\n        var _this = _super.call(this) || this;\n        _this._bounding = createDefaultBounding();\n        _this._pane = pane;\n        _this._rootContainer = rootContainer;\n        _this._container = _this.createContainer();\n        rootContainer.appendChild(_this._container);\n        return _this;\n    }\n    Widget.prototype.setBounding = function (bounding) {\n        merge(this._bounding, bounding);\n        return this;\n    };\n    Widget.prototype.getContainer = function () { return this._container; };\n    Widget.prototype.getBounding = function () {\n        return this._bounding;\n    };\n    Widget.prototype.getPane = function () {\n        return this._pane;\n    };\n    Widget.prototype.update = function (level) {\n        this.updateImp(this._container, this._bounding, level !== null && level !== void 0 ? level : 3 /* UpdateLevel.Drawer */);\n    };\n    Widget.prototype.destroy = function () {\n        this._rootContainer.removeChild(this._container);\n    };\n    return Widget;\n}(Eventful));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DrawWidget = /** @class */ (function (_super) {\n    __extends(DrawWidget, _super);\n    function DrawWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._mainCanvas = new Canvas({\n            position: 'absolute',\n            top: '0',\n            left: '0',\n            zIndex: '2',\n            boxSizing: 'border-box'\n        }, function () {\n            _this.updateMain(_this._mainCanvas.getContext());\n        });\n        _this._overlayCanvas = new Canvas({\n            position: 'absolute',\n            top: '0',\n            left: '0',\n            zIndex: '2',\n            boxSizing: 'border-box'\n        }, function () {\n            _this.updateOverlay(_this._overlayCanvas.getContext());\n        });\n        var container = _this.getContainer();\n        container.appendChild(_this._mainCanvas.getElement());\n        container.appendChild(_this._overlayCanvas.getElement());\n        return _this;\n    }\n    DrawWidget.prototype.createContainer = function () {\n        return createDom('div', {\n            margin: '0',\n            padding: '0',\n            position: 'absolute',\n            top: '0',\n            overflow: 'hidden',\n            boxSizing: 'border-box',\n            zIndex: '1'\n        });\n    };\n    DrawWidget.prototype.updateImp = function (container, bounding, level) {\n        var width = bounding.width, height = bounding.height, left = bounding.left;\n        container.style.left = \"\".concat(left, \"px\");\n        var l = level;\n        var w = container.clientWidth;\n        var h = container.clientHeight;\n        if (width !== w || height !== h) {\n            container.style.width = \"\".concat(width, \"px\");\n            container.style.height = \"\".concat(height, \"px\");\n            l = 3 /* UpdateLevel.Drawer */;\n        }\n        switch (l) {\n            case 0 /* UpdateLevel.Main */: {\n                this._mainCanvas.update(width, height);\n                break;\n            }\n            case 1 /* UpdateLevel.Overlay */: {\n                this._overlayCanvas.update(width, height);\n                break;\n            }\n            case 3 /* UpdateLevel.Drawer */:\n            case 4 /* UpdateLevel.All */: {\n                this._mainCanvas.update(width, height);\n                this._overlayCanvas.update(width, height);\n                break;\n            }\n        }\n    };\n    DrawWidget.prototype.destroy = function () {\n        this._mainCanvas.destroy();\n        this._overlayCanvas.destroy();\n    };\n    DrawWidget.prototype.getImage = function (includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var canvas = createDom('canvas', {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: 'border-box'\n        });\n        var ctx = canvas.getContext('2d');\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.drawImage(this._mainCanvas.getElement(), 0, 0, width, height);\n        if (includeOverlay) {\n            ctx.drawImage(this._overlayCanvas.getElement(), 0, 0, width, height);\n        }\n        return canvas;\n    };\n    return DrawWidget;\n}(Widget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction checkCoordinateOnCircle(coordinate, attrs) {\n    var e_1, _a;\n    var circles = [];\n    circles = circles.concat(attrs);\n    try {\n        for (var circles_1 = __values(circles), circles_1_1 = circles_1.next(); !circles_1_1.done; circles_1_1 = circles_1.next()) {\n            var circle_1 = circles_1_1.value;\n            var x = circle_1.x, y = circle_1.y, r = circle_1.r;\n            var difX = coordinate.x - x;\n            var difY = coordinate.y - y;\n            if (!(difX * difX + difY * difY > r * r)) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (circles_1_1 && !circles_1_1.done && (_a = circles_1.return)) _a.call(circles_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction drawCircle(ctx, attrs, styles) {\n    var circles = [];\n    circles = circles.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? PolygonType.Fill : _a, _b = styles.color, color = _b === void 0 ? 'currentColor' : _b, _c = styles.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles.borderColor, borderColor = _d === void 0 ? 'currentColor' : _d, _e = styles.borderStyle, borderStyle = _e === void 0 ? LineType.Solid : _e, _f = styles.borderDashedValue, borderDashedValue = _f === void 0 ? [2, 2] : _f;\n    var solid = (style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) && (!isString(color) || !isTransparent(color));\n    if (solid) {\n        ctx.fillStyle = color;\n        circles.forEach(function (_a) {\n            var x = _a.x, y = _a.y, r = _a.r;\n            ctx.beginPath();\n            ctx.arc(x, y, r, 0, Math.PI * 2);\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        }\n        else {\n            ctx.setLineDash([]);\n        }\n        circles.forEach(function (_a) {\n            var x = _a.x, y = _a.y, r = _a.r;\n            if (!solid || r > borderSize) {\n                ctx.beginPath();\n                ctx.arc(x, y, r, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.stroke();\n            }\n        });\n    }\n}\nvar circle = {\n    name: 'circle',\n    checkEventOn: checkCoordinateOnCircle,\n    draw: function (ctx, attrs, styles) {\n        drawCircle(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction checkCoordinateOnPolygon(coordinate, attrs) {\n    var e_1, _a;\n    var polygons = [];\n    polygons = polygons.concat(attrs);\n    try {\n        for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {\n            var polygon_1 = polygons_1_1.value;\n            var on = false;\n            var coordinates = polygon_1.coordinates;\n            for (var i = 0, j = coordinates.length - 1; i < coordinates.length; j = i++) {\n                if ((coordinates[i].y > coordinate.y) !== (coordinates[j].y > coordinate.y) &&\n                    (coordinate.x < (coordinates[j].x - coordinates[i].x) * (coordinate.y - coordinates[i].y) / (coordinates[j].y - coordinates[i].y) + coordinates[i].x)) {\n                    on = !on;\n                }\n            }\n            if (on) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction drawPolygon(ctx, attrs, styles) {\n    var polygons = [];\n    polygons = polygons.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? PolygonType.Fill : _a, _b = styles.color, color = _b === void 0 ? 'currentColor' : _b, _c = styles.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles.borderColor, borderColor = _d === void 0 ? 'currentColor' : _d, _e = styles.borderStyle, borderStyle = _e === void 0 ? LineType.Solid : _e, _f = styles.borderDashedValue, borderDashedValue = _f === void 0 ? [2, 2] : _f;\n    if ((style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) &&\n        (!isString(color) || !isTransparent(color))) {\n        ctx.fillStyle = color;\n        polygons.forEach(function (_a) {\n            var coordinates = _a.coordinates;\n            ctx.beginPath();\n            ctx.moveTo(coordinates[0].x, coordinates[0].y);\n            for (var i = 1; i < coordinates.length; i++) {\n                ctx.lineTo(coordinates[i].x, coordinates[i].y);\n            }\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        }\n        else {\n            ctx.setLineDash([]);\n        }\n        polygons.forEach(function (_a) {\n            var coordinates = _a.coordinates;\n            ctx.beginPath();\n            ctx.moveTo(coordinates[0].x, coordinates[0].y);\n            for (var i = 1; i < coordinates.length; i++) {\n                ctx.lineTo(coordinates[i].x, coordinates[i].y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        });\n    }\n}\nvar polygon = {\n    name: 'polygon',\n    checkEventOn: checkCoordinateOnPolygon,\n    draw: function (ctx, attrs, styles) {\n        drawPolygon(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction checkCoordinateOnRect(coordinate, attrs) {\n    var e_1, _a;\n    var rects = [];\n    rects = rects.concat(attrs);\n    try {\n        for (var rects_1 = __values(rects), rects_1_1 = rects_1.next(); !rects_1_1.done; rects_1_1 = rects_1.next()) {\n            var rect_1 = rects_1_1.value;\n            var x = rect_1.x;\n            var width = rect_1.width;\n            if (width < DEVIATION * 2) {\n                x -= DEVIATION;\n                width = DEVIATION * 2;\n            }\n            var y = rect_1.y;\n            var height = rect_1.height;\n            if (height < DEVIATION * 2) {\n                y -= DEVIATION;\n                height = DEVIATION * 2;\n            }\n            if (coordinate.x >= x &&\n                coordinate.x <= x + width &&\n                coordinate.y >= y &&\n                coordinate.y <= y + height) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (rects_1_1 && !rects_1_1.done && (_a = rects_1.return)) _a.call(rects_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction drawRect(ctx, attrs, styles) {\n    var _a;\n    var rects = [];\n    rects = rects.concat(attrs);\n    var _b = styles.style, style = _b === void 0 ? PolygonType.Fill : _b, _c = styles.color, color = _c === void 0 ? 'transparent' : _c, _d = styles.borderSize, borderSize = _d === void 0 ? 1 : _d, _e = styles.borderColor, borderColor = _e === void 0 ? 'transparent' : _e, _f = styles.borderStyle, borderStyle = _f === void 0 ? LineType.Solid : _f, _g = styles.borderRadius, r = _g === void 0 ? 0 : _g, _h = styles.borderDashedValue, borderDashedValue = _h === void 0 ? [2, 2] : _h;\n    // eslint-disable-next-line @typescript-eslint/unbound-method, @typescript-eslint/no-unnecessary-condition -- ignore\n    var draw = (_a = ctx.roundRect) !== null && _a !== void 0 ? _a : ctx.rect;\n    var solid = (style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) && (!isString(color) || !isTransparent(color));\n    if (solid) {\n        ctx.fillStyle = color;\n        rects.forEach(function (_a) {\n            var x = _a.x, y = _a.y, w = _a.width, h = _a.height;\n            ctx.beginPath();\n            draw.call(ctx, x, y, w, h, r);\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.fillStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        }\n        else {\n            ctx.setLineDash([]);\n        }\n        var correction_1 = borderSize % 2 === 1 ? 0.5 : 0;\n        var doubleCorrection_1 = Math.round(correction_1 * 2);\n        rects.forEach(function (_a) {\n            var x = _a.x, y = _a.y, w = _a.width, h = _a.height;\n            if (w > borderSize * 2 && h > borderSize * 2) {\n                ctx.beginPath();\n                draw.call(ctx, x + correction_1, y + correction_1, w - doubleCorrection_1, h - doubleCorrection_1, r);\n                ctx.closePath();\n                ctx.stroke();\n            }\n            else {\n                if (!solid) {\n                    ctx.fillRect(x, y, w, h);\n                }\n            }\n        });\n    }\n}\nvar rect = {\n    name: 'rect',\n    checkEventOn: checkCoordinateOnRect,\n    draw: function (ctx, attrs, styles) {\n        drawRect(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getTextRect(attrs, styles) {\n    var _a = styles.size, size = _a === void 0 ? 12 : _a, _b = styles.paddingLeft, paddingLeft = _b === void 0 ? 0 : _b, _c = styles.paddingTop, paddingTop = _c === void 0 ? 0 : _c, _d = styles.paddingRight, paddingRight = _d === void 0 ? 0 : _d, _e = styles.paddingBottom, paddingBottom = _e === void 0 ? 0 : _e, _f = styles.weight, weight = _f === void 0 ? 'normal' : _f, family = styles.family;\n    var x = attrs.x, y = attrs.y, text = attrs.text, _g = attrs.align, align = _g === void 0 ? 'left' : _g, _h = attrs.baseline, baseline = _h === void 0 ? 'top' : _h, w = attrs.width, h = attrs.height;\n    var width = w !== null && w !== void 0 ? w : (paddingLeft + calcTextWidth(text, size, weight, family) + paddingRight);\n    var height = h !== null && h !== void 0 ? h : (paddingTop + size + paddingBottom);\n    var startX = 0;\n    switch (align) {\n        case 'left':\n        case 'start': {\n            startX = x;\n            break;\n        }\n        case 'right':\n        case 'end': {\n            startX = x - width;\n            break;\n        }\n        default: {\n            startX = x - width / 2;\n            break;\n        }\n    }\n    var startY = 0;\n    switch (baseline) {\n        case 'top':\n        case 'hanging': {\n            startY = y;\n            break;\n        }\n        case 'bottom':\n        case 'ideographic':\n        case 'alphabetic': {\n            startY = y - height;\n            break;\n        }\n        default: {\n            startY = y - height / 2;\n            break;\n        }\n    }\n    return { x: startX, y: startY, width: width, height: height };\n}\nfunction checkCoordinateOnText(coordinate, attrs, styles) {\n    var e_1, _a;\n    var texts = [];\n    texts = texts.concat(attrs);\n    try {\n        for (var texts_1 = __values(texts), texts_1_1 = texts_1.next(); !texts_1_1.done; texts_1_1 = texts_1.next()) {\n            var text_1 = texts_1_1.value;\n            var _b = getTextRect(text_1, styles), x = _b.x, y = _b.y, width = _b.width, height = _b.height;\n            if (coordinate.x >= x &&\n                coordinate.x <= x + width &&\n                coordinate.y >= y &&\n                coordinate.y <= y + height) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (texts_1_1 && !texts_1_1.done && (_a = texts_1.return)) _a.call(texts_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction drawText(ctx, attrs, styles) {\n    var texts = [];\n    texts = texts.concat(attrs);\n    var _a = styles.color, color = _a === void 0 ? 'currentColor' : _a, _b = styles.size, size = _b === void 0 ? 12 : _b, family = styles.family, weight = styles.weight, _c = styles.paddingLeft, paddingLeft = _c === void 0 ? 0 : _c, _d = styles.paddingTop, paddingTop = _d === void 0 ? 0 : _d, _e = styles.paddingRight, paddingRight = _e === void 0 ? 0 : _e;\n    var rects = texts.map(function (text) { return getTextRect(text, styles); });\n    drawRect(ctx, rects, __assign(__assign({}, styles), { color: styles.backgroundColor }));\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n    ctx.font = createFont(size, weight, family);\n    ctx.fillStyle = color;\n    texts.forEach(function (text, index) {\n        var rect = rects[index];\n        ctx.fillText(text.text, rect.x + paddingLeft, rect.y + paddingTop, rect.width - paddingLeft - paddingRight);\n    });\n}\nvar text = {\n    name: 'text',\n    checkEventOn: checkCoordinateOnText,\n    draw: function (ctx, attrs, styles) {\n        drawText(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getDistance(coordinate1, coordinate2) {\n    var xDif = coordinate1.x - coordinate2.x;\n    var yDif = coordinate1.y - coordinate2.y;\n    return Math.sqrt(xDif * xDif + yDif * yDif);\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction checkCoordinateOnArc(coordinate, attrs) {\n    var e_1, _a;\n    var arcs = [];\n    arcs = arcs.concat(attrs);\n    try {\n        for (var arcs_1 = __values(arcs), arcs_1_1 = arcs_1.next(); !arcs_1_1.done; arcs_1_1 = arcs_1.next()) {\n            var arc_1 = arcs_1_1.value;\n            if (Math.abs(getDistance(coordinate, arc_1) - arc_1.r) < DEVIATION) {\n                var r = arc_1.r, startAngle = arc_1.startAngle, endAngle = arc_1.endAngle;\n                var startCoordinateX = r * Math.cos(startAngle) + arc_1.x;\n                var startCoordinateY = r * Math.sin(startAngle) + arc_1.y;\n                var endCoordinateX = r * Math.cos(endAngle) + arc_1.x;\n                var endCoordinateY = r * Math.sin(endAngle) + arc_1.y;\n                if (coordinate.x <= Math.max(startCoordinateX, endCoordinateX) + DEVIATION &&\n                    coordinate.x >= Math.min(startCoordinateX, endCoordinateX) - DEVIATION &&\n                    coordinate.y <= Math.max(startCoordinateY, endCoordinateY) + DEVIATION &&\n                    coordinate.y >= Math.min(startCoordinateY, endCoordinateY) - DEVIATION) {\n                    return true;\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (arcs_1_1 && !arcs_1_1.done && (_a = arcs_1.return)) _a.call(arcs_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\nfunction drawArc(ctx, attrs, styles) {\n    var arcs = [];\n    arcs = arcs.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? LineType.Solid : _a, _b = styles.size, size = _b === void 0 ? 1 : _b, _c = styles.color, color = _c === void 0 ? 'currentColor' : _c, _d = styles.dashedValue, dashedValue = _d === void 0 ? [2, 2] : _d;\n    ctx.lineWidth = size;\n    ctx.strokeStyle = color;\n    if (style === LineType.Dashed) {\n        ctx.setLineDash(dashedValue);\n    }\n    else {\n        ctx.setLineDash([]);\n    }\n    arcs.forEach(function (_a) {\n        var x = _a.x, y = _a.y, r = _a.r, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        ctx.beginPath();\n        ctx.arc(x, y, r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.closePath();\n    });\n}\nvar arc = {\n    name: 'arc',\n    checkEventOn: checkCoordinateOnArc,\n    draw: function (ctx, attrs, styles) {\n        drawArc(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction drawEllipticalArc(ctx, x1, y1, args, offsetX, offsetY, isRelative) {\n    var _a = __read(args, 7), rx = _a[0], ry = _a[1], rotation = _a[2], largeArcFlag = _a[3], sweepFlag = _a[4], x2 = _a[5], y2 = _a[6];\n    var targetX = isRelative ? x1 + x2 : x2 + offsetX;\n    var targetY = isRelative ? y1 + y2 : y2 + offsetY;\n    var segments = ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, targetX, targetY);\n    segments.forEach(function (segment) {\n        ctx.bezierCurveTo(segment[0], segment[1], segment[2], segment[3], segment[4], segment[5]);\n    });\n}\nfunction ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {\n    var _a = computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2), cx = _a.cx, cy = _a.cy, startAngle = _a.startAngle, deltaAngle = _a.deltaAngle;\n    var segments = [];\n    var numSegments = Math.ceil(Math.abs(deltaAngle) / (Math.PI / 2));\n    for (var i = 0; i < numSegments; i++) {\n        var start = startAngle + (i * deltaAngle) / numSegments;\n        var end = startAngle + ((i + 1) * deltaAngle) / numSegments;\n        var bezier = ellipticalArcToBezier(cx, cy, rx, ry, rotation, start, end);\n        segments.push(bezier);\n    }\n    return segments;\n}\nfunction computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {\n    var phi = (rotation * Math.PI) / 180;\n    var dx = (x1 - x2) / 2;\n    var dy = (y1 - y2) / 2;\n    var x1p = Math.cos(phi) * dx + Math.sin(phi) * dy;\n    var y1p = -Math.sin(phi) * dx + Math.cos(phi) * dy;\n    var lambda = (Math.pow(x1p, 2)) / (Math.pow(rx, 2)) + (Math.pow(y1p, 2)) / (Math.pow(ry, 2));\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    var sign = largeArcFlag === sweepFlag ? -1 : 1;\n    var numerator = (Math.pow(rx, 2)) * (Math.pow(ry, 2)) - (Math.pow(rx, 2)) * (Math.pow(y1p, 2)) - (Math.pow(ry, 2)) * (Math.pow(x1p, 2));\n    var denominator = (Math.pow(rx, 2)) * (Math.pow(y1p, 2)) + (Math.pow(ry, 2)) * (Math.pow(x1p, 2));\n    var cxp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (rx * y1p / ry);\n    var cyp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (-ry * x1p / rx);\n    var cx = Math.cos(phi) * cxp - Math.sin(phi) * cyp + (x1 + x2) / 2;\n    var cy = Math.sin(phi) * cxp + Math.cos(phi) * cyp + (y1 + y2) / 2;\n    var startAngle = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);\n    var deltaAngle = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx) - startAngle;\n    if (deltaAngle < 0 && sweepFlag === 1) {\n        deltaAngle += 2 * Math.PI;\n    }\n    else if (deltaAngle > 0 && sweepFlag === 0) {\n        deltaAngle -= 2 * Math.PI;\n    }\n    return { cx: cx, cy: cy, startAngle: startAngle, deltaAngle: deltaAngle };\n}\n/**\n * Ellipse arc segment to Bezier curve\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param rotation\n * @param startAngle\n * @param endAngle\n * @returns\n */\nfunction ellipticalArcToBezier(cx, cy, rx, ry, rotation, startAngle, endAngle) {\n    // 计算控制点\n    var alpha = Math.sin(endAngle - startAngle) * (Math.sqrt(4 + 3 * Math.pow(Math.tan((endAngle - startAngle) / 2), 2)) - 1) / 3;\n    var cosPhi = Math.cos(rotation);\n    var sinPhi = Math.sin(rotation);\n    var x1 = cx + rx * Math.cos(startAngle) * cosPhi - ry * Math.sin(startAngle) * sinPhi;\n    var y1 = cy + rx * Math.cos(startAngle) * sinPhi + ry * Math.sin(startAngle) * cosPhi;\n    var x2 = cx + rx * Math.cos(endAngle) * cosPhi - ry * Math.sin(endAngle) * sinPhi;\n    var y2 = cy + rx * Math.cos(endAngle) * sinPhi + ry * Math.sin(endAngle) * cosPhi;\n    var cp1x = x1 + alpha * (-rx * Math.sin(startAngle) * cosPhi - ry * Math.cos(startAngle) * sinPhi);\n    var cp1y = y1 + alpha * (-rx * Math.sin(startAngle) * sinPhi + ry * Math.cos(startAngle) * cosPhi);\n    var cp2x = x2 - alpha * (-rx * Math.sin(endAngle) * cosPhi - ry * Math.cos(endAngle) * sinPhi);\n    var cp2y = y2 - alpha * (-rx * Math.sin(endAngle) * sinPhi + ry * Math.cos(endAngle) * cosPhi);\n    return [cp1x, cp1y, cp2x, cp2y, x2, y2];\n}\nfunction drawPath(ctx, attrs, styles) {\n    var paths = [];\n    paths = paths.concat(attrs);\n    var _a = styles.lineWidth, lineWidth = _a === void 0 ? 1 : _a, _b = styles.color, color = _b === void 0 ? 'currentColor' : _b;\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.setLineDash([]);\n    paths.forEach(function (_a) {\n        var x = _a.x, y = _a.y, path = _a.path;\n        var commands = path.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);\n        if (isValid(commands)) {\n            var offsetX_1 = x;\n            var offsetY_1 = y;\n            ctx.beginPath();\n            commands.forEach(function (command) {\n                var currentX = 0;\n                var currentY = 0;\n                var startX = 0;\n                var startY = 0;\n                var type = command[0];\n                var args = command.slice(1).trim().split(/[\\s,]+/).map(Number);\n                switch (type) {\n                    case 'M':\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        ctx.moveTo(currentX, currentY);\n                        startX = currentX;\n                        startY = currentY;\n                        break;\n                    case 'm':\n                        currentX += args[0];\n                        currentY += args[1];\n                        ctx.moveTo(currentX, currentY);\n                        startX = currentX;\n                        startY = currentY;\n                        break;\n                    case 'L':\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'l':\n                        currentX += args[0];\n                        currentY += args[1];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'H':\n                        currentX = args[0] + offsetX_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'h':\n                        currentX += args[0];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'V':\n                        currentY = args[0] + offsetY_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'v':\n                        currentY += args[0];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case 'C':\n                        ctx.bezierCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1, args[4] + offsetX_1, args[5] + offsetY_1);\n                        currentX = args[4] + offsetX_1;\n                        currentY = args[5] + offsetY_1;\n                        break;\n                    case 'c':\n                        ctx.bezierCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3], currentX + args[4], currentY + args[5]);\n                        currentX += args[4];\n                        currentY += args[5];\n                        break;\n                    case 'S':\n                        ctx.bezierCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);\n                        currentX = args[2] + offsetX_1;\n                        currentY = args[3] + offsetY_1;\n                        break;\n                    case 's':\n                        ctx.bezierCurveTo(currentX, currentY, currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);\n                        currentX += args[2];\n                        currentY += args[3];\n                        break;\n                    case 'Q':\n                        ctx.quadraticCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);\n                        currentX = args[2] + offsetX_1;\n                        currentY = args[3] + offsetY_1;\n                        break;\n                    case 'q':\n                        ctx.quadraticCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);\n                        currentX += args[2];\n                        currentY += args[3];\n                        break;\n                    case 'T':\n                        ctx.quadraticCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1);\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        break;\n                    case 't':\n                        ctx.quadraticCurveTo(currentX, currentY, currentX + args[0], currentY + args[1]);\n                        currentX += args[0];\n                        currentY += args[1];\n                        break;\n                    case 'A':\n                        // arc\n                        // reference https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                        drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, false);\n                        currentX = args[5] + offsetX_1;\n                        currentY = args[6] + offsetY_1;\n                        break;\n                    case 'a':\n                        // arc\n                        // reference https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                        drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, true);\n                        currentX += args[5];\n                        currentY += args[6];\n                        break;\n                    case 'Z':\n                    case 'z':\n                        ctx.closePath();\n                        currentX = startX;\n                        currentY = startY;\n                        break;\n                }\n            });\n            if (styles.style === PathType.Fill) {\n                ctx.fill();\n            }\n            else {\n                ctx.stroke();\n            }\n        }\n    });\n}\nvar path = {\n    name: 'path',\n    checkEventOn: checkCoordinateOnRect,\n    draw: function (ctx, attrs, styles) {\n        drawPath(ctx, attrs, styles);\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar figures = {};\nvar extensions = [circle, line, polygon, rect, text, arc, path];\nextensions.forEach(function (figure) {\n    figures[figure.name] = FigureImp.extend(figure);\n});\nfunction getSupportedFigures() {\n    return Object.keys(figures);\n}\nfunction registerFigure(figure) {\n    figures[figure.name] = FigureImp.extend(figure);\n}\nfunction getInnerFigureClass(name) {\n    var _a;\n    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getFigureClass(name) {\n    var _a;\n    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar View = /** @class */ (function (_super) {\n    __extends(View, _super);\n    function View(widget) {\n        var _this = _super.call(this) || this;\n        _this._widget = widget;\n        return _this;\n    }\n    View.prototype.getWidget = function () { return this._widget; };\n    View.prototype.createFigure = function (create, eventHandler) {\n        var FigureClazz = getInnerFigureClass(create.name);\n        if (FigureClazz !== null) {\n            var figure = new FigureClazz(create);\n            if (isValid(eventHandler)) {\n                for (var key in eventHandler) {\n                    // eslint-disable-next-line no-prototype-builtins -- ignore\n                    if (eventHandler.hasOwnProperty(key)) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n                        figure.registerEvent(key, eventHandler[key]);\n                    }\n                }\n                this.addChild(figure);\n            }\n            return figure;\n        }\n        return null;\n    };\n    View.prototype.draw = function (ctx) {\n        var extend = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            extend[_i - 1] = arguments[_i];\n        }\n        this.clear();\n        this.drawImp(ctx, extend);\n    };\n    return View;\n}(Eventful));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar GridView = /** @class */ (function (_super) {\n    __extends(GridView, _super);\n    function GridView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GridView.prototype.drawImp = function (ctx) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var bounding = widget.getBounding();\n        var styles = chart.getStyles().grid;\n        var show = styles.show;\n        if (show) {\n            ctx.save();\n            ctx.globalCompositeOperation = 'destination-over';\n            var horizontalStyles = styles.horizontal;\n            var horizontalShow = horizontalStyles.show;\n            if (horizontalShow) {\n                var yAxis = pane.getAxisComponent();\n                var attrs = yAxis.getTicks().map(function (tick) { return ({\n                    coordinates: [\n                        { x: 0, y: tick.coord },\n                        { x: bounding.width, y: tick.coord }\n                    ]\n                }); });\n                (_a = this.createFigure({\n                    name: 'line',\n                    attrs: attrs,\n                    styles: horizontalStyles\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n            var verticalStyles = styles.vertical;\n            var verticalShow = verticalStyles.show;\n            if (verticalShow) {\n                var xAxis = chart.getXAxisPane().getAxisComponent();\n                var attrs = xAxis.getTicks().map(function (tick) { return ({\n                    coordinates: [\n                        { x: tick.coord, y: 0 },\n                        { x: tick.coord, y: bounding.height }\n                    ]\n                }); });\n                (_b = this.createFigure({\n                    name: 'line',\n                    attrs: attrs,\n                    styles: verticalStyles\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            }\n            ctx.restore();\n        }\n    };\n    return GridView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ChildrenView = /** @class */ (function (_super) {\n    __extends(ChildrenView, _super);\n    function ChildrenView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChildrenView.prototype.eachChildren = function (childCallback) {\n        var pane = this.getWidget().getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var visibleRangeDataList = chartStore.getVisibleRangeDataList();\n        var barSpace = chartStore.getBarSpace();\n        var dataLength = visibleRangeDataList.length;\n        var index = 0;\n        while (index < dataLength) {\n            childCallback(visibleRangeDataList[index], barSpace, index);\n            ++index;\n        }\n    };\n    return ChildrenView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleBarView = /** @class */ (function (_super) {\n    __extends(CandleBarView, _super);\n    function CandleBarView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._boundCandleBarClickEvent = function (data) { return function () {\n            _this.getWidget().getPane().getChart().getChartStore().executeAction(ActionType.OnCandleBarClick, data);\n            return false;\n        }; };\n        return _this;\n    }\n    CandleBarView.prototype.drawImp = function (ctx) {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var isMain = pane.getId() === PaneIdConstants.CANDLE;\n        var chartStore = pane.getChart().getChartStore();\n        var candleBarOptions = this.getCandleBarOptions();\n        if (candleBarOptions !== null) {\n            var type_1 = candleBarOptions.type, styles_1 = candleBarOptions.styles;\n            var ohlcSize_1 = 0;\n            var halfOhlcSize_1 = 0;\n            if (candleBarOptions.type === CandleType.Ohlc) {\n                var gapBar = chartStore.getBarSpace().gapBar;\n                ohlcSize_1 = Math.min(Math.max(Math.round(gapBar * 0.2), 1), 8);\n                if (ohlcSize_1 > 2 && ohlcSize_1 % 2 === 1) {\n                    ohlcSize_1--;\n                }\n                halfOhlcSize_1 = Math.floor(halfOhlcSize_1 / 2);\n            }\n            var yAxis_1 = pane.getAxisComponent();\n            this.eachChildren(function (visibleData, barSpace) {\n                var _a;\n                var x = visibleData.x, _b = visibleData.data, current = _b.current, prev = _b.prev;\n                if (isValid(current)) {\n                    var open_1 = current.open, high = current.high, low = current.low, close_1 = current.close;\n                    var comparePrice = styles_1.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : ((_a = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _a !== void 0 ? _a : close_1);\n                    var colors = [];\n                    if (close_1 > comparePrice) {\n                        colors[0] = styles_1.upColor;\n                        colors[1] = styles_1.upBorderColor;\n                        colors[2] = styles_1.upWickColor;\n                    }\n                    else if (close_1 < comparePrice) {\n                        colors[0] = styles_1.downColor;\n                        colors[1] = styles_1.downBorderColor;\n                        colors[2] = styles_1.downWickColor;\n                    }\n                    else {\n                        colors[0] = styles_1.noChangeColor;\n                        colors[1] = styles_1.noChangeBorderColor;\n                        colors[2] = styles_1.noChangeWickColor;\n                    }\n                    var openY = yAxis_1.convertToPixel(open_1);\n                    var closeY = yAxis_1.convertToPixel(close_1);\n                    var priceY = [\n                        openY, closeY,\n                        yAxis_1.convertToPixel(high),\n                        yAxis_1.convertToPixel(low)\n                    ];\n                    priceY.sort(function (a, b) { return a - b; });\n                    var correction = barSpace.gapBar % 2 === 0 ? 1 : 0;\n                    var rects = [];\n                    switch (type_1) {\n                        case CandleType.CandleSolid: {\n                            rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                            break;\n                        }\n                        case CandleType.CandleStroke: {\n                            rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                            break;\n                        }\n                        case CandleType.CandleUpStroke: {\n                            if (close_1 > open_1) {\n                                rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                            }\n                            else {\n                                rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                            }\n                            break;\n                        }\n                        case CandleType.CandleDownStroke: {\n                            if (open_1 > close_1) {\n                                rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                            }\n                            else {\n                                rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                            }\n                            break;\n                        }\n                        case CandleType.Ohlc: {\n                            rects = [\n                                {\n                                    name: 'rect',\n                                    attrs: [\n                                        {\n                                            x: x - halfOhlcSize_1,\n                                            y: priceY[0],\n                                            width: ohlcSize_1,\n                                            height: priceY[3] - priceY[0]\n                                        },\n                                        {\n                                            x: x - barSpace.halfGapBar,\n                                            y: openY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : openY,\n                                            width: barSpace.halfGapBar,\n                                            height: ohlcSize_1\n                                        },\n                                        {\n                                            x: x + halfOhlcSize_1,\n                                            y: closeY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : closeY,\n                                            width: barSpace.halfGapBar - halfOhlcSize_1,\n                                            height: ohlcSize_1\n                                        }\n                                    ],\n                                    styles: { color: colors[0] }\n                                }\n                            ];\n                            break;\n                        }\n                    }\n                    rects.forEach(function (rect) {\n                        var _a;\n                        var handler = null;\n                        if (isMain) {\n                            handler = {\n                                mouseClickEvent: _this._boundCandleBarClickEvent(visibleData)\n                            };\n                        }\n                        (_a = _this.createFigure(rect, handler !== null && handler !== void 0 ? handler : undefined)) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                    });\n                }\n            });\n        }\n    };\n    CandleBarView.prototype.getCandleBarOptions = function () {\n        var candleStyles = this.getWidget().getPane().getChart().getStyles().candle;\n        return {\n            type: candleStyles.type,\n            styles: candleStyles.bar\n        };\n    };\n    CandleBarView.prototype._createSolidBar = function (x, priceY, barSpace, colors, correction) {\n        return [\n            {\n                name: 'rect',\n                attrs: {\n                    x: x,\n                    y: priceY[0],\n                    width: 1,\n                    height: priceY[3] - priceY[0]\n                },\n                styles: { color: colors[2] }\n            },\n            {\n                name: 'rect',\n                attrs: {\n                    x: x - barSpace.halfGapBar,\n                    y: priceY[1],\n                    width: barSpace.gapBar + correction,\n                    height: Math.max(1, priceY[2] - priceY[1])\n                },\n                styles: {\n                    style: PolygonType.StrokeFill,\n                    color: colors[0],\n                    borderColor: colors[1]\n                }\n            }\n        ];\n    };\n    CandleBarView.prototype._createStrokeBar = function (x, priceY, barSpace, colors, correction) {\n        return [\n            {\n                name: 'rect',\n                attrs: [\n                    {\n                        x: x,\n                        y: priceY[0],\n                        width: 1,\n                        height: priceY[1] - priceY[0]\n                    },\n                    {\n                        x: x,\n                        y: priceY[2],\n                        width: 1,\n                        height: priceY[3] - priceY[2]\n                    }\n                ],\n                styles: { color: colors[2] }\n            },\n            {\n                name: 'rect',\n                attrs: {\n                    x: x - barSpace.halfGapBar,\n                    y: priceY[1],\n                    width: barSpace.gapBar + correction,\n                    height: Math.max(1, priceY[2] - priceY[1])\n                },\n                styles: {\n                    style: PolygonType.Stroke,\n                    borderColor: colors[1]\n                }\n            }\n        ];\n    };\n    return CandleBarView;\n}(ChildrenView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorView = /** @class */ (function (_super) {\n    __extends(IndicatorView, _super);\n    function IndicatorView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorView.prototype.getCandleBarOptions = function () {\n        var e_1, _a;\n        var pane = this.getWidget().getPane();\n        var yAxis = pane.getAxisComponent();\n        if (!yAxis.isInCandle()) {\n            var chartStore = pane.getChart().getChartStore();\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            try {\n                for (var indicators_1 = __values(indicators), indicators_1_1 = indicators_1.next(); !indicators_1_1.done; indicators_1_1 = indicators_1.next()) {\n                    var indicator = indicators_1_1.value;\n                    if (indicator.shouldOhlc && indicator.visible) {\n                        var indicatorStyles = indicator.styles;\n                        var defaultStyles = chartStore.getStyles().indicator;\n                        var compareRule = formatValue(indicatorStyles, 'ohlc.compareRule', defaultStyles.ohlc.compareRule);\n                        var upColor = formatValue(indicatorStyles, 'ohlc.upColor', defaultStyles.ohlc.upColor);\n                        var downColor = formatValue(indicatorStyles, 'ohlc.downColor', defaultStyles.ohlc.downColor);\n                        var noChangeColor = formatValue(indicatorStyles, 'ohlc.noChangeColor', defaultStyles.ohlc.noChangeColor);\n                        return {\n                            type: CandleType.Ohlc,\n                            styles: {\n                                compareRule: compareRule,\n                                upColor: upColor,\n                                downColor: downColor,\n                                noChangeColor: noChangeColor,\n                                upBorderColor: upColor,\n                                downBorderColor: downColor,\n                                noChangeBorderColor: noChangeColor,\n                                upWickColor: upColor,\n                                downWickColor: downColor,\n                                noChangeWickColor: noChangeColor\n                            }\n                        };\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (indicators_1_1 && !indicators_1_1.done && (_a = indicators_1.return)) _a.call(indicators_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        return null;\n    };\n    IndicatorView.prototype.drawImp = function (ctx) {\n        var _this = this;\n        _super.prototype.drawImp.call(this, ctx);\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var bounding = widget.getBounding();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var yAxis = pane.getAxisComponent();\n        var chartStore = chart.getChartStore();\n        var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n        var defaultStyles = chartStore.getStyles().indicator;\n        ctx.save();\n        indicators.forEach(function (indicator) {\n            if (indicator.visible) {\n                if (indicator.zLevel < 0) {\n                    ctx.globalCompositeOperation = 'destination-over';\n                }\n                else {\n                    ctx.globalCompositeOperation = 'source-over';\n                }\n                var isCover = false;\n                if (indicator.draw !== null) {\n                    ctx.save();\n                    isCover = indicator.draw({\n                        ctx: ctx,\n                        chart: chart,\n                        indicator: indicator,\n                        bounding: bounding,\n                        xAxis: xAxis,\n                        yAxis: yAxis\n                    });\n                    ctx.restore();\n                }\n                if (!isCover) {\n                    var result_1 = indicator.result;\n                    var lines_1 = [];\n                    _this.eachChildren(function (data, barSpace) {\n                        var _a, _b, _c;\n                        var halfGapBar = barSpace.halfGapBar;\n                        var dataIndex = data.dataIndex, x = data.x;\n                        var prevX = xAxis.convertToPixel(dataIndex - 1);\n                        var nextX = xAxis.convertToPixel(dataIndex + 1);\n                        var prevData = (_a = result_1[dataIndex - 1]) !== null && _a !== void 0 ? _a : null;\n                        var currentData = (_b = result_1[dataIndex]) !== null && _b !== void 0 ? _b : null;\n                        var nextData = (_c = result_1[dataIndex + 1]) !== null && _c !== void 0 ? _c : null;\n                        var prevCoordinate = { x: prevX };\n                        var currentCoordinate = { x: x };\n                        var nextCoordinate = { x: nextX };\n                        indicator.figures.forEach(function (_a) {\n                            var key = _a.key;\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var prevValue = prevData === null || prevData === void 0 ? void 0 : prevData[key];\n                            if (isNumber(prevValue)) {\n                                prevCoordinate[key] = yAxis.convertToPixel(prevValue);\n                            }\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var currentValue = currentData === null || currentData === void 0 ? void 0 : currentData[key];\n                            if (isNumber(currentValue)) {\n                                currentCoordinate[key] = yAxis.convertToPixel(currentValue);\n                            }\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var nextValue = nextData === null || nextData === void 0 ? void 0 : nextData[key];\n                            if (isNumber(nextValue)) {\n                                nextCoordinate[key] = yAxis.convertToPixel(nextValue);\n                            }\n                        });\n                        eachFigures(indicator, dataIndex, defaultStyles, function (figure, figureStyles, figureIndex) {\n                            var _a, _b, _c;\n                            if (isValid(currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {\n                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                var valueY = currentCoordinate[figure.key];\n                                var attrs = (_a = figure.attrs) === null || _a === void 0 ? void 0 : _a.call(figure, {\n                                    data: { prev: prevData, current: currentData, next: nextData },\n                                    coordinate: { prev: prevCoordinate, current: currentCoordinate, next: nextCoordinate },\n                                    bounding: bounding,\n                                    barSpace: barSpace,\n                                    xAxis: xAxis,\n                                    yAxis: yAxis\n                                });\n                                if (!isValid(attrs)) {\n                                    switch (figure.type) {\n                                        case 'circle': {\n                                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                            attrs = { x: x, y: valueY, r: Math.max(1, halfGapBar) };\n                                            break;\n                                        }\n                                        case 'rect':\n                                        case 'bar': {\n                                            var baseValue = (_b = figure.baseValue) !== null && _b !== void 0 ? _b : yAxis.getRange().from;\n                                            var baseValueY = yAxis.convertToPixel(baseValue);\n                                            var height = Math.abs(baseValueY - valueY);\n                                            if (baseValue !== (currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {\n                                                height = Math.max(1, height);\n                                            }\n                                            var y = 0;\n                                            if (valueY > baseValueY) {\n                                                y = baseValueY;\n                                            }\n                                            else {\n                                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                y = valueY;\n                                            }\n                                            attrs = {\n                                                x: x - halfGapBar,\n                                                y: y,\n                                                width: Math.max(1, halfGapBar * 2),\n                                                height: height\n                                            };\n                                            break;\n                                        }\n                                        case 'line': {\n                                            if (!isValid(lines_1[figureIndex])) {\n                                                lines_1[figureIndex] = [];\n                                            }\n                                            if (isNumber(currentCoordinate[figure.key]) && isNumber(nextCoordinate[figure.key])) {\n                                                lines_1[figureIndex].push({\n                                                    coordinates: [\n                                                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                        { x: currentCoordinate.x, y: currentCoordinate[figure.key] },\n                                                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                        { x: nextCoordinate.x, y: nextCoordinate[figure.key] }\n                                                    ],\n                                                    styles: figureStyles\n                                                });\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                                var type = figure.type;\n                                if (isValid(attrs) && type !== 'line') {\n                                    (_c = _this.createFigure({\n                                        name: type === 'bar' ? 'rect' : type,\n                                        attrs: attrs,\n                                        styles: figureStyles\n                                    })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n                                }\n                            }\n                        });\n                    });\n                    // merge line and render\n                    lines_1.forEach(function (items) {\n                        var _a, _b, _c, _d;\n                        if (items.length > 1) {\n                            var mergeLines = [\n                                {\n                                    coordinates: [items[0].coordinates[0], items[0].coordinates[1]],\n                                    styles: items[0].styles\n                                }\n                            ];\n                            for (var i = 1; i < items.length; i++) {\n                                var lastMergeLine = mergeLines[mergeLines.length - 1];\n                                var current = items[i];\n                                var lastMergeLineLastCoordinate = lastMergeLine.coordinates[lastMergeLine.coordinates.length - 1];\n                                if (lastMergeLineLastCoordinate.x === current.coordinates[0].x &&\n                                    lastMergeLineLastCoordinate.y === current.coordinates[0].y &&\n                                    lastMergeLine.styles.style === current.styles.style &&\n                                    lastMergeLine.styles.color === current.styles.color &&\n                                    lastMergeLine.styles.size === current.styles.size &&\n                                    lastMergeLine.styles.smooth === current.styles.smooth &&\n                                    ((_a = lastMergeLine.styles.dashedValue) === null || _a === void 0 ? void 0 : _a[0]) === ((_b = current.styles.dashedValue) === null || _b === void 0 ? void 0 : _b[0]) &&\n                                    ((_c = lastMergeLine.styles.dashedValue) === null || _c === void 0 ? void 0 : _c[1]) === ((_d = current.styles.dashedValue) === null || _d === void 0 ? void 0 : _d[1])) {\n                                    lastMergeLine.coordinates.push(current.coordinates[1]);\n                                }\n                                else {\n                                    mergeLines.push({\n                                        coordinates: [current.coordinates[0], current.coordinates[1]],\n                                        styles: current.styles\n                                    });\n                                }\n                            }\n                            mergeLines.forEach(function (_a) {\n                                var _b;\n                                var coordinates = _a.coordinates, styles = _a.styles;\n                                (_b = _this.createFigure({\n                                    name: 'line',\n                                    attrs: { coordinates: coordinates },\n                                    styles: styles\n                                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                            });\n                        }\n                    });\n                }\n            }\n        });\n        ctx.restore();\n    };\n    return IndicatorView;\n}(CandleBarView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CrosshairLineView = /** @class */ (function (_super) {\n    __extends(CrosshairLineView, _super);\n    function CrosshairLineView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairLineView.prototype.drawImp = function (ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        var styles = chartStore.getStyles().crosshair;\n        if (isString(crosshair.paneId) && styles.show) {\n            if (crosshair.paneId === pane.getId()) {\n                var y = crosshair.y;\n                this._drawLine(ctx, [\n                    { x: 0, y: y },\n                    { x: bounding.width, y: y }\n                ], styles.horizontal);\n            }\n            var x = crosshair.realX;\n            this._drawLine(ctx, [\n                { x: x, y: 0 },\n                { x: x, y: bounding.height }\n            ], styles.vertical);\n        }\n    };\n    CrosshairLineView.prototype._drawLine = function (ctx, coordinates, styles) {\n        var _a;\n        if (styles.show) {\n            var lineStyles = styles.line;\n            if (lineStyles.show) {\n                (_a = this.createFigure({\n                    name: 'line',\n                    attrs: { coordinates: coordinates },\n                    styles: lineStyles\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n        }\n    };\n    return CrosshairLineView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorTooltipView = /** @class */ (function (_super) {\n    __extends(IndicatorTooltipView, _super);\n    function IndicatorTooltipView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._boundFeatureClickEvent = function (currentFeatureInfo) { return function () {\n            var _a;\n            var pane = _this.getWidget().getPane();\n            var indicator = currentFeatureInfo.indicator, others = __rest(currentFeatureInfo, [\"indicator\"]);\n            if (isValid(indicator)) {\n                (_a = indicator.onClick) === null || _a === void 0 ? void 0 : _a.call(indicator, __assign({ target: IndicatorEventTarget.Feature, chart: pane.getChart(), indicator: indicator }, others));\n            }\n            else {\n                pane.getChart().getChartStore().executeAction(ActionType.OnCandleTooltipFeatureClick, currentFeatureInfo);\n            }\n            return true;\n        }; };\n        _this._boundFeatureMouseMoveEvent = function (currentFeatureInfo) { return function () {\n            _this.getWidget().getPane().getChart().getChartStore().setActiveTooltipFeatureInfo(currentFeatureInfo);\n            return true;\n        }; };\n        return _this;\n    }\n    IndicatorTooltipView.prototype.drawImp = function (ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        if (isValid(crosshair.kLineData)) {\n            var bounding = widget.getBounding();\n            var _a = chartStore.getStyles().indicator.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;\n            this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, bounding.width - offsetRight);\n        }\n    };\n    IndicatorTooltipView.prototype.drawIndicatorTooltip = function (ctx, left, top, maxWidth) {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var styles = chartStore.getStyles().indicator;\n        var tooltipStyles = styles.tooltip;\n        if (this.isDrawTooltip(chartStore.getCrosshair(), tooltipStyles)) {\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var tooltipTextStyles_1 = tooltipStyles.text;\n            indicators.forEach(function (indicator) {\n                var prevRowHeight = 0;\n                var coordinate = { x: left, y: top };\n                var _a = _this.getIndicatorTooltipData(indicator), name = _a.name, calcParamsText = _a.calcParamsText, legends = _a.legends, features = _a.features;\n                var nameValid = name.length > 0;\n                var legendValid = legends.length > 0;\n                if (nameValid || legendValid) {\n                    var _b = __read(_this.classifyTooltipFeatures(features), 3), leftFeatures = _b[0], middleFeatures = _b[1], rightFeatures = _b[2];\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, leftFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    if (nameValid) {\n                        var text = name;\n                        if (calcParamsText.length > 0) {\n                            text = \"\".concat(text).concat(calcParamsText);\n                        }\n                        prevRowHeight = _this.drawStandardTooltipLegends(ctx, [\n                            {\n                                title: { text: '', color: tooltipTextStyles_1.color },\n                                value: { text: text, color: tooltipTextStyles_1.color }\n                            }\n                        ], coordinate, left, prevRowHeight, maxWidth, tooltipTextStyles_1);\n                    }\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, middleFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    if (legendValid) {\n                        prevRowHeight = _this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipStyles.text);\n                    }\n                    // draw right icons\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, rightFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    top = coordinate.y + prevRowHeight;\n                }\n            });\n        }\n        return top;\n    };\n    IndicatorTooltipView.prototype.drawStandardTooltipFeatures = function (ctx, features, coordinate, indicator, left, prevRowHeight, maxWidth) {\n        var _this = this;\n        if (features.length > 0) {\n            var width_1 = 0;\n            var height_1 = 0;\n            features.forEach(function (feature) {\n                var _a = feature.marginLeft, marginLeft = _a === void 0 ? 0 : _a, _b = feature.marginTop, marginTop = _b === void 0 ? 0 : _b, _c = feature.marginRight, marginRight = _c === void 0 ? 0 : _c, _d = feature.marginBottom, marginBottom = _d === void 0 ? 0 : _d, _e = feature.paddingLeft, paddingLeft = _e === void 0 ? 0 : _e, _f = feature.paddingTop, paddingTop = _f === void 0 ? 0 : _f, _g = feature.paddingRight, paddingRight = _g === void 0 ? 0 : _g, _h = feature.paddingBottom, paddingBottom = _h === void 0 ? 0 : _h, _j = feature.size, size = _j === void 0 ? 0 : _j, type = feature.type, iconFont = feature.iconFont;\n                var contentWidth = 0;\n                if (type === TooltipFeatureType.IconFont) {\n                    ctx.font = createFont(size, 'normal', iconFont.family);\n                    contentWidth = ctx.measureText(iconFont.content).width;\n                }\n                else {\n                    contentWidth = size;\n                }\n                width_1 += (marginLeft + paddingLeft + contentWidth + paddingRight + marginRight);\n                height_1 = Math.max(height_1, marginTop + paddingTop + size + paddingBottom + marginBottom);\n            });\n            if (coordinate.x + width_1 > maxWidth) {\n                coordinate.x = left;\n                coordinate.y += prevRowHeight;\n                prevRowHeight = height_1;\n            }\n            else {\n                prevRowHeight = Math.max(prevRowHeight, height_1);\n            }\n            var pane = this.getWidget().getPane();\n            var paneId_1 = pane.getId();\n            var activeFeatureInfo_1 = pane.getChart().getChartStore().getActiveTooltipFeatureInfo();\n            features.forEach(function (feature) {\n                var _a, _b, _c, _d;\n                var _e = feature.marginLeft, marginLeft = _e === void 0 ? 0 : _e, _f = feature.marginTop, marginTop = _f === void 0 ? 0 : _f, _g = feature.marginRight, marginRight = _g === void 0 ? 0 : _g, _h = feature.paddingLeft, paddingLeft = _h === void 0 ? 0 : _h, _j = feature.paddingTop, paddingTop = _j === void 0 ? 0 : _j, _k = feature.paddingRight, paddingRight = _k === void 0 ? 0 : _k, _l = feature.paddingBottom, paddingBottom = _l === void 0 ? 0 : _l, backgroundColor = feature.backgroundColor, activeBackgroundColor = feature.activeBackgroundColor, borderRadius = feature.borderRadius, _m = feature.size, size = _m === void 0 ? 0 : _m, color = feature.color, activeColor = feature.activeColor, type = feature.type, iconFont = feature.iconFont, path = feature.path;\n                var active = (activeFeatureInfo_1 === null || activeFeatureInfo_1 === void 0 ? void 0 : activeFeatureInfo_1.paneId) === paneId_1 && ((_a = activeFeatureInfo_1.indicator) === null || _a === void 0 ? void 0 : _a.id) === (indicator === null || indicator === void 0 ? void 0 : indicator.id) && activeFeatureInfo_1.feature.id === feature.id;\n                var contentWidth = 0;\n                var eventHandler = {\n                    mouseClickEvent: _this._boundFeatureClickEvent({ paneId: paneId_1, indicator: indicator, feature: feature }),\n                    mouseMoveEvent: _this._boundFeatureMouseMoveEvent({ paneId: paneId_1, indicator: indicator, feature: feature })\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n                var finalColor = active ? (activeColor !== null && activeColor !== void 0 ? activeColor : color) : color;\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n                var finalBackgroundColor = active ? (activeBackgroundColor !== null && activeBackgroundColor !== void 0 ? activeBackgroundColor : backgroundColor) : backgroundColor;\n                if (type === TooltipFeatureType.IconFont) {\n                    (_b = _this.createFigure({\n                        name: 'text',\n                        attrs: { text: iconFont.content, x: coordinate.x + marginLeft, y: coordinate.y + marginTop },\n                        styles: {\n                            paddingLeft: paddingLeft,\n                            paddingTop: paddingTop,\n                            paddingRight: paddingRight,\n                            paddingBottom: paddingBottom,\n                            borderRadius: borderRadius,\n                            size: size,\n                            family: iconFont.family,\n                            color: finalColor,\n                            backgroundColor: finalBackgroundColor\n                        }\n                    }, eventHandler)) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                    contentWidth = ctx.measureText(iconFont.content).width;\n                }\n                else {\n                    (_c = _this.createFigure({\n                        name: 'rect',\n                        attrs: { x: coordinate.x + marginLeft, y: coordinate.y + marginTop, width: size, height: size },\n                        styles: {\n                            paddingLeft: paddingLeft,\n                            paddingTop: paddingTop,\n                            paddingRight: paddingRight,\n                            paddingBottom: paddingBottom,\n                            color: finalBackgroundColor\n                        }\n                    }, eventHandler)) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n                    (_d = _this.createFigure({\n                        name: 'path',\n                        attrs: { path: path.path, x: coordinate.x + marginLeft + paddingLeft, y: coordinate.y + marginTop + paddingTop, width: size, height: size },\n                        styles: {\n                            style: path.style,\n                            lineWidth: path.lineWidth,\n                            color: finalColor\n                        }\n                    })) === null || _d === void 0 ? void 0 : _d.draw(ctx);\n                    contentWidth = size;\n                }\n                coordinate.x += (marginLeft + paddingLeft + contentWidth + paddingRight + marginRight);\n            });\n        }\n        return prevRowHeight;\n    };\n    IndicatorTooltipView.prototype.drawStandardTooltipLegends = function (ctx, legends, coordinate, left, prevRowHeight, maxWidth, styles) {\n        var _this = this;\n        if (legends.length > 0) {\n            var marginLeft_1 = styles.marginLeft, marginTop_1 = styles.marginTop, marginRight_1 = styles.marginRight, marginBottom_1 = styles.marginBottom, size_1 = styles.size, family_1 = styles.family, weight_1 = styles.weight;\n            ctx.font = createFont(size_1, weight_1, family_1);\n            legends.forEach(function (data) {\n                var _a, _b;\n                var title = data.title;\n                var value = data.value;\n                var titleTextWidth = ctx.measureText(title.text).width;\n                var valueTextWidth = ctx.measureText(value.text).width;\n                var totalTextWidth = titleTextWidth + valueTextWidth;\n                var h = marginTop_1 + size_1 + marginBottom_1;\n                if (coordinate.x + marginLeft_1 + totalTextWidth + marginRight_1 > maxWidth) {\n                    coordinate.x = left;\n                    coordinate.y += prevRowHeight;\n                    prevRowHeight = h;\n                }\n                else {\n                    prevRowHeight = Math.max(prevRowHeight, h);\n                }\n                if (title.text.length > 0) {\n                    (_a = _this.createFigure({\n                        name: 'text',\n                        attrs: { x: coordinate.x + marginLeft_1, y: coordinate.y + marginTop_1, text: title.text },\n                        styles: { color: title.color, size: size_1, family: family_1, weight: weight_1 }\n                    })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                }\n                (_b = _this.createFigure({\n                    name: 'text',\n                    attrs: { x: coordinate.x + marginLeft_1 + titleTextWidth, y: coordinate.y + marginTop_1, text: value.text },\n                    styles: { color: value.color, size: size_1, family: family_1, weight: weight_1 }\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                coordinate.x += (marginLeft_1 + totalTextWidth + marginRight_1);\n            });\n        }\n        return prevRowHeight;\n    };\n    IndicatorTooltipView.prototype.isDrawTooltip = function (crosshair, styles) {\n        var showRule = styles.showRule;\n        return showRule === TooltipShowRule.Always ||\n            (showRule === TooltipShowRule.FollowCross && isString(crosshair.paneId));\n    };\n    IndicatorTooltipView.prototype.getIndicatorTooltipData = function (indicator) {\n        var _a, _b;\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().indicator;\n        var tooltipStyles = styles.tooltip;\n        var name = tooltipStyles.showName ? indicator.shortName : '';\n        var calcParamsText = '';\n        if (tooltipStyles.showParams) {\n            var calcParams = indicator.calcParams;\n            if (calcParams.length > 0) {\n                calcParamsText = \"(\".concat(calcParams.join(','), \")\");\n            }\n        }\n        var tooltipData = { name: name, calcParamsText: calcParamsText, legends: [], features: tooltipStyles.features };\n        var dataIndex = chartStore.getCrosshair().dataIndex;\n        var result = indicator.result;\n        var customApi = chartStore.getCustomApi();\n        var decimalFold = chartStore.getDecimalFold();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var legends = [];\n        if (indicator.visible) {\n            var data_1 = (_b = (_a = result[dataIndex]) !== null && _a !== void 0 ? _a : result[dataIndex - 1]) !== null && _b !== void 0 ? _b : {};\n            eachFigures(indicator, dataIndex, styles, function (figure, figureStyles) {\n                if (isString(figure.title)) {\n                    var color = figureStyles.color;\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment  -- ignore\n                    var value = data_1[figure.key];\n                    if (isNumber(value)) {\n                        value = formatPrecision(value, indicator.precision);\n                        if (indicator.shouldFormatBigNumber) {\n                            value = customApi.formatBigNumber(value);\n                        }\n                        value = decimalFold.format(thousandsSeparator.format(value));\n                    }\n                    legends.push({ title: { text: figure.title, color: color }, value: { text: (value !== null && value !== void 0 ? value : tooltipStyles.defaultValue), color: color } });\n                }\n            });\n            tooltipData.legends = legends;\n        }\n        if (isFunction(indicator.createTooltipDataSource)) {\n            var widget = this.getWidget();\n            var pane = widget.getPane();\n            var chart = pane.getChart();\n            var _c = indicator.createTooltipDataSource({\n                chart: chart,\n                indicator: indicator,\n                crosshair: chartStore.getCrosshair(),\n                bounding: widget.getBounding(),\n                xAxis: pane.getChart().getXAxisPane().getAxisComponent(),\n                yAxis: pane.getAxisComponent()\n            }), customName = _c.name, customCalcParamsText = _c.calcParamsText, customLegends = _c.legends, customFeatures = _c.features;\n            if (isString(customName) && tooltipStyles.showName) {\n                tooltipData.name = customName;\n            }\n            if (isString(customCalcParamsText) && tooltipStyles.showParams) {\n                tooltipData.calcParamsText = customCalcParamsText;\n            }\n            if (isValid(customFeatures)) {\n                tooltipData.features = customFeatures;\n            }\n            if (isValid(customLegends) && indicator.visible) {\n                var optimizedLegends_1 = [];\n                var color_1 = styles.tooltip.text.color;\n                customLegends.forEach(function (data) {\n                    var title = { text: '', color: color_1 };\n                    if (isObject(data.title)) {\n                        title = data.title;\n                    }\n                    else {\n                        title.text = data.title;\n                    }\n                    var value = { text: '', color: color_1 };\n                    if (isObject(data.value)) {\n                        value = data.value;\n                    }\n                    else {\n                        value.text = data.value;\n                    }\n                    if (isNumber(Number(value.text))) {\n                        value.text = decimalFold.format(thousandsSeparator.format(value.text));\n                    }\n                    optimizedLegends_1.push({ title: title, value: value });\n                });\n                tooltipData.legends = optimizedLegends_1;\n            }\n        }\n        return tooltipData;\n    };\n    IndicatorTooltipView.prototype.classifyTooltipFeatures = function (features) {\n        var leftFeatures = [];\n        var middleFeatures = [];\n        var rightFeatures = [];\n        features.forEach(function (feature) {\n            switch (feature.position) {\n                case TooltipFeaturePosition.Left: {\n                    leftFeatures.push(feature);\n                    break;\n                }\n                case TooltipFeaturePosition.Middle: {\n                    middleFeatures.push(feature);\n                    break;\n                }\n                case TooltipFeaturePosition.Right: {\n                    rightFeatures.push(feature);\n                    break;\n                }\n            }\n        });\n        return [leftFeatures, middleFeatures, rightFeatures];\n    };\n    return IndicatorTooltipView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OverlayView = /** @class */ (function (_super) {\n    __extends(OverlayView, _super);\n    function OverlayView(widget) {\n        var _this = _super.call(this, widget) || this;\n        _this._initEvent();\n        return _this;\n    }\n    OverlayView.prototype._initEvent = function () {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var paneId = pane.getId();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        this.registerEvent('mouseMoveEvent', function (event) {\n            var _a;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isStart()) {\n                    chartStore.updateProgressOverlayInfo(paneId);\n                    progressOverlayPaneId = paneId;\n                }\n                var index = overlay.points.length - 1;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));\n                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: chart, overlay: overlay }, event));\n                }\n                return _this._figureMouseMoveEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */, index, { key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index), type: 'circle', attrs: {} })(event);\n            }\n            chartStore.setHoverOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */,\n                figureIndex: -1,\n                figure: null\n            }, event);\n            return false;\n        }).registerEvent('mouseClickEvent', function (event) {\n            var _a, _b;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isStart()) {\n                    chartStore.updateProgressOverlayInfo(paneId, true);\n                    progressOverlayPaneId = paneId;\n                }\n                var index = overlay.points.length - 1;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));\n                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: chart, overlay: overlay }, event));\n                    overlay.nextStep();\n                    if (!overlay.isDrawing()) {\n                        chartStore.progressOverlayComplete();\n                        (_b = overlay.onDrawEnd) === null || _b === void 0 ? void 0 : _b.call(overlay, __assign({ chart: chart, overlay: overlay }, event));\n                    }\n                }\n                return _this._figureMouseClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */, index, {\n                    key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                    type: 'circle',\n                    attrs: {}\n                })(event);\n            }\n            chartStore.setClickOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */,\n                figureIndex: -1,\n                figure: null\n            }, event);\n            return false;\n        }).registerEvent('mouseDoubleClickEvent', function (event) {\n            var _a;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.forceComplete();\n                    if (!overlay.isDrawing()) {\n                        chartStore.progressOverlayComplete();\n                        (_a = overlay.onDrawEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: chart, overlay: overlay }, event));\n                    }\n                }\n                var index = overlay.points.length - 1;\n                return _this._figureMouseClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */, index, {\n                    key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                    type: 'circle',\n                    attrs: {}\n                })(event);\n            }\n            return false;\n        }).registerEvent('mouseRightClickEvent', function (event) {\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                if (overlay.isDrawing()) {\n                    var index = overlay.points.length - 1;\n                    return _this._figureMouseRightClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */, index, {\n                        key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                        type: 'circle',\n                        attrs: {}\n                    })(event);\n                }\n            }\n            return false;\n        }).registerEvent('mouseUpEvent', function (event) {\n            var _a;\n            var _b = chartStore.getPressedOverlayInfo(), overlay = _b.overlay, figure = _b.figure;\n            if (overlay !== null) {\n                if (checkOverlayFigureEvent('onPressedMoveEnd', figure)) {\n                    (_a = overlay.onPressedMoveEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: chart, overlay: overlay, figure: figure !== null && figure !== void 0 ? figure : undefined }, event));\n                }\n            }\n            chartStore.setPressedOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */,\n                figureIndex: -1,\n                figure: null\n            });\n            return false;\n        }).registerEvent('pressedMouseMoveEvent', function (event) {\n            var _a, _b;\n            var _c = chartStore.getPressedOverlayInfo(), overlay = _c.overlay, figureType = _c.figureType, figureIndex = _c.figureIndex, figure = _c.figure;\n            if (overlay !== null) {\n                if (checkOverlayFigureEvent('onPressedMoving', figure)) {\n                    if (!overlay.lock) {\n                        if (!((_b = (_a = overlay.onPressedMoving) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: chart, overlay: overlay, figure: figure !== null && figure !== void 0 ? figure : undefined }, event))) !== null && _b !== void 0 ? _b : false)) {\n                            var point = _this._coordinateToPoint(overlay, event);\n                            if (figureType === 1 /* EventOverlayInfoFigureType.Point */) {\n                                overlay.eventPressedPointMove(point, figureIndex);\n                            }\n                            else {\n                                overlay.eventPressedOtherMove(point, _this.getWidget().getPane().getChart().getChartStore());\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        });\n    };\n    OverlayView.prototype._createFigureEvents = function (overlay, figureType, figureIndex, figure) {\n        if (overlay.isDrawing()) {\n            return null;\n        }\n        return {\n            mouseMoveEvent: this._figureMouseMoveEvent(overlay, figureType, figureIndex, figure),\n            mouseDownEvent: this._figureMouseDownEvent(overlay, figureType, figureIndex, figure),\n            mouseClickEvent: this._figureMouseClickEvent(overlay, figureType, figureIndex, figure),\n            mouseRightClickEvent: this._figureMouseRightClickEvent(overlay, figureType, figureIndex, figure),\n            mouseDoubleClickEvent: this._figureMouseDoubleClickEvent(overlay, figureType, figureIndex, figure)\n        };\n    };\n    OverlayView.prototype._figureMouseMoveEvent = function (overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function (event) {\n            var pane = _this.getWidget().getPane();\n            pane.getChart().getChartStore().setHoverOverlayInfo({ paneId: pane.getId(), overlay: overlay, figureType: figureType, figure: figure, figureIndex: figureIndex }, event);\n            return checkOverlayFigureEvent('onMouseEnter', figure) && !overlay.isDrawing();\n        };\n    };\n    OverlayView.prototype._figureMouseDownEvent = function (overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function (event) {\n            var _a;\n            var pane = _this.getWidget().getPane();\n            var paneId = pane.getId();\n            overlay.startPressedMove(_this._coordinateToPoint(overlay, event));\n            if (checkOverlayFigureEvent('onPressedMoveStart', figure)) {\n                (_a = overlay.onPressedMoveStart) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: pane.getChart(), overlay: overlay, figure: figure }, event));\n                pane.getChart().getChartStore().setPressedOverlayInfo({ paneId: paneId, overlay: overlay, figureType: figureType, figureIndex: figureIndex, figure: figure });\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._figureMouseClickEvent = function (overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function (event) {\n            var pane = _this.getWidget().getPane();\n            var paneId = pane.getId();\n            pane.getChart().getChartStore().setClickOverlayInfo({ paneId: paneId, overlay: overlay, figureType: figureType, figureIndex: figureIndex, figure: figure }, event);\n            return checkOverlayFigureEvent('onClick', figure) && !overlay.isDrawing();\n        };\n    };\n    OverlayView.prototype._figureMouseDoubleClickEvent = function (overlay, _figureType, _figureIndex, figure) {\n        var _this = this;\n        return function (event) {\n            var _a;\n            if (checkOverlayFigureEvent('onDoubleClick', figure)) {\n                (_a = overlay.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({}, event), { chart: _this.getWidget().getPane().getChart(), figure: figure, overlay: overlay }));\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._figureMouseRightClickEvent = function (overlay, _figureType, _figureIndex, figure) {\n        var _this = this;\n        return function (event) {\n            var _a, _b;\n            if (checkOverlayFigureEvent('onRightClick', figure)) {\n                if (!((_b = (_a = overlay.onRightClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: _this.getWidget().getPane().getChart(), overlay: overlay, figure: figure }, event))) !== null && _b !== void 0 ? _b : false)) {\n                    _this.getWidget().getPane().getChart().getChartStore().removeOverlay(overlay);\n                }\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._coordinateToPoint = function (o, coordinate) {\n        var _a;\n        var point = {};\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var paneId = pane.getId();\n        var chartStore = chart.getChartStore();\n        if (this.coordinateToPointTimestampDataIndexFlag()) {\n            var xAxis = chart.getXAxisPane().getAxisComponent();\n            var dataIndex = xAxis.convertFromPixel(coordinate.x);\n            var timestamp = (_a = chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n            point.timestamp = timestamp;\n            point.dataIndex = dataIndex;\n        }\n        if (this.coordinateToPointValueFlag()) {\n            var yAxis = pane.getAxisComponent();\n            var value = yAxis.convertFromPixel(coordinate.y);\n            if (o.mode !== OverlayMode.Normal && paneId === PaneIdConstants.CANDLE && isNumber(point.dataIndex)) {\n                var kLineData = chartStore.getDataByDataIndex(point.dataIndex);\n                if (kLineData !== null) {\n                    var modeSensitivity = o.modeSensitivity;\n                    if (value > kLineData.high) {\n                        if (o.mode === OverlayMode.WeakMagnet) {\n                            var highY = yAxis.convertToPixel(kLineData.high);\n                            var buffValue = yAxis.convertFromPixel(highY - modeSensitivity);\n                            if (value < buffValue) {\n                                value = kLineData.high;\n                            }\n                        }\n                        else {\n                            value = kLineData.high;\n                        }\n                    }\n                    else if (value < kLineData.low) {\n                        if (o.mode === OverlayMode.WeakMagnet) {\n                            var lowY = yAxis.convertToPixel(kLineData.low);\n                            var buffValue = yAxis.convertFromPixel(lowY - modeSensitivity);\n                            if (value > buffValue) {\n                                value = kLineData.low;\n                            }\n                        }\n                        else {\n                            value = kLineData.low;\n                        }\n                    }\n                    else {\n                        var max = Math.max(kLineData.open, kLineData.close);\n                        var min = Math.min(kLineData.open, kLineData.close);\n                        if (value > max) {\n                            if (value - max < kLineData.high - value) {\n                                value = max;\n                            }\n                            else {\n                                value = kLineData.high;\n                            }\n                        }\n                        else if (value < min) {\n                            if (value - kLineData.low < min - value) {\n                                value = kLineData.low;\n                            }\n                            else {\n                                value = min;\n                            }\n                        }\n                        else if (max - value < value - min) {\n                            value = max;\n                        }\n                        else {\n                            value = min;\n                        }\n                    }\n                }\n            }\n            point.value = value;\n        }\n        return point;\n    };\n    OverlayView.prototype.coordinateToPointValueFlag = function () {\n        return true;\n    };\n    OverlayView.prototype.coordinateToPointTimestampDataIndexFlag = function () {\n        return true;\n    };\n    OverlayView.prototype.dispatchEvent = function (name, event, other) {\n        if (this.getWidget().getPane().getChart().getChartStore().isOverlayDrawing()) {\n            return this.onEvent(name, event, other);\n        }\n        return _super.prototype.dispatchEvent.call(this, name, event, other);\n    };\n    OverlayView.prototype.checkEventOn = function () {\n        return true;\n    };\n    OverlayView.prototype.drawImp = function (ctx) {\n        var _this = this;\n        var overlays = this.getCompleteOverlays();\n        overlays.forEach(function (overlay) {\n            if (overlay.visible) {\n                _this._drawOverlay(ctx, overlay);\n            }\n        });\n        var progressOverlay = this.getProgressOverlay();\n        if (isValid(progressOverlay) && progressOverlay.visible) {\n            this._drawOverlay(ctx, progressOverlay);\n        }\n    };\n    OverlayView.prototype._drawOverlay = function (ctx, overlay) {\n        var points = overlay.points;\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var coordinates = points.map(function (point) {\n            var _a;\n            var dataIndex = null;\n            if (isNumber(point.timestamp)) {\n                dataIndex = chartStore.timestampToDataIndex(point.timestamp);\n            }\n            var coordinate = { x: 0, y: 0 };\n            if (isNumber(dataIndex)) {\n                coordinate.x = xAxis.convertToPixel(dataIndex);\n            }\n            if (isNumber(point.value)) {\n                coordinate.y = (_a = yAxis === null || yAxis === void 0 ? void 0 : yAxis.convertToPixel(point.value)) !== null && _a !== void 0 ? _a : 0;\n            }\n            return coordinate;\n        });\n        if (coordinates.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            var figures = [].concat(this.getFigures(overlay, coordinates));\n            this.drawFigures(ctx, overlay, figures);\n        }\n        this.drawDefaultFigures(ctx, overlay, coordinates);\n    };\n    OverlayView.prototype.drawFigures = function (ctx, overlay, figures) {\n        var _this = this;\n        var defaultStyles = this.getWidget().getPane().getChart().getStyles().overlay;\n        figures.forEach(function (figure, figureIndex) {\n            var type = figure.type, styles = figure.styles, attrs = figure.attrs;\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            var attrsArray = [].concat(attrs);\n            attrsArray.forEach(function (ats) {\n                var _a, _b;\n                var events = _this._createFigureEvents(overlay, 2 /* EventOverlayInfoFigureType.Other */, figureIndex, figure);\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                var ss = __assign(__assign(__assign({}, defaultStyles[type]), (_a = overlay.styles) === null || _a === void 0 ? void 0 : _a[type]), styles);\n                (_b = _this.createFigure({\n                    name: type, attrs: ats, styles: ss\n                }, events !== null && events !== void 0 ? events : undefined)) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            });\n        });\n    };\n    OverlayView.prototype.getCompleteOverlays = function () {\n        var pane = this.getWidget().getPane();\n        return pane.getChart().getChartStore().getOverlaysByPaneId(pane.getId());\n    };\n    OverlayView.prototype.getProgressOverlay = function () {\n        var pane = this.getWidget().getPane();\n        var info = pane.getChart().getChartStore().getProgressOverlayInfo();\n        if (isValid(info) && info.paneId === pane.getId()) {\n            return info.overlay;\n        }\n        return null;\n    };\n    OverlayView.prototype.getFigures = function (o, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = o.createPointFigures) === null || _a === void 0 ? void 0 : _a.call(o, { chart: chart, overlay: o, coordinates: coordinates, bounding: bounding, xAxis: xAxis, yAxis: yAxis })) !== null && _b !== void 0 ? _b : [];\n    };\n    OverlayView.prototype.drawDefaultFigures = function (ctx, overlay, coordinates) {\n        var _this = this;\n        var _a, _b;\n        if (overlay.needDefaultPointFigure) {\n            var chartStore = this.getWidget().getPane().getChart().getChartStore();\n            var hoverOverlayInfo_1 = chartStore.getHoverOverlayInfo();\n            var clickOverlayInfo = chartStore.getClickOverlayInfo();\n            if ((((_a = hoverOverlayInfo_1.overlay) === null || _a === void 0 ? void 0 : _a.id) === overlay.id && hoverOverlayInfo_1.figureType !== 0 /* EventOverlayInfoFigureType.None */) ||\n                (((_b = clickOverlayInfo.overlay) === null || _b === void 0 ? void 0 : _b.id) === overlay.id && clickOverlayInfo.figureType !== 0 /* EventOverlayInfoFigureType.None */)) {\n                var defaultStyles = chartStore.getStyles().overlay;\n                var styles = overlay.styles;\n                var pointStyles_1 = __assign(__assign({}, defaultStyles.point), styles === null || styles === void 0 ? void 0 : styles.point);\n                coordinates.forEach(function (_a, index) {\n                    var _b, _c, _d, _e, _f;\n                    var x = _a.x, y = _a.y;\n                    var radius = pointStyles_1.radius;\n                    var color = pointStyles_1.color;\n                    var borderColor = pointStyles_1.borderColor;\n                    var borderSize = pointStyles_1.borderSize;\n                    if (((_b = hoverOverlayInfo_1.overlay) === null || _b === void 0 ? void 0 : _b.id) === overlay.id &&\n                        hoverOverlayInfo_1.figureType === 1 /* EventOverlayInfoFigureType.Point */ &&\n                        ((_c = hoverOverlayInfo_1.figure) === null || _c === void 0 ? void 0 : _c.key) === \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index)) {\n                        radius = pointStyles_1.activeRadius;\n                        color = pointStyles_1.activeColor;\n                        borderColor = pointStyles_1.activeBorderColor;\n                        borderSize = pointStyles_1.activeBorderSize;\n                    }\n                    (_e = _this.createFigure({\n                        name: 'circle',\n                        attrs: { x: x, y: y, r: radius + borderSize },\n                        styles: { color: borderColor }\n                    }, (_d = _this._createFigureEvents(overlay, 1 /* EventOverlayInfoFigureType.Point */, index, {\n                        key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                        type: 'circle',\n                        attrs: { x: x, y: y, r: radius + borderSize },\n                        styles: { color: borderColor }\n                    })) !== null && _d !== void 0 ? _d : undefined)) === null || _e === void 0 ? void 0 : _e.draw(ctx);\n                    (_f = _this.createFigure({\n                        name: 'circle',\n                        attrs: { x: x, y: y, r: radius },\n                        styles: { color: color }\n                    })) === null || _f === void 0 ? void 0 : _f.draw(ctx);\n                });\n            }\n        }\n    };\n    return OverlayView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorWidget = /** @class */ (function (_super) {\n    __extends(IndicatorWidget, _super);\n    function IndicatorWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._gridView = new GridView(_this);\n        _this._indicatorView = new IndicatorView(_this);\n        _this._crosshairLineView = new CrosshairLineView(_this);\n        _this._tooltipView = _this.createTooltipView();\n        _this._overlayView = new OverlayView(_this);\n        _this.addChild(_this._tooltipView);\n        _this.addChild(_this._overlayView);\n        _this.getContainer().style.cursor = 'crosshair';\n        return _this;\n    }\n    IndicatorWidget.prototype.getName = function () {\n        return WidgetNameConstants.MAIN;\n    };\n    IndicatorWidget.prototype.updateMain = function (ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */) {\n            this.updateMainContent(ctx);\n            this._indicatorView.draw(ctx);\n            this._gridView.draw(ctx);\n        }\n    };\n    IndicatorWidget.prototype.createTooltipView = function () {\n        return new IndicatorTooltipView(this);\n    };\n    IndicatorWidget.prototype.updateMainContent = function (_ctx) {\n        // to do it\n    };\n    IndicatorWidget.prototype.updateOverlay = function (ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */) {\n            this._overlayView.draw(ctx);\n            this._crosshairLineView.draw(ctx);\n        }\n        this._tooltipView.draw(ctx);\n    };\n    return IndicatorWidget;\n}(DrawWidget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleAreaView = /** @class */ (function (_super) {\n    __extends(CandleAreaView, _super);\n    function CandleAreaView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._ripplePoint = _this.createFigure({\n            name: 'circle',\n            attrs: {\n                x: 0,\n                y: 0,\n                r: 0\n            },\n            styles: {\n                style: 'fill'\n            }\n        });\n        _this._animationFrameTime = 0;\n        _this._animation = new Animation({ iterationCount: Infinity }).doFrame(function (time) {\n            _this._animationFrameTime = time;\n            var pane = _this.getWidget().getPane();\n            pane.getChart().updatePane(0 /* UpdateLevel.Main */, pane.getId());\n        });\n        return _this;\n    }\n    CandleAreaView.prototype.drawImp = function (ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var dataList = chart.getDataList();\n        var lastDataIndex = dataList.length - 1;\n        var bounding = widget.getBounding();\n        var yAxis = pane.getAxisComponent();\n        var styles = chart.getStyles().candle.area;\n        var coordinates = [];\n        var minY = Number.MAX_SAFE_INTEGER;\n        var areaStartX = Number.MIN_SAFE_INTEGER;\n        var ripplePointCoordinate = null;\n        this.eachChildren(function (data) {\n            var x = data.x;\n            var kLineData = data.data.current;\n            var value = kLineData === null || kLineData === void 0 ? void 0 : kLineData[styles.value];\n            if (isNumber(value)) {\n                var y = yAxis.convertToPixel(value);\n                if (areaStartX === Number.MIN_SAFE_INTEGER) {\n                    areaStartX = x;\n                }\n                coordinates.push({ x: x, y: y });\n                minY = Math.min(minY, y);\n                if (data.dataIndex === lastDataIndex) {\n                    ripplePointCoordinate = { x: x, y: y };\n                }\n            }\n        });\n        if (coordinates.length > 0) {\n            (_a = this.createFigure({\n                name: 'line',\n                attrs: { coordinates: coordinates },\n                styles: {\n                    color: styles.lineColor,\n                    size: styles.lineSize,\n                    smooth: styles.smooth\n                }\n            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            // render area\n            var backgroundColor = styles.backgroundColor;\n            var color = '';\n            if (isArray(backgroundColor)) {\n                var gradient_1 = ctx.createLinearGradient(0, bounding.height, 0, minY);\n                try {\n                    backgroundColor.forEach(function (_a) {\n                        var offset = _a.offset, color = _a.color;\n                        gradient_1.addColorStop(offset, color);\n                    });\n                }\n                catch (e) {\n                }\n                color = gradient_1;\n            }\n            else {\n                color = backgroundColor;\n            }\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            ctx.moveTo(areaStartX, bounding.height);\n            ctx.lineTo(coordinates[0].x, coordinates[0].y);\n            lineTo(ctx, coordinates, styles.smooth);\n            ctx.lineTo(coordinates[coordinates.length - 1].x, bounding.height);\n            ctx.closePath();\n            ctx.fill();\n        }\n        var pointStyles = styles.point;\n        if (pointStyles.show && isValid(ripplePointCoordinate)) {\n            (_b = this.createFigure({\n                name: 'circle',\n                attrs: {\n                    x: ripplePointCoordinate.x,\n                    y: ripplePointCoordinate.y,\n                    r: pointStyles.radius\n                },\n                styles: {\n                    style: 'fill',\n                    color: pointStyles.color\n                }\n            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            var rippleRadius = pointStyles.rippleRadius;\n            if (pointStyles.animation) {\n                rippleRadius = pointStyles.radius + this._animationFrameTime / pointStyles.animationDuration * (pointStyles.rippleRadius - pointStyles.radius);\n                this._animation.setDuration(pointStyles.animationDuration).start();\n            }\n            (_c = this._ripplePoint) === null || _c === void 0 ? void 0 : _c.setAttrs({\n                x: ripplePointCoordinate.x,\n                y: ripplePointCoordinate.y,\n                r: rippleRadius\n            }).setStyles({ style: 'fill', color: pointStyles.rippleColor }).draw(ctx);\n        }\n        else {\n            this.stopAnimation();\n        }\n    };\n    CandleAreaView.prototype.stopAnimation = function () {\n        this._animation.stop();\n    };\n    return CandleAreaView;\n}(ChildrenView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleHighLowPriceView = /** @class */ (function (_super) {\n    __extends(CandleHighLowPriceView, _super);\n    function CandleHighLowPriceView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleHighLowPriceView.prototype.drawImp = function (ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var highPriceMarkStyles = priceMarkStyles.high;\n        var lowPriceMarkStyles = priceMarkStyles.low;\n        if (priceMarkStyles.show && (highPriceMarkStyles.show || lowPriceMarkStyles.show)) {\n            var highestLowestPrice = chartStore.getVisibleRangeHighLowPrice();\n            var precision = chartStore.getPrecision();\n            var yAxis = pane.getAxisComponent();\n            var _a = highestLowestPrice[0], high = _a.price, highX = _a.x;\n            var _b = highestLowestPrice[1], low = _b.price, lowX = _b.x;\n            var highY = yAxis.convertToPixel(high);\n            var lowY = yAxis.convertToPixel(low);\n            var decimalFold = chartStore.getDecimalFold();\n            var thousandsSeparator = chartStore.getThousandsSeparator();\n            if (highPriceMarkStyles.show && high !== Number.MIN_SAFE_INTEGER) {\n                this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(high, precision.price))), { x: highX, y: highY }, highY < lowY ? [-2, -5] : [2, 5], highPriceMarkStyles);\n            }\n            if (lowPriceMarkStyles.show && low !== Number.MAX_SAFE_INTEGER) {\n                this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(low, precision.price))), { x: lowX, y: lowY }, highY < lowY ? [2, 5] : [-2, -5], lowPriceMarkStyles);\n            }\n        }\n    };\n    CandleHighLowPriceView.prototype._drawMark = function (ctx, text, coordinate, offsets, styles) {\n        var _a, _b, _c;\n        var startX = coordinate.x;\n        var startY = coordinate.y + offsets[0];\n        (_a = this.createFigure({\n            name: 'line',\n            attrs: {\n                coordinates: [\n                    { x: startX - 2, y: startY + offsets[0] },\n                    { x: startX, y: startY },\n                    { x: startX + 2, y: startY + offsets[0] }\n                ]\n            },\n            styles: { color: styles.color }\n        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n        var lineEndX = 0;\n        var textStartX = 0;\n        var textAlign = 'left';\n        var width = this.getWidget().getBounding().width;\n        if (startX > width / 2) {\n            lineEndX = startX - 5;\n            textStartX = lineEndX - styles.textOffset;\n            textAlign = 'right';\n        }\n        else {\n            lineEndX = startX + 5;\n            textAlign = 'left';\n            textStartX = lineEndX + styles.textOffset;\n        }\n        var y = startY + offsets[1];\n        (_b = this.createFigure({\n            name: 'line',\n            attrs: {\n                coordinates: [\n                    { x: startX, y: startY },\n                    { x: startX, y: y },\n                    { x: lineEndX, y: y }\n                ]\n            },\n            styles: { color: styles.color }\n        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n        (_c = this.createFigure({\n            name: 'text',\n            attrs: {\n                x: textStartX,\n                y: y,\n                text: text,\n                align: textAlign,\n                baseline: 'middle'\n            },\n            styles: {\n                color: styles.color,\n                size: styles.textSize,\n                family: styles.textFamily,\n                weight: styles.textWeight\n            }\n        })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n    };\n    return CandleHighLowPriceView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleLastPriceView = /** @class */ (function (_super) {\n    __extends(CandleLastPriceView, _super);\n    function CandleLastPriceView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleLastPriceView.prototype.drawImp = function (ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var lastPriceMarkStyles = priceMarkStyles.last;\n        var lastPriceMarkLineStyles = lastPriceMarkStyles.line;\n        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkLineStyles.show) {\n            var yAxis = pane.getAxisComponent();\n            var dataList = chartStore.getDataList();\n            var data = dataList[dataList.length - 1];\n            if (isValid(data)) {\n                var close_1 = data.close, open_1 = data.open;\n                var comparePrice = lastPriceMarkStyles.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : ((_b = (_a = dataList[dataList.length - 2]) === null || _a === void 0 ? void 0 : _a.close) !== null && _b !== void 0 ? _b : close_1);\n                var priceY = yAxis.convertToNicePixel(close_1);\n                var color = '';\n                if (close_1 > comparePrice) {\n                    color = lastPriceMarkStyles.upColor;\n                }\n                else if (close_1 < comparePrice) {\n                    color = lastPriceMarkStyles.downColor;\n                }\n                else {\n                    color = lastPriceMarkStyles.noChangeColor;\n                }\n                (_c = this.createFigure({\n                    name: 'line',\n                    attrs: {\n                        coordinates: [\n                            { x: 0, y: priceY },\n                            { x: bounding.width, y: priceY }\n                        ]\n                    },\n                    styles: {\n                        style: lastPriceMarkLineStyles.style,\n                        color: color,\n                        size: lastPriceMarkLineStyles.size,\n                        dashedValue: lastPriceMarkLineStyles.dashedValue\n                    }\n                })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n            }\n        }\n    };\n    return CandleLastPriceView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar AxisPosition;\n(function (AxisPosition) {\n    AxisPosition[\"Left\"] = \"left\";\n    AxisPosition[\"Right\"] = \"right\";\n})(AxisPosition || (AxisPosition = {}));\nfunction getDefaultAxisRange() {\n    return {\n        from: 0,\n        to: 0,\n        range: 0,\n        realFrom: 0,\n        realTo: 0,\n        realRange: 0,\n        displayFrom: 0,\n        displayTo: 0,\n        displayRange: 0\n    };\n}\nvar AxisImp = /** @class */ (function () {\n    function AxisImp(parent) {\n        this.scrollZoomEnabled = true;\n        this._range = getDefaultAxisRange();\n        this._prevRange = getDefaultAxisRange();\n        this._ticks = [];\n        this._autoCalcTickFlag = true;\n        this._parent = parent;\n    }\n    AxisImp.prototype.getParent = function () { return this._parent; };\n    AxisImp.prototype.buildTicks = function (force) {\n        if (this._autoCalcTickFlag) {\n            this._range = this.createRangeImp();\n        }\n        if (this._prevRange.from !== this._range.from || this._prevRange.to !== this._range.to || force) {\n            this._prevRange = this._range;\n            this._ticks = this.createTicksImp();\n            return true;\n        }\n        return false;\n    };\n    AxisImp.prototype.getTicks = function () {\n        return this._ticks;\n    };\n    AxisImp.prototype.setRange = function (range) {\n        this._autoCalcTickFlag = false;\n        this._range = range;\n    };\n    AxisImp.prototype.getRange = function () { return this._range; };\n    AxisImp.prototype.setAutoCalcTickFlag = function (flag) {\n        this._autoCalcTickFlag = flag;\n    };\n    AxisImp.prototype.getAutoCalcTickFlag = function () { return this._autoCalcTickFlag; };\n    return AxisImp;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar zhCN = {\n    time: '时间：',\n    open: '开：',\n    high: '高：',\n    low: '低：',\n    close: '收：',\n    volume: '成交量：',\n    turnover: '成交额：',\n    change: '涨幅：'\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar enUS = {\n    time: 'Time: ',\n    open: 'Open: ',\n    high: 'High: ',\n    low: 'Low: ',\n    close: 'Close: ',\n    volume: 'Volume: ',\n    turnover: 'Turnover: ',\n    change: 'Change: '\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar locales = {\n    'zh-CN': zhCN,\n    'en-US': enUS\n};\nfunction registerLocale(locale, ls) {\n    locales[locale] = __assign(__assign({}, locales[locale]), ls);\n}\nfunction getSupportedLocales() {\n    return Object.keys(locales);\n}\nfunction i18n(key, locale) {\n    var _a;\n    return (_a = locales[locale][key]) !== null && _a !== void 0 ? _a : key;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleTooltipView = /** @class */ (function (_super) {\n    __extends(CandleTooltipView, _super);\n    function CandleTooltipView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleTooltipView.prototype.drawImp = function (ctx) {\n        var widget = this.getWidget();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        if (isValid(crosshair.kLineData)) {\n            var bounding = widget.getBounding();\n            var styles = chartStore.getStyles();\n            var candleStyles = styles.candle;\n            var indicatorStyles = styles.indicator;\n            if (candleStyles.tooltip.showType === TooltipShowType.Rect &&\n                indicatorStyles.tooltip.showType === TooltipShowType.Rect) {\n                var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);\n                var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);\n                this._drawRectTooltip(ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, candleStyles.tooltip.offsetTop);\n            }\n            else if (candleStyles.tooltip.showType === TooltipShowType.Standard &&\n                indicatorStyles.tooltip.showType === TooltipShowType.Standard) {\n                var _a = candleStyles.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_1 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                this.drawIndicatorTooltip(ctx, offsetLeft, top_1, maxWidth);\n            }\n            else if (candleStyles.tooltip.showType === TooltipShowType.Rect &&\n                indicatorStyles.tooltip.showType === TooltipShowType.Standard) {\n                var _b = candleStyles.tooltip, offsetLeft = _b.offsetLeft, offsetTop = _b.offsetTop, offsetRight = _b.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_2 = this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);\n                this._drawRectTooltip(ctx, isDrawCandleTooltip, false, top_2);\n            }\n            else {\n                var _c = candleStyles.tooltip, offsetLeft = _c.offsetLeft, offsetTop = _c.offsetTop, offsetRight = _c.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_3 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);\n                this._drawRectTooltip(ctx, false, isDrawIndicatorTooltip, top_3);\n            }\n        }\n    };\n    CandleTooltipView.prototype._drawCandleStandardTooltip = function (ctx, left, top, maxWidth) {\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().candle;\n        var tooltipStyles = styles.tooltip;\n        var tooltipTextStyles = tooltipStyles.text;\n        var prevRowHeight = 0;\n        var coordinate = { x: left, y: top };\n        var crosshair = chartStore.getCrosshair();\n        if (this.isDrawTooltip(crosshair, tooltipStyles)) {\n            var legends = this._getCandleTooltipLegends();\n            var _a = __read(this.classifyTooltipFeatures(tooltipStyles.features), 3), leftFeatures = _a[0], middleFeatures = _a[1], rightFeatures = _a[2];\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, leftFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, middleFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n            if (legends.length > 0) {\n                prevRowHeight = this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipTextStyles);\n            }\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, rightFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n        }\n        return coordinate.y + prevRowHeight;\n    };\n    CandleTooltipView.prototype._drawRectTooltip = function (ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, top) {\n        var _this = this;\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var styles = chartStore.getStyles();\n        var candleStyles = styles.candle;\n        var indicatorStyles = styles.indicator;\n        var candleTooltipStyles = candleStyles.tooltip;\n        var indicatorTooltipStyles = indicatorStyles.tooltip;\n        if (isDrawCandleTooltip || isDrawIndicatorTooltip) {\n            var candleLegends = this._getCandleTooltipLegends();\n            var offsetLeft = candleTooltipStyles.offsetLeft, offsetTop = candleTooltipStyles.offsetTop, offsetRight = candleTooltipStyles.offsetRight, offsetBottom = candleTooltipStyles.offsetBottom;\n            var _c = candleTooltipStyles.text, baseTextMarginLeft_1 = _c.marginLeft, baseTextMarginRight_1 = _c.marginRight, baseTextMarginTop_1 = _c.marginTop, baseTextMarginBottom_1 = _c.marginBottom, baseTextSize_1 = _c.size, baseTextWeight_1 = _c.weight, baseTextFamily_1 = _c.family;\n            var _d = candleTooltipStyles.rect, rectPosition = _d.position, rectPaddingLeft = _d.paddingLeft, rectPaddingRight_1 = _d.paddingRight, rectPaddingTop = _d.paddingTop, rectPaddingBottom = _d.paddingBottom, rectOffsetLeft = _d.offsetLeft, rectOffsetRight = _d.offsetRight, rectOffsetTop = _d.offsetTop, rectOffsetBottom = _d.offsetBottom, rectBorderSize_1 = _d.borderSize, rectBorderRadius = _d.borderRadius, rectBorderColor = _d.borderColor, rectBackgroundColor = _d.color;\n            var maxTextWidth_1 = 0;\n            var rectWidth_1 = 0;\n            var rectHeight_1 = 0;\n            if (isDrawCandleTooltip) {\n                ctx.font = createFont(baseTextSize_1, baseTextWeight_1, baseTextFamily_1);\n                candleLegends.forEach(function (data) {\n                    var title = data.title;\n                    var value = data.value;\n                    var text = \"\".concat(title.text).concat(value.text);\n                    var labelWidth = ctx.measureText(text).width + baseTextMarginLeft_1 + baseTextMarginRight_1;\n                    maxTextWidth_1 = Math.max(maxTextWidth_1, labelWidth);\n                });\n                rectHeight_1 += ((baseTextMarginBottom_1 + baseTextMarginTop_1 + baseTextSize_1) * candleLegends.length);\n            }\n            var _e = indicatorTooltipStyles.text, indicatorTextMarginLeft_1 = _e.marginLeft, indicatorTextMarginRight_1 = _e.marginRight, indicatorTextMarginTop_1 = _e.marginTop, indicatorTextMarginBottom_1 = _e.marginBottom, indicatorTextSize_1 = _e.size, indicatorTextWeight_1 = _e.weight, indicatorTextFamily_1 = _e.family;\n            var indicatorLegendsArray_1 = [];\n            if (isDrawIndicatorTooltip) {\n                var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n                ctx.font = createFont(indicatorTextSize_1, indicatorTextWeight_1, indicatorTextFamily_1);\n                indicators.forEach(function (indicator) {\n                    var tooltipDataLegends = _this.getIndicatorTooltipData(indicator).legends;\n                    indicatorLegendsArray_1.push(tooltipDataLegends);\n                    tooltipDataLegends.forEach(function (data) {\n                        var title = data.title;\n                        var value = data.value;\n                        var text = \"\".concat(title.text).concat(value.text);\n                        var textWidth = ctx.measureText(text).width + indicatorTextMarginLeft_1 + indicatorTextMarginRight_1;\n                        maxTextWidth_1 = Math.max(maxTextWidth_1, textWidth);\n                        rectHeight_1 += (indicatorTextMarginTop_1 + indicatorTextMarginBottom_1 + indicatorTextSize_1);\n                    });\n                });\n            }\n            rectWidth_1 += maxTextWidth_1;\n            if (rectWidth_1 !== 0 && rectHeight_1 !== 0) {\n                var crosshair = chartStore.getCrosshair();\n                var bounding = widget.getBounding();\n                var yAxisBounding = pane.getYAxisWidget().getBounding();\n                rectWidth_1 += (rectBorderSize_1 * 2 + rectPaddingLeft + rectPaddingRight_1);\n                rectHeight_1 += (rectBorderSize_1 * 2 + rectPaddingTop + rectPaddingBottom);\n                var centerX = bounding.width / 2;\n                var isPointer = rectPosition === CandleTooltipRectPosition.Pointer && crosshair.paneId === PaneIdConstants.CANDLE;\n                var isLeft = ((_a = crosshair.realX) !== null && _a !== void 0 ? _a : 0) > centerX;\n                var rectX_1 = 0;\n                if (isPointer) {\n                    var realX = crosshair.realX;\n                    if (isLeft) {\n                        rectX_1 = realX - rectOffsetRight - rectWidth_1;\n                    }\n                    else {\n                        rectX_1 = realX + rectOffsetLeft;\n                    }\n                }\n                else {\n                    var yAxis = this.getWidget().getPane().getAxisComponent();\n                    if (isLeft) {\n                        rectX_1 = rectOffsetLeft + offsetLeft;\n                        if (yAxis.inside && yAxis.position === AxisPosition.Left) {\n                            rectX_1 += yAxisBounding.width;\n                        }\n                    }\n                    else {\n                        rectX_1 = bounding.width - rectOffsetRight - rectWidth_1 - offsetRight;\n                        if (yAxis.inside && yAxis.position === AxisPosition.Right) {\n                            rectX_1 -= yAxisBounding.width;\n                        }\n                    }\n                }\n                var rectY = top + rectOffsetTop;\n                if (isPointer) {\n                    var y = crosshair.y;\n                    rectY = y - rectHeight_1 / 2;\n                    if (rectY + rectHeight_1 > bounding.height - rectOffsetBottom - offsetBottom) {\n                        rectY = bounding.height - rectOffsetBottom - rectHeight_1 - offsetBottom;\n                    }\n                    if (rectY < top + rectOffsetTop) {\n                        rectY = top + rectOffsetTop + offsetTop;\n                    }\n                }\n                (_b = this.createFigure({\n                    name: 'rect',\n                    attrs: {\n                        x: rectX_1,\n                        y: rectY,\n                        width: rectWidth_1,\n                        height: rectHeight_1\n                    },\n                    styles: {\n                        style: PolygonType.StrokeFill,\n                        color: rectBackgroundColor,\n                        borderColor: rectBorderColor,\n                        borderSize: rectBorderSize_1,\n                        borderRadius: rectBorderRadius\n                    }\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                var candleTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + baseTextMarginLeft_1;\n                var textY_1 = rectY + rectBorderSize_1 + rectPaddingTop;\n                if (isDrawCandleTooltip) {\n                    // render candle texts\n                    candleLegends.forEach(function (data) {\n                        var _a, _b;\n                        textY_1 += baseTextMarginTop_1;\n                        var title = data.title;\n                        (_a = _this.createFigure({\n                            name: 'text',\n                            attrs: {\n                                x: candleTextX_1,\n                                y: textY_1,\n                                text: title.text\n                            },\n                            styles: {\n                                color: title.color,\n                                size: baseTextSize_1,\n                                family: baseTextFamily_1,\n                                weight: baseTextWeight_1\n                            }\n                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                        var value = data.value;\n                        (_b = _this.createFigure({\n                            name: 'text',\n                            attrs: {\n                                x: rectX_1 + rectWidth_1 - rectBorderSize_1 - baseTextMarginRight_1 - rectPaddingRight_1,\n                                y: textY_1,\n                                text: value.text,\n                                align: 'right'\n                            },\n                            styles: {\n                                color: value.color,\n                                size: baseTextSize_1,\n                                family: baseTextFamily_1,\n                                weight: baseTextWeight_1\n                            }\n                        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                        textY_1 += (baseTextSize_1 + baseTextMarginBottom_1);\n                    });\n                }\n                if (isDrawIndicatorTooltip) {\n                    // render indicator texts\n                    var indicatorTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + indicatorTextMarginLeft_1;\n                    indicatorLegendsArray_1.forEach(function (legends) {\n                        legends.forEach(function (data) {\n                            var _a, _b;\n                            textY_1 += indicatorTextMarginTop_1;\n                            var title = data.title;\n                            var value = data.value;\n                            (_a = _this.createFigure({\n                                name: 'text',\n                                attrs: {\n                                    x: indicatorTextX_1,\n                                    y: textY_1,\n                                    text: title.text\n                                },\n                                styles: {\n                                    color: title.color,\n                                    size: indicatorTextSize_1,\n                                    family: indicatorTextFamily_1,\n                                    weight: indicatorTextWeight_1\n                                }\n                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                            (_b = _this.createFigure({\n                                name: 'text',\n                                attrs: {\n                                    x: rectX_1 + rectWidth_1 - rectBorderSize_1 - indicatorTextMarginRight_1 - rectPaddingRight_1,\n                                    y: textY_1,\n                                    text: value.text,\n                                    align: 'right'\n                                },\n                                styles: {\n                                    color: value.color,\n                                    size: indicatorTextSize_1,\n                                    family: indicatorTextFamily_1,\n                                    weight: indicatorTextWeight_1\n                                }\n                            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                            textY_1 += (indicatorTextSize_1 + indicatorTextMarginBottom_1);\n                        });\n                    });\n                }\n            }\n        }\n    };\n    CandleTooltipView.prototype._getCandleTooltipLegends = function () {\n        var _a, _b, _c, _d, _e, _f;\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().candle;\n        var dataList = chartStore.getDataList();\n        var customApi = chartStore.getCustomApi();\n        var decimalFold = chartStore.getDecimalFold();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var locale = chartStore.getLocale();\n        var _g = chartStore.getPrecision(), pricePrecision = _g.price, volumePrecision = _g.volume;\n        var dataIndex = (_a = chartStore.getCrosshair().dataIndex) !== null && _a !== void 0 ? _a : 0;\n        var tooltipStyles = styles.tooltip;\n        var textColor = tooltipStyles.text.color;\n        var prev = (_b = dataList[dataIndex - 1]) !== null && _b !== void 0 ? _b : null;\n        var current = dataList[dataIndex];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        var prevClose = (_c = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _c !== void 0 ? _c : current.close;\n        var changeValue = current.close - prevClose;\n        var mapping = {\n            '{time}': customApi.formatDate(current.timestamp, 'YYYY-MM-DD HH:mm', FormatDateType.Tooltip),\n            '{open}': decimalFold.format(thousandsSeparator.format(formatPrecision(current.open, pricePrecision))),\n            '{high}': decimalFold.format(thousandsSeparator.format(formatPrecision(current.high, pricePrecision))),\n            '{low}': decimalFold.format(thousandsSeparator.format(formatPrecision(current.low, pricePrecision))),\n            '{close}': decimalFold.format(thousandsSeparator.format(formatPrecision(current.close, pricePrecision))),\n            '{volume}': decimalFold.format(thousandsSeparator.format(customApi.formatBigNumber(formatPrecision((_d = current.volume) !== null && _d !== void 0 ? _d : tooltipStyles.defaultValue, volumePrecision)))),\n            '{turnover}': decimalFold.format(thousandsSeparator.format(formatPrecision((_e = current.turnover) !== null && _e !== void 0 ? _e : tooltipStyles.defaultValue, pricePrecision))),\n            '{change}': prevClose === 0 ? tooltipStyles.defaultValue : \"\".concat(thousandsSeparator.format(formatPrecision(changeValue / prevClose * 100)), \"%\")\n        };\n        var legends = (isFunction(tooltipStyles.custom)\n            ? tooltipStyles.custom({ prev: prev, current: current, next: (_f = dataList[dataIndex + 1]) !== null && _f !== void 0 ? _f : null }, styles)\n            : tooltipStyles.custom);\n        return legends.map(function (_a) {\n            var _b;\n            var title = _a.title, value = _a.value;\n            var t = { text: '', color: textColor };\n            if (isObject(title)) {\n                t = __assign({}, title);\n            }\n            else {\n                t.text = title;\n            }\n            t.text = i18n(t.text, locale);\n            var v = { text: tooltipStyles.defaultValue, color: textColor };\n            if (isObject(value)) {\n                v = __assign({}, value);\n            }\n            else {\n                v.text = value;\n            }\n            var match = /{(\\S*)}/.exec(v.text);\n            if (match !== null && match.length > 1) {\n                var key = \"{\".concat(match[1], \"}\");\n                v.text = v.text.replace(key, ((_b = mapping[key]) !== null && _b !== void 0 ? _b : tooltipStyles.defaultValue));\n                if (key === '{change}') {\n                    v.color = changeValue === 0 ? styles.priceMark.last.noChangeColor : (changeValue > 0 ? styles.priceMark.last.upColor : styles.priceMark.last.downColor);\n                }\n            }\n            return { title: t, value: v };\n        });\n    };\n    return CandleTooltipView;\n}(IndicatorTooltipView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleWidget = /** @class */ (function (_super) {\n    __extends(CandleWidget, _super);\n    function CandleWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._candleBarView = new CandleBarView(_this);\n        _this._candleAreaView = new CandleAreaView(_this);\n        _this._candleHighLowPriceView = new CandleHighLowPriceView(_this);\n        _this._candleLastPriceLineView = new CandleLastPriceView(_this);\n        _this.addChild(_this._candleBarView);\n        return _this;\n    }\n    CandleWidget.prototype.updateMainContent = function (ctx) {\n        var candleStyles = this.getPane().getChart().getStyles().candle;\n        if (candleStyles.type !== CandleType.Area) {\n            this._candleBarView.draw(ctx);\n            this._candleHighLowPriceView.draw(ctx);\n            this._candleAreaView.stopAnimation();\n        }\n        else {\n            this._candleAreaView.draw(ctx);\n        }\n        this._candleLastPriceLineView.draw(ctx);\n    };\n    CandleWidget.prototype.createTooltipView = function () {\n        return new CandleTooltipView(this);\n    };\n    return CandleWidget;\n}(IndicatorWidget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar AxisView = /** @class */ (function (_super) {\n    __extends(AxisView, _super);\n    function AxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AxisView.prototype.drawImp = function (ctx, extend) {\n        var _this = this;\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var axis = pane.getAxisComponent();\n        var styles = this.getAxisStyles(pane.getChart().getStyles());\n        if (styles.show) {\n            if (styles.axisLine.show) {\n                (_a = this.createFigure({\n                    name: 'line',\n                    attrs: this.createAxisLine(bounding, styles),\n                    styles: styles.axisLine\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n            if (!extend[0]) {\n                var ticks = axis.getTicks();\n                if (styles.tickLine.show) {\n                    var lines = this.createTickLines(ticks, bounding, styles);\n                    lines.forEach(function (line) {\n                        var _a;\n                        (_a = _this.createFigure({\n                            name: 'line',\n                            attrs: line,\n                            styles: styles.tickLine\n                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                    });\n                }\n                if (styles.tickText.show) {\n                    var texts = this.createTickTexts(ticks, bounding, styles);\n                    (_b = this.createFigure({\n                        name: 'text',\n                        attrs: texts,\n                        styles: styles.tickText\n                    })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                }\n            }\n        }\n    };\n    return AxisView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar YAxisView = /** @class */ (function (_super) {\n    __extends(YAxisView, _super);\n    function YAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    YAxisView.prototype.getAxisStyles = function (styles) {\n        return styles.yAxis;\n    };\n    YAxisView.prototype.createAxisLine = function (bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var size = styles.axisLine.size;\n        var x = 0;\n        if (yAxis.isFromZero()) {\n            x = 0;\n        }\n        else {\n            x = bounding.width - size;\n        }\n        return {\n            coordinates: [\n                { x: x, y: 0 },\n                { x: x, y: bounding.height }\n            ]\n        };\n    };\n    YAxisView.prototype.createTickLines = function (ticks, bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var axisLineStyles = styles.axisLine;\n        var tickLineStyles = styles.tickLine;\n        var startX = 0;\n        var endX = 0;\n        if (yAxis.isFromZero()) {\n            startX = 0;\n            if (axisLineStyles.show) {\n                startX += axisLineStyles.size;\n            }\n            endX = startX + tickLineStyles.length;\n        }\n        else {\n            startX = bounding.width;\n            if (axisLineStyles.show) {\n                startX -= axisLineStyles.size;\n            }\n            endX = startX - tickLineStyles.length;\n        }\n        return ticks.map(function (tick) { return ({\n            coordinates: [\n                { x: startX, y: tick.coord },\n                { x: endX, y: tick.coord }\n            ]\n        }); });\n    };\n    YAxisView.prototype.createTickTexts = function (ticks, bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var axisLineStyles = styles.axisLine;\n        var tickLineStyles = styles.tickLine;\n        var tickTextStyles = styles.tickText;\n        var x = 0;\n        if (yAxis.isFromZero()) {\n            x = tickTextStyles.marginStart;\n            if (axisLineStyles.show) {\n                x += axisLineStyles.size;\n            }\n            if (tickLineStyles.show) {\n                x += tickLineStyles.length;\n            }\n        }\n        else {\n            x = bounding.width - tickTextStyles.marginEnd;\n            if (axisLineStyles.show) {\n                x -= axisLineStyles.size;\n            }\n            if (tickLineStyles.show) {\n                x -= tickLineStyles.length;\n            }\n        }\n        var textAlign = this.getWidget().getPane().getAxisComponent().isFromZero() ? 'left' : 'right';\n        return ticks.map(function (tick) { return ({\n            x: x,\n            y: tick.coord,\n            text: tick.text,\n            align: textAlign,\n            baseline: 'middle'\n        }); });\n    };\n    return YAxisView;\n}(AxisView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandleLastPriceLabelView = /** @class */ (function (_super) {\n    __extends(CandleLastPriceLabelView, _super);\n    function CandleLastPriceLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleLastPriceLabelView.prototype.drawImp = function (ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var lastPriceMarkStyles = priceMarkStyles.last;\n        var lastPriceMarkTextStyles = lastPriceMarkStyles.text;\n        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkTextStyles.show) {\n            var precision = chartStore.getPrecision();\n            var yAxis = pane.getAxisComponent();\n            var dataList = chartStore.getDataList();\n            var data = dataList[dataList.length - 1];\n            if (isValid(data)) {\n                var close_1 = data.close, open_1 = data.open;\n                var comparePrice = lastPriceMarkStyles.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : ((_b = (_a = dataList[dataList.length - 2]) === null || _a === void 0 ? void 0 : _a.close) !== null && _b !== void 0 ? _b : close_1);\n                var priceY = yAxis.convertToNicePixel(close_1);\n                var backgroundColor = '';\n                if (close_1 > comparePrice) {\n                    backgroundColor = lastPriceMarkStyles.upColor;\n                }\n                else if (close_1 < comparePrice) {\n                    backgroundColor = lastPriceMarkStyles.downColor;\n                }\n                else {\n                    backgroundColor = lastPriceMarkStyles.noChangeColor;\n                }\n                var yAxisRange = yAxis.getRange();\n                var text = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(close_1, { range: yAxisRange }), { range: yAxisRange }), precision.price);\n                text = chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text));\n                var x = 0;\n                var textAlgin = 'left';\n                if (yAxis.isFromZero()) {\n                    x = 0;\n                    textAlgin = 'left';\n                }\n                else {\n                    x = bounding.width;\n                    textAlgin = 'right';\n                }\n                (_c = this.createFigure({\n                    name: 'text',\n                    attrs: {\n                        x: x,\n                        y: priceY,\n                        text: text,\n                        align: textAlgin,\n                        baseline: 'middle'\n                    },\n                    styles: __assign(__assign({}, lastPriceMarkTextStyles), { backgroundColor: backgroundColor })\n                })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n            }\n        }\n    };\n    return CandleLastPriceLabelView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorLastValueView = /** @class */ (function (_super) {\n    __extends(IndicatorLastValueView, _super);\n    function IndicatorLastValueView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorLastValueView.prototype.drawImp = function (ctx) {\n        var _this = this;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var defaultStyles = chartStore.getStyles().indicator;\n        var lastValueMarkStyles = defaultStyles.lastValueMark;\n        var lastValueMarkTextStyles = lastValueMarkStyles.text;\n        if (lastValueMarkStyles.show) {\n            var yAxis_1 = pane.getAxisComponent();\n            var yAxisRange_1 = yAxis_1.getRange();\n            var dataList = chartStore.getDataList();\n            var dataIndex_1 = dataList.length - 1;\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var customApi_1 = chartStore.getCustomApi();\n            var decimalFold_1 = chartStore.getDecimalFold();\n            var thousandsSeparator_1 = chartStore.getThousandsSeparator();\n            indicators.forEach(function (indicator) {\n                var _a, _b;\n                var result = indicator.result;\n                var data = (_b = (_a = result[dataIndex_1]) !== null && _a !== void 0 ? _a : result[dataIndex_1 - 1]) !== null && _b !== void 0 ? _b : {};\n                if (isValid(data) && indicator.visible) {\n                    var precision_1 = indicator.precision;\n                    eachFigures(indicator, dataIndex_1, defaultStyles, function (figure, figureStyles) {\n                        var _a;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                        var value = data[figure.key];\n                        if (isNumber(value)) {\n                            var y = yAxis_1.convertToNicePixel(value);\n                            var text = yAxis_1.displayValueToText(yAxis_1.realValueToDisplayValue(yAxis_1.valueToRealValue(value, { range: yAxisRange_1 }), { range: yAxisRange_1 }), precision_1);\n                            if (indicator.shouldFormatBigNumber) {\n                                text = customApi_1.formatBigNumber(text);\n                            }\n                            text = decimalFold_1.format(thousandsSeparator_1.format(text));\n                            var x = 0;\n                            var textAlign = 'left';\n                            if (yAxis_1.isFromZero()) {\n                                x = 0;\n                                textAlign = 'left';\n                            }\n                            else {\n                                x = bounding.width;\n                                textAlign = 'right';\n                            }\n                            (_a = _this.createFigure({\n                                name: 'text',\n                                attrs: {\n                                    x: x,\n                                    y: y,\n                                    text: text,\n                                    align: textAlign,\n                                    baseline: 'middle'\n                                },\n                                styles: __assign(__assign({}, lastValueMarkTextStyles), { backgroundColor: figureStyles.color })\n                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                        }\n                    });\n                }\n            });\n        }\n    };\n    return IndicatorLastValueView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OverlayYAxisView = /** @class */ (function (_super) {\n    __extends(OverlayYAxisView, _super);\n    function OverlayYAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OverlayYAxisView.prototype.coordinateToPointTimestampDataIndexFlag = function () {\n        return false;\n    };\n    OverlayYAxisView.prototype.drawDefaultFigures = function (ctx, overlay, coordinates) {\n        this.drawFigures(ctx, overlay, this.getDefaultFigures(overlay, coordinates));\n    };\n    OverlayYAxisView.prototype.getDefaultFigures = function (overlay, coordinates) {\n        var _a;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var clickOverlayInfo = chartStore.getClickOverlayInfo();\n        var figures = [];\n        if (overlay.needDefaultYAxisFigure &&\n            overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id) &&\n            clickOverlayInfo.paneId === pane.getId()) {\n            var yAxis = pane.getAxisComponent();\n            var bounding = widget.getBounding();\n            var topY_1 = Number.MAX_SAFE_INTEGER;\n            var bottomY_1 = Number.MIN_SAFE_INTEGER;\n            var isFromZero = yAxis.isFromZero();\n            var textAlign_1 = 'left';\n            var x_1 = 0;\n            if (isFromZero) {\n                textAlign_1 = 'left';\n                x_1 = 0;\n            }\n            else {\n                textAlign_1 = 'right';\n                x_1 = bounding.width;\n            }\n            var decimalFold_1 = chartStore.getDecimalFold();\n            var thousandsSeparator_1 = chartStore.getThousandsSeparator();\n            coordinates.forEach(function (coordinate, index) {\n                var point = overlay.points[index];\n                if (isNumber(point.value)) {\n                    topY_1 = Math.min(topY_1, coordinate.y);\n                    bottomY_1 = Math.max(bottomY_1, coordinate.y);\n                    var text = decimalFold_1.format(thousandsSeparator_1.format(formatPrecision(point.value, chartStore.getPrecision().price)));\n                    figures.push({ type: 'text', attrs: { x: x_1, y: coordinate.y, text: text, align: textAlign_1, baseline: 'middle' }, ignoreEvent: true });\n                }\n            });\n            if (coordinates.length > 1) {\n                figures.unshift({ type: 'rect', attrs: { x: 0, y: topY_1, width: bounding.width, height: bottomY_1 - topY_1 }, ignoreEvent: true });\n            }\n        }\n        return figures;\n    };\n    OverlayYAxisView.prototype.getFigures = function (overlay, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = overlay.createYAxisFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, { chart: chart, overlay: overlay, coordinates: coordinates, bounding: bounding, xAxis: xAxis, yAxis: yAxis })) !== null && _b !== void 0 ? _b : [];\n    };\n    return OverlayYAxisView;\n}(OverlayView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CrosshairHorizontalLabelView = /** @class */ (function (_super) {\n    __extends(CrosshairHorizontalLabelView, _super);\n    function CrosshairHorizontalLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairHorizontalLabelView.prototype.drawImp = function (ctx) {\n        var _a;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        var styles = chartStore.getStyles().crosshair;\n        if (isString(crosshair.paneId) && this.compare(crosshair, pane.getId())) {\n            if (styles.show) {\n                var directionStyles = this.getDirectionStyles(styles);\n                var textStyles = directionStyles.text;\n                if (directionStyles.show && textStyles.show) {\n                    var axis = pane.getAxisComponent();\n                    var text = this.getText(crosshair, chartStore, axis);\n                    ctx.font = createFont(textStyles.size, textStyles.weight, textStyles.family);\n                    (_a = this.createFigure({\n                        name: 'text',\n                        attrs: this.getTextAttrs(text, ctx.measureText(text).width, crosshair, bounding, axis, textStyles),\n                        styles: textStyles\n                    })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                }\n            }\n        }\n    };\n    CrosshairHorizontalLabelView.prototype.compare = function (crosshair, paneId) {\n        return crosshair.paneId === paneId;\n    };\n    CrosshairHorizontalLabelView.prototype.getDirectionStyles = function (styles) {\n        return styles.horizontal;\n    };\n    CrosshairHorizontalLabelView.prototype.getText = function (crosshair, chartStore, axis) {\n        var yAxis = axis;\n        var value = axis.convertFromPixel(crosshair.y);\n        var precision = 0;\n        var shouldFormatBigNumber = false;\n        if (yAxis.isInCandle()) {\n            precision = chartStore.getPrecision().price;\n        }\n        else {\n            var indicators = chartStore.getIndicatorsByPaneId(crosshair.paneId);\n            indicators.forEach(function (indicator) {\n                precision = Math.max(indicator.precision, precision);\n                shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);\n            });\n        }\n        var yAxisRange = yAxis.getRange();\n        var text = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(value, { range: yAxisRange }), { range: yAxisRange }), precision);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (shouldFormatBigNumber) {\n            text = chartStore.getCustomApi().formatBigNumber(text);\n        }\n        return chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text));\n    };\n    CrosshairHorizontalLabelView.prototype.getTextAttrs = function (text, _textWidth, crosshair, bounding, axis, _styles) {\n        var yAxis = axis;\n        var x = 0;\n        var textAlign = 'left';\n        if (yAxis.isFromZero()) {\n            x = 0;\n            textAlign = 'left';\n        }\n        else {\n            x = bounding.width;\n            textAlign = 'right';\n        }\n        return { x: x, y: crosshair.y, text: text, align: textAlign, baseline: 'middle' };\n    };\n    return CrosshairHorizontalLabelView;\n}(View));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar YAxisWidget = /** @class */ (function (_super) {\n    __extends(YAxisWidget, _super);\n    function YAxisWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._yAxisView = new YAxisView(_this);\n        _this._candleLastPriceLabelView = new CandleLastPriceLabelView(_this);\n        _this._indicatorLastValueView = new IndicatorLastValueView(_this);\n        _this._overlayYAxisView = new OverlayYAxisView(_this);\n        _this._crosshairHorizontalLabelView = new CrosshairHorizontalLabelView(_this);\n        _this.getContainer().style.cursor = 'ns-resize';\n        _this.addChild(_this._overlayYAxisView);\n        return _this;\n    }\n    YAxisWidget.prototype.getName = function () {\n        return WidgetNameConstants.Y_AXIS;\n    };\n    YAxisWidget.prototype.updateMain = function (ctx) {\n        var minimize = this.getPane().getOptions().state === \"minimize\" /* PaneState.Minimize */;\n        this._yAxisView.draw(ctx, minimize);\n        if (!minimize) {\n            if (this.getPane().getAxisComponent().isInCandle()) {\n                this._candleLastPriceLabelView.draw(ctx);\n            }\n            this._indicatorLastValueView.draw(ctx);\n        }\n    };\n    YAxisWidget.prototype.updateOverlay = function (ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */) {\n            this._overlayYAxisView.draw(ctx);\n            this._crosshairHorizontalLabelView.draw(ctx);\n        }\n    };\n    return YAxisWidget;\n}(DrawWidget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TICK_COUNT = 8;\nvar YAxisImp = /** @class */ (function (_super) {\n    __extends(YAxisImp, _super);\n    function YAxisImp(parent, yAxis) {\n        var _this = _super.call(this, parent) || this;\n        _this.reverse = false;\n        _this.inside = false;\n        _this.position = AxisPosition.Right;\n        _this.gap = {\n            top: 0.2,\n            bottom: 0.1\n        };\n        _this.createRange = function (params) { return params.defaultRange; };\n        _this.minSpan = function (precision) { return index10(-precision); };\n        _this.valueToRealValue = function (value) { return value; };\n        _this.realValueToDisplayValue = function (value) { return value; };\n        _this.displayValueToRealValue = function (value) { return value; };\n        _this.realValueToValue = function (value) { return value; };\n        _this.displayValueToText = function (value, precision) { return formatPrecision(value, precision); };\n        _this.override(yAxis);\n        return _this;\n    }\n    YAxisImp.prototype.override = function (yAxis) {\n        var name = yAxis.name, gap = yAxis.gap, others = __rest(yAxis, [\"name\", \"gap\"]);\n        if (!isString(this.name)) {\n            this.name = name;\n        }\n        merge(this.gap, gap);\n        merge(this, others);\n    };\n    YAxisImp.prototype.createRangeImp = function () {\n        var parent = this.getParent();\n        var chart = parent.getChart();\n        var chartStore = chart.getChartStore();\n        var paneId = parent.getId();\n        var min = Number.MAX_SAFE_INTEGER;\n        var max = Number.MIN_SAFE_INTEGER;\n        var shouldOhlc = false;\n        var specifyMin = Number.MAX_SAFE_INTEGER;\n        var specifyMax = Number.MIN_SAFE_INTEGER;\n        var indicatorPrecision = Number.MAX_SAFE_INTEGER;\n        var indicators = chartStore.getIndicatorsByPaneId(paneId);\n        indicators.forEach(function (indicator) {\n            shouldOhlc || (shouldOhlc = indicator.shouldOhlc);\n            indicatorPrecision = Math.min(indicatorPrecision, indicator.precision);\n            if (isNumber(indicator.minValue)) {\n                specifyMin = Math.min(specifyMin, indicator.minValue);\n            }\n            if (isNumber(indicator.maxValue)) {\n                specifyMax = Math.max(specifyMax, indicator.maxValue);\n            }\n        });\n        var precision = 4;\n        var inCandle = this.isInCandle();\n        if (inCandle) {\n            var pricePrecision = chartStore.getPrecision().price;\n            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {\n                precision = Math.min(indicatorPrecision, pricePrecision);\n            }\n            else {\n                precision = pricePrecision;\n            }\n        }\n        else {\n            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {\n                precision = indicatorPrecision;\n            }\n        }\n        var visibleRangeDataList = chartStore.getVisibleRangeDataList();\n        var candleStyles = chart.getStyles().candle;\n        var isArea = candleStyles.type === CandleType.Area;\n        var areaValueKey = candleStyles.area.value;\n        var shouldCompareHighLow = (inCandle && !isArea) || (!inCandle && shouldOhlc);\n        visibleRangeDataList.forEach(function (visibleData) {\n            var dataIndex = visibleData.dataIndex;\n            var data = visibleData.data.current;\n            if (isValid(data)) {\n                if (shouldCompareHighLow) {\n                    min = Math.min(min, data.low);\n                    max = Math.max(max, data.high);\n                }\n                if (inCandle && isArea) {\n                    var value = data[areaValueKey];\n                    if (isNumber(value)) {\n                        min = Math.min(min, value);\n                        max = Math.max(max, value);\n                    }\n                }\n            }\n            indicators.forEach(function (_a) {\n                var _b;\n                var result = _a.result, figures = _a.figures;\n                var data = (_b = result[dataIndex]) !== null && _b !== void 0 ? _b : {};\n                figures.forEach(function (figure) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                    var value = data[figure.key];\n                    if (isNumber(value)) {\n                        min = Math.min(min, value);\n                        max = Math.max(max, value);\n                    }\n                });\n            });\n        });\n        if (min !== Number.MAX_SAFE_INTEGER && max !== Number.MIN_SAFE_INTEGER) {\n            min = Math.min(specifyMin, min);\n            max = Math.max(specifyMax, max);\n        }\n        else {\n            min = 0;\n            max = 10;\n        }\n        var defaultDiff = max - min;\n        var defaultRange = {\n            from: min,\n            to: max,\n            range: defaultDiff,\n            realFrom: min,\n            realTo: max,\n            realRange: defaultDiff,\n            displayFrom: min,\n            displayTo: max,\n            displayRange: defaultDiff\n        };\n        var range = this.createRange({\n            chart: chart,\n            paneId: paneId,\n            defaultRange: defaultRange\n        });\n        var realFrom = range.realFrom;\n        var realTo = range.realTo;\n        var realRange = range.realRange;\n        var minSpan = this.minSpan(precision);\n        if (realFrom === realTo || realRange < minSpan) {\n            var minCheck = specifyMin === realFrom;\n            var maxCheck = specifyMax === realTo;\n            var halfTickCount = TICK_COUNT / 2;\n            realFrom = minCheck ? realFrom : (maxCheck ? realFrom - TICK_COUNT * minSpan : realFrom - halfTickCount * minSpan);\n            realTo = maxCheck ? realTo : (minCheck ? realTo + TICK_COUNT * minSpan : realTo + halfTickCount * minSpan);\n        }\n        var height = this.getBounding().height;\n        var _a = this.gap, top = _a.top, bottom = _a.bottom;\n        var topRate = top;\n        if (topRate >= 1) {\n            topRate = topRate / height;\n        }\n        var bottomRate = bottom;\n        if (bottomRate >= 1) {\n            bottomRate = bottomRate / height;\n        }\n        realRange = realTo - realFrom;\n        realFrom = realFrom - realRange * bottomRate;\n        realTo = realTo + realRange * topRate;\n        var from = this.realValueToValue(realFrom, { range: range });\n        var to = this.realValueToValue(realTo, { range: range });\n        var displayFrom = this.realValueToDisplayValue(realFrom, { range: range });\n        var displayTo = this.realValueToDisplayValue(realTo, { range: range });\n        return {\n            from: from,\n            to: to,\n            range: to - from,\n            realFrom: realFrom,\n            realTo: realTo,\n            realRange: realTo - realFrom,\n            displayFrom: displayFrom,\n            displayTo: displayTo,\n            displayRange: displayTo - displayFrom\n        };\n    };\n    /**\n     * 是否是蜡烛图轴\n     * @return {boolean}\n     */\n    YAxisImp.prototype.isInCandle = function () {\n        return this.getParent().getId() === PaneIdConstants.CANDLE;\n    };\n    /**\n     * 是否从y轴0开始\n     * @return {boolean}\n     */\n    YAxisImp.prototype.isFromZero = function () {\n        return ((this.position === AxisPosition.Left && this.inside) ||\n            (this.position === AxisPosition.Right && !this.inside));\n    };\n    YAxisImp.prototype.createTicksImp = function () {\n        var _this = this;\n        var _a, _b;\n        var range = this.getRange();\n        var displayFrom = range.displayFrom, displayTo = range.displayTo, displayRange = range.displayRange;\n        var ticks = [];\n        if (displayRange >= 0) {\n            var interval = nice(displayRange / TICK_COUNT);\n            var precision_1 = getPrecision(interval);\n            var first = round(Math.ceil(displayFrom / interval) * interval, precision_1);\n            var last = round(Math.floor(displayTo / interval) * interval, precision_1);\n            var n = 0;\n            var f = first;\n            if (interval !== 0) {\n                while (f <= last) {\n                    var v = f.toFixed(precision_1);\n                    ticks[n] = { text: v, coord: 0, value: v };\n                    ++n;\n                    f += interval;\n                }\n            }\n        }\n        var pane = this.getParent();\n        var height = (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var chartStore = pane.getChart().getChartStore();\n        var optimalTicks = [];\n        var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n        var styles = chartStore.getStyles();\n        var precision = 0;\n        var shouldFormatBigNumber = false;\n        if (this.isInCandle()) {\n            precision = chartStore.getPrecision().price;\n        }\n        else {\n            indicators.forEach(function (indicator) {\n                precision = Math.max(precision, indicator.precision);\n                shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);\n            });\n        }\n        var customApi = chartStore.getCustomApi();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var decimalFold = chartStore.getDecimalFold();\n        var textHeight = styles.xAxis.tickText.size;\n        var validY = NaN;\n        ticks.forEach(function (_a) {\n            var value = _a.value;\n            var v = _this.displayValueToText(+value, precision);\n            var y = _this.convertToPixel(_this.realValueToValue(_this.displayValueToRealValue(+value, { range: range }), { range: range }));\n            if (shouldFormatBigNumber) {\n                v = customApi.formatBigNumber(value);\n            }\n            v = decimalFold.format(thousandsSeparator.format(v));\n            var validYNumber = isNumber(validY);\n            if (y > textHeight &&\n                y < height - textHeight &&\n                ((validYNumber && (Math.abs(validY - y) > textHeight * 2)) || !validYNumber)) {\n                optimalTicks.push({ text: v, coord: y, value: value });\n                validY = y;\n            }\n        });\n        if (isFunction(this.createTicks)) {\n            return this.createTicks({\n                range: this.getRange(),\n                bounding: this.getBounding(),\n                defaultTicks: optimalTicks\n            });\n        }\n        return optimalTicks;\n    };\n    YAxisImp.prototype.getAutoSize = function () {\n        var pane = this.getParent();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        var styles = chartStore.getStyles();\n        var yAxisStyles = styles.yAxis;\n        var width = yAxisStyles.size;\n        if (width !== 'auto') {\n            return width;\n        }\n        var yAxisWidth = 0;\n        if (yAxisStyles.show) {\n            if (yAxisStyles.axisLine.show) {\n                yAxisWidth += yAxisStyles.axisLine.size;\n            }\n            if (yAxisStyles.tickLine.show) {\n                yAxisWidth += yAxisStyles.tickLine.length;\n            }\n            if (yAxisStyles.tickText.show) {\n                var textWidth_1 = 0;\n                this.getTicks().forEach(function (tick) {\n                    textWidth_1 = Math.max(textWidth_1, calcTextWidth(tick.text, yAxisStyles.tickText.size, yAxisStyles.tickText.weight, yAxisStyles.tickText.family));\n                });\n                yAxisWidth += (yAxisStyles.tickText.marginStart + yAxisStyles.tickText.marginEnd + textWidth_1);\n            }\n        }\n        var crosshairStyles = styles.crosshair;\n        var crosshairVerticalTextWidth = 0;\n        if (crosshairStyles.show &&\n            crosshairStyles.horizontal.show &&\n            crosshairStyles.horizontal.text.show) {\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var indicatorPrecision_1 = 0;\n            var shouldFormatBigNumber_1 = false;\n            indicators.forEach(function (indicator) {\n                indicatorPrecision_1 = Math.max(indicator.precision, indicatorPrecision_1);\n                shouldFormatBigNumber_1 || (shouldFormatBigNumber_1 = indicator.shouldFormatBigNumber);\n            });\n            var precision = 2;\n            if (this.isInCandle()) {\n                var pricePrecision = chartStore.getPrecision().price;\n                var lastValueMarkStyles = styles.indicator.lastValueMark;\n                if (lastValueMarkStyles.show && lastValueMarkStyles.text.show) {\n                    precision = Math.max(indicatorPrecision_1, pricePrecision);\n                }\n                else {\n                    precision = pricePrecision;\n                }\n            }\n            else {\n                precision = indicatorPrecision_1;\n            }\n            var valueText = formatPrecision(this.getRange().displayTo, precision);\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (shouldFormatBigNumber_1) {\n                valueText = chartStore.getCustomApi().formatBigNumber(valueText);\n            }\n            valueText = chartStore.getDecimalFold().format(valueText);\n            crosshairVerticalTextWidth += (crosshairStyles.horizontal.text.paddingLeft +\n                crosshairStyles.horizontal.text.paddingRight +\n                crosshairStyles.horizontal.text.borderSize * 2 +\n                calcTextWidth(valueText, crosshairStyles.horizontal.text.size, crosshairStyles.horizontal.text.weight, crosshairStyles.horizontal.text.family));\n        }\n        return Math.max(yAxisWidth, crosshairVerticalTextWidth);\n    };\n    YAxisImp.prototype.getBounding = function () {\n        return this.getParent().getYAxisWidget().getBounding();\n    };\n    YAxisImp.prototype.convertFromPixel = function (pixel) {\n        var height = this.getBounding().height;\n        var range = this.getRange();\n        var realFrom = range.realFrom, realRange = range.realRange;\n        var rate = this.reverse ? pixel / height : 1 - pixel / height;\n        var realValue = rate * realRange + realFrom;\n        return this.realValueToValue(realValue, { range: range });\n    };\n    YAxisImp.prototype.convertToPixel = function (value) {\n        var _a, _b;\n        var range = this.getRange();\n        var realValue = this.valueToRealValue(value, { range: range });\n        var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var realFrom = range.realFrom, realRange = range.realRange;\n        var rate = (realValue - realFrom) / realRange;\n        return this.reverse ? Math.round(rate * height) : Math.round((1 - rate) * height);\n    };\n    YAxisImp.prototype.convertToNicePixel = function (value) {\n        var _a, _b;\n        var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var pixel = this.convertToPixel(value);\n        return Math.round(Math.max(height * 0.05, Math.min(pixel, height * 0.98)));\n    };\n    YAxisImp.extend = function (template) {\n        var Custom = /** @class */ (function (_super) {\n            __extends(Custom, _super);\n            function Custom(parent) {\n                return _super.call(this, parent, template) || this;\n            }\n            return Custom;\n        }(YAxisImp));\n        return Custom;\n    };\n    return YAxisImp;\n}(AxisImp));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar normal$1 = {\n    name: 'normal'\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar percentage = {\n    name: 'percentage',\n    minSpan: function () { return Math.pow(10, -2); },\n    displayValueToText: function (value) { return \"\".concat(formatPrecision(value, 2), \"%\"); },\n    valueToRealValue: function (value, _a) {\n        var range = _a.range;\n        return (value - range.from) / range.range * range.realRange + range.realFrom;\n    },\n    realValueToValue: function (value, _a) {\n        var range = _a.range;\n        return (value - range.realFrom) / range.realRange * range.range + range.from;\n    },\n    createRange: function (_a) {\n        var chart = _a.chart, defaultRange = _a.defaultRange;\n        var kLineDataList = chart.getDataList();\n        var visibleRange = chart.getVisibleRange();\n        var kLineData = kLineDataList[visibleRange.from];\n        if (isValid(kLineData)) {\n            var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;\n            var realFrom = (defaultRange.from - kLineData.close) / kLineData.close * 100;\n            var realTo = (defaultRange.to - kLineData.close) / kLineData.close * 100;\n            var realRange = realTo - realFrom;\n            return {\n                from: from,\n                to: to,\n                range: range,\n                realFrom: realFrom,\n                realTo: realTo,\n                realRange: realRange,\n                displayFrom: realFrom,\n                displayTo: realTo,\n                displayRange: realRange\n            };\n        }\n        return defaultRange;\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar logarithm = {\n    name: 'logarithm',\n    minSpan: function (precision) { return 0.05 * index10(-precision); },\n    valueToRealValue: function (value) { return value < 0 ? -log10(Math.abs(value)) : log10(value); },\n    realValueToDisplayValue: function (value) { return value < 0 ? -index10(Math.abs(value)) : index10(value); },\n    displayValueToRealValue: function (value) { return value < 0 ? -log10(Math.abs(value)) : log10(value); },\n    realValueToValue: function (value) { return value < 0 ? -index10(Math.abs(value)) : index10(value); },\n    createRange: function (_a) {\n        var defaultRange = _a.defaultRange;\n        var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;\n        var realFrom = from < 0 ? -log10(Math.abs(from)) : log10(from);\n        var realTo = to < 0 ? -log10(Math.abs(to)) : log10(to);\n        return {\n            from: from,\n            to: to,\n            range: range,\n            realFrom: realFrom,\n            realTo: realTo,\n            realRange: realTo - realFrom,\n            displayFrom: from,\n            displayTo: to,\n            displayRange: range\n        };\n    }\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar yAxises = {\n    normal: YAxisImp.extend(normal$1),\n    percentage: YAxisImp.extend(percentage),\n    logarithm: YAxisImp.extend(logarithm)\n};\nfunction registerYAxis(axis) {\n    yAxises[axis.name] = YAxisImp.extend(axis);\n}\nfunction getYAxisClass(name) {\n    var _a;\n    return (_a = yAxises[name]) !== null && _a !== void 0 ? _a : yAxises.normal;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Pane = /** @class */ (function () {\n    function Pane(chart, id) {\n        this._bounding = createDefaultBounding();\n        this._originalBounding = createDefaultBounding();\n        this._visible = true;\n        this._chart = chart;\n        this._id = id;\n        this._container = createDom('div', {\n            width: '100%',\n            margin: '0',\n            padding: '0',\n            position: 'relative',\n            overflow: 'hidden',\n            boxSizing: 'border-box'\n        });\n    }\n    Pane.prototype.getContainer = function () {\n        return this._container;\n    };\n    Pane.prototype.setVisible = function (visible) {\n        if (this._visible !== visible) {\n            this._container.style.display = visible ? 'block' : 'none';\n            this._visible = visible;\n        }\n    };\n    Pane.prototype.getVisible = function () {\n        return this._visible;\n    };\n    Pane.prototype.getId = function () {\n        return this._id;\n    };\n    Pane.prototype.getChart = function () {\n        return this._chart;\n    };\n    Pane.prototype.getBounding = function () {\n        return this._bounding;\n    };\n    Pane.prototype.setOriginalBounding = function (bounding) {\n        merge(this._originalBounding, bounding);\n    };\n    Pane.prototype.getOriginalBounding = function () {\n        return this._originalBounding;\n    };\n    Pane.prototype.update = function (level) {\n        if (this._bounding.height !== this._container.clientHeight) {\n            this._container.style.height = \"\".concat(this._bounding.height, \"px\");\n        }\n        this.updateImp(level !== null && level !== void 0 ? level : 3 /* UpdateLevel.Drawer */, this._container, this._bounding);\n    };\n    return Pane;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DrawPane = /** @class */ (function (_super) {\n    __extends(DrawPane, _super);\n    function DrawPane(chart, id, options) {\n        var _this = _super.call(this, chart, id) || this;\n        _this._yAxisWidget = null;\n        _this._options = {\n            id: '',\n            minHeight: PANE_MIN_HEIGHT,\n            dragEnabled: true,\n            order: 0,\n            height: PANE_DEFAULT_HEIGHT,\n            state: \"normal\" /* PaneState.Normal */,\n            axis: { name: 'normal', scrollZoomEnabled: true }\n        };\n        var container = _this.getContainer();\n        _this._mainWidget = _this.createMainWidget(container);\n        _this._yAxisWidget = _this.createYAxisWidget(container);\n        _this.setOptions(options);\n        return _this;\n    }\n    DrawPane.prototype.setOptions = function (options) {\n        var _a, _b, _c, _d, _e;\n        var paneId = this.getId();\n        if (paneId === PaneIdConstants.CANDLE || paneId === PaneIdConstants.X_AXIS) {\n            var axisName = (_a = options.axis) === null || _a === void 0 ? void 0 : _a.name;\n            if (!isValid(this._axis) ||\n                (isValid(axisName) && this._options.axis.name !== axisName)) {\n                this._axis = this.createAxisComponent(axisName !== null && axisName !== void 0 ? axisName : 'normal');\n            }\n        }\n        else {\n            if (!isValid(this._axis)) {\n                this._axis = this.createAxisComponent('normal');\n            }\n        }\n        if (this._axis instanceof YAxisImp) {\n            this._axis.setAutoCalcTickFlag(true);\n        }\n        merge(this._options, options);\n        this._axis.override(__assign(__assign({}, this._options.axis), { name: (_c = (_b = options.axis) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : 'normal' }));\n        var container = null;\n        var cursor = 'default';\n        if (this.getId() === PaneIdConstants.X_AXIS) {\n            container = this.getMainWidget().getContainer();\n            cursor = 'ew-resize';\n        }\n        else {\n            container = this.getYAxisWidget().getContainer();\n            cursor = 'ns-resize';\n        }\n        if ((_e = (_d = options.axis) === null || _d === void 0 ? void 0 : _d.scrollZoomEnabled) !== null && _e !== void 0 ? _e : true) {\n            container.style.cursor = cursor;\n        }\n        else {\n            container.style.cursor = 'default';\n        }\n        return this;\n    };\n    DrawPane.prototype.getOptions = function () { return this._options; };\n    DrawPane.prototype.getAxisComponent = function () {\n        return this._axis;\n    };\n    DrawPane.prototype.setBounding = function (rootBounding, mainBounding, leftYAxisBounding, rightYAxisBounding) {\n        var _a, _b, _c, _d;\n        merge(this.getBounding(), rootBounding);\n        var contentBounding = {};\n        if (isValid(rootBounding.height)) {\n            contentBounding.height = rootBounding.height;\n        }\n        if (isValid(rootBounding.top)) {\n            contentBounding.top = rootBounding.top;\n        }\n        this._mainWidget.setBounding(contentBounding);\n        var mainBoundingValid = isValid(mainBounding);\n        if (mainBoundingValid) {\n            this._mainWidget.setBounding(mainBounding);\n        }\n        if (isValid(this._yAxisWidget)) {\n            this._yAxisWidget.setBounding(contentBounding);\n            var yAxis = this._axis;\n            if (yAxis.position === AxisPosition.Left) {\n                if (isValid(leftYAxisBounding)) {\n                    this._yAxisWidget.setBounding(__assign(__assign({}, leftYAxisBounding), { left: 0 }));\n                }\n            }\n            else {\n                if (isValid(rightYAxisBounding)) {\n                    this._yAxisWidget.setBounding(rightYAxisBounding);\n                    if (mainBoundingValid) {\n                        this._yAxisWidget.setBounding({\n                            left: ((_a = mainBounding.left) !== null && _a !== void 0 ? _a : 0) +\n                                ((_b = mainBounding.width) !== null && _b !== void 0 ? _b : 0) +\n                                ((_c = mainBounding.right) !== null && _c !== void 0 ? _c : 0) -\n                                ((_d = rightYAxisBounding.width) !== null && _d !== void 0 ? _d : 0)\n                        });\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    DrawPane.prototype.getMainWidget = function () { return this._mainWidget; };\n    DrawPane.prototype.getYAxisWidget = function () { return this._yAxisWidget; };\n    DrawPane.prototype.updateImp = function (level) {\n        var _a;\n        this._mainWidget.update(level);\n        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.update(level);\n    };\n    DrawPane.prototype.destroy = function () {\n        var _a;\n        this._mainWidget.destroy();\n        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.destroy();\n    };\n    DrawPane.prototype.getImage = function (includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var canvas = createDom('canvas', {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: 'border-box'\n        });\n        var ctx = canvas.getContext('2d');\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        var mainBounding = this._mainWidget.getBounding();\n        ctx.drawImage(this._mainWidget.getImage(includeOverlay), mainBounding.left, 0, mainBounding.width, mainBounding.height);\n        if (this._yAxisWidget !== null) {\n            var yAxisBounding = this._yAxisWidget.getBounding();\n            ctx.drawImage(this._yAxisWidget.getImage(includeOverlay), yAxisBounding.left, 0, yAxisBounding.width, yAxisBounding.height);\n        }\n        return canvas;\n    };\n    DrawPane.prototype.createYAxisWidget = function (_container) { return null; };\n    return DrawPane;\n}(Pane));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IndicatorPane = /** @class */ (function (_super) {\n    __extends(IndicatorPane, _super);\n    function IndicatorPane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorPane.prototype.createAxisComponent = function (name) {\n        var YAxisClass = getYAxisClass(name !== null && name !== void 0 ? name : 'default');\n        return new YAxisClass(this);\n    };\n    IndicatorPane.prototype.createMainWidget = function (container) {\n        return new IndicatorWidget(container, this);\n    };\n    IndicatorPane.prototype.createYAxisWidget = function (container) {\n        return new YAxisWidget(container, this);\n    };\n    return IndicatorPane;\n}(DrawPane));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CandlePane = /** @class */ (function (_super) {\n    __extends(CandlePane, _super);\n    function CandlePane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandlePane.prototype.createMainWidget = function (container) {\n        return new CandleWidget(container, this);\n    };\n    return CandlePane;\n}(IndicatorPane));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar XAxisView = /** @class */ (function (_super) {\n    __extends(XAxisView, _super);\n    function XAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    XAxisView.prototype.getAxisStyles = function (styles) {\n        return styles.xAxis;\n    };\n    XAxisView.prototype.createAxisLine = function (bounding) {\n        return {\n            coordinates: [\n                { x: 0, y: 0 },\n                { x: bounding.width, y: 0 }\n            ]\n        };\n    };\n    XAxisView.prototype.createTickLines = function (ticks, _bounding, styles) {\n        var tickLineStyles = styles.tickLine;\n        var axisLineSize = styles.axisLine.size;\n        return ticks.map(function (tick) { return ({\n            coordinates: [\n                { x: tick.coord, y: 0 },\n                { x: tick.coord, y: axisLineSize + tickLineStyles.length }\n            ]\n        }); });\n    };\n    XAxisView.prototype.createTickTexts = function (ticks, _bounding, styles) {\n        var tickTickStyles = styles.tickText;\n        var axisLineSize = styles.axisLine.size;\n        var tickLineLength = styles.tickLine.length;\n        return ticks.map(function (tick) { return ({\n            x: tick.coord,\n            y: axisLineSize + tickLineLength + tickTickStyles.marginStart,\n            text: tick.text,\n            align: 'center',\n            baseline: 'top'\n        }); });\n    };\n    return XAxisView;\n}(AxisView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OverlayXAxisView = /** @class */ (function (_super) {\n    __extends(OverlayXAxisView, _super);\n    function OverlayXAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OverlayXAxisView.prototype.coordinateToPointTimestampDataIndexFlag = function () {\n        return true;\n    };\n    OverlayXAxisView.prototype.coordinateToPointValueFlag = function () {\n        return false;\n    };\n    OverlayXAxisView.prototype.getCompleteOverlays = function () {\n        return this.getWidget().getPane().getChart().getChartStore().getOverlaysByPaneId();\n    };\n    OverlayXAxisView.prototype.getProgressOverlay = function () {\n        var _a, _b;\n        return (_b = (_a = this.getWidget().getPane().getChart().getChartStore().getProgressOverlayInfo()) === null || _a === void 0 ? void 0 : _a.overlay) !== null && _b !== void 0 ? _b : null;\n    };\n    OverlayXAxisView.prototype.getDefaultFigures = function (overlay, coordinates) {\n        var _a;\n        var figures = [];\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var clickOverlayInfo = chartStore.getClickOverlayInfo();\n        if (overlay.needDefaultXAxisFigure && overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id)) {\n            var leftX_1 = Number.MAX_SAFE_INTEGER;\n            var rightX_1 = Number.MIN_SAFE_INTEGER;\n            coordinates.forEach(function (coordinate, index) {\n                leftX_1 = Math.min(leftX_1, coordinate.x);\n                rightX_1 = Math.max(rightX_1, coordinate.x);\n                var point = overlay.points[index];\n                if (isNumber(point.timestamp)) {\n                    var text = chartStore.getCustomApi().formatDate(point.timestamp, 'YYYY-MM-DD HH:mm', FormatDateType.Crosshair);\n                    figures.push({ type: 'text', attrs: { x: coordinate.x, y: 0, text: text, align: 'center' }, ignoreEvent: true });\n                }\n            });\n            if (coordinates.length > 1) {\n                figures.unshift({ type: 'rect', attrs: { x: leftX_1, y: 0, width: rightX_1 - leftX_1, height: widget.getBounding().height }, ignoreEvent: true });\n            }\n        }\n        return figures;\n    };\n    OverlayXAxisView.prototype.getFigures = function (o, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = o.createXAxisFigures) === null || _a === void 0 ? void 0 : _a.call(o, { chart: chart, overlay: o, coordinates: coordinates, bounding: bounding, xAxis: xAxis, yAxis: yAxis })) !== null && _b !== void 0 ? _b : [];\n    };\n    return OverlayXAxisView;\n}(OverlayYAxisView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar CrosshairVerticalLabelView = /** @class */ (function (_super) {\n    __extends(CrosshairVerticalLabelView, _super);\n    function CrosshairVerticalLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairVerticalLabelView.prototype.compare = function (crosshair) {\n        return isValid(crosshair.timestamp);\n    };\n    CrosshairVerticalLabelView.prototype.getDirectionStyles = function (styles) {\n        return styles.vertical;\n    };\n    CrosshairVerticalLabelView.prototype.getText = function (crosshair, chartStore) {\n        var timestamp = crosshair.timestamp;\n        return chartStore.getCustomApi().formatDate(timestamp, 'YYYY-MM-DD HH:mm', FormatDateType.Crosshair);\n    };\n    CrosshairVerticalLabelView.prototype.getTextAttrs = function (text, textWidth, crosshair, bounding, _axis, styles) {\n        var x = crosshair.realX;\n        var optimalX = 0;\n        var align = 'center';\n        if (x - textWidth / 2 - styles.paddingLeft < 0) {\n            optimalX = 0;\n            align = 'left';\n        }\n        else if (x + textWidth / 2 + styles.paddingRight > bounding.width) {\n            optimalX = bounding.width;\n            align = 'right';\n        }\n        else {\n            optimalX = x;\n        }\n        return { x: optimalX, y: 0, text: text, align: align, baseline: 'top' };\n    };\n    return CrosshairVerticalLabelView;\n}(CrosshairHorizontalLabelView));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar XAxisWidget = /** @class */ (function (_super) {\n    __extends(XAxisWidget, _super);\n    function XAxisWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._xAxisView = new XAxisView(_this);\n        _this._overlayXAxisView = new OverlayXAxisView(_this);\n        _this._crosshairVerticalLabelView = new CrosshairVerticalLabelView(_this);\n        _this.getContainer().style.cursor = 'ew-resize';\n        _this.addChild(_this._overlayXAxisView);\n        return _this;\n    }\n    XAxisWidget.prototype.getName = function () {\n        return WidgetNameConstants.X_AXIS;\n    };\n    XAxisWidget.prototype.updateMain = function (ctx) {\n        this._xAxisView.draw(ctx);\n    };\n    XAxisWidget.prototype.updateOverlay = function (ctx) {\n        this._overlayXAxisView.draw(ctx);\n        this._crosshairVerticalLabelView.draw(ctx);\n    };\n    return XAxisWidget;\n}(DrawWidget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar XAxisImp = /** @class */ (function (_super) {\n    __extends(XAxisImp, _super);\n    function XAxisImp(parent, xAxis) {\n        var _this = _super.call(this, parent) || this;\n        _this.override(xAxis);\n        return _this;\n    }\n    XAxisImp.prototype.override = function (xAxis) {\n        var name = xAxis.name, scrollZoomEnabled = xAxis.scrollZoomEnabled, createTicks = xAxis.createTicks;\n        if (!isString(this.name)) {\n            this.name = name;\n        }\n        this.scrollZoomEnabled = scrollZoomEnabled !== null && scrollZoomEnabled !== void 0 ? scrollZoomEnabled : this.scrollZoomEnabled;\n        this.createTicks = createTicks !== null && createTicks !== void 0 ? createTicks : this.createTicks;\n    };\n    XAxisImp.prototype.createRangeImp = function () {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var visibleDataRange = chartStore.getVisibleRange();\n        var realFrom = visibleDataRange.realFrom, realTo = visibleDataRange.realTo;\n        var af = realFrom;\n        var at = realTo;\n        var diff = realTo - realFrom + 1;\n        var range = {\n            from: af,\n            to: at,\n            range: diff,\n            realFrom: af,\n            realTo: at,\n            realRange: diff,\n            displayFrom: af,\n            displayTo: at,\n            displayRange: diff\n        };\n        return range;\n    };\n    XAxisImp.prototype.createTicksImp = function () {\n        var _this = this;\n        var _a = this.getRange(), realFrom = _a.realFrom, realTo = _a.realTo;\n        var chartStore = this.getParent().getChart().getChartStore();\n        var formatDate = chartStore.getCustomApi().formatDate;\n        var timeWeightTickList = chartStore.getTimeWeightTickList();\n        var ticks = [];\n        var fitTicks = function (list, start) {\n            var e_1, _a;\n            try {\n                for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {\n                    var timeWeightTick = list_1_1.value;\n                    if (timeWeightTick.dataIndex >= start && timeWeightTick.dataIndex < realTo) {\n                        var timestamp = timeWeightTick.timestamp, weight = timeWeightTick.weight, dataIndex = timeWeightTick.dataIndex;\n                        var text = '';\n                        switch (weight) {\n                            case TimeWeightConstants.Year: {\n                                text = formatDate(timestamp, 'YYYY', FormatDateType.XAxis);\n                                break;\n                            }\n                            case TimeWeightConstants.Month: {\n                                text = formatDate(timestamp, 'YYYY-MM', FormatDateType.XAxis);\n                                break;\n                            }\n                            case TimeWeightConstants.Day: {\n                                text = formatDate(timestamp, 'MM-DD', FormatDateType.XAxis);\n                                break;\n                            }\n                            case TimeWeightConstants.Hour:\n                            case TimeWeightConstants.Minute: {\n                                text = formatDate(timestamp, 'HH:mm', FormatDateType.XAxis);\n                                break;\n                            }\n                            case TimeWeightConstants.Second: {\n                                text = formatDate(timestamp, 'HH:mm:ss', FormatDateType.XAxis);\n                                break;\n                            }\n                            default: {\n                                text = formatDate(timestamp, 'YYYY-MM-DD HH:mm', FormatDateType.XAxis);\n                                break;\n                            }\n                        }\n                        ticks.push({\n                            coord: _this.convertToPixel(dataIndex),\n                            value: timestamp,\n                            text: text\n                        });\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        };\n        fitTicks(timeWeightTickList, realFrom);\n        // Future time tick\n        if (timeWeightTickList.length > 0) {\n            var barSpace = chartStore.getBarSpace().bar;\n            var textStyles = chartStore.getStyles().xAxis.tickText;\n            var barCount = calcBetweenTimeWeightTickBarCount(barSpace, textStyles);\n            var startDataIndex = timeWeightTickList[timeWeightTickList.length - 1].dataIndex + barCount - 1;\n            var dataList = [];\n            for (var i = startDataIndex; i < realTo; i++) {\n                var timestamp = chartStore.dataIndexToTimestamp(i);\n                if (isNumber(timestamp)) {\n                    dataList.push({ timestamp: timestamp });\n                }\n            }\n            if (dataList.length > 0) {\n                var map = new Map();\n                classifyTimeWeightTicks(map, dataList, chartStore.getDateTimeFormat(), startDataIndex);\n                fitTicks(createTimeWeightTickList(map, barSpace, textStyles), startDataIndex);\n            }\n        }\n        if (isFunction(this.createTicks)) {\n            return this.createTicks({\n                range: this.getRange(),\n                bounding: this.getBounding(),\n                defaultTicks: ticks\n            });\n        }\n        return ticks;\n    };\n    XAxisImp.prototype.getAutoSize = function () {\n        var styles = this.getParent().getChart().getStyles();\n        var xAxisStyles = styles.xAxis;\n        var height = xAxisStyles.size;\n        if (height !== 'auto') {\n            return height;\n        }\n        var crosshairStyles = styles.crosshair;\n        var xAxisHeight = 0;\n        if (xAxisStyles.show) {\n            if (xAxisStyles.axisLine.show) {\n                xAxisHeight += xAxisStyles.axisLine.size;\n            }\n            if (xAxisStyles.tickLine.show) {\n                xAxisHeight += xAxisStyles.tickLine.length;\n            }\n            if (xAxisStyles.tickText.show) {\n                xAxisHeight += (xAxisStyles.tickText.marginStart + xAxisStyles.tickText.marginEnd + xAxisStyles.tickText.size);\n            }\n        }\n        var crosshairVerticalTextHeight = 0;\n        if (crosshairStyles.show &&\n            crosshairStyles.vertical.show &&\n            crosshairStyles.vertical.text.show) {\n            crosshairVerticalTextHeight += (crosshairStyles.vertical.text.paddingTop +\n                crosshairStyles.vertical.text.paddingBottom +\n                crosshairStyles.vertical.text.borderSize * 2 +\n                crosshairStyles.vertical.text.size);\n        }\n        return Math.max(xAxisHeight, crosshairVerticalTextHeight);\n    };\n    XAxisImp.prototype.getBounding = function () {\n        return this.getParent().getMainWidget().getBounding();\n    };\n    XAxisImp.prototype.convertTimestampFromPixel = function (pixel) {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var dataIndex = chartStore.coordinateToDataIndex(pixel);\n        return chartStore.dataIndexToTimestamp(dataIndex);\n    };\n    XAxisImp.prototype.convertTimestampToPixel = function (timestamp) {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var dataIndex = chartStore.timestampToDataIndex(timestamp);\n        return chartStore.dataIndexToCoordinate(dataIndex);\n    };\n    XAxisImp.prototype.convertFromPixel = function (pixel) {\n        return this.getParent().getChart().getChartStore().coordinateToDataIndex(pixel);\n    };\n    XAxisImp.prototype.convertToPixel = function (value) {\n        return this.getParent().getChart().getChartStore().dataIndexToCoordinate(value);\n    };\n    XAxisImp.extend = function (template) {\n        var Custom = /** @class */ (function (_super) {\n            __extends(Custom, _super);\n            function Custom(parent) {\n                return _super.call(this, parent, template) || this;\n            }\n            return Custom;\n        }(XAxisImp));\n        return Custom;\n    };\n    return XAxisImp;\n}(AxisImp));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar normal = {\n    name: 'normal'\n};\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar xAxises = {\n    normal: XAxisImp.extend(normal)\n};\nfunction registerXAxis(axis) {\n    xAxises[axis.name] = XAxisImp.extend(axis);\n}\nfunction getXAxisClass(name) {\n    var _a;\n    return (_a = xAxises[name]) !== null && _a !== void 0 ? _a : xAxises.normal;\n}\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar XAxisPane = /** @class */ (function (_super) {\n    __extends(XAxisPane, _super);\n    function XAxisPane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    XAxisPane.prototype.createAxisComponent = function (name) {\n        var XAxisClass = getXAxisClass(name);\n        return new XAxisClass(this);\n    };\n    XAxisPane.prototype.createMainWidget = function (container) {\n        return new XAxisWidget(container, this);\n    };\n    return XAxisPane;\n}(DrawPane));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction throttle(func, wait) {\n    var previous = 0;\n    return function () {\n        var now = Date.now();\n        if (now - previous > (wait )) {\n            func.apply(this, arguments);\n            previous = now;\n        }\n    };\n}\n// export function memoize<R1 = any, R2 = any> (func: (...args: any[]) => R1, resolver?: (...args: any[]) => R2): (...args: any[]) => R1 {\n//   if (!isFunction(func) || (isValid(resolver) && !isFunction(resolver))) {\n//     throw new TypeError('Expected a function')\n//   }\n//   const memoized = function (...args: any[]): any {\n//     const key = isFunction(resolver) ? resolver.apply(this, args) : args[0]\n//     const cache = memoized.cache\n//     if (cache.has(key)) {\n//       return cache.get(key)\n//     }\n//     const result = func.apply(this, args)\n//     // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n//     memoized.cache = cache.set(key, result) || cache\n//     return result\n//   }\n//   // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n//   memoized.cache = new (memoize.Cache || Map)()\n//   return memoized\n// }\n// memoize.Cache = Map\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SeparatorWidget = /** @class */ (function (_super) {\n    __extends(SeparatorWidget, _super);\n    function SeparatorWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._dragFlag = false;\n        _this._dragStartY = 0;\n        _this._topPaneHeight = 0;\n        _this._bottomPaneHeight = 0;\n        _this._topPane = null;\n        _this._bottomPane = null;\n        // eslint-disable-next-line @typescript-eslint/unbound-method -- ignore\n        _this._pressedMouseMoveEvent = throttle(_this._pressedTouchMouseMoveEvent, 20);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        _this.registerEvent('touchStartEvent', _this._mouseDownEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('touchMoveEvent', _this._pressedMouseMoveEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('touchEndEvent', _this._mouseUpEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('mouseDownEvent', _this._mouseDownEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('mouseUpEvent', _this._mouseUpEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('pressedMouseMoveEvent', _this._pressedMouseMoveEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('mouseEnterEvent', _this._mouseEnterEvent.bind(_this))\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            .registerEvent('mouseLeaveEvent', _this._mouseLeaveEvent.bind(_this));\n        return _this;\n    }\n    SeparatorWidget.prototype.getName = function () {\n        return WidgetNameConstants.SEPARATOR;\n    };\n    SeparatorWidget.prototype.checkEventOn = function () {\n        return true;\n    };\n    SeparatorWidget.prototype._mouseDownEvent = function (event) {\n        var _this = this;\n        this._dragFlag = true;\n        this._dragStartY = event.pageY;\n        var pane = this.getPane();\n        var chart = pane.getChart();\n        this._topPane = pane.getTopPane();\n        this._bottomPane = pane.getBottomPane();\n        var drawPanes = chart.getDrawPanes();\n        if (this._topPane.getOptions().state === \"minimize\" /* PaneState.Minimize */) {\n            var index = drawPanes.findIndex(function (pane) { var _a; return pane.getId() === ((_a = _this._topPane) === null || _a === void 0 ? void 0 : _a.getId()); });\n            for (var i = index - 1; i > -1; i--) {\n                var pane_1 = drawPanes[i];\n                if (pane_1.getOptions().state !== \"minimize\" /* PaneState.Minimize */) {\n                    this._topPane = pane_1;\n                    break;\n                }\n            }\n        }\n        if (this._bottomPane.getOptions().state === \"minimize\" /* PaneState.Minimize */) {\n            var index = drawPanes.findIndex(function (pane) { var _a; return pane.getId() === ((_a = _this._bottomPane) === null || _a === void 0 ? void 0 : _a.getId()); });\n            for (var i = index + 1; i < drawPanes.length; i++) {\n                var pane_2 = drawPanes[i];\n                if (pane_2.getOptions().state !== \"minimize\" /* PaneState.Minimize */) {\n                    this._bottomPane = pane_2;\n                    break;\n                }\n            }\n        }\n        this._topPaneHeight = this._topPane.getBounding().height;\n        this._bottomPaneHeight = this._bottomPane.getBounding().height;\n        return true;\n    };\n    SeparatorWidget.prototype._mouseUpEvent = function () {\n        this._dragFlag = false;\n        this._topPane = null;\n        this._bottomPane = null;\n        this._topPaneHeight = 0;\n        this._bottomPaneHeight = 0;\n        return this._mouseLeaveEvent();\n    };\n    SeparatorWidget.prototype._pressedTouchMouseMoveEvent = function (event) {\n        var dragDistance = event.pageY - this._dragStartY;\n        var isUpDrag = dragDistance < 0;\n        if (isValid(this._topPane) && isValid(this._bottomPane)) {\n            var bottomPaneOptions = this._bottomPane.getOptions();\n            if (this._topPane.getOptions().state !== \"minimize\" /* PaneState.Minimize */ &&\n                bottomPaneOptions.state !== \"minimize\" /* PaneState.Minimize */ &&\n                bottomPaneOptions.dragEnabled) {\n                var reducedPane = null;\n                var increasedPane = null;\n                var startDragReducedPaneHeight = 0;\n                var startDragIncreasedPaneHeight = 0;\n                if (isUpDrag) {\n                    reducedPane = this._topPane;\n                    increasedPane = this._bottomPane;\n                    startDragReducedPaneHeight = this._topPaneHeight;\n                    startDragIncreasedPaneHeight = this._bottomPaneHeight;\n                }\n                else {\n                    reducedPane = this._bottomPane;\n                    increasedPane = this._topPane;\n                    startDragReducedPaneHeight = this._bottomPaneHeight;\n                    startDragIncreasedPaneHeight = this._topPaneHeight;\n                }\n                var reducedPaneMinHeight = reducedPane.getOptions().minHeight;\n                if (startDragReducedPaneHeight > reducedPaneMinHeight) {\n                    var reducedPaneHeight = Math.max(startDragReducedPaneHeight - Math.abs(dragDistance), reducedPaneMinHeight);\n                    var diffHeight = startDragReducedPaneHeight - reducedPaneHeight;\n                    reducedPane.setBounding({ height: reducedPaneHeight });\n                    increasedPane.setBounding({ height: startDragIncreasedPaneHeight + diffHeight });\n                    var currentPane = this.getPane();\n                    var chart = currentPane.getChart();\n                    chart.getChartStore().executeAction(ActionType.OnPaneDrag, { paneId: currentPane.getId() });\n                    chart.layout({\n                        measureHeight: true,\n                        measureWidth: true,\n                        update: true,\n                        buildYAxisTick: true,\n                        forceBuildYAxisTick: true\n                    });\n                }\n            }\n        }\n        return true;\n    };\n    SeparatorWidget.prototype._mouseEnterEvent = function () {\n        var pane = this.getPane();\n        var bottomPane = pane.getBottomPane();\n        if (bottomPane.getOptions().dragEnabled) {\n            var chart = pane.getChart();\n            var styles = chart.getStyles().separator;\n            this.getContainer().style.background = styles.activeBackgroundColor;\n            return true;\n        }\n        return false;\n    };\n    SeparatorWidget.prototype._mouseLeaveEvent = function () {\n        if (!this._dragFlag) {\n            this.getContainer().style.background = 'transparent';\n            return true;\n        }\n        return false;\n    };\n    SeparatorWidget.prototype.createContainer = function () {\n        return createDom('div', {\n            width: '100%',\n            height: \"\".concat(REAL_SEPARATOR_HEIGHT, \"px\"),\n            margin: '0',\n            padding: '0',\n            position: 'absolute',\n            top: '-3px',\n            zIndex: '20',\n            boxSizing: 'border-box',\n            cursor: 'ns-resize'\n        });\n    };\n    SeparatorWidget.prototype.updateImp = function (container, _bounding, level) {\n        if (level === 4 /* UpdateLevel.All */ || level === 2 /* UpdateLevel.Separator */) {\n            var styles = this.getPane().getChart().getStyles().separator;\n            container.style.top = \"\".concat(-Math.floor((REAL_SEPARATOR_HEIGHT - styles.size) / 2), \"px\");\n            container.style.height = \"\".concat(REAL_SEPARATOR_HEIGHT, \"px\");\n        }\n    };\n    return SeparatorWidget;\n}(Widget));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SeparatorPane = /** @class */ (function (_super) {\n    __extends(SeparatorPane, _super);\n    function SeparatorPane(chart, id, topPane, bottomPane) {\n        var _this = _super.call(this, chart, id) || this;\n        _this.getContainer().style.overflow = '';\n        _this._topPane = topPane;\n        _this._bottomPane = bottomPane;\n        _this._separatorWidget = new SeparatorWidget(_this.getContainer(), _this);\n        return _this;\n    }\n    SeparatorPane.prototype.setBounding = function (rootBounding) {\n        merge(this.getBounding(), rootBounding);\n        return this;\n    };\n    SeparatorPane.prototype.getTopPane = function () {\n        return this._topPane;\n    };\n    SeparatorPane.prototype.setTopPane = function (pane) {\n        this._topPane = pane;\n        return this;\n    };\n    SeparatorPane.prototype.getBottomPane = function () {\n        return this._bottomPane;\n    };\n    SeparatorPane.prototype.setBottomPane = function (pane) {\n        this._bottomPane = pane;\n        return this;\n    };\n    SeparatorPane.prototype.getWidget = function () { return this._separatorWidget; };\n    SeparatorPane.prototype.getImage = function (_includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var styles = this.getChart().getStyles().separator;\n        var canvas = createDom('canvas', {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: 'border-box'\n        });\n        var ctx = canvas.getContext('2d');\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.fillStyle = styles.color;\n        ctx.fillRect(0, 0, width, height);\n        return canvas;\n    };\n    SeparatorPane.prototype.updateImp = function (level, container, bounding) {\n        if (level === 4 /* UpdateLevel.All */ || level === 2 /* UpdateLevel.Separator */) {\n            var styles = this.getChart().getStyles().separator;\n            container.style.backgroundColor = styles.color;\n            container.style.height = \"\".concat(bounding.height, \"px\");\n            container.style.marginLeft = \"\".concat(bounding.left, \"px\");\n            container.style.width = \"\".concat(bounding.width, \"px\");\n            this._separatorWidget.update(level);\n        }\n    };\n    return SeparatorPane;\n}(Pane));\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isFF() {\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    return window.navigator.userAgent.toLowerCase().includes('firefox');\n}\nfunction isIOS() {\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    return /iPhone|iPad|iPod|iOS/.test(window.navigator.userAgent);\n}\n\n/* eslint-disable eslint-comments/require-description -- ignore */\nvar ManhattanDistance = {\n    CancelClick: 5,\n    CancelTap: 5,\n    DoubleClick: 5,\n    DoubleTap: 30\n};\nvar MouseEventButton = {\n    Left: 0,\n    Middle: 1,\n    Right: 2\n};\nvar TOUCH_MIN_RADIUS = 10;\n// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum\nvar SyntheticEvent = /** @class */ (function () {\n    function SyntheticEvent(target, handler, options) {\n        var _this = this;\n        this._clickCount = 0;\n        this._clickTimeoutId = null;\n        this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };\n        this._tapCount = 0;\n        this._tapTimeoutId = null;\n        this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };\n        this._longTapTimeoutId = null;\n        this._longTapActive = false;\n        this._mouseMoveStartCoordinate = null;\n        this._touchMoveStartCoordinate = null;\n        this._touchMoveExceededManhattanDistance = false;\n        this._cancelClick = false;\n        this._cancelTap = false;\n        this._unsubscribeOutsideMouseEvents = null;\n        this._unsubscribeOutsideTouchEvents = null;\n        this._unsubscribeMobileSafariEvents = null;\n        this._unsubscribeMousemove = null;\n        this._unsubscribeMouseWheel = null;\n        this._unsubscribeContextMenu = null;\n        this._unsubscribeRootMouseEvents = null;\n        this._unsubscribeRootTouchEvents = null;\n        this._startPinchMiddleCoordinate = null;\n        this._startPinchDistance = 0;\n        this._pinchPrevented = false;\n        this._preventTouchDragProcess = false;\n        this._mousePressed = false;\n        this._lastTouchEventTimeStamp = 0;\n        // for touchstart/touchmove/touchend events we handle only first touch\n        // i.e. we don't support several active touches at the same time (except pinch event)\n        this._activeTouchId = null;\n        // accept all mouse leave events if it's not an iOS device\n        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler\n        this._acceptMouseLeave = !isIOS();\n        /**\n         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.\n         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.\n         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.\n         */\n        this._onFirefoxOutsideMouseUp = function (mouseUpEvent) {\n            _this._mouseUpHandler(mouseUpEvent);\n        };\n        /**\n         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.\n         * There are two possible solutions:\n         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.\n         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.\n         * https://developer.apple.com/forums/thread/125073\n         */\n        this._onMobileSafariDoubleClick = function (dblClickEvent) {\n            if (_this._firesTouchEvents(dblClickEvent)) {\n                ++_this._tapCount;\n                if (_this._tapTimeoutId !== null && _this._tapCount > 1) {\n                    var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._tapCoordinate).manhattanDistance;\n                    if (manhattanDistance < ManhattanDistance.DoubleTap && !_this._cancelTap) {\n                        _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.doubleTapEvent);\n                    }\n                    _this._resetTapTimeout();\n                }\n            }\n            else {\n                ++_this._clickCount;\n                if (_this._clickTimeoutId !== null && _this._clickCount > 1) {\n                    var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._clickCoordinate).manhattanDistance;\n                    if (manhattanDistance < ManhattanDistance.DoubleClick && !_this._cancelClick) {\n                        _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.mouseDoubleClickEvent);\n                    }\n                    _this._resetClickTimeout();\n                }\n            }\n        };\n        this._target = target;\n        this._handler = handler;\n        this._options = options;\n        this._init();\n    }\n    SyntheticEvent.prototype.destroy = function () {\n        if (this._unsubscribeOutsideMouseEvents !== null) {\n            this._unsubscribeOutsideMouseEvents();\n            this._unsubscribeOutsideMouseEvents = null;\n        }\n        if (this._unsubscribeOutsideTouchEvents !== null) {\n            this._unsubscribeOutsideTouchEvents();\n            this._unsubscribeOutsideTouchEvents = null;\n        }\n        if (this._unsubscribeMousemove !== null) {\n            this._unsubscribeMousemove();\n            this._unsubscribeMousemove = null;\n        }\n        if (this._unsubscribeMouseWheel !== null) {\n            this._unsubscribeMouseWheel();\n            this._unsubscribeMouseWheel = null;\n        }\n        if (this._unsubscribeContextMenu !== null) {\n            this._unsubscribeContextMenu();\n            this._unsubscribeContextMenu = null;\n        }\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        if (this._unsubscribeMobileSafariEvents !== null) {\n            this._unsubscribeMobileSafariEvents();\n            this._unsubscribeMobileSafariEvents = null;\n        }\n        this._clearLongTapTimeout();\n        this._resetClickTimeout();\n    };\n    SyntheticEvent.prototype._mouseEnterHandler = function (enterEvent) {\n        var _this = this;\n        var _a, _b, _c;\n        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);\n        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundMouseMoveHandler = this._mouseMoveHandler.bind(this);\n        this._unsubscribeMousemove = function () {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener('mousemove', boundMouseMoveHandler);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('mousemove', boundMouseMoveHandler);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundMouseWheel = this._mouseWheelHandler.bind(this);\n        this._unsubscribeMouseWheel = function () {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener('wheel', boundMouseWheel);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('wheel', boundMouseWheel, { passive: false });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundContextMenu = this._contextMenuHandler.bind(this);\n        this._unsubscribeContextMenu = function () {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener('contextmenu', boundContextMenu);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('contextmenu', boundContextMenu, { passive: false });\n        if (this._firesTouchEvents(enterEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(enterEvent), this._handler.mouseEnterEvent);\n        this._acceptMouseLeave = true;\n    };\n    SyntheticEvent.prototype._resetClickTimeout = function () {\n        if (this._clickTimeoutId !== null) {\n            clearTimeout(this._clickTimeoutId);\n        }\n        this._clickCount = 0;\n        this._clickTimeoutId = null;\n        this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };\n    };\n    SyntheticEvent.prototype._resetTapTimeout = function () {\n        if (this._tapTimeoutId !== null) {\n            clearTimeout(this._tapTimeoutId);\n        }\n        this._tapCount = 0;\n        this._tapTimeoutId = null;\n        this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };\n    };\n    SyntheticEvent.prototype._mouseMoveHandler = function (moveEvent) {\n        if (this._mousePressed || this._touchMoveStartCoordinate !== null) {\n            return;\n        }\n        if (this._firesTouchEvents(moveEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(moveEvent), this._handler.mouseMoveEvent);\n        this._acceptMouseLeave = true;\n    };\n    SyntheticEvent.prototype._mouseWheelHandler = function (wheelEvent) {\n        if (Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {\n            if (!isValid(this._handler.mouseWheelHortEvent)) {\n                return;\n            }\n            this._preventDefault(wheelEvent);\n            if (Math.abs(wheelEvent.deltaX) === 0) {\n                return;\n            }\n            this._handler.mouseWheelHortEvent(this._makeCompatEvent(wheelEvent), -wheelEvent.deltaX);\n        }\n        else {\n            if (!isValid(this._handler.mouseWheelVertEvent)) {\n                return;\n            }\n            var deltaY = -(wheelEvent.deltaY / 100);\n            if (deltaY === 0) {\n                return;\n            }\n            this._preventDefault(wheelEvent);\n            switch (wheelEvent.deltaMode) {\n                case wheelEvent.DOM_DELTA_PAGE: {\n                    deltaY *= 120;\n                    break;\n                }\n                case wheelEvent.DOM_DELTA_LINE: {\n                    deltaY *= 32;\n                    break;\n                }\n            }\n            if (deltaY !== 0) {\n                var scale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));\n                this._handler.mouseWheelVertEvent(this._makeCompatEvent(wheelEvent), scale);\n            }\n        }\n    };\n    SyntheticEvent.prototype._contextMenuHandler = function (mouseEvent) {\n        this._preventDefault(mouseEvent);\n    };\n    SyntheticEvent.prototype._touchMoveHandler = function (moveEvent) {\n        var touch = this._touchWithId(moveEvent.changedTouches, this._activeTouchId);\n        if (touch === null) {\n            return;\n        }\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(moveEvent);\n        if (this._startPinchMiddleCoordinate !== null) {\n            return;\n        }\n        if (this._preventTouchDragProcess) {\n            return;\n        }\n        // prevent pinch if move event comes faster than the second touch\n        this._pinchPrevented = true;\n        var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._touchMoveStartCoordinate);\n        var xOffset = moveInfo.xOffset, yOffset = moveInfo.yOffset, manhattanDistance = moveInfo.manhattanDistance;\n        if (!this._touchMoveExceededManhattanDistance && manhattanDistance < ManhattanDistance.CancelTap) {\n            return;\n        }\n        if (!this._touchMoveExceededManhattanDistance) {\n            // first time when current position exceeded manhattan distance\n            // vertical drag is more important than horizontal drag\n            // because we scroll the page vertically often than horizontally\n            var correctedXOffset = xOffset * 0.5;\n            // a drag can be only if touch page scroll isn't allowed\n            var isVertDrag = yOffset >= correctedXOffset && !this._options.treatVertDragAsPageScroll();\n            var isHorzDrag = correctedXOffset > yOffset && !this._options.treatHorzDragAsPageScroll();\n            // if drag event happened then we should revert preventDefault state to original one\n            // and try to process the drag event\n            // else we shouldn't prevent default of the event and ignore processing the drag event\n            if (!isVertDrag && !isHorzDrag) {\n                this._preventTouchDragProcess = true;\n            }\n            this._touchMoveExceededManhattanDistance = true;\n            // if manhattan distance is more that 5 - we should cancel tap event\n            this._cancelTap = true;\n            this._clearLongTapTimeout();\n            this._resetTapTimeout();\n        }\n        if (!this._preventTouchDragProcess) {\n            this._processEvent(this._makeCompatEvent(moveEvent, touch), this._handler.touchMoveEvent);\n            // we should prevent default in case of touch only\n            // to prevent scroll of the page\n            // preventDefault(moveEvent)\n        }\n    };\n    SyntheticEvent.prototype._mouseMoveWithDownHandler = function (moveEvent) {\n        if (moveEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(moveEvent), this._mouseMoveStartCoordinate);\n        var manhattanDistance = moveInfo.manhattanDistance;\n        if (manhattanDistance >= ManhattanDistance.CancelClick) {\n            // if manhattan distance is more that 5 - we should cancel click event\n            this._cancelClick = true;\n            this._resetClickTimeout();\n        }\n        if (this._cancelClick) {\n            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded\n            this._processEvent(this._makeCompatEvent(moveEvent), this._handler.pressedMouseMoveEvent);\n        }\n    };\n    SyntheticEvent.prototype._mouseTouchMoveWithDownInfo = function (currentCoordinate, startCoordinate) {\n        var xOffset = Math.abs(startCoordinate.x - currentCoordinate.x);\n        var yOffset = Math.abs(startCoordinate.y - currentCoordinate.y);\n        var manhattanDistance = xOffset + yOffset;\n        return { xOffset: xOffset, yOffset: yOffset, manhattanDistance: manhattanDistance };\n    };\n    SyntheticEvent.prototype._touchEndHandler = function (touchEndEvent) {\n        var touch = this._touchWithId(touchEndEvent.changedTouches, this._activeTouchId);\n        if (touch === null && touchEndEvent.touches.length === 0) {\n            // something went wrong, somehow we missed the required touchend event\n            // probably the browser has not sent this event\n            touch = touchEndEvent.changedTouches[0];\n        }\n        if (touch === null) {\n            return;\n        }\n        this._activeTouchId = null;\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(touchEndEvent);\n        this._clearLongTapTimeout();\n        this._touchMoveStartCoordinate = null;\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        var compatEvent = this._makeCompatEvent(touchEndEvent, touch);\n        this._processEvent(compatEvent, this._handler.touchEndEvent);\n        ++this._tapCount;\n        if (this._tapTimeoutId !== null && this._tapCount > 1) {\n            // check that both clicks are near enough\n            var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._tapCoordinate).manhattanDistance;\n            if (manhattanDistance < ManhattanDistance.DoubleTap && !this._cancelTap) {\n                this._processEvent(compatEvent, this._handler.doubleTapEvent);\n            }\n            this._resetTapTimeout();\n        }\n        else {\n            if (!this._cancelTap) {\n                this._processEvent(compatEvent, this._handler.tapEvent);\n                // do not fire mouse events if tap handler was executed\n                // prevent click event on new dom element (who appeared after tap)\n                if (isValid(this._handler.tapEvent)) {\n                    this._preventDefault(touchEndEvent);\n                }\n            }\n        }\n        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap\n        // we handle mouseDoubleClickEvent here ourselves\n        if (this._tapCount === 0) {\n            this._preventDefault(touchEndEvent);\n        }\n        if (touchEndEvent.touches.length === 0) {\n            if (this._longTapActive) {\n                this._longTapActive = false;\n                // prevent native click event\n                this._preventDefault(touchEndEvent);\n            }\n        }\n    };\n    SyntheticEvent.prototype._mouseUpHandler = function (mouseUpEvent) {\n        if (mouseUpEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var compatEvent = this._makeCompatEvent(mouseUpEvent);\n        this._mouseMoveStartCoordinate = null;\n        this._mousePressed = false;\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        if (isFF()) {\n            var rootElement = this._target.ownerDocument.documentElement;\n            rootElement.removeEventListener('mouseleave', this._onFirefoxOutsideMouseUp);\n        }\n        if (this._firesTouchEvents(mouseUpEvent)) {\n            return;\n        }\n        this._processEvent(compatEvent, this._handler.mouseUpEvent);\n        ++this._clickCount;\n        if (this._clickTimeoutId !== null && this._clickCount > 1) {\n            // check that both clicks are near enough\n            var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(mouseUpEvent), this._clickCoordinate).manhattanDistance;\n            if (manhattanDistance < ManhattanDistance.DoubleClick && !this._cancelClick) {\n                this._processEvent(compatEvent, this._handler.mouseDoubleClickEvent);\n            }\n            this._resetClickTimeout();\n        }\n        else {\n            if (!this._cancelClick) {\n                this._processEvent(compatEvent, this._handler.mouseClickEvent);\n            }\n        }\n    };\n    SyntheticEvent.prototype._clearLongTapTimeout = function () {\n        if (this._longTapTimeoutId === null) {\n            return;\n        }\n        clearTimeout(this._longTapTimeoutId);\n        this._longTapTimeoutId = null;\n    };\n    SyntheticEvent.prototype._touchStartHandler = function (downEvent) {\n        if (this._activeTouchId !== null) {\n            return;\n        }\n        var touch = downEvent.changedTouches[0];\n        this._activeTouchId = touch.identifier;\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(downEvent);\n        var rootElement = this._target.ownerDocument.documentElement;\n        this._cancelTap = false;\n        this._touchMoveExceededManhattanDistance = false;\n        this._preventTouchDragProcess = false;\n        this._touchMoveStartCoordinate = this._getCoordinate(touch);\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundTouchMoveWithDownHandler_1 = this._touchMoveHandler.bind(this);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundTouchEndHandler_1 = this._touchEndHandler.bind(this);\n            this._unsubscribeRootTouchEvents = function () {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener('touchmove', boundTouchMoveWithDownHandler_1);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener('touchend', boundTouchEndHandler_1);\n            };\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener('touchmove', boundTouchMoveWithDownHandler_1, { passive: false });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener('touchend', boundTouchEndHandler_1, { passive: false });\n            this._clearLongTapTimeout();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, downEvent), 500 /* Delay.LongTap */);\n        }\n        this._processEvent(this._makeCompatEvent(downEvent, touch), this._handler.touchStartEvent);\n        if (this._tapTimeoutId === null) {\n            this._tapCount = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), 500 /* Delay.ResetClick */);\n            this._tapCoordinate = this._getCoordinate(touch);\n        }\n    };\n    SyntheticEvent.prototype._mouseDownHandler = function (downEvent) {\n        if (downEvent.button === MouseEventButton.Right) {\n            this._preventDefault(downEvent);\n            this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseRightClickEvent);\n            return;\n        }\n        if (downEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var rootElement = this._target.ownerDocument.documentElement;\n        if (isFF()) {\n            rootElement.addEventListener('mouseleave', this._onFirefoxOutsideMouseUp);\n        }\n        this._cancelClick = false;\n        this._mouseMoveStartCoordinate = this._getCoordinate(downEvent);\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundMouseMoveWithDownHandler_1 = this._mouseMoveWithDownHandler.bind(this);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundMouseUpHandler_1 = this._mouseUpHandler.bind(this);\n            this._unsubscribeRootMouseEvents = function () {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener('mousemove', boundMouseMoveWithDownHandler_1);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener('mouseup', boundMouseUpHandler_1);\n            };\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener('mousemove', boundMouseMoveWithDownHandler_1);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener('mouseup', boundMouseUpHandler_1);\n        }\n        this._mousePressed = true;\n        if (this._firesTouchEvents(downEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseDownEvent);\n        if (this._clickTimeoutId === null) {\n            this._clickCount = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), 500 /* Delay.ResetClick */);\n            this._clickCoordinate = this._getCoordinate(downEvent);\n        }\n    };\n    SyntheticEvent.prototype._init = function () {\n        var _this = this;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('mouseenter', this._mouseEnterHandler.bind(this));\n        // Do not show context menu when something went wrong\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('touchcancel', this._clearLongTapTimeout.bind(this));\n        {\n            var doc_1 = this._target.ownerDocument;\n            var outsideHandler_1 = function (event) {\n                if (_this._handler.mouseDownOutsideEvent == null) {\n                    return;\n                }\n                if (event.composed && _this._target.contains(event.composedPath()[0])) {\n                    return;\n                }\n                if ((event.target !== null) && _this._target.contains(event.target)) {\n                    return;\n                }\n                _this._handler.mouseDownOutsideEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });\n            };\n            this._unsubscribeOutsideTouchEvents = function () {\n                doc_1.removeEventListener('touchstart', outsideHandler_1);\n            };\n            this._unsubscribeOutsideMouseEvents = function () {\n                doc_1.removeEventListener('mousedown', outsideHandler_1);\n            };\n            doc_1.addEventListener('mousedown', outsideHandler_1);\n            doc_1.addEventListener('touchstart', outsideHandler_1, { passive: true });\n        }\n        if (isIOS()) {\n            this._unsubscribeMobileSafariEvents = function () {\n                _this._target.removeEventListener('dblclick', _this._onMobileSafariDoubleClick);\n            };\n            this._target.addEventListener('dblclick', this._onMobileSafariDoubleClick);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('mouseleave', this._mouseLeaveHandler.bind(this));\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('touchstart', this._touchStartHandler.bind(this), { passive: true });\n        this._target.addEventListener('mousedown', function (e) {\n            if (e.button === MouseEventButton.Middle) {\n                // prevent incorrect scrolling event\n                e.preventDefault();\n                return false;\n            }\n            return undefined;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener('mousedown', this._mouseDownHandler.bind(this));\n        this._initPinch();\n        // Hey mobile Safari, what's up?\n        // If mobile Safari doesn't have any touchmove handler with passive=false\n        // it treats a touchstart and the following touchmove events as cancelable=false,\n        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).\n        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this._target.addEventListener('touchmove', function () { }, { passive: false });\n    };\n    SyntheticEvent.prototype._initPinch = function () {\n        var _this = this;\n        if (!isValid(this._handler.pinchStartEvent) &&\n            !isValid(this._handler.pinchEvent) &&\n            !isValid(this._handler.pinchEndEvent)) {\n            return;\n        }\n        this._target.addEventListener('touchstart', function (event) { _this._checkPinchState(event.touches); }, { passive: true });\n        this._target.addEventListener('touchmove', function (event) {\n            if (event.touches.length !== 2 || _this._startPinchMiddleCoordinate === null) {\n                return;\n            }\n            if (isValid(_this._handler.pinchEvent)) {\n                var currentDistance = _this._getTouchDistance(event.touches[0], event.touches[1]);\n                var scale = currentDistance / _this._startPinchDistance;\n                _this._handler.pinchEvent(__assign(__assign({}, _this._startPinchMiddleCoordinate), { pageX: 0, pageY: 0 }), scale);\n                _this._preventDefault(event);\n            }\n        }, { passive: false });\n        this._target.addEventListener('touchend', function (event) {\n            _this._checkPinchState(event.touches);\n        });\n    };\n    SyntheticEvent.prototype._checkPinchState = function (touches) {\n        if (touches.length === 1) {\n            this._pinchPrevented = false;\n        }\n        if (touches.length !== 2 || this._pinchPrevented || this._longTapActive) {\n            this._stopPinch();\n        }\n        else {\n            this._startPinch(touches);\n        }\n    };\n    SyntheticEvent.prototype._startPinch = function (touches) {\n        var box = this._target.getBoundingClientRect();\n        this._startPinchMiddleCoordinate = {\n            x: ((touches[0].clientX - box.left) + (touches[1].clientX - box.left)) / 2,\n            y: ((touches[0].clientY - box.top) + (touches[1].clientY - box.top)) / 2\n        };\n        this._startPinchDistance = this._getTouchDistance(touches[0], touches[1]);\n        if (isValid(this._handler.pinchStartEvent)) {\n            this._handler.pinchStartEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });\n        }\n        this._clearLongTapTimeout();\n    };\n    SyntheticEvent.prototype._stopPinch = function () {\n        if (this._startPinchMiddleCoordinate === null) {\n            return;\n        }\n        this._startPinchMiddleCoordinate = null;\n        if (isValid(this._handler.pinchEndEvent)) {\n            this._handler.pinchEndEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });\n        }\n    };\n    SyntheticEvent.prototype._mouseLeaveHandler = function (event) {\n        var _a, _b, _c;\n        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);\n        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);\n        if (this._firesTouchEvents(event)) {\n            return;\n        }\n        if (!this._acceptMouseLeave) {\n            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way\n            // just ignore this event if there was no mouse move or mouse enter events\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(event), this._handler.mouseLeaveEvent);\n        // accept all mouse leave events if it's not an iOS device\n        this._acceptMouseLeave = !isIOS();\n    };\n    SyntheticEvent.prototype._longTapHandler = function (event) {\n        var touch = this._touchWithId(event.touches, this._activeTouchId);\n        if (touch === null) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(event, touch), this._handler.longTapEvent);\n        this._cancelTap = true;\n        // long tap is active until touchend event with 0 touches occurred\n        this._longTapActive = true;\n    };\n    SyntheticEvent.prototype._firesTouchEvents = function (e) {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (isValid((_a = e.sourceCapabilities) === null || _a === void 0 ? void 0 : _a.firesTouchEvents)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-expect-error\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n            return e.sourceCapabilities.firesTouchEvents;\n        }\n        return this._eventTimeStamp(e) < this._lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */;\n    };\n    SyntheticEvent.prototype._processEvent = function (event, callback) {\n        callback === null || callback === void 0 ? void 0 : callback.call(this._handler, event);\n    };\n    SyntheticEvent.prototype._makeCompatEvent = function (event, touch) {\n        var _this = this;\n        // TouchEvent has no clientX/Y coordinates:\n        // We have to use the last Touch instead\n        var eventLike = touch !== null && touch !== void 0 ? touch : event;\n        var box = this._target.getBoundingClientRect();\n        return {\n            x: eventLike.clientX - box.left,\n            y: eventLike.clientY - box.top,\n            pageX: eventLike.pageX,\n            pageY: eventLike.pageY,\n            isTouch: !event.type.startsWith('mouse') && event.type !== 'contextmenu' && event.type !== 'click' && event.type !== 'wheel',\n            preventDefault: function () {\n                if (event.type !== 'touchstart') {\n                    // touchstart is passive and cannot be prevented\n                    _this._preventDefault(event);\n                }\n            }\n        };\n    };\n    SyntheticEvent.prototype._getTouchDistance = function (p1, p2) {\n        var xDiff = p1.clientX - p2.clientX;\n        var yDiff = p1.clientY - p2.clientY;\n        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    };\n    SyntheticEvent.prototype._preventDefault = function (event) {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n    };\n    SyntheticEvent.prototype._getCoordinate = function (eventLike) {\n        return {\n            x: eventLike.pageX,\n            y: eventLike.pageY\n        };\n    };\n    SyntheticEvent.prototype._eventTimeStamp = function (e) {\n        var _a;\n        // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        return (_a = e.timeStamp) !== null && _a !== void 0 ? _a : performance.now();\n    };\n    SyntheticEvent.prototype._touchWithId = function (touches, id) {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (var i = 0; i < touches.length; ++i) {\n            if (touches[i].identifier === id) {\n                return touches[i];\n            }\n        }\n        return null;\n    };\n    return SyntheticEvent;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Event = /** @class */ (function () {\n    function Event(container, chart) {\n        var _this = this;\n        // 惯性滚动开始时间\n        this._flingStartTime = new Date().getTime();\n        // 惯性滚动定时器\n        this._flingScrollRequestId = null;\n        // 开始滚动时坐标点\n        this._startScrollCoordinate = null;\n        // 开始触摸时坐标\n        this._touchCoordinate = null;\n        // 是否是取消了十字光标\n        this._touchCancelCrosshair = false;\n        // 是否缩放过\n        this._touchZoomed = false;\n        // 用来记录捏合缩放的尺寸\n        this._pinchScale = 1;\n        this._mouseDownWidget = null;\n        this._prevYAxisRange = null;\n        this._xAxisStartScaleCoordinate = null;\n        this._xAxisStartScaleDistance = 0;\n        this._xAxisScale = 1;\n        this._yAxisStartScaleDistance = 0;\n        this._mouseMoveTriggerWidgetInfo = { pane: null, widget: null };\n        this._boundKeyBoardDownEvent = function (event) {\n            if (event.shiftKey) {\n                switch (event.code) {\n                    case 'Equal': {\n                        _this._chart.getChartStore().zoom(0.5);\n                        break;\n                    }\n                    case 'Minus': {\n                        _this._chart.getChartStore().zoom(-0.5);\n                        break;\n                    }\n                    case 'ArrowLeft': {\n                        var store = _this._chart.getChartStore();\n                        store.startScroll();\n                        store.scroll(-3 * store.getBarSpace().bar);\n                        break;\n                    }\n                    case 'ArrowRight': {\n                        var store = _this._chart.getChartStore();\n                        store.startScroll();\n                        store.scroll(3 * store.getBarSpace().bar);\n                        break;\n                    }\n                }\n            }\n        };\n        this._container = container;\n        this._chart = chart;\n        this._event = new SyntheticEvent(container, this, {\n            treatVertDragAsPageScroll: function () { return false; },\n            treatHorzDragAsPageScroll: function () { return false; }\n        });\n        container.addEventListener('keydown', this._boundKeyBoardDownEvent);\n    }\n    Event.prototype.pinchStartEvent = function () {\n        this._touchZoomed = true;\n        this._pinchScale = 1;\n        return true;\n    };\n    Event.prototype.pinchEvent = function (e, scale) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if ((pane === null || pane === void 0 ? void 0 : pane.getId()) !== PaneIdConstants.X_AXIS && (widget === null || widget === void 0 ? void 0 : widget.getName()) === WidgetNameConstants.MAIN) {\n            var event_1 = this._makeWidgetEvent(e, widget);\n            var zoomScale = (scale - this._pinchScale) * 5;\n            this._pinchScale = scale;\n            this._chart.getChartStore().zoom(zoomScale, { x: event_1.x, y: event_1.y });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype.mouseWheelHortEvent = function (_, distance) {\n        var store = this._chart.getChartStore();\n        store.startScroll();\n        store.scroll(distance);\n        return true;\n    };\n    Event.prototype.mouseWheelVertEvent = function (e, scale) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var event = this._makeWidgetEvent(e, widget);\n        var name = widget === null || widget === void 0 ? void 0 : widget.getName();\n        if (name === WidgetNameConstants.MAIN) {\n            this._chart.getChartStore().zoom(scale, { x: event.x, y: event.y });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype.mouseDownEvent = function (e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        this._mouseDownWidget = widget;\n        if (widget !== null) {\n            var event_2 = this._makeWidgetEvent(e, widget);\n            var name_1 = widget.getName();\n            switch (name_1) {\n                case WidgetNameConstants.SEPARATOR: {\n                    return widget.dispatchEvent('mouseDownEvent', event_2);\n                }\n                case WidgetNameConstants.MAIN: {\n                    var yAxis = pane.getAxisComponent();\n                    if (!yAxis.getAutoCalcTickFlag()) {\n                        var range = yAxis.getRange();\n                        this._prevYAxisRange = __assign({}, range);\n                    }\n                    this._startScrollCoordinate = { x: event_2.x, y: event_2.y };\n                    this._chart.getChartStore().startScroll();\n                    return widget.dispatchEvent('mouseDownEvent', event_2);\n                }\n                case WidgetNameConstants.X_AXIS: {\n                    return this._processXAxisScrollStartEvent(widget, event_2);\n                }\n                case WidgetNameConstants.Y_AXIS: {\n                    return this._processYAxisScaleStartEvent(widget, event_2);\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseMoveEvent = function (e) {\n        var _a, _b, _c;\n        var _d = this._findWidgetByEvent(e), pane = _d.pane, widget = _d.widget;\n        var event = this._makeWidgetEvent(e, widget);\n        if (((_a = this._mouseMoveTriggerWidgetInfo.pane) === null || _a === void 0 ? void 0 : _a.getId()) !== (pane === null || pane === void 0 ? void 0 : pane.getId()) ||\n            ((_b = this._mouseMoveTriggerWidgetInfo.widget) === null || _b === void 0 ? void 0 : _b.getName()) !== (widget === null || widget === void 0 ? void 0 : widget.getName())) {\n            widget === null || widget === void 0 ? void 0 : widget.dispatchEvent('mouseEnterEvent', event);\n            (_c = this._mouseMoveTriggerWidgetInfo.widget) === null || _c === void 0 ? void 0 : _c.dispatchEvent('mouseLeaveEvent', event);\n            this._mouseMoveTriggerWidgetInfo = { pane: pane, widget: widget };\n        }\n        if (widget !== null) {\n            var name_2 = widget.getName();\n            switch (name_2) {\n                case WidgetNameConstants.MAIN: {\n                    var consumed = widget.dispatchEvent('mouseMoveEvent', event);\n                    var crosshair = { x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() };\n                    if (consumed) {\n                        crosshair = undefined;\n                        widget.getContainer().style.cursor = 'pointer';\n                    }\n                    else {\n                        widget.getContainer().style.cursor = 'crosshair';\n                    }\n                    this._chart.getChartStore().setCrosshair(crosshair);\n                    return consumed;\n                }\n                case WidgetNameConstants.SEPARATOR:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS: {\n                    var consumed = widget.dispatchEvent('mouseMoveEvent', event);\n                    this._chart.getChartStore().setCrosshair();\n                    return consumed;\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.pressedMouseMoveEvent = function (e) {\n        var _a, _b;\n        if (this._mouseDownWidget !== null && this._mouseDownWidget.getName() === WidgetNameConstants.SEPARATOR) {\n            return this._mouseDownWidget.dispatchEvent('pressedMouseMoveEvent', e);\n        }\n        var _c = this._findWidgetByEvent(e), pane = _c.pane, widget = _c.widget;\n        if (widget !== null &&\n            ((_a = this._mouseDownWidget) === null || _a === void 0 ? void 0 : _a.getPane().getId()) === (pane === null || pane === void 0 ? void 0 : pane.getId()) &&\n            ((_b = this._mouseDownWidget) === null || _b === void 0 ? void 0 : _b.getName()) === widget.getName()) {\n            var event_3 = this._makeWidgetEvent(e, widget);\n            var name_3 = widget.getName();\n            switch (name_3) {\n                case WidgetNameConstants.MAIN: {\n                    // eslint-disable-next-line @typescript-eslint/init-declarations -- ignore\n                    var crosshair = void 0;\n                    var consumed = widget.dispatchEvent('pressedMouseMoveEvent', event_3);\n                    if (!consumed) {\n                        crosshair = { x: event_3.x, y: event_3.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() };\n                        this._processMainScrollingEvent(widget, event_3);\n                    }\n                    this._chart.getChartStore().setCrosshair(crosshair, { forceInvalidate: true });\n                    return consumed;\n                }\n                case WidgetNameConstants.X_AXIS: {\n                    return this._processXAxisScrollingEvent(widget, event_3);\n                }\n                case WidgetNameConstants.Y_AXIS: {\n                    return this._processYAxisScalingEvent(widget, event_3);\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseUpEvent = function (e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_4 = this._makeWidgetEvent(e, widget);\n            var name_4 = widget.getName();\n            switch (name_4) {\n                case WidgetNameConstants.MAIN:\n                case WidgetNameConstants.SEPARATOR:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS: {\n                    consumed = widget.dispatchEvent('mouseUpEvent', event_4);\n                    break;\n                }\n            }\n            if (consumed) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n            }\n        }\n        this._mouseDownWidget = null;\n        this._startScrollCoordinate = null;\n        this._prevYAxisRange = null;\n        this._xAxisStartScaleCoordinate = null;\n        this._xAxisStartScaleDistance = 0;\n        this._xAxisScale = 1;\n        this._yAxisStartScaleDistance = 0;\n        return consumed;\n    };\n    Event.prototype.mouseClickEvent = function (e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        if (widget !== null) {\n            var event_5 = this._makeWidgetEvent(e, widget);\n            return widget.dispatchEvent('mouseClickEvent', event_5);\n        }\n        return false;\n    };\n    Event.prototype.mouseRightClickEvent = function (e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_6 = this._makeWidgetEvent(e, widget);\n            var name_5 = widget.getName();\n            switch (name_5) {\n                case WidgetNameConstants.MAIN:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS: {\n                    consumed = widget.dispatchEvent('mouseRightClickEvent', event_6);\n                    break;\n                }\n            }\n            if (consumed) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseDoubleClickEvent = function (e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if (widget !== null) {\n            var name_6 = widget.getName();\n            switch (name_6) {\n                case WidgetNameConstants.MAIN: {\n                    var event_7 = this._makeWidgetEvent(e, widget);\n                    return widget.dispatchEvent('mouseDoubleClickEvent', event_7);\n                }\n                case WidgetNameConstants.Y_AXIS: {\n                    var yAxis = pane.getAxisComponent();\n                    if (!yAxis.getAutoCalcTickFlag()) {\n                        yAxis.setAutoCalcTickFlag(true);\n                        this._chart.layout({\n                            measureWidth: true,\n                            update: true,\n                            buildYAxisTick: true\n                        });\n                        return true;\n                    }\n                    break;\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseLeaveEvent = function () {\n        this._chart.getChartStore().setCrosshair();\n        return true;\n    };\n    Event.prototype.touchStartEvent = function (e) {\n        var _a;\n        var _b = this._findWidgetByEvent(e), pane = _b.pane, widget = _b.widget;\n        if (widget !== null) {\n            var event_8 = this._makeWidgetEvent(e, widget);\n            (_a = event_8.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_8);\n            var name_7 = widget.getName();\n            switch (name_7) {\n                case WidgetNameConstants.MAIN: {\n                    var chartStore = this._chart.getChartStore();\n                    if (widget.dispatchEvent('mouseDownEvent', event_8)) {\n                        this._touchCancelCrosshair = true;\n                        this._touchCoordinate = null;\n                        chartStore.setCrosshair(undefined, { notInvalidate: true });\n                        this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n                        return true;\n                    }\n                    if (this._flingScrollRequestId !== null) {\n                        cancelAnimationFrame(this._flingScrollRequestId);\n                        this._flingScrollRequestId = null;\n                    }\n                    this._flingStartTime = new Date().getTime();\n                    var yAxis = pane.getAxisComponent();\n                    if (!yAxis.getAutoCalcTickFlag()) {\n                        var range = yAxis.getRange();\n                        this._prevYAxisRange = __assign({}, range);\n                    }\n                    this._startScrollCoordinate = { x: event_8.x, y: event_8.y };\n                    chartStore.startScroll();\n                    this._touchZoomed = false;\n                    if (this._touchCoordinate !== null) {\n                        var xDif = event_8.x - this._touchCoordinate.x;\n                        var yDif = event_8.y - this._touchCoordinate.y;\n                        var radius = Math.sqrt(xDif * xDif + yDif * yDif);\n                        if (radius < TOUCH_MIN_RADIUS) {\n                            this._touchCoordinate = { x: event_8.x, y: event_8.y };\n                            chartStore.setCrosshair({ x: event_8.x, y: event_8.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });\n                        }\n                        else {\n                            this._touchCoordinate = null;\n                            this._touchCancelCrosshair = true;\n                            chartStore.setCrosshair();\n                        }\n                    }\n                    return true;\n                }\n                case WidgetNameConstants.X_AXIS: {\n                    return this._processXAxisScrollStartEvent(widget, event_8);\n                }\n                case WidgetNameConstants.Y_AXIS: {\n                    return this._processYAxisScaleStartEvent(widget, event_8);\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.touchMoveEvent = function (e) {\n        var _a;\n        var _b = this._findWidgetByEvent(e), pane = _b.pane, widget = _b.widget;\n        if (widget !== null) {\n            var event_9 = this._makeWidgetEvent(e, widget);\n            (_a = event_9.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_9);\n            var name_8 = widget.getName();\n            var chartStore = this._chart.getChartStore();\n            switch (name_8) {\n                case WidgetNameConstants.MAIN: {\n                    if (widget.dispatchEvent('pressedMouseMoveEvent', event_9)) {\n                        chartStore.setCrosshair(undefined, { notInvalidate: true });\n                        this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n                        return true;\n                    }\n                    if (this._touchCoordinate !== null) {\n                        chartStore.setCrosshair({ x: event_9.x, y: event_9.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });\n                    }\n                    else {\n                        this._processMainScrollingEvent(widget, event_9);\n                    }\n                    return true;\n                }\n                case WidgetNameConstants.X_AXIS: {\n                    return this._processXAxisScrollingEvent(widget, event_9);\n                }\n                case WidgetNameConstants.Y_AXIS: {\n                    return this._processYAxisScalingEvent(widget, event_9);\n                }\n            }\n        }\n        return false;\n    };\n    Event.prototype.touchEndEvent = function (e) {\n        var _this = this;\n        var widget = this._findWidgetByEvent(e).widget;\n        if (widget !== null) {\n            var event_10 = this._makeWidgetEvent(e, widget);\n            var name_9 = widget.getName();\n            switch (name_9) {\n                case WidgetNameConstants.MAIN: {\n                    widget.dispatchEvent('mouseUpEvent', event_10);\n                    if (this._startScrollCoordinate !== null) {\n                        var time = new Date().getTime() - this._flingStartTime;\n                        var distance = event_10.x - this._startScrollCoordinate.x;\n                        var v_1 = distance / (time > 0 ? time : 1) * 20;\n                        if (time < 200 && Math.abs(v_1) > 0) {\n                            var store_1 = this._chart.getChartStore();\n                            var flingScroll_1 = function () {\n                                _this._flingScrollRequestId = requestAnimationFrame(function () {\n                                    store_1.startScroll();\n                                    store_1.scroll(v_1);\n                                    v_1 = v_1 * (1 - 0.025);\n                                    if (Math.abs(v_1) < 1) {\n                                        if (_this._flingScrollRequestId !== null) {\n                                            cancelAnimationFrame(_this._flingScrollRequestId);\n                                            _this._flingScrollRequestId = null;\n                                        }\n                                    }\n                                    else {\n                                        flingScroll_1();\n                                    }\n                                });\n                            };\n                            flingScroll_1();\n                        }\n                    }\n                    return true;\n                }\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS: {\n                    var consumed = widget.dispatchEvent('mouseUpEvent', event_10);\n                    if (consumed) {\n                        this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n                    }\n                }\n            }\n            this._startScrollCoordinate = null;\n            this._prevYAxisRange = null;\n            this._xAxisStartScaleCoordinate = null;\n            this._xAxisStartScaleDistance = 0;\n            this._xAxisScale = 1;\n            this._yAxisStartScaleDistance = 0;\n        }\n        return false;\n    };\n    Event.prototype.tapEvent = function (e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_11 = this._makeWidgetEvent(e, widget);\n            var result = widget.dispatchEvent('mouseClickEvent', event_11);\n            if (widget.getName() === WidgetNameConstants.MAIN) {\n                var event_12 = this._makeWidgetEvent(e, widget);\n                var chartStore = this._chart.getChartStore();\n                if (result) {\n                    this._touchCancelCrosshair = true;\n                    this._touchCoordinate = null;\n                    chartStore.setCrosshair(undefined, { notInvalidate: true });\n                    consumed = true;\n                }\n                else {\n                    if (!this._touchCancelCrosshair && !this._touchZoomed) {\n                        this._touchCoordinate = { x: event_12.x, y: event_12.y };\n                        chartStore.setCrosshair({ x: event_12.x, y: event_12.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() }, { notInvalidate: true });\n                        consumed = true;\n                    }\n                    this._touchCancelCrosshair = false;\n                }\n            }\n            if (consumed || result) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n            }\n        }\n        return consumed;\n    };\n    Event.prototype.doubleTapEvent = function (e) {\n        return this.mouseDoubleClickEvent(e);\n    };\n    Event.prototype.longTapEvent = function (e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if (widget !== null && widget.getName() === WidgetNameConstants.MAIN) {\n            var event_13 = this._makeWidgetEvent(e, widget);\n            this._touchCoordinate = { x: event_13.x, y: event_13.y };\n            this._chart.getChartStore().setCrosshair({ x: event_13.x, y: event_13.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype._processMainScrollingEvent = function (widget, event) {\n        if (this._startScrollCoordinate !== null) {\n            var yAxis = widget.getPane().getAxisComponent();\n            if (this._prevYAxisRange !== null && !yAxis.getAutoCalcTickFlag() && yAxis.scrollZoomEnabled) {\n                var _a = this._prevYAxisRange, from = _a.from, to = _a.to, range = _a.range;\n                var distance_1 = 0;\n                if (yAxis.reverse) {\n                    distance_1 = this._startScrollCoordinate.y - event.y;\n                }\n                else {\n                    distance_1 = event.y - this._startScrollCoordinate.y;\n                }\n                var bounding = widget.getBounding();\n                var scale = distance_1 / bounding.height;\n                var difRange = range * scale;\n                var newFrom = from + difRange;\n                var newTo = to + difRange;\n                var newRealFrom = yAxis.valueToRealValue(newFrom, { range: this._prevYAxisRange });\n                var newRealTo = yAxis.valueToRealValue(newTo, { range: this._prevYAxisRange });\n                var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, { range: this._prevYAxisRange });\n                var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, { range: this._prevYAxisRange });\n                yAxis.setRange({\n                    from: newFrom,\n                    to: newTo,\n                    range: newTo - newFrom,\n                    realFrom: newRealFrom,\n                    realTo: newRealTo,\n                    realRange: newRealTo - newRealFrom,\n                    displayFrom: newDisplayFrom,\n                    displayTo: newDisplayTo,\n                    displayRange: newDisplayTo - newDisplayFrom\n                });\n            }\n            var distance = event.x - this._startScrollCoordinate.x;\n            this._chart.getChartStore().scroll(distance);\n        }\n    };\n    Event.prototype._processXAxisScrollStartEvent = function (widget, event) {\n        var consumed = widget.dispatchEvent('mouseDownEvent', event);\n        if (consumed) {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n        }\n        this._xAxisStartScaleCoordinate = { x: event.x, y: event.y };\n        this._xAxisStartScaleDistance = event.pageX;\n        return consumed;\n    };\n    Event.prototype._processXAxisScrollingEvent = function (widget, event) {\n        var _a;\n        var consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);\n        if (!consumed) {\n            var xAxis = widget.getPane().getAxisComponent();\n            if (xAxis.scrollZoomEnabled && this._xAxisStartScaleDistance !== 0) {\n                var scale = this._xAxisStartScaleDistance / event.pageX;\n                if (Number.isFinite(scale)) {\n                    var zoomScale = (scale - this._xAxisScale) * 10;\n                    this._xAxisScale = scale;\n                    this._chart.getChartStore().zoom(zoomScale, (_a = this._xAxisStartScaleCoordinate) !== null && _a !== void 0 ? _a : undefined);\n                }\n            }\n        }\n        else {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n        }\n        return consumed;\n    };\n    Event.prototype._processYAxisScaleStartEvent = function (widget, event) {\n        var consumed = widget.dispatchEvent('mouseDownEvent', event);\n        if (consumed) {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n        }\n        var range = widget.getPane().getAxisComponent().getRange();\n        this._prevYAxisRange = __assign({}, range);\n        this._yAxisStartScaleDistance = event.pageY;\n        return consumed;\n    };\n    Event.prototype._processYAxisScalingEvent = function (widget, event) {\n        var consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);\n        if (!consumed) {\n            var yAxis = widget.getPane().getAxisComponent();\n            if (this._prevYAxisRange !== null && yAxis.scrollZoomEnabled && this._yAxisStartScaleDistance !== 0) {\n                var _a = this._prevYAxisRange, from = _a.from, to = _a.to, range = _a.range;\n                var scale = event.pageY / this._yAxisStartScaleDistance;\n                var newRange = range * scale;\n                var difRange = (newRange - range) / 2;\n                var newFrom = from - difRange;\n                var newTo = to + difRange;\n                var newRealFrom = yAxis.valueToRealValue(newFrom, { range: this._prevYAxisRange });\n                var newRealTo = yAxis.valueToRealValue(newTo, { range: this._prevYAxisRange });\n                var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, { range: this._prevYAxisRange });\n                var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, { range: this._prevYAxisRange });\n                yAxis.setRange({\n                    from: newFrom,\n                    to: newTo,\n                    range: newRange,\n                    realFrom: newRealFrom,\n                    realTo: newRealTo,\n                    realRange: newRealTo - newRealFrom,\n                    displayFrom: newDisplayFrom,\n                    displayTo: newDisplayTo,\n                    displayRange: newDisplayTo - newDisplayFrom\n                });\n                this._chart.layout({\n                    measureWidth: true,\n                    update: true,\n                    buildYAxisTick: true\n                });\n            }\n        }\n        else {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */);\n        }\n        return consumed;\n    };\n    Event.prototype._findWidgetByEvent = function (event) {\n        var e_1, _a, e_2, _b;\n        var x = event.x, y = event.y;\n        var separatorPanes = this._chart.getSeparatorPanes();\n        var separatorSize = this._chart.getStyles().separator.size;\n        try {\n            for (var separatorPanes_1 = __values(separatorPanes), separatorPanes_1_1 = separatorPanes_1.next(); !separatorPanes_1_1.done; separatorPanes_1_1 = separatorPanes_1.next()) {\n                var _c = __read(separatorPanes_1_1.value, 2), pane_1 = _c[1];\n                var bounding = pane_1.getBounding();\n                var top_1 = bounding.top - Math.round((REAL_SEPARATOR_HEIGHT - separatorSize) / 2);\n                if (x >= bounding.left && x <= bounding.left + bounding.width &&\n                    y >= top_1 && y <= top_1 + REAL_SEPARATOR_HEIGHT) {\n                    return { pane: pane_1, widget: pane_1.getWidget() };\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (separatorPanes_1_1 && !separatorPanes_1_1.done && (_a = separatorPanes_1.return)) _a.call(separatorPanes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var drawPanes = this._chart.getDrawPanes();\n        var pane = null;\n        try {\n            for (var drawPanes_1 = __values(drawPanes), drawPanes_1_1 = drawPanes_1.next(); !drawPanes_1_1.done; drawPanes_1_1 = drawPanes_1.next()) {\n                var p = drawPanes_1_1.value;\n                var bounding = p.getBounding();\n                if (x >= bounding.left && x <= bounding.left + bounding.width &&\n                    y >= bounding.top && y <= bounding.top + bounding.height) {\n                    pane = p;\n                    break;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (drawPanes_1_1 && !drawPanes_1_1.done && (_b = drawPanes_1.return)) _b.call(drawPanes_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        var widget = null;\n        if (pane !== null) {\n            if (!isValid(widget)) {\n                var mainWidget = pane.getMainWidget();\n                var mainBounding = mainWidget.getBounding();\n                if (x >= mainBounding.left && x <= mainBounding.left + mainBounding.width &&\n                    y >= mainBounding.top && y <= mainBounding.top + mainBounding.height) {\n                    widget = mainWidget;\n                }\n            }\n            if (!isValid(widget)) {\n                var yAxisWidget = pane.getYAxisWidget();\n                if (yAxisWidget !== null) {\n                    var yAxisBounding = yAxisWidget.getBounding();\n                    if (x >= yAxisBounding.left && x <= yAxisBounding.left + yAxisBounding.width &&\n                        y >= yAxisBounding.top && y <= yAxisBounding.top + yAxisBounding.height) {\n                        widget = yAxisWidget;\n                    }\n                }\n            }\n        }\n        return { pane: pane, widget: widget };\n    };\n    Event.prototype._makeWidgetEvent = function (event, widget) {\n        var _a, _b, _c;\n        var bounding = (_a = widget === null || widget === void 0 ? void 0 : widget.getBounding()) !== null && _a !== void 0 ? _a : null;\n        return __assign(__assign({}, event), { x: event.x - ((_b = bounding === null || bounding === void 0 ? void 0 : bounding.left) !== null && _b !== void 0 ? _b : 0), y: event.y - ((_c = bounding === null || bounding === void 0 ? void 0 : bounding.top) !== null && _c !== void 0 ? _c : 0) });\n    };\n    Event.prototype.destroy = function () {\n        this._container.removeEventListener('keydown', this._boundKeyBoardDownEvent);\n        this._event.destroy();\n    };\n    return Event;\n}());\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DomPosition;\n(function (DomPosition) {\n    DomPosition[\"Root\"] = \"root\";\n    DomPosition[\"Main\"] = \"main\";\n    DomPosition[\"YAxis\"] = \"yAxis\";\n})(DomPosition || (DomPosition = {}));\nvar ChartImp = /** @class */ (function () {\n    function ChartImp(container, options) {\n        this._chartBounding = createDefaultBounding();\n        this._drawPanes = [];\n        this._separatorPanes = new Map();\n        this._layoutOptions = {\n            sort: true,\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: false,\n            forceBuildYAxisTick: false\n        };\n        this._layoutPending = false;\n        this._initContainer(container);\n        this._chartEvent = new Event(this._chartContainer, this);\n        this._chartStore = new StoreImp(this, options);\n        this._initPanes(options);\n        this._layout();\n    }\n    ChartImp.prototype._initContainer = function (container) {\n        this._container = container;\n        this._chartContainer = createDom('div', {\n            position: 'relative',\n            width: '100%',\n            height: '100%',\n            outline: 'none',\n            borderStyle: 'none',\n            cursor: 'crosshair',\n            boxSizing: 'border-box',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            overflow: 'hidden',\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            msUserSelect: 'none',\n            MozUserSelect: 'none',\n            webkitTapHighlightColor: 'transparent'\n        });\n        this._chartContainer.tabIndex = 1;\n        container.appendChild(this._chartContainer);\n        this._cacheChartBounding();\n    };\n    ChartImp.prototype._cacheChartBounding = function () {\n        this._chartBounding.width = Math.floor(this._chartContainer.clientWidth);\n        this._chartBounding.height = Math.floor(this._chartContainer.clientHeight);\n    };\n    ChartImp.prototype._initPanes = function (options) {\n        var _this = this;\n        var _a;\n        var layout = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : [{ type: \"candle\" /* LayoutChildType.Candle */ }];\n        var createCandlePane = function (child) {\n            var _a, _b;\n            if (!isValid(_this._candlePane)) {\n                var paneOptions_1 = (_a = child.options) !== null && _a !== void 0 ? _a : {};\n                merge(paneOptions_1, { id: PaneIdConstants.CANDLE });\n                _this._candlePane = _this._createPane(CandlePane, PaneIdConstants.CANDLE, paneOptions_1);\n                var content = (_b = child.content) !== null && _b !== void 0 ? _b : [];\n                content.forEach(function (v) {\n                    _this.createIndicator(v, true, paneOptions_1);\n                });\n            }\n        };\n        var createXAxisPane = function (ops) {\n            if (!isValid(_this._xAxisPane)) {\n                var pane = _this._createPane(XAxisPane, PaneIdConstants.X_AXIS, ops !== null && ops !== void 0 ? ops : {});\n                _this._xAxisPane = pane;\n            }\n        };\n        layout.forEach(function (child) {\n            var _a, _b, _c;\n            switch (child.type) {\n                case \"candle\" /* LayoutChildType.Candle */: {\n                    createCandlePane(child);\n                    break;\n                }\n                case \"indicator\" /* LayoutChildType.Indicator */: {\n                    var content = (_a = child.content) !== null && _a !== void 0 ? _a : [];\n                    if (content.length > 0) {\n                        var paneId = (_c = (_b = child.options) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : null;\n                        if (isValid(paneId)) {\n                            paneId = createId(PaneIdConstants.INDICATOR);\n                        }\n                        var paneOptions_2 = __assign(__assign({}, child.options), { id: paneId });\n                        content.forEach(function (v) {\n                            _this.createIndicator(v, true, paneOptions_2);\n                        });\n                    }\n                    break;\n                }\n                case \"xAxis\" /* LayoutChildType.XAxis */: {\n                    createXAxisPane(child.options);\n                    break;\n                }\n            }\n        });\n        createCandlePane({ });\n        createXAxisPane({ order: Number.MAX_SAFE_INTEGER });\n    };\n    ChartImp.prototype._createPane = function (DrawPaneClass, id, options) {\n        var pane = new DrawPaneClass(this, id, options !== null && options !== void 0 ? options : {});\n        this._drawPanes.push(pane);\n        return pane;\n    };\n    ChartImp.prototype._recalculatePaneHeight = function (currentPane, currentHeight, changeHeight) {\n        if (changeHeight === 0) {\n            return false;\n        }\n        var normalStatePanes = this._drawPanes.filter(function (pane) {\n            var paneId = pane.getId();\n            return (pane.getOptions().state === \"normal\" /* PaneState.Normal */ &&\n                paneId !== currentPane.getId() &&\n                paneId !== PaneIdConstants.X_AXIS);\n        });\n        var count = normalStatePanes.length;\n        if (count === 0) {\n            return false;\n        }\n        if (currentPane.getId() !== PaneIdConstants.CANDLE &&\n            isValid(this._candlePane) &&\n            this._candlePane.getOptions().state === \"normal\" /* PaneState.Normal */) {\n            var height = this._candlePane.getBounding().height;\n            if (height > 0) {\n                var minHeight = this._candlePane.getOptions().minHeight;\n                var newHeight = height + changeHeight;\n                if (newHeight < minHeight) {\n                    newHeight = minHeight;\n                    currentHeight -= (height + changeHeight - newHeight);\n                }\n                this._candlePane.setBounding({ height: newHeight });\n            }\n        }\n        else {\n            var remainingHeight_1 = changeHeight;\n            var normalStatePaneChangeHeight_1 = Math.floor(changeHeight / count);\n            normalStatePanes.forEach(function (pane, index) {\n                var height = pane.getBounding().height;\n                var newHeight = 0;\n                if (index === count - 1) {\n                    newHeight = height + remainingHeight_1;\n                }\n                else {\n                    newHeight = height + normalStatePaneChangeHeight_1;\n                }\n                if (newHeight < pane.getOptions().minHeight) {\n                    newHeight = pane.getOptions().minHeight;\n                }\n                pane.setBounding({ height: newHeight });\n                remainingHeight_1 -= (newHeight - height);\n            });\n            if (Math.abs(remainingHeight_1) > 0) {\n                currentHeight -= remainingHeight_1;\n            }\n        }\n        currentPane.setBounding({ height: currentHeight });\n        return true;\n    };\n    ChartImp.prototype.getDrawPaneById = function (paneId) {\n        if (paneId === PaneIdConstants.CANDLE) {\n            return this._candlePane;\n        }\n        if (paneId === PaneIdConstants.X_AXIS) {\n            return this._xAxisPane;\n        }\n        var pane = this._drawPanes.find(function (p) { return p.getId() === paneId; });\n        return pane !== null && pane !== void 0 ? pane : null;\n    };\n    ChartImp.prototype.getContainer = function () { return this._container; };\n    ChartImp.prototype.getChartStore = function () { return this._chartStore; };\n    ChartImp.prototype.getXAxisPane = function () { return this._xAxisPane; };\n    ChartImp.prototype.getDrawPanes = function () { return this._drawPanes; };\n    ChartImp.prototype.getSeparatorPanes = function () { return this._separatorPanes; };\n    ChartImp.prototype.layout = function (options) {\n        var _this = this;\n        var _a, _b, _c, _d, _e, _f;\n        if ((_a = options.sort) !== null && _a !== void 0 ? _a : false) {\n            this._layoutOptions.sort = options.sort;\n        }\n        if ((_b = options.measureHeight) !== null && _b !== void 0 ? _b : false) {\n            this._layoutOptions.measureHeight = options.measureHeight;\n        }\n        if ((_c = options.measureWidth) !== null && _c !== void 0 ? _c : false) {\n            this._layoutOptions.measureWidth = options.measureWidth;\n        }\n        if ((_d = options.update) !== null && _d !== void 0 ? _d : false) {\n            this._layoutOptions.update = options.update;\n        }\n        if ((_e = options.buildYAxisTick) !== null && _e !== void 0 ? _e : false) {\n            this._layoutOptions.buildYAxisTick = options.buildYAxisTick;\n        }\n        if ((_f = options.buildYAxisTick) !== null && _f !== void 0 ? _f : false) {\n            this._layoutOptions.forceBuildYAxisTick = options.forceBuildYAxisTick;\n        }\n        if (!this._layoutPending) {\n            this._layoutPending = true;\n            Promise.resolve().then(function (_) {\n                _this._layout();\n                _this._layoutPending = false;\n            }).catch(function (_) {\n                // todo\n            });\n        }\n    };\n    ChartImp.prototype._layout = function () {\n        var _this = this;\n        var _a = this._layoutOptions, sort = _a.sort, measureHeight = _a.measureHeight, measureWidth = _a.measureWidth, update = _a.update, buildYAxisTick = _a.buildYAxisTick, forceBuildYAxisTick = _a.forceBuildYAxisTick;\n        if (sort) {\n            while (isValid(this._chartContainer.firstChild)) {\n                this._chartContainer.removeChild(this._chartContainer.firstChild);\n            }\n            this._separatorPanes.clear();\n            this._drawPanes.sort(function (a, b) { return a.getOptions().order - b.getOptions().order; });\n            var prevPane_1 = null;\n            this._drawPanes.forEach(function (pane) {\n                if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                    if (isValid(prevPane_1)) {\n                        var separatorPane = new SeparatorPane(_this, '', prevPane_1, pane);\n                        _this._chartContainer.appendChild(separatorPane.getContainer());\n                        _this._separatorPanes.set(pane, separatorPane);\n                    }\n                    prevPane_1 = pane;\n                }\n                _this._chartContainer.appendChild(pane.getContainer());\n            });\n        }\n        if (measureHeight) {\n            var totalHeight = this._chartBounding.height;\n            var separatorSize_1 = this.getStyles().separator.size;\n            var xAxisHeight = this._xAxisPane.getAxisComponent().getAutoSize();\n            var remainingHeight_2 = totalHeight - xAxisHeight;\n            if (remainingHeight_2 < 0) {\n                remainingHeight_2 = 0;\n            }\n            this._drawPanes.forEach(function (pane) {\n                var paneId = pane.getId();\n                if (isValid(_this._separatorPanes.get(pane))) {\n                    remainingHeight_2 -= separatorSize_1;\n                }\n                if (paneId !== PaneIdConstants.X_AXIS && paneId !== PaneIdConstants.CANDLE && pane.getVisible()) {\n                    var paneHeight = pane.getBounding().height;\n                    if (paneHeight > remainingHeight_2) {\n                        paneHeight = remainingHeight_2;\n                        remainingHeight_2 = 0;\n                    }\n                    else {\n                        remainingHeight_2 -= paneHeight;\n                    }\n                    pane.setBounding({ height: paneHeight });\n                }\n            });\n            this._candlePane.setBounding({ height: Math.max(remainingHeight_2, 0) });\n            this._xAxisPane.setBounding({ height: xAxisHeight });\n            var top_1 = 0;\n            this._drawPanes.forEach(function (pane) {\n                var separatorPane = _this._separatorPanes.get(pane);\n                if (isValid(separatorPane)) {\n                    separatorPane.setBounding({ height: separatorSize_1, top: top_1 });\n                    top_1 += separatorSize_1;\n                }\n                pane.setBounding({ top: top_1 });\n                top_1 += pane.getBounding().height;\n            });\n        }\n        var forceMeasureWidth = measureWidth;\n        if (buildYAxisTick || forceBuildYAxisTick) {\n            this._drawPanes.forEach(function (pane) {\n                var success = pane.getAxisComponent().buildTicks(forceBuildYAxisTick);\n                forceMeasureWidth || (forceMeasureWidth = success);\n            });\n        }\n        if (forceMeasureWidth) {\n            var totalWidth = this._chartBounding.width;\n            var styles = this.getStyles();\n            var leftYAxisWidth_1 = 0;\n            var leftYAxisOutside_1 = true;\n            var rightYAxisWidth_1 = 0;\n            var rightYAxisOutside_1 = true;\n            this._drawPanes.forEach(function (pane) {\n                if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                    var yAxis = pane.getAxisComponent();\n                    var inside = yAxis.inside;\n                    var yAxisWidth = yAxis.getAutoSize();\n                    if (yAxis.position === AxisPosition.Left) {\n                        leftYAxisWidth_1 = Math.max(leftYAxisWidth_1, yAxisWidth);\n                        if (inside) {\n                            leftYAxisOutside_1 = false;\n                        }\n                    }\n                    else {\n                        rightYAxisWidth_1 = Math.max(rightYAxisWidth_1, yAxisWidth);\n                        if (inside) {\n                            rightYAxisOutside_1 = false;\n                        }\n                    }\n                }\n            });\n            var mainWidth = totalWidth;\n            var mainLeft = 0;\n            var mainRight = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (leftYAxisOutside_1) {\n                mainWidth -= leftYAxisWidth_1;\n                mainLeft = leftYAxisWidth_1;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (rightYAxisOutside_1) {\n                mainWidth -= rightYAxisWidth_1;\n                mainRight = rightYAxisWidth_1;\n            }\n            this._chartStore.setTotalBarSpace(mainWidth);\n            var paneBounding_1 = { width: totalWidth };\n            var mainBounding_1 = { width: mainWidth, left: mainLeft, right: mainRight };\n            var leftYAxisBounding_1 = { width: leftYAxisWidth_1 };\n            var rightYAxisBounding_1 = { width: rightYAxisWidth_1 };\n            var separatorFill = styles.separator.fill;\n            var separatorBounding_1 = {};\n            if (!separatorFill) {\n                separatorBounding_1 = mainBounding_1;\n            }\n            else {\n                separatorBounding_1 = paneBounding_1;\n            }\n            this._drawPanes.forEach(function (pane) {\n                var _a;\n                (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setBounding(separatorBounding_1);\n                pane.setBounding(paneBounding_1, mainBounding_1, leftYAxisBounding_1, rightYAxisBounding_1);\n            });\n        }\n        if (update) {\n            this._xAxisPane.getAxisComponent().buildTicks(true);\n            this.updatePane(4 /* UpdateLevel.All */);\n        }\n        this._layoutOptions = {\n            sort: false,\n            measureHeight: false,\n            measureWidth: false,\n            update: false,\n            buildYAxisTick: false,\n            forceBuildYAxisTick: false\n        };\n    };\n    ChartImp.prototype.updatePane = function (level, paneId) {\n        var _this = this;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            pane === null || pane === void 0 ? void 0 : pane.update(level);\n        }\n        else {\n            this._drawPanes.forEach(function (pane) {\n                var _a;\n                pane.update(level);\n                (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.update(level);\n            });\n        }\n    };\n    ChartImp.prototype.crosshairChange = function (crosshair) {\n        var _this = this;\n        if (this._chartStore.hasAction(ActionType.OnCrosshairChange)) {\n            var indicatorData_1 = {};\n            this._drawPanes.forEach(function (pane) {\n                var id = pane.getId();\n                var paneIndicatorData = {};\n                var indicators = _this._chartStore.getIndicatorsByPaneId(id);\n                indicators.forEach(function (indicator) {\n                    var _a;\n                    var result = indicator.result;\n                    paneIndicatorData[indicator.name] = result[(_a = crosshair.dataIndex) !== null && _a !== void 0 ? _a : result.length - 1];\n                });\n                indicatorData_1[id] = paneIndicatorData;\n            });\n            if (isString(crosshair.paneId)) {\n                this._chartStore.executeAction(ActionType.OnCrosshairChange, __assign(__assign({}, crosshair), { indicatorData: indicatorData_1 }));\n            }\n        }\n    };\n    ChartImp.prototype.getDom = function (paneId, position) {\n        var _a, _b;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            if (isValid(pane)) {\n                var pos = position !== null && position !== void 0 ? position : DomPosition.Root;\n                switch (pos) {\n                    case DomPosition.Root: {\n                        return pane.getContainer();\n                    }\n                    case DomPosition.Main: {\n                        return pane.getMainWidget().getContainer();\n                    }\n                    case DomPosition.YAxis: {\n                        return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getContainer()) !== null && _b !== void 0 ? _b : null;\n                    }\n                }\n            }\n        }\n        else {\n            return this._chartContainer;\n        }\n        return null;\n    };\n    ChartImp.prototype.getSize = function (paneId, position) {\n        var _a, _b;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            if (isValid(pane)) {\n                var pos = position !== null && position !== void 0 ? position : DomPosition.Root;\n                switch (pos) {\n                    case DomPosition.Root: {\n                        return pane.getBounding();\n                    }\n                    case DomPosition.Main: {\n                        return pane.getMainWidget().getBounding();\n                    }\n                    case DomPosition.YAxis: {\n                        return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding()) !== null && _b !== void 0 ? _b : null;\n                    }\n                }\n            }\n        }\n        else {\n            return this._chartBounding;\n        }\n        return null;\n    };\n    ChartImp.prototype.setPrecision = function (precision) {\n        this._chartStore.setPrecision(precision);\n    };\n    ChartImp.prototype.getPrecision = function () {\n        return this._chartStore.getPrecision();\n    };\n    ChartImp.prototype.setStyles = function (value) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setStyles(value);\n        });\n    };\n    ChartImp.prototype.getStyles = function () { return this._chartStore.getStyles(); };\n    ChartImp.prototype.setCustomApi = function (api) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setCustomApi(api);\n        });\n    };\n    ChartImp.prototype.getCustomApi = function () { return this._chartStore.getCustomApi(); };\n    ChartImp.prototype.setLocale = function (locale) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setLocale(locale);\n        });\n    };\n    ChartImp.prototype.getLocale = function () { return this._chartStore.getLocale(); };\n    ChartImp.prototype.setTimezone = function (timezone) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setTimezone(timezone);\n        });\n    };\n    ChartImp.prototype.getTimezone = function () { return this._chartStore.getTimezone(); };\n    ChartImp.prototype.setThousandsSeparator = function (thousandsSeparator) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setThousandsSeparator(thousandsSeparator);\n        });\n    };\n    ChartImp.prototype.getThousandsSeparator = function () { return this._chartStore.getThousandsSeparator(); };\n    ChartImp.prototype.setDecimalFold = function (decimalFold) {\n        var _this = this;\n        this._setOptions(function () {\n            _this._chartStore.setDecimalFold(decimalFold);\n        });\n    };\n    ChartImp.prototype.getDecimalFold = function () { return this._chartStore.getDecimalFold(); };\n    ChartImp.prototype._setOptions = function (fuc) {\n        fuc();\n        this.layout({\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true,\n            forceBuildYAxisTick: true\n        });\n    };\n    ChartImp.prototype.setOffsetRightDistance = function (distance) {\n        this._chartStore.setOffsetRightDistance(distance, true);\n    };\n    ChartImp.prototype.getOffsetRightDistance = function () {\n        return this._chartStore.getOffsetRightDistance();\n    };\n    ChartImp.prototype.setMaxOffsetLeftDistance = function (distance) {\n        if (distance < 0) {\n            logWarn('setMaxOffsetLeftDistance', 'distance', 'distance must greater than zero!!!');\n            return;\n        }\n        this._chartStore.setMaxOffsetLeftDistance(distance);\n    };\n    ChartImp.prototype.setMaxOffsetRightDistance = function (distance) {\n        if (distance < 0) {\n            logWarn('setMaxOffsetRightDistance', 'distance', 'distance must greater than zero!!!');\n            return;\n        }\n        this._chartStore.setMaxOffsetRightDistance(distance);\n    };\n    ChartImp.prototype.setLeftMinVisibleBarCount = function (barCount) {\n        if (barCount < 0) {\n            logWarn('setLeftMinVisibleBarCount', 'barCount', 'barCount must greater than zero!!!');\n            return;\n        }\n        this._chartStore.setLeftMinVisibleBarCount(Math.ceil(barCount));\n    };\n    ChartImp.prototype.setRightMinVisibleBarCount = function (barCount) {\n        if (barCount < 0) {\n            logWarn('setRightMinVisibleBarCount', 'barCount', 'barCount must greater than zero!!!');\n            return;\n        }\n        this._chartStore.setRightMinVisibleBarCount(Math.ceil(barCount));\n    };\n    ChartImp.prototype.setBarSpace = function (space) {\n        this._chartStore.setBarSpace(space);\n    };\n    ChartImp.prototype.getBarSpace = function () {\n        return this._chartStore.getBarSpace();\n    };\n    ChartImp.prototype.getVisibleRange = function () {\n        return this._chartStore.getVisibleRange();\n    };\n    ChartImp.prototype.clearData = function () {\n        this._chartStore.clearData();\n    };\n    ChartImp.prototype.getDataList = function () {\n        return this._chartStore.getDataList();\n    };\n    ChartImp.prototype.applyNewData = function (data, more) {\n        this._drawPanes.forEach(function (pane) {\n            pane.getAxisComponent().setAutoCalcTickFlag(true);\n        });\n        var loadDataMore = { forward: false, backward: false };\n        if (isBoolean(more)) {\n            loadDataMore.forward = more;\n            loadDataMore.backward = more;\n        }\n        else {\n            loadDataMore = __assign(__assign({}, loadDataMore), more);\n        }\n        this._chartStore.addData(data, LoadDataType.Init, loadDataMore);\n    };\n    ChartImp.prototype.updateData = function (data) {\n        this._chartStore.addData(data, LoadDataType.Update);\n    };\n    ChartImp.prototype.setLoadMoreDataCallback = function (cb) {\n        this._chartStore.setLoadMoreDataCallback(cb);\n    };\n    ChartImp.prototype.createIndicator = function (value, isStack, paneOptions) {\n        var _a;\n        var indicator = isString(value) ? { name: value } : value;\n        if (getIndicatorClass(indicator.name) === null) {\n            logWarn('createIndicator', 'value', 'indicator not supported, you may need to use registerIndicator to add one!!!');\n            return null;\n        }\n        var paneOpts = paneOptions !== null && paneOptions !== void 0 ? paneOptions : {};\n        if (!isString(paneOpts.id)) {\n            paneOpts.id = createId(PaneIdConstants.INDICATOR);\n        }\n        if (!isString(indicator.id)) {\n            indicator.id = createId(indicator.name);\n        }\n        var result = this._chartStore.addIndicator(indicator, paneOpts.id, isStack !== null && isStack !== void 0 ? isStack : false);\n        if (result) {\n            var shouldSort = false;\n            if (!isValid(this.getDrawPaneById(paneOpts.id))) {\n                this._createPane(IndicatorPane, paneOpts.id, paneOpts);\n                (_a = paneOpts.height) !== null && _a !== void 0 ? _a : (paneOpts.height = PANE_DEFAULT_HEIGHT);\n                shouldSort = true;\n            }\n            this.setPaneOptions(paneOpts);\n            this.layout({\n                sort: shouldSort,\n                measureHeight: true,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n            return indicator.id;\n        }\n        return null;\n    };\n    ChartImp.prototype.overrideIndicator = function (override) {\n        return this._chartStore.overrideIndicator(override);\n    };\n    ChartImp.prototype.getIndicators = function (filter) {\n        return this._chartStore.getIndicatorsByFilter(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.removeIndicator = function (filter) {\n        var _this = this;\n        var removed = this._chartStore.removeIndicator(filter !== null && filter !== void 0 ? filter : {});\n        if (removed) {\n            var shouldMeasureHeight_1 = false;\n            var paneIds_1 = [];\n            this._drawPanes.forEach(function (pane) {\n                var paneId = pane.getId();\n                if (paneId !== PaneIdConstants.CANDLE && paneId !== PaneIdConstants.X_AXIS) {\n                    paneIds_1.push(paneId);\n                }\n            });\n            paneIds_1.forEach(function (paneId) {\n                if (!_this._chartStore.hasIndicators(paneId)) {\n                    var index = _this._drawPanes.findIndex(function (pane) { return pane.getId() === paneId; });\n                    var pane = _this._drawPanes[index];\n                    if (isValid(pane)) {\n                        shouldMeasureHeight_1 = true;\n                        _this._recalculatePaneHeight(pane, 0, pane.getBounding().height);\n                        _this._drawPanes.splice(index, 1);\n                        pane.destroy();\n                    }\n                }\n            });\n            if (this._drawPanes.length === 2) {\n                this._candlePane.setVisible(true);\n                this._candlePane.setBounding({ height: this._chartBounding.height - this._xAxisPane.getBounding().height });\n            }\n            this.layout({\n                sort: shouldMeasureHeight_1,\n                measureHeight: shouldMeasureHeight_1,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n        }\n        return removed;\n    };\n    ChartImp.prototype.createOverlay = function (value) {\n        var _this = this;\n        var overlays = [];\n        var appointPaneFlags = [];\n        var build = function (overlay) {\n            if (!isValid(overlay.paneId) || _this.getDrawPaneById(overlay.paneId) === null) {\n                overlay.paneId = PaneIdConstants.CANDLE;\n                appointPaneFlags.push(false);\n            }\n            else {\n                appointPaneFlags.push(true);\n            }\n            overlays.push(overlay);\n        };\n        if (isString(value)) {\n            build({ name: value });\n        }\n        else if (isArray(value)) {\n            value.forEach(function (v) {\n                var overlay = null;\n                if (isString(v)) {\n                    overlay = { name: v };\n                }\n                else {\n                    overlay = v;\n                }\n                build(overlay);\n            });\n        }\n        else {\n            build(value);\n        }\n        var ids = this._chartStore.addOverlays(overlays, appointPaneFlags);\n        if (isArray(value)) {\n            return ids;\n        }\n        return ids[0];\n    };\n    ChartImp.prototype.getOverlays = function (filter) {\n        return this._chartStore.getOverlaysByFilter(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.overrideOverlay = function (override) {\n        return this._chartStore.overrideOverlay(override);\n    };\n    ChartImp.prototype.removeOverlay = function (filter) {\n        return this._chartStore.removeOverlay(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.setPaneOptions = function (options) {\n        var e_1, _a;\n        var _this = this;\n        var _b;\n        var shouldMeasureHeight = false;\n        var shouldLayout = false;\n        var validId = isValid(options.id);\n        var _loop_1 = function (currentPane) {\n            var currentPaneId = currentPane.getId();\n            if ((validId && options.id === currentPaneId) || !validId) {\n                if (currentPaneId !== PaneIdConstants.X_AXIS) {\n                    if (isNumber(options.height) && options.height > 0) {\n                        var minHeight = Math.max((_b = options.minHeight) !== null && _b !== void 0 ? _b : currentPane.getOptions().minHeight, 0);\n                        var height = Math.max(minHeight, options.height);\n                        shouldLayout = true;\n                        shouldMeasureHeight = true;\n                        currentPane.setOriginalBounding({ height: height });\n                        this_1._recalculatePaneHeight(currentPane, height, -height);\n                    }\n                    if (isValid(options.state) &&\n                        currentPane.getOptions().state !== options.state) {\n                        shouldMeasureHeight = true;\n                        shouldLayout = true;\n                        var state = options.state;\n                        switch (state) {\n                            case \"maximize\" /* PaneState.Maximize */: {\n                                var maximizePane = this_1._drawPanes.find(function (pane) {\n                                    var paneId = pane.getId();\n                                    return pane.getOptions().state === \"maximize\" /* PaneState.Maximize */ && paneId !== PaneIdConstants.X_AXIS;\n                                });\n                                if (!isValid(maximizePane)) {\n                                    if (currentPane.getOptions().state === \"normal\" /* PaneState.Normal */) {\n                                        currentPane.setOriginalBounding({ height: currentPane.getBounding().height });\n                                    }\n                                    currentPane.setOptions({ state: state });\n                                    var totalHeight = this_1._chartBounding.height;\n                                    currentPane.setBounding({ height: totalHeight - this_1._xAxisPane.getBounding().height });\n                                    this_1._drawPanes.forEach(function (pane) {\n                                        var _a;\n                                        if (pane.getId() !== PaneIdConstants.X_AXIS && pane.getId() !== currentPaneId) {\n                                            pane.setBounding({ height: pane.getOriginalBounding().height });\n                                            pane.setVisible(false);\n                                            (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(false);\n                                        }\n                                    });\n                                }\n                                break;\n                            }\n                            case \"minimize\" /* PaneState.Minimize */: {\n                                var height = currentPane.getBounding().height;\n                                var currentState = currentPane.getOptions().state;\n                                var changeHeight = height - PANE_MIN_HEIGHT;\n                                if (currentState === \"maximize\" /* PaneState.Maximize */) {\n                                    changeHeight = currentPane.getOriginalBounding().height - PANE_MIN_HEIGHT;\n                                }\n                                if (this_1._recalculatePaneHeight(currentPane, PANE_MIN_HEIGHT, changeHeight)) {\n                                    if (currentState === \"normal\" /* PaneState.Normal */) {\n                                        currentPane.setOriginalBounding({ height: height });\n                                    }\n                                    currentPane.setOptions({ state: state });\n                                }\n                                this_1._drawPanes.forEach(function (pane) {\n                                    var _a;\n                                    if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                                        pane.setVisible(true);\n                                        (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(true);\n                                    }\n                                });\n                                break;\n                            }\n                            default: {\n                                var height = currentPane.getOriginalBounding().height;\n                                if (this_1._recalculatePaneHeight(currentPane, height, currentPane.getBounding().height - height)) {\n                                    currentPane.setOptions({ state: state });\n                                }\n                                this_1._drawPanes.forEach(function (pane) {\n                                    var _a;\n                                    if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                                        pane.setVisible(true);\n                                        (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(true);\n                                    }\n                                });\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (isValid(options.axis)) {\n                    shouldLayout = true;\n                }\n                var ops = __assign({}, options);\n                delete ops.state;\n                currentPane.setOptions(ops);\n                if (currentPaneId === options.id) {\n                    return \"break\";\n                }\n            }\n        };\n        var this_1 = this;\n        try {\n            for (var _c = __values(this._drawPanes), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var currentPane = _d.value;\n                var state_1 = _loop_1(currentPane);\n                if (state_1 === \"break\")\n                    break;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (shouldLayout) {\n            this.layout({\n                measureHeight: shouldMeasureHeight,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n        }\n    };\n    ChartImp.prototype.getPaneOptions = function (id) {\n        var _a;\n        if (isValid(id)) {\n            var pane = this.getDrawPaneById(id);\n            return (_a = pane === null || pane === void 0 ? void 0 : pane.getOptions()) !== null && _a !== void 0 ? _a : null;\n        }\n        return this._drawPanes.map(function (pane) { return pane.getOptions(); });\n    };\n    ChartImp.prototype.setZoomEnabled = function (enabled) {\n        this._chartStore.setZoomEnabled(enabled);\n    };\n    ChartImp.prototype.isZoomEnabled = function () {\n        return this._chartStore.isZoomEnabled();\n    };\n    ChartImp.prototype.setScrollEnabled = function (enabled) {\n        this._chartStore.setScrollEnabled(enabled);\n    };\n    ChartImp.prototype.isScrollEnabled = function () {\n        return this._chartStore.isScrollEnabled();\n    };\n    ChartImp.prototype.scrollByDistance = function (distance, animationDuration) {\n        var _this = this;\n        var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;\n        this._chartStore.startScroll();\n        if (duration > 0) {\n            var animation = new Animation({ duration: duration });\n            animation.doFrame(function (frameTime) {\n                var progressDistance = distance * (frameTime / duration);\n                _this._chartStore.scroll(progressDistance);\n            });\n            animation.start();\n        }\n        else {\n            this._chartStore.scroll(distance);\n        }\n    };\n    ChartImp.prototype.scrollToRealTime = function (animationDuration) {\n        var barSpace = this._chartStore.getBarSpace().bar;\n        var difBarCount = this._chartStore.getLastBarRightSideDiffBarCount() - this._chartStore.getInitialOffsetRightDistance() / barSpace;\n        var distance = difBarCount * barSpace;\n        this.scrollByDistance(distance, animationDuration);\n    };\n    ChartImp.prototype.scrollToDataIndex = function (dataIndex, animationDuration) {\n        var distance = (this._chartStore.getLastBarRightSideDiffBarCount() + (this.getDataList().length - 1 - dataIndex)) * this._chartStore.getBarSpace().bar;\n        this.scrollByDistance(distance, animationDuration);\n    };\n    ChartImp.prototype.scrollToTimestamp = function (timestamp, animationDuration) {\n        var dataIndex = binarySearchNearest(this.getDataList(), 'timestamp', timestamp);\n        this.scrollToDataIndex(dataIndex, animationDuration);\n    };\n    ChartImp.prototype.zoomAtCoordinate = function (scale, coordinate, animationDuration) {\n        var _this = this;\n        var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;\n        var barSpace = this._chartStore.getBarSpace().bar;\n        var scaleBarSpace = barSpace * scale;\n        var difSpace = scaleBarSpace - barSpace;\n        if (duration > 0) {\n            var prevProgressBarSpace_1 = 0;\n            var animation = new Animation({ duration: duration });\n            animation.doFrame(function (frameTime) {\n                var progressBarSpace = difSpace * (frameTime / duration);\n                var scale = (progressBarSpace - prevProgressBarSpace_1) / _this._chartStore.getBarSpace().bar * SCALE_MULTIPLIER;\n                _this._chartStore.zoom(scale, coordinate);\n                prevProgressBarSpace_1 = progressBarSpace;\n            });\n            animation.start();\n        }\n        else {\n            this._chartStore.zoom(difSpace / barSpace * SCALE_MULTIPLIER, coordinate);\n        }\n    };\n    ChartImp.prototype.zoomAtDataIndex = function (scale, dataIndex, animationDuration) {\n        var x = this._chartStore.dataIndexToCoordinate(dataIndex);\n        this.zoomAtCoordinate(scale, { x: x, y: 0 }, animationDuration);\n    };\n    ChartImp.prototype.zoomAtTimestamp = function (scale, timestamp, animationDuration) {\n        var dataIndex = binarySearchNearest(this.getDataList(), 'timestamp', timestamp);\n        this.zoomAtDataIndex(scale, dataIndex, animationDuration);\n    };\n    ChartImp.prototype.convertToPixel = function (points, filter) {\n        var _this = this;\n        var _a;\n        var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;\n        var coordinates = [];\n        if (paneId !== PaneIdConstants.X_AXIS) {\n            var pane = this.getDrawPaneById(paneId);\n            if (pane !== null) {\n                var bounding_1 = pane.getBounding();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                var ps = [].concat(points);\n                var xAxis_1 = this._xAxisPane.getAxisComponent();\n                var yAxis_1 = pane.getAxisComponent();\n                coordinates = ps.map(function (point) {\n                    var coordinate = {};\n                    var dataIndex = point.dataIndex;\n                    if (isNumber(point.timestamp)) {\n                        dataIndex = _this._chartStore.timestampToDataIndex(point.timestamp);\n                    }\n                    if (isNumber(dataIndex)) {\n                        coordinate.x = xAxis_1.convertToPixel(dataIndex);\n                    }\n                    if (isNumber(point.value)) {\n                        var y = yAxis_1.convertToPixel(point.value);\n                        coordinate.y = absolute ? bounding_1.top + y : y;\n                    }\n                    return coordinate;\n                });\n            }\n        }\n        return isArray(points) ? coordinates : ((_a = coordinates[0]) !== null && _a !== void 0 ? _a : {});\n    };\n    ChartImp.prototype.convertFromPixel = function (coordinates, filter) {\n        var _this = this;\n        var _a;\n        var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;\n        var points = [];\n        if (paneId !== PaneIdConstants.X_AXIS) {\n            var pane = this.getDrawPaneById(paneId);\n            if (pane !== null) {\n                var bounding_2 = pane.getBounding();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                var cs = [].concat(coordinates);\n                var xAxis_2 = this._xAxisPane.getAxisComponent();\n                var yAxis_2 = pane.getAxisComponent();\n                points = cs.map(function (coordinate) {\n                    var _a;\n                    var point = {};\n                    if (isNumber(coordinate.x)) {\n                        var dataIndex = xAxis_2.convertFromPixel(coordinate.x);\n                        point.dataIndex = dataIndex;\n                        point.timestamp = (_a = _this._chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n                    }\n                    if (isNumber(coordinate.y)) {\n                        var y = absolute ? coordinate.y - bounding_2.top : coordinate.y;\n                        point.value = yAxis_2.convertFromPixel(y);\n                    }\n                    return point;\n                });\n            }\n        }\n        return isArray(coordinates) ? points : ((_a = points[0]) !== null && _a !== void 0 ? _a : {});\n    };\n    ChartImp.prototype.executeAction = function (type, data) {\n        var _a;\n        switch (type) {\n            case ActionType.OnCrosshairChange: {\n                var crosshair = __assign({}, data);\n                (_a = crosshair.paneId) !== null && _a !== void 0 ? _a : (crosshair.paneId = PaneIdConstants.CANDLE);\n                this._chartStore.setCrosshair(crosshair, { notExecuteAction: true });\n                break;\n            }\n        }\n    };\n    ChartImp.prototype.subscribeAction = function (type, callback) {\n        this._chartStore.subscribeAction(type, callback);\n    };\n    ChartImp.prototype.unsubscribeAction = function (type, callback) {\n        this._chartStore.unsubscribeAction(type, callback);\n    };\n    ChartImp.prototype.getConvertPictureUrl = function (includeOverlay, type, backgroundColor) {\n        var _this = this;\n        var _a = this._chartBounding, width = _a.width, height = _a.height;\n        var canvas = createDom('canvas', {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: 'border-box'\n        });\n        var ctx = canvas.getContext('2d');\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.fillStyle = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : '#FFFFFF';\n        ctx.fillRect(0, 0, width, height);\n        var overlayFlag = includeOverlay !== null && includeOverlay !== void 0 ? includeOverlay : false;\n        this._drawPanes.forEach(function (pane) {\n            var separatorPane = _this._separatorPanes.get(pane);\n            if (isValid(separatorPane)) {\n                var separatorBounding = separatorPane.getBounding();\n                ctx.drawImage(separatorPane.getImage(overlayFlag), separatorBounding.left, separatorBounding.top, separatorBounding.width, separatorBounding.height);\n            }\n            var bounding = pane.getBounding();\n            ctx.drawImage(pane.getImage(overlayFlag), 0, bounding.top, width, bounding.height);\n        });\n        return canvas.toDataURL(\"image/\".concat(type !== null && type !== void 0 ? type : 'jpeg'));\n    };\n    ChartImp.prototype.resize = function () {\n        this._cacheChartBounding();\n        this.layout({\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true,\n            forceBuildYAxisTick: true\n        });\n    };\n    ChartImp.prototype.destroy = function () {\n        this._chartEvent.destroy();\n        this._drawPanes.forEach(function (pane) {\n            pane.destroy();\n        });\n        this._drawPanes = [];\n        this._separatorPanes.clear();\n        this._container.removeChild(this._chartContainer);\n    };\n    return ChartImp;\n}());\n\n/**\n *       ___           ___                   ___           ___           ___           ___           ___           ___           ___\n *      /\\__\\         /\\__\\      ___        /\\__\\         /\\  \\         /\\  \\         /\\__\\         /\\  \\         /\\  \\         /\\  \\\n *     /:/  /        /:/  /     /\\  \\      /::|  |       /::\\  \\       /::\\  \\       /:/  /        /::\\  \\       /::\\  \\        \\:\\  \\\n *    /:/__/        /:/  /      \\:\\  \\    /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/__/        /:/\\:\\  \\     /:/\\:\\  \\        \\:\\  \\\n *   /::\\__\\____   /:/  /       /::\\__\\  /:/|:|  |__   /::\\~\\:\\  \\   /:/  \\:\\  \\   /::\\  \\ ___   /::\\~\\:\\  \\   /::\\~\\:\\  \\       /::\\  \\\n *  /:/\\:::::\\__\\ /:/__/     __/:/\\/__/ /:/ |:| /\\__\\ /:/\\:\\ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:\\  /\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\     /:/\\:\\__\\\n *  \\/_|:|~~|~    \\:\\  \\    /\\/:/  /    \\/__|:|/:/  / \\:\\~\\:\\ \\/__/ \\:\\  \\  \\/__/ \\/__\\:\\/:/  / \\/__\\:\\/:/  / \\/_|::\\/:/  /    /:/  \\/__/\n *     |:|  |      \\:\\  \\   \\::/__/         |:/:/  /   \\:\\ \\:\\__\\    \\:\\  \\            \\::/  /       \\::/  /     |:|::/  /    /:/  /\n *     |:|  |       \\:\\  \\   \\:\\__\\         |::/  /     \\:\\ \\/__/     \\:\\  \\           /:/  /        /:/  /      |:|\\/__/     \\/__/\n *     |:|  |        \\:\\__\\   \\/__/         /:/  /       \\:\\__\\        \\:\\__\\         /:/  /        /:/  /       |:|  |\n *      \\|__|         \\/__/                 \\/__/         \\/__/         \\/__/         \\/__/         \\/__/         \\|__|\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar charts = new Map();\nvar chartBaseId = 1;\n/**\n * Chart version\n * @return {string}\n */\nfunction version() {\n    return '10.0.0-alpha5';\n}\n/**\n * Init chart instance\n * @param ds\n * @param options\n * @returns {Chart}\n */\nfunction init(ds, options) {\n    logTag();\n    var dom = null;\n    if (isString(ds)) {\n        dom = document.getElementById(ds);\n    }\n    else {\n        dom = ds;\n    }\n    if (dom === null) {\n        logError('', '', 'The chart cannot be initialized correctly. Please check the parameters. The chart container cannot be null and child elements need to be added!!!');\n        return null;\n    }\n    var chart = charts.get(dom.id);\n    if (isValid(chart)) {\n        logWarn('', '', 'The chart has been initialized on the dom！！！');\n        return chart;\n    }\n    var id = \"k_line_chart_\".concat(chartBaseId++);\n    chart = new ChartImp(dom, options);\n    chart.id = id;\n    dom.setAttribute('k-line-chart-id', id);\n    charts.set(id, chart);\n    return chart;\n}\n/**\n * Destroy chart instance\n * @param dcs\n */\nfunction dispose(dcs) {\n    var _a, _b;\n    var id = null;\n    if (dcs instanceof ChartImp) {\n        id = dcs.id;\n    }\n    else {\n        var dom = null;\n        if (isString(dcs)) {\n            dom = document.getElementById(dcs);\n        }\n        else {\n            dom = dcs;\n        }\n        id = (_a = dom === null || dom === void 0 ? void 0 : dom.getAttribute('k-line-chart-id')) !== null && _a !== void 0 ? _a : null;\n    }\n    if (id !== null) {\n        (_b = charts.get(id)) === null || _b === void 0 ? void 0 : _b.destroy();\n        charts.delete(id);\n    }\n}\nvar utils = {\n    clone: clone,\n    merge: merge,\n    isString: isString,\n    isNumber: isNumber,\n    isValid: isValid,\n    isObject: isObject,\n    isArray: isArray,\n    isFunction: isFunction,\n    isBoolean: isBoolean,\n    formatValue: formatValue,\n    formatPrecision: formatPrecision,\n    formatBigNumber: formatBigNumber,\n    formatDate: formatTimestampToString,\n    formatThousands: formatThousands,\n    formatFoldDecimal: formatFoldDecimal,\n    calcTextWidth: calcTextWidth,\n    getLinearSlopeIntercept: getLinearSlopeIntercept,\n    getLinearYFromSlopeIntercept: getLinearYFromSlopeIntercept,\n    getLinearYFromCoordinates: getLinearYFromCoordinates,\n    checkCoordinateOnArc: checkCoordinateOnArc,\n    checkCoordinateOnCircle: checkCoordinateOnCircle,\n    checkCoordinateOnLine: checkCoordinateOnLine,\n    checkCoordinateOnPolygon: checkCoordinateOnPolygon,\n    checkCoordinateOnRect: checkCoordinateOnRect,\n    checkCoordinateOnText: checkCoordinateOnText\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9rbGluZWNoYXJ0cy9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4Ryw2SUFBNkksY0FBYztBQUMzSix1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdC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Q0E7QUFDQSxhQUFhO0FBQ2IsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsMENBQTBDO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNENBQTRDO0FBQ3RELFVBQVUsNkNBQTZDO0FBQ3ZELFVBQVU7QUFDVjtBQUNBLDJDQUEyQyxvQ0FBb0MsVUFBVSxzRUFBc0UsSUFBSSxJQUFJO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsMkNBQTJDO0FBQ3JELFVBQVUsMkNBQTJDO0FBQ3JELFVBQVU7QUFDVjtBQUNBLDJDQUEyQyxvQ0FBb0MsVUFBVSxvRUFBb0UsSUFBSSxJQUFJO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQsVUFBVSxzQ0FBc0M7QUFDaEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsMkNBQTJDO0FBQ3JELFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLG9FQUFvRSxJQUFJO0FBQ3JJO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBDQUEwQztBQUNwRCxVQUFVLDBDQUEwQztBQUNwRCxVQUFVO0FBQ1Y7QUFDQSwyQ0FBMkMsb0NBQW9DLFVBQVUsd0VBQXdFLElBQUksSUFBSTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0I7QUFDL0U7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsbUJBQW1CLElBQUksaUJBQWlCLEdBQUc7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkVBQTJFO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCx1REFBdUQ7QUFDdkQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxpRUFBaUU7QUFDakUsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUUsb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UscUhBQXFIO0FBQzdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUscUhBQXFIO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzREFBc0Qsd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhDQUE4QyxTQUFTLCtMQUErTDtBQUN0UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsbUJBQW1CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixvQkFBb0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdCQUF3QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUNBQW1DO0FBQy9FLDZDQUE2QyxhQUFhLCtCQUErQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUSxrR0FBa0c7QUFDeEssb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxRQUFRLHFHQUFxRztBQUMzSyxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFLGdEQUFnRCxtREFBbUQ7QUFDbkc7QUFDQTtBQUNBLGlGQUFpRiw2QkFBNkI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnQkFBZ0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixnQkFBZ0I7QUFDekc7QUFDQSwrRUFBK0UsZ0JBQWdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQ0FBZ0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxlQUFlO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGVBQWU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLElBQUksZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsd0NBQXdDLElBQUksZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3Q0FBd0Msb0JBQW9CO0FBQzFIO0FBQ0E7QUFDQSxTQUFTLElBQUksZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQ0FBZ0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdDQUFnQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGVBQWU7QUFDcEUscURBQXFEO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0QkFBNEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSwwRUFBMEUsdUJBQXVCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1ZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMva2xpbmVjaGFydHMvZGlzdC9pbmRleC5lc20uanM/OGZiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIEtMaW5lQ2hhcnQgdjEwLjAuMC1hbHBoYTVcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTkgbGlodS5cbiAgICAgKiBMaWNlbnNlZCB1bmRlciBBcGFjaGUgTGljZW5zZSAyLjAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xyXG4gICAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gaWdub3JlXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICgoIWlzT2JqZWN0KHRhcmdldCkgJiYgIWlzT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIGlnbm9yZVxuICAgICAgICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAtLSBpZ25vcmVcbiAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdCh0YXJnZXRQcm9wKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbG9uZSh0YXJnZXQpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gaWdub3JlXG4gICAgdmFyIGNvcHkgPSBudWxsO1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgY29weSA9IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29weSA9IHt9O1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gLS0gaWdub3JlXG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtcGFyYW1ldGVycyAtLSBpZ25vcmVcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpICYmIGlzVmFsaWQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc1RyYW5zcGFyZW50KGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yID09PSAndHJhbnNwYXJlbnQnIHx8XG4gICAgICAgIGNvbG9yID09PSAnbm9uZScgfHxcbiAgICAgICAgL15bclJdW2dHXVtCYl1bQWFdXFwoKFtcXHNdKigyWzAtNF1bMC05XXwyNVswLTVdfFswMV0/WzAtOV1bMC05XT8pW1xcc10qLCl7M31bXFxzXSowW1xcc10qXFwpJC8udGVzdChjb2xvcikgfHxcbiAgICAgICAgL15baEhdW1NzXVtMbF1bQWFdXFwoKFtcXHNdKigzNjDvvZwzWzAtNV1bMC05XXxbMDEyXT9bMC05XVswLTldPylbXFxzXSosKShbXFxzXSooKDEwMHxbMC05XVswLTldPyklfDApW1xcc10qLCl7Mn0oW1xcc10qMFtcXHNdKilcXCkkLy50ZXN0KGNvbG9yKTtcbn1cbmZ1bmN0aW9uIGhleFRvUmdiKGhleCwgYWxwaGEpIHtcbiAgICB2YXIgaCA9IGhleC5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICB2YXIgaSA9IHBhcnNlSW50KGgsIDE2KTtcbiAgICB2YXIgciA9IChpID4+IDE2KSAmIDI1NTtcbiAgICB2YXIgZyA9IChpID4+IDgpICYgMjU1O1xuICAgIHZhciBiID0gaSAmIDI1NTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiLmNvbmNhdChyLCBcIiwgXCIpLmNvbmNhdChnLCBcIiwgXCIpLmNvbmNhdChiLCBcIiwgXCIpLmNvbmNhdChhbHBoYSAhPT0gbnVsbCAmJiBhbHBoYSAhPT0gdm9pZCAwID8gYWxwaGEgOiAxLCBcIilcIik7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBsaW5lIHR5cGVcbiAqL1xudmFyIExpbmVUeXBlO1xuKGZ1bmN0aW9uIChMaW5lVHlwZSkge1xuICAgIExpbmVUeXBlW1wiRGFzaGVkXCJdID0gXCJkYXNoZWRcIjtcbiAgICBMaW5lVHlwZVtcIlNvbGlkXCJdID0gXCJzb2xpZFwiO1xufSkoTGluZVR5cGUgfHwgKExpbmVUeXBlID0ge30pKTtcbnZhciBQYXRoVHlwZTtcbihmdW5jdGlvbiAoUGF0aFR5cGUpIHtcbiAgICBQYXRoVHlwZVtcIlN0cm9rZVwiXSA9IFwic3Ryb2tlXCI7XG4gICAgUGF0aFR5cGVbXCJGaWxsXCJdID0gXCJmaWxsXCI7XG59KShQYXRoVHlwZSB8fCAoUGF0aFR5cGUgPSB7fSkpO1xudmFyIFBvbHlnb25UeXBlO1xuKGZ1bmN0aW9uIChQb2x5Z29uVHlwZSkge1xuICAgIFBvbHlnb25UeXBlW1wiU3Ryb2tlXCJdID0gXCJzdHJva2VcIjtcbiAgICBQb2x5Z29uVHlwZVtcIkZpbGxcIl0gPSBcImZpbGxcIjtcbiAgICBQb2x5Z29uVHlwZVtcIlN0cm9rZUZpbGxcIl0gPSBcInN0cm9rZV9maWxsXCI7XG59KShQb2x5Z29uVHlwZSB8fCAoUG9seWdvblR5cGUgPSB7fSkpO1xudmFyIFRvb2x0aXBTaG93UnVsZTtcbihmdW5jdGlvbiAoVG9vbHRpcFNob3dSdWxlKSB7XG4gICAgVG9vbHRpcFNob3dSdWxlW1wiQWx3YXlzXCJdID0gXCJhbHdheXNcIjtcbiAgICBUb29sdGlwU2hvd1J1bGVbXCJGb2xsb3dDcm9zc1wiXSA9IFwiZm9sbG93X2Nyb3NzXCI7XG4gICAgVG9vbHRpcFNob3dSdWxlW1wiTm9uZVwiXSA9IFwibm9uZVwiO1xufSkoVG9vbHRpcFNob3dSdWxlIHx8IChUb29sdGlwU2hvd1J1bGUgPSB7fSkpO1xudmFyIFRvb2x0aXBTaG93VHlwZTtcbihmdW5jdGlvbiAoVG9vbHRpcFNob3dUeXBlKSB7XG4gICAgVG9vbHRpcFNob3dUeXBlW1wiU3RhbmRhcmRcIl0gPSBcInN0YW5kYXJkXCI7XG4gICAgVG9vbHRpcFNob3dUeXBlW1wiUmVjdFwiXSA9IFwicmVjdFwiO1xufSkoVG9vbHRpcFNob3dUeXBlIHx8IChUb29sdGlwU2hvd1R5cGUgPSB7fSkpO1xudmFyIFRvb2x0aXBGZWF0dXJlVHlwZTtcbihmdW5jdGlvbiAoVG9vbHRpcEZlYXR1cmVUeXBlKSB7XG4gICAgVG9vbHRpcEZlYXR1cmVUeXBlW1wiUGF0aFwiXSA9IFwicGF0aFwiO1xuICAgIFRvb2x0aXBGZWF0dXJlVHlwZVtcIkljb25Gb250XCJdID0gXCJpY29uX2ZvbnRcIjtcbn0pKFRvb2x0aXBGZWF0dXJlVHlwZSB8fCAoVG9vbHRpcEZlYXR1cmVUeXBlID0ge30pKTtcbnZhciBUb29sdGlwRmVhdHVyZVBvc2l0aW9uO1xuKGZ1bmN0aW9uIChUb29sdGlwRmVhdHVyZVBvc2l0aW9uKSB7XG4gICAgVG9vbHRpcEZlYXR1cmVQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBUb29sdGlwRmVhdHVyZVBvc2l0aW9uW1wiTWlkZGxlXCJdID0gXCJtaWRkbGVcIjtcbiAgICBUb29sdGlwRmVhdHVyZVBvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG59KShUb29sdGlwRmVhdHVyZVBvc2l0aW9uIHx8IChUb29sdGlwRmVhdHVyZVBvc2l0aW9uID0ge30pKTtcbnZhciBDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uKSB7XG4gICAgQ2FuZGxlVG9vbHRpcFJlY3RQb3NpdGlvbltcIkZpeGVkXCJdID0gXCJmaXhlZFwiO1xuICAgIENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb25bXCJQb2ludGVyXCJdID0gXCJwb2ludGVyXCI7XG59KShDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uIHx8IChDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uID0ge30pKTtcbnZhciBDYW5kbGVUeXBlO1xuKGZ1bmN0aW9uIChDYW5kbGVUeXBlKSB7XG4gICAgQ2FuZGxlVHlwZVtcIkNhbmRsZVNvbGlkXCJdID0gXCJjYW5kbGVfc29saWRcIjtcbiAgICBDYW5kbGVUeXBlW1wiQ2FuZGxlU3Ryb2tlXCJdID0gXCJjYW5kbGVfc3Ryb2tlXCI7XG4gICAgQ2FuZGxlVHlwZVtcIkNhbmRsZVVwU3Ryb2tlXCJdID0gXCJjYW5kbGVfdXBfc3Ryb2tlXCI7XG4gICAgQ2FuZGxlVHlwZVtcIkNhbmRsZURvd25TdHJva2VcIl0gPSBcImNhbmRsZV9kb3duX3N0cm9rZVwiO1xuICAgIENhbmRsZVR5cGVbXCJPaGxjXCJdID0gXCJvaGxjXCI7XG4gICAgQ2FuZGxlVHlwZVtcIkFyZWFcIl0gPSBcImFyZWFcIjtcbn0pKENhbmRsZVR5cGUgfHwgKENhbmRsZVR5cGUgPSB7fSkpO1xudmFyIENhbmRsZUNvbG9yQ29tcGFyZVJ1bGU7XG4oZnVuY3Rpb24gKENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUpIHtcbiAgICBDYW5kbGVDb2xvckNvbXBhcmVSdWxlW1wiQ3VycmVudE9wZW5cIl0gPSBcImN1cnJlbnRfb3BlblwiO1xuICAgIENhbmRsZUNvbG9yQ29tcGFyZVJ1bGVbXCJQcmV2aW91c0Nsb3NlXCJdID0gXCJwcmV2aW91c19jbG9zZVwiO1xufSkoQ2FuZGxlQ29sb3JDb21wYXJlUnVsZSB8fCAoQ2FuZGxlQ29sb3JDb21wYXJlUnVsZSA9IHt9KSk7XG52YXIgQ29sb3IgPSB7XG4gICAgUkVEOiAnI0Y5Mjg1NScsXG4gICAgR1JFRU46ICcjMkRDMDhFJyxcbiAgICBXSElURTogJyNGRkZGRkYnLFxuICAgIEdSRVk6ICcjNzY4MDhGJyxcbiAgICBCTFVFOiAnIzE2NzdGRidcbn07XG5mdW5jdGlvbiBnZXREZWZhdWx0R3JpZFN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgY29sb3I6ICcjRURFREVEJyxcbiAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5EYXNoZWQsXG4gICAgICAgICAgICBkYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIGNvbG9yOiAnI0VERURFRCcsXG4gICAgICAgICAgICBzdHlsZTogTGluZVR5cGUuRGFzaGVkLFxuICAgICAgICAgICAgZGFzaGVkVmFsdWU6IFsyLCAyXVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogR2V0IGRlZmF1bHQgY2FuZGxlIHN0eWxlXG4gKiBAdHlwZSB7e2FyZWE6IHtiYWNrZ3JvdW5kQ29sb3I6IFt7b2Zmc2V0OiBudW1iZXIsIGNvbG9yOiBzdHJpbmd9LCB7b2Zmc2V0OiBudW1iZXIsIGNvbG9yOiBzdHJpbmd9XSwgbGluZUNvbG9yOiBzdHJpbmcsIGxpbmVTaXplOiBudW1iZXIsIHZhbHVlOiBzdHJpbmd9LCBiYXI6IHtub0NoYW5nZUNvbG9yOiBzdHJpbmcsIHVwQ29sb3I6IHN0cmluZywgZG93bkNvbG9yOiBzdHJpbmd9LCB0b29sdGlwOiB7cmVjdDoge29mZnNldFRvcDogbnVtYmVyLCBmaWxsQ29sb3I6IHN0cmluZywgYm9yZGVyQ29sb3I6IHN0cmluZywgcGFkZGluZ0JvdHRvbTogbnVtYmVyLCBib3JkZXJSYWRpdXM6IG51bWJlciwgcGFkZGluZ1JpZ2h0OiBudW1iZXIsIGJvcmRlclNpemU6IG51bWJlciwgb2Zmc2V0TGVmdDogbnVtYmVyLCBwYWRkaW5nVG9wOiBudW1iZXIsIHBhZGRpbmdMZWZ0OiBudW1iZXIsIG9mZnNldFJpZ2h0OiBudW1iZXJ9LCBzaG93UnVsZTogc3RyaW5nLCB2YWx1ZXM6IG51bGwsIHNob3dUeXBlOiBzdHJpbmcsIHRleHQ6IHttYXJnaW5SaWdodDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIHdlaWdodDogc3RyaW5nLCBtYXJnaW5Cb3R0b206IG51bWJlciwgZmFtaWx5OiBzdHJpbmcsIG1hcmdpblRvcDogbnVtYmVyLCBtYXJnaW5MZWZ0OiBudW1iZXJ9LCBsYWJlbHM6IHN0cmluZ1tdfSwgdHlwZTogc3RyaW5nLCBwcmljZU1hcms6IHtoaWdoOiB7dGV4dE1hcmdpbjogbnVtYmVyLCB0ZXh0U2l6ZTogbnVtYmVyLCBjb2xvcjogc3RyaW5nLCB0ZXh0RmFtaWx5OiBzdHJpbmcsIHNob3c6IGJvb2xlYW4sIHRleHRXZWlnaHQ6IHN0cmluZ30sIGxhc3Q6IHtub0NoYW5nZUNvbG9yOiBzdHJpbmcsIHVwQ29sb3I6IHN0cmluZywgbGluZToge2Rhc2hWYWx1ZTogbnVtYmVyW10sIHNpemU6IG51bWJlciwgc2hvdzogYm9vbGVhbiwgc3R5bGU6IHN0cmluZ30sIHNob3c6IGJvb2xlYW4sIHRleHQ6IHtwYWRkaW5nQm90dG9tOiBudW1iZXIsIHNpemU6IG51bWJlciwgY29sb3I6IHN0cmluZywgcGFkZGluZ1JpZ2h0OiBudW1iZXIsIHNob3c6IGJvb2xlYW4sIHdlaWdodDogc3RyaW5nLCBwYWRkaW5nVG9wOiBudW1iZXIsIGZhbWlseTogc3RyaW5nLCBwYWRkaW5nTGVmdDogbnVtYmVyfSwgZG93bkNvbG9yOiBzdHJpbmd9LCBsb3c6IHt0ZXh0TWFyZ2luOiBudW1iZXIsIHRleHRTaXplOiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIHRleHRGYW1pbHk6IHN0cmluZywgc2hvdzogYm9vbGVhbiwgdGV4dFdlaWdodDogc3RyaW5nfSwgc2hvdzogYm9vbGVhbn19fVxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0Q2FuZGxlU3R5bGUoKSB7XG4gICAgdmFyIGhpZ2hMb3cgPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIGNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICB0ZXh0T2Zmc2V0OiA1LFxuICAgICAgICB0ZXh0U2l6ZTogMTAsXG4gICAgICAgIHRleHRGYW1pbHk6ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgIHRleHRXZWlnaHQ6ICdub3JtYWwnXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBDYW5kbGVUeXBlLkNhbmRsZVNvbGlkLFxuICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgIGNvbXBhcmVSdWxlOiBDYW5kbGVDb2xvckNvbXBhcmVSdWxlLkN1cnJlbnRPcGVuLFxuICAgICAgICAgICAgdXBDb2xvcjogQ29sb3IuR1JFRU4sXG4gICAgICAgICAgICBkb3duQ29sb3I6IENvbG9yLlJFRCxcbiAgICAgICAgICAgIG5vQ2hhbmdlQ29sb3I6IENvbG9yLkdSRVksXG4gICAgICAgICAgICB1cEJvcmRlckNvbG9yOiBDb2xvci5HUkVFTixcbiAgICAgICAgICAgIGRvd25Cb3JkZXJDb2xvcjogQ29sb3IuUkVELFxuICAgICAgICAgICAgbm9DaGFuZ2VCb3JkZXJDb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgIHVwV2lja0NvbG9yOiBDb2xvci5HUkVFTixcbiAgICAgICAgICAgIGRvd25XaWNrQ29sb3I6IENvbG9yLlJFRCxcbiAgICAgICAgICAgIG5vQ2hhbmdlV2lja0NvbG9yOiBDb2xvci5HUkVZXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIGxpbmVTaXplOiAyLFxuICAgICAgICAgICAgbGluZUNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiAnY2xvc2UnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoZXhUb1JnYihDb2xvci5CTFVFLCAwLjAxKVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGV4VG9SZ2IoQ29sb3IuQkxVRSwgMC4yKVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgICAgICAgICByaXBwbGVDb2xvcjogaGV4VG9SZ2IoQ29sb3IuQkxVRSwgMC4zKSxcbiAgICAgICAgICAgICAgICByaXBwbGVSYWRpdXM6IDgsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByaWNlTWFyazoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGhpZ2g6IF9fYXNzaWduKHt9LCBoaWdoTG93KSxcbiAgICAgICAgICAgIGxvdzogX19hc3NpZ24oe30sIGhpZ2hMb3cpLFxuICAgICAgICAgICAgbGFzdDoge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tcGFyZVJ1bGU6IENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUuQ3VycmVudE9wZW4sXG4gICAgICAgICAgICAgICAgdXBDb2xvcjogQ29sb3IuR1JFRU4sXG4gICAgICAgICAgICAgICAgZG93bkNvbG9yOiBDb2xvci5SRUQsXG4gICAgICAgICAgICAgICAgbm9DaGFuZ2VDb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5EYXNoZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbNCwgNF0sXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLkZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJTaXplOiAwLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJEYXNoZWRWYWx1ZTogWzIsIDJdLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgICAgIGZhbWlseTogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0OiA0LFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiA2LFxuICAgICAgICAgICAgb2Zmc2V0UmlnaHQ6IDQsXG4gICAgICAgICAgICBvZmZzZXRCb3R0b206IDYsXG4gICAgICAgICAgICBzaG93UnVsZTogVG9vbHRpcFNob3dSdWxlLkFsd2F5cyxcbiAgICAgICAgICAgIHNob3dUeXBlOiBUb29sdGlwU2hvd1R5cGUuU3RhbmRhcmQsXG4gICAgICAgICAgICBjdXN0b206IFtcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAndGltZScsIHZhbHVlOiAne3RpbWV9JyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdvcGVuJywgdmFsdWU6ICd7b3Blbn0nIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ2hpZ2gnLCB2YWx1ZTogJ3toaWdofScgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAnbG93JywgdmFsdWU6ICd7bG93fScgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAnY2xvc2UnLCB2YWx1ZTogJ3tjbG9zZX0nIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ3ZvbHVtZScsIHZhbHVlOiAne3ZvbHVtZX0nIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6ICduL2EnLFxuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uLkZpeGVkLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0TGVmdDogNCxcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IDQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tOiA0LFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI0YyRjNGNScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjRkVGRUZFJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgICAgICBmYW1pbHk6ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiA4LFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogNCxcbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogOCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IDRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEdldCBkZWZhdWx0IGluZGljYXRvciBzdHlsZVxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0SW5kaWNhdG9yU3R5bGUoKSB7XG4gICAgdmFyIGFscGhhR3JlZW4gPSBoZXhUb1JnYihDb2xvci5HUkVFTiwgMC43KTtcbiAgICB2YXIgYWxwaGFSZWQgPSBoZXhUb1JnYihDb2xvci5SRUQsIDAuNyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2hsYzoge1xuICAgICAgICAgICAgY29tcGFyZVJ1bGU6IENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUuQ3VycmVudE9wZW4sXG4gICAgICAgICAgICB1cENvbG9yOiBhbHBoYUdyZWVuLFxuICAgICAgICAgICAgZG93bkNvbG9yOiBhbHBoYVJlZCxcbiAgICAgICAgICAgIG5vQ2hhbmdlQ29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgfSxcbiAgICAgICAgYmFyczogW3tcbiAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgICAgICBib3JkZXJEYXNoZWRWYWx1ZTogWzIsIDJdLFxuICAgICAgICAgICAgICAgIHVwQ29sb3I6IGFscGhhR3JlZW4sXG4gICAgICAgICAgICAgICAgZG93bkNvbG9yOiBhbHBoYVJlZCxcbiAgICAgICAgICAgICAgICBub0NoYW5nZUNvbG9yOiBDb2xvci5HUkVZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgbGluZXM6IFsnI0ZGOTYwMCcsICcjOTM1RUJEJywgQ29sb3IuQkxVRSwgJyNFMTFENzQnLCAnIzAxQzVDNCddLm1hcChmdW5jdGlvbiAoY29sb3IpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgfSk7IH0pLFxuICAgICAgICBjaXJjbGVzOiBbe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICAgICAgdXBDb2xvcjogYWxwaGFHcmVlbixcbiAgICAgICAgICAgICAgICBkb3duQ29sb3I6IGFscGhhUmVkLFxuICAgICAgICAgICAgICAgIG5vQ2hhbmdlQ29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBsYXN0VmFsdWVNYXJrOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgIGJvcmRlclNpemU6IDAsXG4gICAgICAgICAgICAgICAgYm9yZGVyRGFzaGVkVmFsdWU6IFsyLCAyXSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0OiA0LFxuICAgICAgICAgICAgb2Zmc2V0VG9wOiA2LFxuICAgICAgICAgICAgb2Zmc2V0UmlnaHQ6IDQsXG4gICAgICAgICAgICBvZmZzZXRCb3R0b206IDYsXG4gICAgICAgICAgICBzaG93UnVsZTogVG9vbHRpcFNob3dSdWxlLkFsd2F5cyxcbiAgICAgICAgICAgIHNob3dUeXBlOiBUb29sdGlwU2hvd1R5cGUuU3RhbmRhcmQsXG4gICAgICAgICAgICBzaG93TmFtZTogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dQYXJhbXM6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6ICduL2EnLFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZhbWlseTogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDgsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiA0LFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiA4LFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRBeGlzU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgc2l6ZTogJ2F1dG8nLFxuICAgICAgICBheGlzTGluZToge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCcsXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tUZXh0OiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6IENvbG9yLkdSRVksXG4gICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgIGZhbWlseTogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICBtYXJnaW5TdGFydDogNCxcbiAgICAgICAgICAgIG1hcmdpbkVuZDogNlxuICAgICAgICB9LFxuICAgICAgICB0aWNrTGluZToge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICBsZW5ndGg6IDMsXG4gICAgICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENyb3NzaGFpclN0eWxlKCkge1xuICAgIGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgc3R5bGU6IExpbmVUeXBlLkRhc2hlZCxcbiAgICAgICAgICAgICAgICBkYXNoZWRWYWx1ZTogWzQsIDJdLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgY29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogNCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgaG9yaXpvbnRhbDogaXRlbSgpLFxuICAgICAgICB2ZXJ0aWNhbDogaXRlbSgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRPdmVybGF5U3R5bGUoKSB7XG4gICAgdmFyIHBvaW50Qm9yZGVyQ29sb3IgPSBoZXhUb1JnYihDb2xvci5CTFVFLCAwLjM1KTtcbiAgICB2YXIgYWxwaGFCZyA9IGhleFRvUmdiKENvbG9yLkJMVUUsIDAuMjUpO1xuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvci5XSElURSxcbiAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAyLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNCxcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5CTFVFXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICBjb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBwb2ludEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgICAgIGFjdGl2ZUNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgYWN0aXZlQm9yZGVyQ29sb3I6IHBvaW50Qm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBhY3RpdmVCb3JkZXJTaXplOiAzLFxuICAgICAgICAgICAgYWN0aXZlUmFkaXVzOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICBkYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgY29sb3I6IGFscGhhQmcsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIGJvcmRlclNpemU6IDEsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICBib3JkZXJEYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb246IHtcbiAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgY29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIGJvcmRlclNpemU6IDEsXG4gICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICBib3JkZXJEYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZToge1xuICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLkZpbGwsXG4gICAgICAgICAgICBjb2xvcjogYWxwaGFCZyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgYXJjOiB7XG4gICAgICAgICAgICBzdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICBjb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICBkYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IHRleHQoKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2VwYXJhdG9yU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgY29sb3I6ICcjREREREREJyxcbiAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgYWN0aXZlQmFja2dyb3VuZENvbG9yOiBoZXhUb1JnYihDb2xvci5CTFVFLCAwLjA4KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U3R5bGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdyaWQ6IGdldERlZmF1bHRHcmlkU3R5bGUoKSxcbiAgICAgICAgY2FuZGxlOiBnZXREZWZhdWx0Q2FuZGxlU3R5bGUoKSxcbiAgICAgICAgaW5kaWNhdG9yOiBnZXREZWZhdWx0SW5kaWNhdG9yU3R5bGUoKSxcbiAgICAgICAgeEF4aXM6IGdldERlZmF1bHRBeGlzU3R5bGUoKSxcbiAgICAgICAgeUF4aXM6IGdldERlZmF1bHRBeGlzU3R5bGUoKSxcbiAgICAgICAgc2VwYXJhdG9yOiBnZXREZWZhdWx0U2VwYXJhdG9yU3R5bGUoKSxcbiAgICAgICAgY3Jvc3NoYWlyOiBnZXREZWZhdWx0Q3Jvc3NoYWlyU3R5bGUoKSxcbiAgICAgICAgb3ZlcmxheTogZ2V0RGVmYXVsdE92ZXJsYXlTdHlsZSgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVWID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG5mdW5jdGlvbiBsb2codGVtcGxhdGVUZXh0LCB0YWdTdHlsZSwgbWVzc2FnZVN0eWxlLCBhcGksIGludmFsaWRQYXJhbSwgYXBwZW5kKSB7XG4gICAgaWYgKERFVikge1xuICAgICAgICB2YXIgYXBpU3RyID0gYXBpICE9PSAnJyA/IFwiQ2FsbCBhcGkgYFwiLmNvbmNhdChhcGksIFwiYFwiKS5jb25jYXQoaW52YWxpZFBhcmFtICE9PSAnJyB8fCBhcHBlbmQgIT09ICcnID8gJywgJyA6ICcuJykgOiAnJztcbiAgICAgICAgdmFyIGludmFsaWRQYXJhbVN0ciA9IGludmFsaWRQYXJhbSAhPT0gJycgPyBcImludmFsaWQgcGFyYW1ldGVyIGBcIi5jb25jYXQoaW52YWxpZFBhcmFtLCBcImBcIikuY29uY2F0KGFwcGVuZCAhPT0gJycgPyAnLCAnIDogJy4nKSA6ICcnO1xuICAgICAgICB2YXIgYXBwZW5kU3RyID0gYXBwZW5kICE9PSAnJyA/IGFwcGVuZCA6ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyh0ZW1wbGF0ZVRleHQsIHRhZ1N0eWxlLCBtZXNzYWdlU3R5bGUsIGFwaVN0ciwgaW52YWxpZFBhcmFtU3RyLCBhcHBlbmRTdHIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ1dhcm4oYXBpLCBpbnZhbGlkUGFyYW0sIGFwcGVuZCkge1xuICAgIGxvZygnJWPwn5iRIGtsaW5lY2hhcnRzIHdhcm5pbmclYyAlcyVzJXMnLCAncGFkZGluZzozcHggNHB4O2JvcmRlci1yYWRpdXM6MnB4O2NvbG9yOiNmZmZmZmY7YmFja2dyb3VuZC1jb2xvcjojRkY5NjAwJywgJ2NvbG9yOiNGRjk2MDAnLCBhcGksIGludmFsaWRQYXJhbSwgYXBwZW5kICE9PSBudWxsICYmIGFwcGVuZCAhPT0gdm9pZCAwID8gYXBwZW5kIDogJycpO1xufVxuZnVuY3Rpb24gbG9nRXJyb3IoYXBpLCBpbnZhbGlkUGFyYW0sIGFwcGVuZCkge1xuICAgIGxvZygnJWPwn5ifIGtsaW5lY2hhcnRzIGVycm9yJWMgJXMlcyVzJywgJ3BhZGRpbmc6M3B4IDRweDtib3JkZXItcmFkaXVzOjJweDtjb2xvcjojZmZmZmZmO2JhY2tncm91bmQtY29sb3I6I0Y5Mjg1NTsnLCAnY29sb3I6I0Y5Mjg1NTsnLCBhcGksIGludmFsaWRQYXJhbSwgYXBwZW5kICk7XG59XG5mdW5jdGlvbiBsb2dUYWcoKSB7XG4gICAgbG9nKCclY+KdpO+4jyBXZWxjb21lIHRvIGtsaW5lY2hhcnRzLiBWZXJzaW9uIGlzIDEwLjAuMC1hbHBoYTUnLCAnYm9yZGVyLXJhZGl1czo0cHg7Ym9yZGVyOmRhc2hlZCAxcHggIzE2NzdGRjtsaW5lLWhlaWdodDo3MHB4O3BhZGRpbmc6MCAyMHB4O21hcmdpbjoxNnB4IDA7Zm9udC1zaXplOjE0cHg7Y29sb3I6IzE2NzdGRjsnLCAnJywgJycsICcnLCAnJyk7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xudmFyIHJlUHJvcE5hbWUgPSBSZWdFeHAoJ1teLltcXFxcXV0rJyArICd8JyArXG4gICAgJ1xcXFxbKD86JyArXG4gICAgJyhbXlwiXFwnXVteW10qKScgKyAnfCcgK1xuICAgICcoW1wiXFwnXSkoKD86KD8hXFxcXDIpW15cXFxcXFxcXF18XFxcXFxcXFwuKSo/KVxcXFwyJyArXG4gICAgJylcXFxcXScgKyAnfCcgK1xuICAgICcoPz0oPzpcXFxcLnxcXFxcW1xcXFxdKSg/OlxcXFwufFxcXFxbXFxcXF18JCkpJywgJ2cnKTtcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGRhdGEsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgdmFyIHBhdGhfMSA9IFtdO1xuICAgICAgICBrZXkucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbiAoc3ViU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBzdWJTdHJpbmc7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChhcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgIGsgPSBhcmdzWzJdLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWQoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBrID0gYXJnc1swXS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoXzEucHVzaChrKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGE7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBsZW5ndGhfMSA9IHBhdGhfMS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpc1ZhbGlkKHZhbHVlKSAmJiBpbmRleCA8IGxlbmd0aF8xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVtwYXRoXzFbaW5kZXgrK11dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHZhbHVlKSA/IHZhbHVlIDogKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHZvaWQgMCA/IGRlZmF1bHRWYWx1ZSA6ICctLScpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogJy0tJztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVzdGFtcFRvRGF0ZVRpbWUoZGF0ZVRpbWVGb3JtYXQsIHRpbWVzdGFtcCkge1xuICAgIHZhciBkYXRlID0ge307XG4gICAgZGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSh0aW1lc3RhbXApKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IHtcbiAgICAgICAgICAgICAgICBkYXRlLllZWVkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzoge1xuICAgICAgICAgICAgICAgIGRhdGUuTU0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RheSc6IHtcbiAgICAgICAgICAgICAgICBkYXRlLkREID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdob3VyJzoge1xuICAgICAgICAgICAgICAgIGRhdGUuSEggPSB2YWx1ZSA9PT0gJzI0JyA/ICcwMCcgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IHtcbiAgICAgICAgICAgICAgICBkYXRlLm1tID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOiB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGU7XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lc3RhbXBUb1N0cmluZyhkYXRlVGltZUZvcm1hdCwgdGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICB2YXIgZGF0ZSA9IGZvcm1hdFRpbWVzdGFtcFRvRGF0ZVRpbWUoZGF0ZVRpbWVGb3JtYXQsIHRpbWVzdGFtcCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuIC0tIGlnbm9yZVxuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvWVlZWXxNTXxERHxISHxtbXxzcy9nLCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkYXRlW2tleV07IH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgdiA9ICt2YWx1ZTtcbiAgICBpZiAoaXNOdW1iZXIodikpIHtcbiAgICAgICAgcmV0dXJuIHYudG9GaXhlZChwcmVjaXNpb24gIT09IG51bGwgJiYgcHJlY2lzaW9uICE9PSB2b2lkIDAgPyBwcmVjaXNpb24gOiAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEJpZ051bWJlcih2YWx1ZSkge1xuICAgIHZhciB2ID0gK3ZhbHVlO1xuICAgIGlmIChpc051bWJlcih2KSkge1xuICAgICAgICBpZiAodiA+IDEwMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgrKCh2IC8gMTAwMDAwMDAwMCkudG9GaXhlZCgzKSksIFwiQlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA+IDEwMDAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgrKCh2IC8gMTAwMDAwMCkudG9GaXhlZCgzKSksIFwiTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA+IDEwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgrKCh2IC8gMTAwMCkudG9GaXhlZCgzKSksIFwiS1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGhvdXNhbmRzKHZhbHVlLCBzaWduKSB7XG4gICAgdmFyIHZsID0gXCJcIi5jb25jYXQodmFsdWUpO1xuICAgIGlmIChzaWduLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmw7XG4gICAgfVxuICAgIGlmICh2bC5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgIHZhciBhcnIgPSB2bC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoYXJyWzBdLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrJCkvZywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiBcIlwiLmNvbmNhdCgkMSkuY29uY2F0KHNpZ24pOyB9KSwgXCIuXCIpLmNvbmNhdChhcnJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmwucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSskKS9nLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuIFwiXCIuY29uY2F0KCQxKS5jb25jYXQoc2lnbik7IH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0Rm9sZERlY2ltYWwodmFsdWUsIHRocmVzaG9sZCkge1xuICAgIHZhciB2bCA9IFwiXCIuY29uY2F0KHZhbHVlKTtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXC4weycgKyB0aHJlc2hvbGQgKyAnLH1bMS05XVswLTldKiQnKTtcbiAgICBpZiAocmVnLnRlc3QodmwpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB2bC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciB2ID0gcmVzdWx0W2xhc3RJbmRleF07XG4gICAgICAgIHZhciBtYXRjaCA9IC8wKi8uZXhlYyh2KTtcbiAgICAgICAgaWYgKGlzVmFsaWQobWF0Y2gpKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHRbbGFzdEluZGV4XSA9IHYucmVwbGFjZSgvMCovLCBcIjB7XCIuY29uY2F0KGNvdW50LCBcIn1cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZsO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBtZWFzdXJlQ3R4ID0gbnVsbDtcbi8qKlxuICogR2V0IHBpeGVsIHJhdGlvXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRQaXhlbFJhdGlvKGNhbnZhcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGNhbnZhcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlUGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvbnQoc2l6ZSwgd2VpZ2h0LCBmYW1pbHkpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQod2VpZ2h0ICE9PSBudWxsICYmIHdlaWdodCAhPT0gdm9pZCAwID8gd2VpZ2h0IDogJ25vcm1hbCcsIFwiIFwiKS5jb25jYXQoc2l6ZSAhPT0gbnVsbCAmJiBzaXplICE9PSB2b2lkIDAgPyBzaXplIDogMTIsIFwicHggXCIpLmNvbmNhdChmYW1pbHkgIT09IG51bGwgJiYgZmFtaWx5ICE9PSB2b2lkIDAgPyBmYW1pbHkgOiAnSGVsdmV0aWNhIE5ldWUnKTtcbn1cbi8qKlxuICogTWVhc3VyZSB0aGUgd2lkdGggb2YgdGV4dFxuICogQHBhcmFtIHRleHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNhbGNUZXh0V2lkdGgodGV4dCwgc2l6ZSwgd2VpZ2h0LCBmYW1pbHkpIHtcbiAgICBpZiAoIWlzVmFsaWQobWVhc3VyZUN0eCkpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oY2FudmFzKTtcbiAgICAgICAgbWVhc3VyZUN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBtZWFzdXJlQ3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICBtZWFzdXJlQ3R4LmZvbnQgPSBjcmVhdGVGb250KHNpemUsIHdlaWdodCwgZmFtaWx5KTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtZWFzdXJlQ3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQWN0aW9uVHlwZTtcbihmdW5jdGlvbiAoQWN0aW9uVHlwZSkge1xuICAgIEFjdGlvblR5cGVbXCJPblpvb21cIl0gPSBcIm9uWm9vbVwiO1xuICAgIEFjdGlvblR5cGVbXCJPblNjcm9sbFwiXSA9IFwib25TY3JvbGxcIjtcbiAgICBBY3Rpb25UeXBlW1wiT25WaXNpYmxlUmFuZ2VDaGFuZ2VcIl0gPSBcIm9uVmlzaWJsZVJhbmdlQ2hhbmdlXCI7XG4gICAgQWN0aW9uVHlwZVtcIk9uQ2FuZGxlVG9vbHRpcEZlYXR1cmVDbGlja1wiXSA9IFwib25DYW5kbGVUb29sdGlwRmVhdHVyZUNsaWNrXCI7XG4gICAgQWN0aW9uVHlwZVtcIk9uQ3Jvc3NoYWlyQ2hhbmdlXCJdID0gXCJvbkNyb3NzaGFpckNoYW5nZVwiO1xuICAgIEFjdGlvblR5cGVbXCJPbkNhbmRsZUJhckNsaWNrXCJdID0gXCJvbkNhbmRsZUJhckNsaWNrXCI7XG4gICAgQWN0aW9uVHlwZVtcIk9uUGFuZURyYWdcIl0gPSBcIm9uUGFuZURyYWdcIjtcbn0pKEFjdGlvblR5cGUgfHwgKEFjdGlvblR5cGUgPSB7fSkpO1xudmFyIEFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBBY3Rpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9jYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWN0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBY3Rpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEluZGljYXRvclNlcmllcztcbihmdW5jdGlvbiAoSW5kaWNhdG9yU2VyaWVzKSB7XG4gICAgSW5kaWNhdG9yU2VyaWVzW1wiTm9ybWFsXCJdID0gXCJub3JtYWxcIjtcbiAgICBJbmRpY2F0b3JTZXJpZXNbXCJQcmljZVwiXSA9IFwicHJpY2VcIjtcbiAgICBJbmRpY2F0b3JTZXJpZXNbXCJWb2x1bWVcIl0gPSBcInZvbHVtZVwiO1xufSkoSW5kaWNhdG9yU2VyaWVzIHx8IChJbmRpY2F0b3JTZXJpZXMgPSB7fSkpO1xudmFyIEluZGljYXRvckV2ZW50VGFyZ2V0O1xuKGZ1bmN0aW9uIChJbmRpY2F0b3JFdmVudFRhcmdldCkge1xuICAgIEluZGljYXRvckV2ZW50VGFyZ2V0W1wiRmVhdHVyZVwiXSA9IFwiZmVhdHVyZVwiO1xufSkoSW5kaWNhdG9yRXZlbnRUYXJnZXQgfHwgKEluZGljYXRvckV2ZW50VGFyZ2V0ID0ge30pKTtcbnZhciBJbmRpY2F0b3JEYXRhU3RhdGU7XG4oZnVuY3Rpb24gKEluZGljYXRvckRhdGFTdGF0ZSkge1xuICAgIEluZGljYXRvckRhdGFTdGF0ZVtcIkxvYWRpbmdcIl0gPSBcImxvYWRpbmdcIjtcbiAgICBJbmRpY2F0b3JEYXRhU3RhdGVbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbiAgICBJbmRpY2F0b3JEYXRhU3RhdGVbXCJSZWFkeVwiXSA9IFwicmVhZHlcIjtcbn0pKEluZGljYXRvckRhdGFTdGF0ZSB8fCAoSW5kaWNhdG9yRGF0YVN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGVhY2hGaWd1cmVzKGluZGljYXRvciwgZGF0YUluZGV4LCBkZWZhdWx0U3R5bGVzLCBlYWNoRmlndXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kaWNhdG9yLnJlc3VsdDtcbiAgICB2YXIgZmlndXJlcyA9IGluZGljYXRvci5maWd1cmVzO1xuICAgIHZhciBzdHlsZXMgPSBpbmRpY2F0b3Iuc3R5bGVzO1xuICAgIHZhciBjaXJjbGVTdHlsZXMgPSBmb3JtYXRWYWx1ZShzdHlsZXMsICdjaXJjbGVzJywgZGVmYXVsdFN0eWxlcy5jaXJjbGVzKTtcbiAgICB2YXIgY2lyY2xlU3R5bGVDb3VudCA9IGNpcmNsZVN0eWxlcy5sZW5ndGg7XG4gICAgdmFyIGJhclN0eWxlcyA9IGZvcm1hdFZhbHVlKHN0eWxlcywgJ2JhcnMnLCBkZWZhdWx0U3R5bGVzLmJhcnMpO1xuICAgIHZhciBiYXJTdHlsZUNvdW50ID0gYmFyU3R5bGVzLmxlbmd0aDtcbiAgICB2YXIgbGluZVN0eWxlcyA9IGZvcm1hdFZhbHVlKHN0eWxlcywgJ2xpbmVzJywgZGVmYXVsdFN0eWxlcy5saW5lcyk7XG4gICAgdmFyIGxpbmVTdHlsZUNvdW50ID0gbGluZVN0eWxlcy5sZW5ndGg7XG4gICAgdmFyIGNpcmNsZUNvdW50ID0gMDtcbiAgICB2YXIgYmFyQ291bnQgPSAwO1xuICAgIHZhciBsaW5lQ291bnQgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvaW5pdC1kZWNsYXJhdGlvbnMgIC0tIGlnbm9yZVxuICAgIHZhciBkZWZhdWx0RmlndXJlU3R5bGVzO1xuICAgIHZhciBmaWd1cmVJbmRleCA9IDA7XG4gICAgZmlndXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWd1cmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaXJjbGUnOiB7XG4gICAgICAgICAgICAgICAgZmlndXJlSW5kZXggPSBjaXJjbGVDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzXzEgPSBjaXJjbGVTdHlsZXNbY2lyY2xlQ291bnQgJSBjaXJjbGVTdHlsZUNvdW50XTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RmlndXJlU3R5bGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlc18xKSwgeyBjb2xvcjogc3R5bGVzXzEubm9DaGFuZ2VDb2xvciB9KTtcbiAgICAgICAgICAgICAgICBjaXJjbGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYmFyJzoge1xuICAgICAgICAgICAgICAgIGZpZ3VyZUluZGV4ID0gYmFyQ291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlc18yID0gYmFyU3R5bGVzW2JhckNvdW50ICUgYmFyU3R5bGVDb3VudF07XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZpZ3VyZVN0eWxlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXNfMiksIHsgY29sb3I6IHN0eWxlc18yLm5vQ2hhbmdlQ29sb3IgfSk7XG4gICAgICAgICAgICAgICAgYmFyQ291bnQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpbmUnOiB7XG4gICAgICAgICAgICAgICAgZmlndXJlSW5kZXggPSBsaW5lQ291bnQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZpZ3VyZVN0eWxlcyA9IGxpbmVTdHlsZXNbbGluZUNvdW50ICUgbGluZVN0eWxlQ291bnRdO1xuICAgICAgICAgICAgICAgIGxpbmVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKGZpZ3VyZS50eXBlKSkge1xuICAgICAgICAgICAgdmFyIHNzID0gKF9hID0gZmlndXJlLnN0eWxlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZmlndXJlLCB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBwcmV2OiByZXN1bHRbZGF0YUluZGV4IC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHJlc3VsdFtkYXRhSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiByZXN1bHRbZGF0YUluZGV4ICsgMV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHlsZXM6IGRlZmF1bHRTdHlsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICBlYWNoRmlndXJlQ2FsbGJhY2soZmlndXJlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdEZpZ3VyZVN0eWxlcyksIHNzKSwgZmlndXJlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG52YXIgSW5kaWNhdG9ySW1wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZGljYXRvckltcChpbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSA0O1xuICAgICAgICB0aGlzLmNhbGNQYXJhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaG91bGRPaGxjID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkRm9ybWF0QmlnTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuekxldmVsID0gMDtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBJbmRpY2F0b3JTZXJpZXMuTm9ybWFsO1xuICAgICAgICB0aGlzLmZpZ3VyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5taW5WYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWF4VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjYWxjID0gSlNPTi5zdHJpbmdpZnkocHJldi5jYWxjUGFyYW1zKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudC5jYWxjUGFyYW1zKSB8fFxuICAgICAgICAgICAgICAgIHByZXYuZmlndXJlcyAhPT0gY3VycmVudC5maWd1cmVzIHx8XG4gICAgICAgICAgICAgICAgcHJldi5jYWxjICE9PSBjdXJyZW50LmNhbGM7XG4gICAgICAgICAgICB2YXIgZHJhdyA9IGNhbGMgfHxcbiAgICAgICAgICAgICAgICBwcmV2LnNob3J0TmFtZSAhPT0gY3VycmVudC5zaG9ydE5hbWUgfHxcbiAgICAgICAgICAgICAgICBwcmV2LnNlcmllcyAhPT0gY3VycmVudC5zZXJpZXMgfHxcbiAgICAgICAgICAgICAgICBwcmV2Lm1pblZhbHVlICE9PSBjdXJyZW50Lm1pblZhbHVlIHx8XG4gICAgICAgICAgICAgICAgcHJldi5tYXhWYWx1ZSAhPT0gY3VycmVudC5tYXhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIHByZXYucHJlY2lzaW9uICE9PSBjdXJyZW50LnByZWNpc2lvbiB8fFxuICAgICAgICAgICAgICAgIHByZXYuc2hvdWxkT2hsYyAhPT0gY3VycmVudC5zaG91bGRPaGxjIHx8XG4gICAgICAgICAgICAgICAgcHJldi5zaG91bGRGb3JtYXRCaWdOdW1iZXIgIT09IGN1cnJlbnQuc2hvdWxkRm9ybWF0QmlnTnVtYmVyIHx8XG4gICAgICAgICAgICAgICAgcHJldi52aXNpYmxlICE9PSBjdXJyZW50LnZpc2libGUgfHxcbiAgICAgICAgICAgICAgICBwcmV2LnpMZXZlbCAhPT0gY3VycmVudC56TGV2ZWwgfHxcbiAgICAgICAgICAgICAgICBwcmV2LmV4dGVuZERhdGEgIT09IGN1cnJlbnQuZXh0ZW5kRGF0YSB8fFxuICAgICAgICAgICAgICAgIHByZXYucmVnZW5lcmF0ZUZpZ3VyZXMgIT09IGN1cnJlbnQucmVnZW5lcmF0ZUZpZ3VyZXMgfHxcbiAgICAgICAgICAgICAgICBwcmV2LmNyZWF0ZVRvb2x0aXBEYXRhU291cmNlICE9PSBjdXJyZW50LmNyZWF0ZVRvb2x0aXBEYXRhU291cmNlIHx8XG4gICAgICAgICAgICAgICAgcHJldi5kcmF3ICE9PSBjdXJyZW50LmRyYXc7XG4gICAgICAgICAgICByZXR1cm4geyBjYWxjOiBjYWxjLCBkcmF3OiBkcmF3IH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICB0aGlzLnJlZ2VuZXJhdGVGaWd1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwRGF0YVNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhdyA9IG51bGw7XG4gICAgICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgICAgIHRoaXMub25EYXRhU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLl9sb2NrU2VyaWVzUHJlY2lzaW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3ZlcnJpZGUoaW5kaWNhdG9yKTtcbiAgICAgICAgdGhpcy5fbG9ja1Nlcmllc1ByZWNpc2lvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBJbmRpY2F0b3JJbXAucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLCByZXN1bHQgPSBfYy5yZXN1bHQsIGN1cnJlbnRPdGhlcnMgPSBfX3Jlc3QoX2MsIFtcInJlc3VsdFwiXSk7XG4gICAgICAgIHRoaXMuX3ByZXZJbmRpY2F0b3IgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2xvbmUoY3VycmVudE90aGVycykpLCB7IHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgICB2YXIgaWQgPSBpbmRpY2F0b3IuaWQsIG5hbWUgPSBpbmRpY2F0b3IubmFtZSwgc2hvcnROYW1lID0gaW5kaWNhdG9yLnNob3J0TmFtZSwgcHJlY2lzaW9uID0gaW5kaWNhdG9yLnByZWNpc2lvbiwgc3R5bGVzID0gaW5kaWNhdG9yLnN0eWxlcywgZmlndXJlcyA9IGluZGljYXRvci5maWd1cmVzLCBjYWxjUGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIG90aGVycyA9IF9fcmVzdChpbmRpY2F0b3IsIFtcImlkXCIsIFwibmFtZVwiLCBcInNob3J0TmFtZVwiLCBcInByZWNpc2lvblwiLCBcInN0eWxlc1wiLCBcImZpZ3VyZXNcIiwgXCJjYWxjUGFyYW1zXCJdKTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyh0aGlzLmlkKSAmJiBpc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uICAtLSBpZ25vcmVcbiAgICAgICAgdGhpcy5zaG9ydE5hbWUgPSAoX2EgPSBzaG9ydE5hbWUgIT09IG51bGwgJiYgc2hvcnROYW1lICE9PSB2b2lkIDAgPyBzaG9ydE5hbWUgOiB0aGlzLnNob3J0TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5uYW1lO1xuICAgICAgICBpZiAoaXNOdW1iZXIocHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9sb2NrU2VyaWVzUHJlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZChzdHlsZXMpKSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnN0eWxlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHRoaXMuc3R5bGVzID0ge30pO1xuICAgICAgICAgICAgbWVyZ2UodGhpcy5zdHlsZXMsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcywgb3RoZXJzKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY2FsY1BhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY1BhcmFtcyA9IGNhbGNQYXJhbXM7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLnJlZ2VuZXJhdGVGaWd1cmVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlndXJlcyA9IHRoaXMucmVnZW5lcmF0ZUZpZ3VyZXModGhpcy5jYWxjUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpZ3VyZXMgPSBmaWd1cmVzICE9PSBudWxsICYmIGZpZ3VyZXMgIT09IHZvaWQgMCA/IGZpZ3VyZXMgOiB0aGlzLmZpZ3VyZXM7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JJbXAucHJvdG90eXBlLnNldFNlcmllc1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NrU2VyaWVzUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5kaWNhdG9ySW1wLnByb3RvdHlwZS5zaG91bGRVcGRhdGVJbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3J0ID0gdGhpcy5fcHJldkluZGljYXRvci56TGV2ZWwgIT09IHRoaXMuekxldmVsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaG91bGRVcGRhdGUodGhpcy5fcHJldkluZGljYXRvciwgdGhpcyk7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2FsYzogcmVzdWx0LCBkcmF3OiByZXN1bHQsIHNvcnQ6IHNvcnQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHsgc29ydDogc29ydCB9KTtcbiAgICB9O1xuICAgIEluZGljYXRvckltcC5wcm90b3R5cGUuY2FsY0ltcCA9IGZ1bmN0aW9uIChkYXRhTGlzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsYyhkYXRhTGlzdCwgdGhpcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5kaWNhdG9ySW1wLmV4dGVuZCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgQ3VzdG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEN1c3RvbSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEN1c3RvbSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGUpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgICAgICB9KEluZGljYXRvckltcCkpO1xuICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgIH07XG4gICAgcmV0dXJuIEluZGljYXRvckltcDtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIE92ZXJsYXlNb2RlO1xuKGZ1bmN0aW9uIChPdmVybGF5TW9kZSkge1xuICAgIE92ZXJsYXlNb2RlW1wiTm9ybWFsXCJdID0gXCJub3JtYWxcIjtcbiAgICBPdmVybGF5TW9kZVtcIldlYWtNYWduZXRcIl0gPSBcIndlYWtfbWFnbmV0XCI7XG4gICAgT3ZlcmxheU1vZGVbXCJTdHJvbmdNYWduZXRcIl0gPSBcInN0cm9uZ19tYWduZXRcIjtcbn0pKE92ZXJsYXlNb2RlIHx8IChPdmVybGF5TW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBjaGVja092ZXJsYXlGaWd1cmVFdmVudCh0YXJnZXRFdmVudFR5cGUsIGZpZ3VyZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgaWdub3JlRXZlbnQgPSAoX2EgPSBmaWd1cmUgPT09IG51bGwgfHwgZmlndXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWd1cmUuaWdub3JlRXZlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGlmIChpc0Jvb2xlYW4oaWdub3JlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiAhaWdub3JlRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiAhaWdub3JlRXZlbnQuaW5jbHVkZXModGFyZ2V0RXZlbnRUeXBlKTtcbn1cbnZhciBPVkVSTEFZX0RSQVdfU1RFUF9TVEFSVCA9IDE7XG52YXIgT1ZFUkxBWV9EUkFXX1NURVBfRklOSVNIRUQgPSAtMTtcbnZhciBPVkVSTEFZX0lEX1BSRUZJWCA9ICdvdmVybGF5Xyc7XG52YXIgT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCA9ICdvdmVybGF5X2ZpZ3VyZV8nO1xudmFyIE92ZXJsYXlJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheUltcChvdmVybGF5KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBJZCA9ICcnO1xuICAgICAgICB0aGlzLnRvdGFsU3RlcCA9IDE7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBPVkVSTEFZX0RSQVdfU1RFUF9TVEFSVDtcbiAgICAgICAgdGhpcy5sb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuekxldmVsID0gMDtcbiAgICAgICAgdGhpcy5uZWVkRGVmYXVsdFBvaW50RmlndXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmVlZERlZmF1bHRYQXhpc0ZpZ3VyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5lZWREZWZhdWx0WUF4aXNGaWd1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2RlID0gT3ZlcmxheU1vZGUuTm9ybWFsO1xuICAgICAgICB0aGlzLm1vZGVTZW5zaXRpdml0eSA9IDg7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jcmVhdGVQb2ludEZpZ3VyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNyZWF0ZVhBeGlzRmlndXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3JlYXRlWUF4aXNGaWd1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXZlbnRQcmVzc2VkTW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLm9uRHJhd1N0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkRyYXdpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLm9uRHJhd0VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgICAgIHRoaXMub25Eb3VibGVDbGljayA9IG51bGw7XG4gICAgICAgIHRoaXMub25SaWdodENsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblByZXNzZWRNb3ZlU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUHJlc3NlZE1vdmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMub25QcmVzc2VkTW92ZUVuZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25Nb3VzZUVudGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25TZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25EZXNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJldlpMZXZlbCA9IDA7XG4gICAgICAgIHRoaXMuX3ByZXZQcmVzc2VkUG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmV2UHJlc3NlZFBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLm92ZXJyaWRlKG92ZXJsYXkpO1xuICAgIH1cbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuX3ByZXZPdmVybGF5ID0gY2xvbmUodGhpcyk7XG4gICAgICAgIHZhciBpZCA9IG92ZXJsYXkuaWQsIG5hbWUgPSBvdmVybGF5Lm5hbWU7IG92ZXJsYXkuY3VycmVudFN0ZXA7IHZhciBwb2ludHMgPSBvdmVybGF5LnBvaW50cywgc3R5bGVzID0gb3ZlcmxheS5zdHlsZXMsIG90aGVycyA9IF9fcmVzdChvdmVybGF5LCBbXCJpZFwiLCBcIm5hbWVcIiwgXCJjdXJyZW50U3RlcFwiLCBcInBvaW50c1wiLCBcInN0eWxlc1wiXSk7XG4gICAgICAgIG1lcmdlKHRoaXMsIG90aGVycyk7XG4gICAgICAgIGlmICghaXNTdHJpbmcodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cmluZyh0aGlzLmlkKSAmJiBpc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZChzdHlsZXMpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnN0eWxlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuc3R5bGVzID0ge30pO1xuICAgICAgICAgICAgbWVyZ2UodGhpcy5zdHlsZXMsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkocG9pbnRzKSAmJiBwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJlcGVhdFRvdGFsU3RlcCA9IDA7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb2ludHMpLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+PSB0aGlzLnRvdGFsU3RlcCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gT1ZFUkxBWV9EUkFXX1NURVBfRklOSVNIRUQ7XG4gICAgICAgICAgICAgICAgcmVwZWF0VG90YWxTdGVwID0gdGhpcy50b3RhbFN0ZXAgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHBvaW50cy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIHJlcGVhdFRvdGFsU3RlcCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHdyb25nIGRyYXdpbmcgZHVlIHRvIHdyb25nIHBvaW50c1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5wZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdFRvdGFsU3RlcDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGkgKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZvcm1Qb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVBvaW50OiB0aGlzLnBvaW50c1tpXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RlcCA9PT0gT1ZFUkxBWV9EUkFXX1NURVBfRklOSVNIRUQpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnBlcmZvcm1FdmVudFByZXNzZWRNb3ZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiB0aGlzLmN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5wb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1Qb2ludEluZGV4OiB0aGlzLnBvaW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtUG9pbnQ6IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLmdldFByZXZaTGV2ZWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmV2WkxldmVsOyB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLnNldFByZXZaTGV2ZWwgPSBmdW5jdGlvbiAoekxldmVsKSB7IHRoaXMuX3ByZXZaTGV2ZWwgPSB6TGV2ZWw7IH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuc2hvdWxkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc29ydCA9IHRoaXMuX3ByZXZPdmVybGF5LnpMZXZlbCAhPT0gdGhpcy56TGV2ZWw7XG4gICAgICAgIHZhciBkcmF3ID0gc29ydCB8fFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fcHJldk92ZXJsYXkpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnBvaW50cykgfHxcbiAgICAgICAgICAgIHRoaXMuX3ByZXZPdmVybGF5LnZpc2libGUgIT09IHRoaXMudmlzaWJsZSB8fFxuICAgICAgICAgICAgdGhpcy5fcHJldk92ZXJsYXkuZXh0ZW5kRGF0YSAhPT0gdGhpcy5leHRlbmREYXRhIHx8XG4gICAgICAgICAgICB0aGlzLl9wcmV2T3ZlcmxheS5zdHlsZXMgIT09IHRoaXMuc3R5bGVzO1xuICAgICAgICByZXR1cm4geyBzb3J0OiBzb3J0LCBkcmF3OiBkcmF3IH07XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5uZXh0U3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0ZXAgPT09IHRoaXMudG90YWxTdGVwIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IE9WRVJMQVlfRFJBV19TVEVQX0ZJTklTSEVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RlcCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5mb3JjZUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gT1ZFUkxBWV9EUkFXX1NURVBfRklOSVNIRUQ7XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5pc0RyYXdpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwICE9PSBPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRDtcbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLmlzU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwID09PSBPVkVSTEFZX0RSQVdfU1RFUF9TVEFSVDtcbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLmV2ZW50TW92ZUZvckRyYXdpbmcgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcG9pbnRJbmRleCA9IHRoaXMuY3VycmVudFN0ZXAgLSAxO1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSB7fTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIG5ld1BvaW50LnRpbWVzdGFtcCA9IHBvaW50LnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQuZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgbmV3UG9pbnQuZGF0YUluZGV4ID0gcG9pbnQuZGF0YUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihwb2ludC52YWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1BvaW50LnZhbHVlID0gcG9pbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHNbcG9pbnRJbmRleF0gPSBuZXdQb2ludDtcbiAgICAgICAgKF9hID0gdGhpcy5wZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY3VycmVudFN0ZXA6IHRoaXMuY3VycmVudFN0ZXAsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgcGVyZm9ybVBvaW50SW5kZXg6IHBvaW50SW5kZXgsXG4gICAgICAgICAgICBwZXJmb3JtUG9pbnQ6IG5ld1BvaW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuZXZlbnRQcmVzc2VkUG9pbnRNb3ZlID0gZnVuY3Rpb24gKHBvaW50LCBwb2ludEluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5wb2ludHNbcG9pbnRJbmRleF0udGltZXN0YW1wID0gcG9pbnQudGltZXN0YW1wO1xuICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50c1twb2ludEluZGV4XS52YWx1ZSA9IHBvaW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucGVyZm9ybUV2ZW50UHJlc3NlZE1vdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGVwOiB0aGlzLmN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIHBlcmZvcm1Qb2ludEluZGV4OiBwb2ludEluZGV4LFxuICAgICAgICAgICAgcGVyZm9ybVBvaW50OiB0aGlzLnBvaW50c1twb2ludEluZGV4XVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLnN0YXJ0UHJlc3NlZE1vdmUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdGhpcy5fcHJldlByZXNzZWRQb2ludCA9IF9fYXNzaWduKHt9LCBwb2ludCk7XG4gICAgICAgIHRoaXMuX3ByZXZQcmVzc2VkUG9pbnRzID0gY2xvbmUodGhpcy5wb2ludHMpO1xuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuZXZlbnRQcmVzc2VkT3RoZXJNb3ZlID0gZnVuY3Rpb24gKHBvaW50LCBjaGFydFN0b3JlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2UHJlc3NlZFBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGlmRGF0YUluZGV4XzEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LmRhdGFJbmRleCkgJiYgaXNOdW1iZXIodGhpcy5fcHJldlByZXNzZWRQb2ludC5kYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgZGlmRGF0YUluZGV4XzEgPSBwb2ludC5kYXRhSW5kZXggLSB0aGlzLl9wcmV2UHJlc3NlZFBvaW50LmRhdGFJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaWZWYWx1ZV8xID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihwb2ludC52YWx1ZSkgJiYgaXNOdW1iZXIodGhpcy5fcHJldlByZXNzZWRQb2ludC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaWZWYWx1ZV8xID0gcG9pbnQudmFsdWUgLSB0aGlzLl9wcmV2UHJlc3NlZFBvaW50LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLl9wcmV2UHJlc3NlZFBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHAudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICBwLmRhdGFJbmRleCA9IGNoYXJ0U3RvcmUudGltZXN0YW1wVG9EYXRhSW5kZXgocC50aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9pbnQgPSBfX2Fzc2lnbih7fSwgcCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGRpZkRhdGFJbmRleF8xKSAmJiBpc051bWJlcihwLmRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9pbnQuZGF0YUluZGV4ID0gcC5kYXRhSW5kZXggKyBkaWZEYXRhSW5kZXhfMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9pbnQudGltZXN0YW1wID0gKF9hID0gY2hhcnRTdG9yZS5kYXRhSW5kZXhUb1RpbWVzdGFtcChuZXdQb2ludC5kYXRhSW5kZXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihkaWZWYWx1ZV8xKSAmJiBpc051bWJlcihwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQb2ludC52YWx1ZSA9IHAudmFsdWUgKyBkaWZWYWx1ZV8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZlcmxheUltcC5leHRlbmQgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIEN1c3RvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDdXN0b20sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b20oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICAgICAgfShPdmVybGF5SW1wKSk7XG4gICAgICAgIHJldHVybiBDdXN0b207XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheUltcDtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEZvcm1hdERhdGVUeXBlO1xuKGZ1bmN0aW9uIChGb3JtYXREYXRlVHlwZSkge1xuICAgIEZvcm1hdERhdGVUeXBlW0Zvcm1hdERhdGVUeXBlW1wiVG9vbHRpcFwiXSA9IDBdID0gXCJUb29sdGlwXCI7XG4gICAgRm9ybWF0RGF0ZVR5cGVbRm9ybWF0RGF0ZVR5cGVbXCJDcm9zc2hhaXJcIl0gPSAxXSA9IFwiQ3Jvc3NoYWlyXCI7XG4gICAgRm9ybWF0RGF0ZVR5cGVbRm9ybWF0RGF0ZVR5cGVbXCJYQXhpc1wiXSA9IDJdID0gXCJYQXhpc1wiO1xufSkoRm9ybWF0RGF0ZVR5cGUgfHwgKEZvcm1hdERhdGVUeXBlID0ge30pKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0Qm91bmRpbmcoYm91bmRpbmcpIHtcbiAgICB2YXIgZGVmYXVsdEJvdW5kaW5nID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIGlmIChpc1ZhbGlkKGJvdW5kaW5nKSkge1xuICAgICAgICBtZXJnZShkZWZhdWx0Qm91bmRpbmcsIGJvdW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRCb3VuZGluZztcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVGQVVMVF9SRVFVRVNUX0lEID0gLTE7XG5mdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgICBpZiAoaXNGdW5jdGlvbih3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSkge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMjApO1xufVxuZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24od2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbik7XG4gICAgfVxuICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbih7XG4gICAgICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgMSk7XG59XG5mdW5jdGlvbiBjYW5jZWxJZGxlQ2FsbGJhY2soaWQpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKSkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQW5pbWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7IGR1cmF0aW9uOiA1MDAsIGl0ZXJhdGlvbkNvdW50OiAxIH07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJdGVyYXRpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgIG1lcmdlKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLl9sb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIF90aGlzLl90aW1lO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmVGltZSA8IF90aGlzLl9vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9kb0ZyYW1lQ2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKF90aGlzLCBkaWZmVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2N1cnJlbnRJdGVyYXRpb25Db3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2N1cnJlbnRJdGVyYXRpb25Db3VudCA8IF90aGlzLl9vcHRpb25zLml0ZXJhdGlvbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmRvRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZG9GcmFtZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB0aGlzLl9vcHRpb25zLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRJdGVyYXRpb25Db3VudCA9IGZ1bmN0aW9uIChpdGVyYXRpb25Db3VudCkge1xuICAgICAgICB0aGlzLl9vcHRpb25zLml0ZXJhdGlvbkNvdW50ID0gaXRlcmF0aW9uQ291bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9sb29wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fZG9GcmFtZUNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgYmFzZUlkID0gMTtcbnZhciBwcmV2SWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbmZ1bmN0aW9uIGNyZWF0ZUlkKHByZWZpeCkge1xuICAgIHZhciB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAodGltZXN0YW1wID09PSBwcmV2SWRUaW1lc3RhbXApIHtcbiAgICAgICAgKytiYXNlSWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiYXNlSWQgPSAxO1xuICAgIH1cbiAgICBwcmV2SWRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCAhPT0gbnVsbCAmJiBwcmVmaXggIT09IHZvaWQgMCA/IHByZWZpeCA6ICcnKS5jb25jYXQodGltZXN0YW1wLCBcIl9cIikuY29uY2F0KGJhc2VJZCk7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDcmVhdGUgZG9tXG4gKiBAcGFyYW0gdGFnTmFtZVxuICogQHBhcmFtIHN0eWxlc1xuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9tKHRhZ05hbWUsIHN0eWxlcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB2YXIgcyA9IHN0eWxlcyAhPT0gbnVsbCAmJiBzdHlsZXMgIT09IHZvaWQgMCA/IHN0eWxlcyA6IHt9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4gLS0gaWdub3JlXG4gICAgZm9yICh2YXIga2V5IGluIHMpIHtcbiAgICAgICAgKGRvbS5zdHlsZSlba2V5XSA9IChfYSA9IHNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgfVxuICAgIHJldHVybiBkb207XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBCaW5hcnkgc2VhcmNoIGZvciB0aGUgbmVhcmVzdCByZXN1bHRcbiAqIEBwYXJhbSBkYXRhTGlzdFxuICogQHBhcmFtIHZhbHVlS2V5XG4gKiBAcGFyYW0gdGFyZ2V0VmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoTmVhcmVzdChkYXRhTGlzdCwgdmFsdWVLZXksIHRhcmdldFZhbHVlKSB7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciByaWdodCA9IDA7XG4gICAgZm9yIChyaWdodCA9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7IGxlZnQgIT09IHJpZ2h0Oykge1xuICAgICAgICB2YXIgbWlkSW5kZXggPSBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMik7XG4gICAgICAgIHZhciBtaWQgPSByaWdodCAtIGxlZnQ7XG4gICAgICAgIHZhciBtaWRWYWx1ZSA9IGRhdGFMaXN0W21pZEluZGV4XVt2YWx1ZUtleV07XG4gICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gZGF0YUxpc3RbbGVmdF1bdmFsdWVLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IGRhdGFMaXN0W3JpZ2h0XVt2YWx1ZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IG1pZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldFZhbHVlID4gbWlkVmFsdWUpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtaWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pZCA8PSAyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbn1cbi8qKlxuICog5LyY5YyW5pWw5a2XXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcnxudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5pY2UodmFsdWUpIHtcbiAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKGxvZzEwKHZhbHVlKSk7XG4gICAgdmFyIGV4cDEwID0gaW5kZXgxMChleHBvbmVudCk7XG4gICAgdmFyIGYgPSB2YWx1ZSAvIGV4cDEwOyAvLyAxIDw9IGYgPCAxMFxuICAgIHZhciBuZiA9IDA7XG4gICAgaWYgKGYgPCAxLjUpIHtcbiAgICAgICAgbmYgPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChmIDwgMi41KSB7XG4gICAgICAgIG5mID0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZiA8IDMuNSkge1xuICAgICAgICBuZiA9IDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYgPCA0LjUpIHtcbiAgICAgICAgbmYgPSA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChmIDwgNS41KSB7XG4gICAgICAgIG5mID0gNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZiA8IDYuNSkge1xuICAgICAgICBuZiA9IDY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZiA9IDg7XG4gICAgfVxuICAgIHZhbHVlID0gbmYgKiBleHAxMDtcbiAgICByZXR1cm4gK3ZhbHVlLnRvRml4ZWQoTWF0aC5hYnMoZXhwb25lbnQpKTtcbn1cbi8qKlxuICogUm91bmRcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHByZWNpc2lvblxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgcHJlY2lzaW9uICE9PSBudWxsICYmIHByZWNpc2lvbiAhPT0gdm9pZCAwID8gcHJlY2lzaW9uIDogMCk7XG4gICAgdmFyIHBvdyA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogcG93KSAvIHBvdztcbn1cbi8qKlxuICogR2V0IHByZWNpc2lvblxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRQcmVjaXNpb24odmFsdWUpIHtcbiAgICB2YXIgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB2YXIgZUluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICBpZiAoZUluZGV4ID4gMCkge1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gK3N0ci5zbGljZShlSW5kZXggKyAxKTtcbiAgICAgICAgcmV0dXJuIHByZWNpc2lvbiA8IDAgPyAtcHJlY2lzaW9uIDogMDtcbiAgICB9XG4gICAgdmFyIGRvdEluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICByZXR1cm4gZG90SW5kZXggPCAwID8gMCA6IHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG59XG5mdW5jdGlvbiBnZXRNYXhNaW4oZGF0YUxpc3QsIG1heEtleSwgbWluS2V5KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgbWF4TWluID0gW051bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl07XG4gICAgdmFyIGRhdGFMZW5ndGggPSBkYXRhTGlzdC5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBkYXRhTGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gZGF0YUxpc3RbaW5kZXhdO1xuICAgICAgICBtYXhNaW5bMF0gPSBNYXRoLm1heCgoKF9hID0gZGF0YVttYXhLZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiksIG1heE1pblswXSk7XG4gICAgICAgIG1heE1pblsxXSA9IE1hdGgubWluKCgoX2IgPSBkYXRhW21pbktleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgbWF4TWluWzFdKTtcbiAgICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIG1heE1pbjtcbn1cbi8qKlxuICogbG9nMTBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBsb2cxMCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nMTAodmFsdWUpO1xufVxuLyoqXG4gKiBpbmRleCAxMFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGluZGV4MTAodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgTG9hZERhdGFUeXBlO1xuKGZ1bmN0aW9uIChMb2FkRGF0YVR5cGUpIHtcbiAgICBMb2FkRGF0YVR5cGVbXCJJbml0XCJdID0gXCJpbml0XCI7XG4gICAgTG9hZERhdGFUeXBlW1wiRm9yd2FyZFwiXSA9IFwiZm9yd2FyZFwiO1xuICAgIExvYWREYXRhVHlwZVtcIkJhY2t3YXJkXCJdID0gXCJiYWNrd2FyZFwiO1xuICAgIExvYWREYXRhVHlwZVtcIlVwZGF0ZVwiXSA9IFwidXBkYXRlXCI7XG59KShMb2FkRGF0YVR5cGUgfHwgKExvYWREYXRhVHlwZSA9IHt9KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFZpc2libGVSYW5nZSgpIHtcbiAgICByZXR1cm4geyBmcm9tOiAwLCB0bzogMCwgcmVhbEZyb206IDAsIHJlYWxUbzogMCB9O1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGFza0lkKCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXJhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCdfJyk7XG59XG52YXIgVGFza1NjaGVkdWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXNrU2NoZWR1bGVyKHRhc2tzKSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZGxlQ2FsbGJhY2tJZCA9IERFRkFVTFRfUkVRVUVTVF9JRDtcbiAgICAgICAgdGhpcy5fdGFza3MgPSB0YXNrcyAhPT0gbnVsbCAmJiB0YXNrcyAhPT0gdm9pZCAwID8gdGFza3MgOiBbXTtcbiAgICAgICAgdGhpcy5fb3BlcmF0ZVRhc2tzKCk7XG4gICAgfVxuICAgIFRhc2tTY2hlZHVsZXIucHJvdG90eXBlLl9vcGVyYXRlVGFza3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RJZGxlQ2FsbGJhY2tJZCAhPT0gREVGQVVMVF9SRVFVRVNUX0lEKSB7XG4gICAgICAgICAgICBjYW5jZWxJZGxlQ2FsbGJhY2sodGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZGxlQ2FsbGJhY2tJZCA9IERFRkFVTFRfUkVRVUVTVF9JRDtcbiAgICAgICAgfVxuICAgICAgICBmbiA9PT0gbnVsbCB8fCBmbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm4oKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkID0gcmVxdWVzdElkbGVDYWxsYmFjayhmdW5jdGlvbiAoZGVhZGxpbmUpIHsgX3RoaXMuX3J1blRhc2tzKGRlYWRsaW5lKTsgfSk7XG4gICAgfTtcbiAgICBUYXNrU2NoZWR1bGVyLnByb3RvdHlwZS5fcnVuVGFza3MgPSBmdW5jdGlvbiAoZGVhZGxpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IDAgJiYgdGhpcy5fdGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0aGlzLl90YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGFzayA9PT0gbnVsbCB8fCB0YXNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXNrLmhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGFza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkID0gcmVxdWVzdElkbGVDYWxsYmFjayhmdW5jdGlvbiAoZGVhZGxpbmUpIHsgX3RoaXMuX3J1blRhc2tzKGRlYWRsaW5lKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhc2tTY2hlZHVsZXIucHJvdG90eXBlLmFkZFRhc2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vcGVyYXRlVGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3Rhc2tzLmZpbmRJbmRleChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pZCA9PT0gdGFzay5pZDsgfSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXNrc1tpbmRleF0gPSB0YXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFRhc2tTY2hlZHVsZXIucHJvdG90eXBlLnJlbW92ZVRhc2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3BlcmF0ZVRhc2tzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl90YXNrcy5maW5kSW5kZXgoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuaWQgPT09IGlkOyB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rhc2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBUYXNrU2NoZWR1bGVyO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgVGltZVdlaWdodENvbnN0YW50cyA9IHtcbiAgICBZZWFyOiAzNjUgKiAyNCAqIDM2MDAsXG4gICAgTW9udGg6IDMwICogMjQgKiAzNjAwLFxuICAgIERheTogMjQgKiAzNjAwLFxuICAgIEhvdXI6IDM2MDAsXG4gICAgTWludXRlOiA2MCxcbiAgICBTZWNvbmQ6IDFcbn07XG5mdW5jdGlvbiBjbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyhtYXAsIGRhdGFMaXN0LCBkYXRlVGltZUZvcm1hdCwgYmFzZURhdGFJbmRleCwgbWluVGltZVNwYW4sIHN0YXJ0VGltZXN0YW1wKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChiYXNlRGF0YUluZGV4ID09PSB2b2lkIDApIHsgYmFzZURhdGFJbmRleCA9IDA7IH1cbiAgICB2YXIgcHJldkRhdGVUaW1lID0gbnVsbDtcbiAgICB2YXIgcHJldlRpbWVzdGFtcCA9IHN0YXJ0VGltZXN0YW1wICE9PSBudWxsICYmIHN0YXJ0VGltZXN0YW1wICE9PSB2b2lkIDAgPyBzdGFydFRpbWVzdGFtcCA6IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gZGF0YUxpc3RbaV0udGltZXN0YW1wO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gVGltZVdlaWdodENvbnN0YW50cy5NaW51dGU7XG4gICAgICAgIHZhciBkYXRlVGltZSA9IGZvcm1hdFRpbWVzdGFtcFRvRGF0ZVRpbWUoZGF0ZVRpbWVGb3JtYXQsIHRpbWVzdGFtcCk7XG4gICAgICAgIGlmIChpc1ZhbGlkKHByZXZEYXRlVGltZSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRlVGltZS5ZWVlZICE9PSBwcmV2RGF0ZVRpbWUuWVlZWSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuWWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVUaW1lLk1NICE9PSBwcmV2RGF0ZVRpbWUuTU0pIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSBUaW1lV2VpZ2h0Q29uc3RhbnRzLk1vbnRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZVRpbWUuREQgIT09IHByZXZEYXRlVGltZS5ERCkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuRGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZVRpbWUuSEggIT09IHByZXZEYXRlVGltZS5ISCkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuSG91cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVUaW1lLm1tICE9PSBwcmV2RGF0ZVRpbWUubW0pIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSBUaW1lV2VpZ2h0Q29uc3RhbnRzLk1pbnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuU2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihwcmV2VGltZXN0YW1wKSAmJiBpc051bWJlcihtaW5UaW1lU3BhbiA9PT0gbnVsbCB8fCBtaW5UaW1lU3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluVGltZVNwYW4uY29tcGFyZSkpIHtcbiAgICAgICAgICAgIG1pblRpbWVTcGFuLmNvbXBhcmUgPSBNYXRoLm1pbihtaW5UaW1lU3Bhbi5jb21wYXJlLCB0aW1lc3RhbXAgLSBwcmV2VGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFRpbWVXZWlnaHRMaXN0ID0gKF9hID0gbWFwLmdldCh3ZWlnaHQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgY3VycmVudFRpbWVXZWlnaHRMaXN0LnB1c2goeyBkYXRhSW5kZXg6IGkgKyBiYXNlRGF0YUluZGV4LCB3ZWlnaHQ6IHdlaWdodCwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSk7XG4gICAgICAgIG1hcC5zZXQod2VpZ2h0LCBjdXJyZW50VGltZVdlaWdodExpc3QpO1xuICAgICAgICBwcmV2RGF0ZVRpbWUgPSBkYXRlVGltZTtcbiAgICAgICAgcHJldlRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjQmV0d2VlblRpbWVXZWlnaHRUaWNrQmFyQ291bnQoYmFyU3BhY2UsIHRleHRTdHlsZXMpIHtcbiAgICB2YXIgc3BhY2UgPSBNYXRoLm1heChjYWxjVGV4dFdpZHRoKCcwMDAwLTAwLTAwIDAwOjAwOjAwJywgdGV4dFN0eWxlcy5zaXplLCB0ZXh0U3R5bGVzLndlaWdodCwgdGV4dFN0eWxlcy5mYW1pbHkpLCAxNDYpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoc3BhY2UgLyBiYXJTcGFjZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaW1lV2VpZ2h0VGlja0xpc3QobWFwLCBiYXJTcGFjZSwgdGV4dFN0eWxlcykge1xuICAgIHZhciBiYXJDb3VudCA9IGNhbGNCZXR3ZWVuVGltZVdlaWdodFRpY2tCYXJDb3VudChiYXJTcGFjZSwgdGV4dFN0eWxlcyk7XG4gICAgdmFyIG9wdFRpbWVXZWlnaHRUaWNrTGlzdCA9IFtdO1xuICAgIEFycmF5LmZyb20obWFwLmtleXMoKSkuc29ydChmdW5jdGlvbiAodzEsIHcyKSB7IHJldHVybiB3MiAtIHcxOyB9KS5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3QgPSBtYXAuZ2V0KHdlaWdodCk7XG4gICAgICAgIHZhciBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0ID0gb3B0VGltZVdlaWdodFRpY2tMaXN0O1xuICAgICAgICBvcHRUaW1lV2VpZ2h0VGlja0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RMZW5ndGggPSBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3RMZW5ndGggPSBjdXJyZW50VGltZVdlaWdodFRpY2tMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50VGltZVdlaWdodFRpY2tMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aW1lV2VpZ2h0VGljayA9IGN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3RbaV07XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGltZVdlaWdodFRpY2suZGF0YUluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyIDwgcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0VGltZVdlaWdodFRpY2sgPSBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0W3ByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGFzdFRpbWVXZWlnaHRUaWNrLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4IDwgY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgIG9wdFRpbWVXZWlnaHRUaWNrTGlzdC5wdXNoKGxhc3RUaW1lV2VpZ2h0VGljayk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0SW5kZXggLSBjdXJyZW50SW5kZXggPj0gYmFyQ291bnQgJiYgY3VycmVudEluZGV4IC0gbGVmdEluZGV4ID49IGJhckNvdW50KSB7XG4gICAgICAgICAgICAgICAgb3B0VGltZVdlaWdodFRpY2tMaXN0LnB1c2godGltZVdlaWdodFRpY2spO1xuICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXIgPCBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0TGVuZ3RoOyBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0UG9pbnRlcisrKSB7XG4gICAgICAgICAgICBvcHRUaW1lV2VpZ2h0VGlja0xpc3QucHVzaChwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0W3ByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3B0VGltZVdlaWdodFRpY2tMaXN0O1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogYXZlcmFnZSBwcmljZVxuICovXG52YXIgYXZlcmFnZVByaWNlID0ge1xuICAgIG5hbWU6ICdBVlAnLFxuICAgIHNob3J0TmFtZTogJ0FWUCcsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXG4gICAgcHJlY2lzaW9uOiAyLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdhdnAnLCB0aXRsZTogJ0FWUDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCkge1xuICAgICAgICB2YXIgdG90YWxUdXJub3ZlciA9IDA7XG4gICAgICAgIHZhciB0b3RhbFZvbHVtZSA9IDA7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBhdnAgPSB7fTtcbiAgICAgICAgICAgIHZhciB0dXJub3ZlciA9IChfYSA9IGtMaW5lRGF0YS50dXJub3ZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIHZhciB2b2x1bWUgPSAoX2IgPSBrTGluZURhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICAgICAgdG90YWxUdXJub3ZlciArPSB0dXJub3ZlcjtcbiAgICAgICAgICAgIHRvdGFsVm9sdW1lICs9IHZvbHVtZTtcbiAgICAgICAgICAgIGlmICh0b3RhbFZvbHVtZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGF2cC5hdnAgPSB0b3RhbFR1cm5vdmVyIC8gdG90YWxWb2x1bWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXZwO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBhd2Vzb21lT3NjaWxsYXRvciA9IHtcbiAgICBuYW1lOiAnQU8nLFxuICAgIHNob3J0TmFtZTogJ0FPJyxcbiAgICBjYWxjUGFyYW1zOiBbNSwgMzRdLFxuICAgIGZpZ3VyZXM6IFt7XG4gICAgICAgICAgICBrZXk6ICdhbycsXG4gICAgICAgICAgICB0aXRsZTogJ0FPOiAnLFxuICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgICBiYXNlVmFsdWU6IDAsXG4gICAgICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBpbmRpY2F0b3IgPSBfYS5pbmRpY2F0b3IsIGRlZmF1bHRTdHlsZXMgPSBfYS5kZWZhdWx0U3R5bGVzO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gZGF0YS5wcmV2LCBjdXJyZW50ID0gZGF0YS5jdXJyZW50O1xuICAgICAgICAgICAgICAgIHZhciBwcmV2QW8gPSAoX2IgPSBwcmV2ID09PSBudWxsIHx8IHByZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXYuYW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QW8gPSAoX2MgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuYW8pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QW8gPiBwcmV2QW8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS51cENvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0udXBDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdiYXJzWzBdLmRvd25Db2xvcicsIChkZWZhdWx0U3R5bGVzLmJhcnMpWzBdLmRvd25Db2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGN1cnJlbnRBbyA+IHByZXZBbyA/IFBvbHlnb25UeXBlLlN0cm9rZSA6IFBvbHlnb25UeXBlLkZpbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29sb3I6IGNvbG9yLCBzdHlsZTogc3R5bGUsIGJvcmRlckNvbG9yOiBjb2xvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBtYXhQZXJpb2QgPSBNYXRoLm1heChwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBzaG9ydFN1bSA9IDA7XG4gICAgICAgIHZhciBsb25nU3VtID0gMDtcbiAgICAgICAgdmFyIHNob3J0ID0gMDtcbiAgICAgICAgdmFyIGxvbmcgPSAwO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBhbyA9IHt9O1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IChrTGluZURhdGEubG93ICsga0xpbmVEYXRhLmhpZ2gpIC8gMjtcbiAgICAgICAgICAgIHNob3J0U3VtICs9IG1pZGRsZTtcbiAgICAgICAgICAgIGxvbmdTdW0gKz0gbWlkZGxlO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIHNob3J0ID0gc2hvcnRTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGFnb0tMaW5lRGF0YSA9IGRhdGFMaXN0W2kgLSAocGFyYW1zWzBdIC0gMSldO1xuICAgICAgICAgICAgICAgIHNob3J0U3VtIC09ICgoYWdvS0xpbmVEYXRhLmxvdyArIGFnb0tMaW5lRGF0YS5oaWdoKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzFdIC0gMSkge1xuICAgICAgICAgICAgICAgIGxvbmcgPSBsb25nU3VtIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIHZhciBhZ29LTGluZURhdGEgPSBkYXRhTGlzdFtpIC0gKHBhcmFtc1sxXSAtIDEpXTtcbiAgICAgICAgICAgICAgICBsb25nU3VtIC09ICgoYWdvS0xpbmVEYXRhLmxvdyArIGFnb0tMaW5lRGF0YS5oaWdoKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gbWF4UGVyaW9kIC0gMSkge1xuICAgICAgICAgICAgICAgIGFvLmFvID0gc2hvcnQgLSBsb25nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFvO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQklBU1xuICog5LmW56a7546HPVso5b2T5pel5pS255uY5Lu3LU7ml6XlubPlnYfku7cpL07ml6XlubPlnYfku7ddKjEwMCVcbiAqL1xudmFyIGJpYXMgPSB7XG4gICAgbmFtZTogJ0JJQVMnLFxuICAgIHNob3J0TmFtZTogJ0JJQVMnLFxuICAgIGNhbGNQYXJhbXM6IFs2LCAxMiwgMjRdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdiaWFzMScsIHRpdGxlOiAnQklBUzY6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2JpYXMyJywgdGl0bGU6ICdCSUFTMTI6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2JpYXMzJywgdGl0bGU6ICdCSUFTMjQ6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICByZWdlbmVyYXRlRmlndXJlczogZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gKHsga2V5OiBcImJpYXNcIi5jb25jYXQoaSArIDEpLCB0aXRsZTogXCJCSUFTXCIuY29uY2F0KHAsIFwiOiBcIiksIHR5cGU6ICdsaW5lJyB9KTsgfSk7IH0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zLCBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXM7XG4gICAgICAgIHZhciBjbG9zZVN1bXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgYmlhcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNsb3NlU3Vtc1tpbmRleF0gPSAoKF9hID0gY2xvc2VTdW1zW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyBjbG9zZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVhbiA9IGNsb3NlU3Vtc1tpbmRleF0gLyBwYXJhbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBiaWFzW2ZpZ3VyZXNbaW5kZXhdLmtleV0gPSAoY2xvc2UgLSBtZWFuKSAvIG1lYW4gKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlU3Vtc1tpbmRleF0gLT0gZGF0YUxpc3RbaSAtIChwIC0gMSldLmNsb3NlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJpYXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiDorqHnrpfluIPmnpfmjIfmoIfkuK3nmoTmoIflh4blt65cbiAqIEBwYXJhbSBkYXRhTGlzdFxuICogQHBhcmFtIG1hXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJvbGxNZChkYXRhTGlzdCwgbWEpIHtcbiAgICB2YXIgZGF0YVNpemUgPSBkYXRhTGlzdC5sZW5ndGg7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgY2xvc2VNYSA9IGRhdGEuY2xvc2UgLSBtYTtcbiAgICAgICAgc3VtICs9IGNsb3NlTWEgKiBjbG9zZU1hO1xuICAgIH0pO1xuICAgIHN1bSA9IE1hdGguYWJzKHN1bSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChzdW0gLyBkYXRhU2l6ZSk7XG59XG4vKipcbiAqIEJPTExcbiAqL1xudmFyIGJvbGxpbmdlckJhbmRzID0ge1xuICAgIG5hbWU6ICdCT0xMJyxcbiAgICBzaG9ydE5hbWU6ICdCT0xMJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5QcmljZSxcbiAgICBjYWxjUGFyYW1zOiBbMjAsIDJdLFxuICAgIHByZWNpc2lvbjogMixcbiAgICBzaG91bGRPaGxjOiB0cnVlLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICd1cCcsIHRpdGxlOiAnVVA6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21pZCcsIHRpdGxlOiAnTUlEOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdkbicsIHRpdGxlOiAnRE46ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBwID0gcGFyYW1zWzBdIC0gMTtcbiAgICAgICAgdmFyIGNsb3NlU3VtID0gMDtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICB2YXIgYm9sbCA9IHt9O1xuICAgICAgICAgICAgY2xvc2VTdW0gKz0gY2xvc2U7XG4gICAgICAgICAgICBpZiAoaSA+PSBwKSB7XG4gICAgICAgICAgICAgICAgYm9sbC5taWQgPSBjbG9zZVN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgbWQgPSBnZXRCb2xsTWQoZGF0YUxpc3Quc2xpY2UoaSAtIHAsIGkgKyAxKSwgYm9sbC5taWQpO1xuICAgICAgICAgICAgICAgIGJvbGwudXAgPSBib2xsLm1pZCArIHBhcmFtc1sxXSAqIG1kO1xuICAgICAgICAgICAgICAgIGJvbGwuZG4gPSBib2xsLm1pZCAtIHBhcmFtc1sxXSAqIG1kO1xuICAgICAgICAgICAgICAgIGNsb3NlU3VtIC09IGRhdGFMaXN0W2kgLSBwXS5jbG9zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib2xsO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQlJBUlxuICog6buY6K6k5Y+C5pWw5pivMjbjgIJcbiAqIOWFrOW8j07ml6VCUj1O5pel5YaF77yISO+8jUNZ77yJ5LmL5ZKM6Zmk5LulTuaXpeWGhe+8iENZ77yNTO+8ieS5i+WSjCoxMDDvvIxcbiAqIOWFtuS4re+8jEjkuLrlvZPml6XmnIDpq5jku7fvvIxM5Li65b2T5pel5pyA5L2O5Lu377yMQ1nkuLrliY3kuIDkuqTmmJPml6XnmoTmlLbnm5jku7fvvIxO5Li66K6+5a6a55qE5pe26Ze05Y+C5pWw44CCXG4gKiBO5pelQVI9KE7ml6XlhoXvvIhI77yNT++8ieS5i+WSjOmZpOS7pU7ml6XlhoXvvIhP77yNTO+8ieS5i+WSjCkqMTAw77yMXG4gKiDlhbbkuK3vvIxI5Li65b2T5pel5pyA6auY5Lu377yMTOS4uuW9k+aXpeacgOS9juS7t++8jE/kuLrlvZPml6XlvIDnm5jku7fvvIxO5Li66K6+5a6a55qE5pe26Ze05Y+C5pWwXG4gKlxuICovXG52YXIgYnJhciA9IHtcbiAgICBuYW1lOiAnQlJBUicsXG4gICAgc2hvcnROYW1lOiAnQlJBUicsXG4gICAgY2FsY1BhcmFtczogWzI2XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnYnInLCB0aXRsZTogJ0JSOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdhcicsIHRpdGxlOiAnQVI6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBoY3kgPSAwO1xuICAgICAgICB2YXIgY3lsID0gMDtcbiAgICAgICAgdmFyIGhvID0gMDtcbiAgICAgICAgdmFyIG9sID0gMDtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGJyYXIgPSB7fTtcbiAgICAgICAgICAgIHZhciBoaWdoID0ga0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICB2YXIgbG93ID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgIHZhciBvcGVuID0ga0xpbmVEYXRhLm9wZW47XG4gICAgICAgICAgICB2YXIgcHJldkNsb3NlID0gKChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhKS5jbG9zZTtcbiAgICAgICAgICAgIGhvICs9IChoaWdoIC0gb3Blbik7XG4gICAgICAgICAgICBvbCArPSAob3BlbiAtIGxvdyk7XG4gICAgICAgICAgICBoY3kgKz0gKGhpZ2ggLSBwcmV2Q2xvc2UpO1xuICAgICAgICAgICAgY3lsICs9IChwcmV2Q2xvc2UgLSBsb3cpO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChvbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmFyLmFyID0gaG8gLyBvbCAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYXIuYXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3lsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYXIuYnIgPSBoY3kgLyBjeWwgKiAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmFyLmJyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFnb0tMaW5lRGF0YSA9IGRhdGFMaXN0W2kgLSAocGFyYW1zWzBdIC0gMSldO1xuICAgICAgICAgICAgICAgIHZhciBhZ29IaWdoID0gYWdvS0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICAgICAgdmFyIGFnb0xvdyA9IGFnb0tMaW5lRGF0YS5sb3c7XG4gICAgICAgICAgICAgICAgdmFyIGFnb09wZW4gPSBhZ29LTGluZURhdGEub3BlbjtcbiAgICAgICAgICAgICAgICB2YXIgYWdvUHJlQ2xvc2UgPSAoKF9iID0gZGF0YUxpc3RbaSAtIHBhcmFtc1swXV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGFMaXN0W2kgLSAocGFyYW1zWzBdIC0gMSldKS5jbG9zZTtcbiAgICAgICAgICAgICAgICBoY3kgLT0gKGFnb0hpZ2ggLSBhZ29QcmVDbG9zZSk7XG4gICAgICAgICAgICAgICAgY3lsIC09IChhZ29QcmVDbG9zZSAtIGFnb0xvdyk7XG4gICAgICAgICAgICAgICAgaG8gLT0gKGFnb0hpZ2ggLSBhZ29PcGVuKTtcbiAgICAgICAgICAgICAgICBvbCAtPSAoYWdvT3BlbiAtIGFnb0xvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnJhcjtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiDlpJrnqbrmjIfmoIdcbiAqIOWFrOW8jzogQkJJID0gKE1BKENMT1NFLCBNKSArIE1BKENMT1NFLCBOKSArIE1BKENMT1NFLCBPKSArIE1BKENMT1NFLCBQKSkgLyA0XG4gKlxuICovXG52YXIgYnVsbEFuZEJlYXJJbmRleCA9IHtcbiAgICBuYW1lOiAnQkJJJyxcbiAgICBzaG9ydE5hbWU6ICdCQkknLFxuICAgIHNlcmllczogSW5kaWNhdG9yU2VyaWVzLlByaWNlLFxuICAgIHByZWNpc2lvbjogMixcbiAgICBjYWxjUGFyYW1zOiBbMywgNiwgMTIsIDI0XSxcbiAgICBzaG91bGRPaGxjOiB0cnVlLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdiYmknLCB0aXRsZTogJ0JCSTogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIG1heFBlcmlvZCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwYXJhbXMpLCBmYWxzZSkpO1xuICAgICAgICB2YXIgY2xvc2VTdW1zID0gW107XG4gICAgICAgIHZhciBtYXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgYmJpID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY2xvc2VTdW1zW2luZGV4XSA9ICgoX2EgPSBjbG9zZVN1bXNbaW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIGNsb3NlO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc1tpbmRleF0gPSBjbG9zZVN1bXNbaW5kZXhdIC8gcDtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VTdW1zW2luZGV4XSAtPSBkYXRhTGlzdFtpIC0gKHAgLSAxKV0uY2xvc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBtYXhQZXJpb2QgLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hU3VtXzEgPSAwO1xuICAgICAgICAgICAgICAgIG1hcy5mb3JFYWNoKGZ1bmN0aW9uIChtYSkge1xuICAgICAgICAgICAgICAgICAgICBtYVN1bV8xICs9IG1hO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJiaS5iYmkgPSBtYVN1bV8xIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYmk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDQ0lcbiAqIENDSe+8iE7ml6XvvIk977yIVFDvvI1NQe+8icO3TUTDtzAuMDE1XG4gKiDlhbbkuK3vvIxUUD3vvIjmnIDpq5jku7cr5pyA5L2O5Lu3K+aUtuebmOS7t++8icO3M1xuICogTUE96L+RTuaXpVRQ5Lu355qE57Sv6K6h5LmL5ZKMw7dOXG4gKiBNRD3ov5FO5pelVFAgLSDlvZPliY1NQee7neWvueWAvOeahOe0r+iuoeS5i+WSjMO3TlxuICpcbiAqL1xudmFyIGNvbW1vZGl0eUNoYW5uZWxJbmRleCA9IHtcbiAgICBuYW1lOiAnQ0NJJyxcbiAgICBzaG9ydE5hbWU6ICdDQ0knLFxuICAgIGNhbGNQYXJhbXM6IFsyMF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2NjaScsIHRpdGxlOiAnQ0NJOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgcCA9IHBhcmFtc1swXSAtIDE7XG4gICAgICAgIHZhciB0cFN1bSA9IDA7XG4gICAgICAgIHZhciB0cExpc3QgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgY2NpID0ge307XG4gICAgICAgICAgICB2YXIgdHAgPSAoa0xpbmVEYXRhLmhpZ2ggKyBrTGluZURhdGEubG93ICsga0xpbmVEYXRhLmNsb3NlKSAvIDM7XG4gICAgICAgICAgICB0cFN1bSArPSB0cDtcbiAgICAgICAgICAgIHRwTGlzdC5wdXNoKHRwKTtcbiAgICAgICAgICAgIGlmIChpID49IHApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFUcF8xID0gdHBTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHNsaWNlVHBMaXN0ID0gdHBMaXN0LnNsaWNlKGkgLSBwLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHN1bV8xID0gMDtcbiAgICAgICAgICAgICAgICBzbGljZVRwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0cCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1fMSArPSBNYXRoLmFicyh0cCAtIG1hVHBfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG1kID0gc3VtXzEgLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgY2NpLmNjaSA9IG1kICE9PSAwID8gKHRwIC0gbWFUcF8xKSAvIG1kIC8gMC4wMTUgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBhZ29UcCA9IChkYXRhTGlzdFtpIC0gcF0uaGlnaCArIGRhdGFMaXN0W2kgLSBwXS5sb3cgKyBkYXRhTGlzdFtpIC0gcF0uY2xvc2UpIC8gMztcbiAgICAgICAgICAgICAgICB0cFN1bSAtPSBhZ29UcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjY2k7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOip3d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1JRDo9UkVGKEhJR0grTE9XLDEpLzI7XG4gKiBDUjpTVU0oTUFYKDAsSElHSC1NSUQpLE4pL1NVTShNQVgoMCxNSUQtTE9XKSxOKSoxMDA7XG4gKiBNQTE6UkVGKE1BKENSLE0xKSxNMS8yLjUrMSk7XG4gKiBNQTI6UkVGKE1BKENSLE0yKSxNMi8yLjUrMSk7XG4gKiBNQTM6UkVGKE1BKENSLE0zKSxNMy8yLjUrMSk7XG4gKiBNQTQ6UkVGKE1BKENSLE00KSxNNC8yLjUrMSk7XG4gKiBNSUTotYvlgLw6KOaYqOaXpeacgOmrmOS7tyvmmKjml6XmnIDkvY7ku7cpLzJcbiAqIOi+k+WHuuW4pueKtuiDvemHj+e6vzow5ZKM5pyA6auY5Lu3LU1JROeahOi+g+Wkp+WAvOeahE7ml6XntK/lkowvMOWSjE1JRC3mnIDkvY7ku7fnmoTovoPlpKflgLznmoRO5pel57Sv5ZKMKjEwMFxuICog6L6T5Ye6TUExOk0xKDUpLzIuNSsx5pel5YmN55qEQ1LnmoRNMSg1KeaXpeeugOWNleenu+WKqOW5s+Wdh1xuICog6L6T5Ye6TUEyOk0yKDEwKS8yLjUrMeaXpeWJjeeahENS55qETTIoMTAp5pel566A5Y2V56e75Yqo5bmz5Z2HXG4gKiDovpPlh7pNQTM6TTMoMjApLzIuNSsx5pel5YmN55qEQ1LnmoRNMygyMCnml6XnroDljZXnp7vliqjlubPlnYdcbiAqIOi+k+WHuk1BNDpNNC8yLjUrMeaXpeWJjeeahENS55qETTTml6XnroDljZXnp7vliqjlubPlnYdcbiAqXG4gKi9cbnZhciBjdXJyZW50UmF0aW8gPSB7XG4gICAgbmFtZTogJ0NSJyxcbiAgICBzaG9ydE5hbWU6ICdDUicsXG4gICAgY2FsY1BhcmFtczogWzI2LCAxMCwgMjAsIDQwLCA2MF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2NyJywgdGl0bGU6ICdDUjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWExJywgdGl0bGU6ICdNQTE6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMicsIHRpdGxlOiAnTUEyOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTMnLCB0aXRsZTogJ01BMzogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWE0JywgdGl0bGU6ICdNQTQ6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBtYTFGb3J3YXJkUGVyaW9kID0gTWF0aC5jZWlsKHBhcmFtc1sxXSAvIDIuNSArIDEpO1xuICAgICAgICB2YXIgbWEyRm9yd2FyZFBlcmlvZCA9IE1hdGguY2VpbChwYXJhbXNbMl0gLyAyLjUgKyAxKTtcbiAgICAgICAgdmFyIG1hM0ZvcndhcmRQZXJpb2QgPSBNYXRoLmNlaWwocGFyYW1zWzNdIC8gMi41ICsgMSk7XG4gICAgICAgIHZhciBtYTRGb3J3YXJkUGVyaW9kID0gTWF0aC5jZWlsKHBhcmFtc1s0XSAvIDIuNSArIDEpO1xuICAgICAgICB2YXIgbWExU3VtID0gMDtcbiAgICAgICAgdmFyIG1hMUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIG1hMlN1bSA9IDA7XG4gICAgICAgIHZhciBtYTJMaXN0ID0gW107XG4gICAgICAgIHZhciBtYTNTdW0gPSAwO1xuICAgICAgICB2YXIgbWEzTGlzdCA9IFtdO1xuICAgICAgICB2YXIgbWE0U3VtID0gMDtcbiAgICAgICAgdmFyIG1hNExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICB2YXIgY3IgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcmV2RGF0YSA9IChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhO1xuICAgICAgICAgICAgdmFyIHByZXZNaWQgPSAocHJldkRhdGEuaGlnaCArIHByZXZEYXRhLmNsb3NlICsgcHJldkRhdGEubG93ICsgcHJldkRhdGEub3BlbikgLyA0O1xuICAgICAgICAgICAgdmFyIGhpZ2hTdWJQcmVNaWQgPSBNYXRoLm1heCgwLCBrTGluZURhdGEuaGlnaCAtIHByZXZNaWQpO1xuICAgICAgICAgICAgdmFyIHByZU1pZFN1YkxvdyA9IE1hdGgubWF4KDAsIHByZXZNaWQgLSBrTGluZURhdGEubG93KTtcbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWlkU3ViTG93ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyLmNyID0gaGlnaFN1YlByZU1pZCAvIHByZU1pZFN1YkxvdyAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyLmNyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWExU3VtICs9IGNyLmNyO1xuICAgICAgICAgICAgICAgIG1hMlN1bSArPSBjci5jcjtcbiAgICAgICAgICAgICAgICBtYTNTdW0gKz0gY3IuY3I7XG4gICAgICAgICAgICAgICAgbWE0U3VtICs9IGNyLmNyO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1sxXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWExTGlzdC5wdXNoKG1hMVN1bSAvIHBhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1sxXSArIG1hMUZvcndhcmRQZXJpb2QgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjci5tYTEgPSBtYTFMaXN0W21hMUxpc3QubGVuZ3RoIC0gMSAtIG1hMUZvcndhcmRQZXJpb2RdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hMVN1bSAtPSAoKF9iID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLmNyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzJdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBtYTJMaXN0LnB1c2gobWEyU3VtIC8gcGFyYW1zWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzJdICsgbWEyRm9yd2FyZFBlcmlvZCAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyLm1hMiA9IG1hMkxpc3RbbWEyTGlzdC5sZW5ndGggLSAxIC0gbWEyRm9yd2FyZFBlcmlvZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWEyU3VtIC09ICgoX2MgPSByZXN1bHRbaSAtIChwYXJhbXNbMl0gLSAxKV0uY3IpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKyBwYXJhbXNbM10gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hM0xpc3QucHVzaChtYTNTdW0gLyBwYXJhbXNbM10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKyBwYXJhbXNbM10gKyBtYTNGb3J3YXJkUGVyaW9kIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3IubWEzID0gbWEzTGlzdFttYTNMaXN0Lmxlbmd0aCAtIDEgLSBtYTNGb3J3YXJkUGVyaW9kXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYTNTdW0gLT0gKChfZCA9IHJlc3VsdFtpIC0gKHBhcmFtc1szXSAtIDEpXS5jcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1s0XSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWE0TGlzdC5wdXNoKG1hNFN1bSAvIHBhcmFtc1s0XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1s0XSArIG1hNEZvcndhcmRQZXJpb2QgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjci5tYTQgPSBtYTRMaXN0W21hNExpc3QubGVuZ3RoIC0gMSAtIG1hNEZvcndhcmRQZXJpb2RdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hNFN1bSAtPSAoKF9lID0gcmVzdWx0W2kgLSAocGFyYW1zWzRdIC0gMSldLmNyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChjcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBETUFcbiAqIOWFrOW8j++8mkRJRjpNQShDTE9TRSxOMSktTUEoQ0xPU0UsTjIpO0RJRk1BOk1BKERJRixNKVxuICovXG52YXIgZGlmZmVyZW50T2ZNb3ZpbmdBdmVyYWdlID0ge1xuICAgIG5hbWU6ICdETUEnLFxuICAgIHNob3J0TmFtZTogJ0RNQScsXG4gICAgY2FsY1BhcmFtczogWzEwLCA1MCwgMTBdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdkbWEnLCB0aXRsZTogJ0RNQTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnYW1hJywgdGl0bGU6ICdBTUE6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBtYXhQZXJpb2QgPSBNYXRoLm1heChwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBjbG9zZVN1bTEgPSAwO1xuICAgICAgICB2YXIgY2xvc2VTdW0yID0gMDtcbiAgICAgICAgdmFyIGRtYVN1bSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgZG1hID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBjbG9zZVN1bTEgKz0gY2xvc2U7XG4gICAgICAgICAgICBjbG9zZVN1bTIgKz0gY2xvc2U7XG4gICAgICAgICAgICB2YXIgbWExID0gMDtcbiAgICAgICAgICAgIHZhciBtYTIgPSAwO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIG1hMSA9IGNsb3NlU3VtMSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICBjbG9zZVN1bTEgLT0gZGF0YUxpc3RbaSAtIChwYXJhbXNbMF0gLSAxKV0uY2xvc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMV0gLSAxKSB7XG4gICAgICAgICAgICAgICAgbWEyID0gY2xvc2VTdW0yIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIGNsb3NlU3VtMiAtPSBkYXRhTGlzdFtpIC0gKHBhcmFtc1sxXSAtIDEpXS5jbG9zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IG1heFBlcmlvZCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmID0gbWExIC0gbWEyO1xuICAgICAgICAgICAgICAgIGRtYS5kbWEgPSBkaWY7XG4gICAgICAgICAgICAgICAgZG1hU3VtICs9IGRpZjtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBtYXhQZXJpb2QgKyBwYXJhbXNbMl0gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRtYS5hbWEgPSBkbWFTdW0gLyBwYXJhbXNbMl07XG4gICAgICAgICAgICAgICAgICAgIGRtYVN1bSAtPSAoKF9hID0gcmVzdWx0W2kgLSAocGFyYW1zWzJdIC0gMSldLmRtYSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG1hKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERNSVxuICpcbiAqIE1UUjo9RVhQTUVNQShNQVgoTUFYKEhJR0gtTE9XLEFCUyhISUdILVJFRihDTE9TRSwxKSkpLEFCUyhSRUYoQ0xPU0UsMSktTE9XKSksTilcbiAqIEhEIDo9SElHSC1SRUYoSElHSCwxKTtcbiAqIExEIDo9UkVGKExPVywxKS1MT1c7XG4gKiBETVA6PUVYUE1FTUEoSUYoSEQ+MCYmSEQ+TEQsSEQsMCksTik7XG4gKiBETU06PUVYUE1FTUEoSUYoTEQ+MCYmTEQ+SEQsTEQsMCksTik7XG4gKlxuICogUERJOiBETVAqMTAwL01UUjtcbiAqIE1ESTogRE1NKjEwMC9NVFI7XG4gKiBBRFg6IEVYUE1FTUEoQUJTKE1ESS1QREkpLyhNREkrUERJKSoxMDAsTU0pO1xuICogQURYUjpFWFBNRU1BKEFEWCxNTSk7XG4gKiDlhazlvI/lkKvkuYnvvJpcbiAqIE1UUui1i+WAvDrmnIDpq5jku7ct5pyA5L2O5Lu35ZKM5pyA6auY5Lu3LeaYqOaUtueahOe7neWvueWAvOeahOi+g+Wkp+WAvOWSjOaYqOaUti3mnIDkvY7ku7fnmoTnu53lr7nlgLznmoTovoPlpKflgLznmoRO5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2HXG4gKiBIROi1i+WAvDrmnIDpq5jku7ct5pio5pel5pyA6auY5Lu3XG4gKiBMROi1i+WAvDrmmKjml6XmnIDkvY7ku7ct5pyA5L2O5Lu3XG4gKiBETVDotYvlgLw65aaC5p6cSEQ+MOW5tuS4lEhEPkxELOi/lOWbnkhELOWQpuWImei/lOWbnjDnmoRO5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2HXG4gKiBETU3otYvlgLw65aaC5p6cTEQ+MOW5tuS4lExEPkhELOi/lOWbnkxELOWQpuWImei/lOWbnjDnmoRO5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2HXG4gKiDovpPlh7pQREk6RE1QKjEwMC9NVFJcbiAqIOi+k+WHuk1ESTpETU0qMTAwL01UUlxuICog6L6T5Ye6QURYOk1ESS1QREnnmoTnu53lr7nlgLwvKE1ESStQREkpKjEwMOeahE1N5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2HXG4gKiDovpPlh7pBRFhSOkFEWOeahE1N5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2HXG4gKlxuICovXG52YXIgZGlyZWN0aW9uYWxNb3ZlbWVudEluZGV4ID0ge1xuICAgIG5hbWU6ICdETUknLFxuICAgIHNob3J0TmFtZTogJ0RNSScsXG4gICAgY2FsY1BhcmFtczogWzE0LCA2XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAncGRpJywgdGl0bGU6ICdQREk6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21kaScsIHRpdGxlOiAnTURJOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdhZHgnLCB0aXRsZTogJ0FEWDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnYWR4cicsIHRpdGxlOiAnQURYUjogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIHRyU3VtID0gMDtcbiAgICAgICAgdmFyIGhTdW0gPSAwO1xuICAgICAgICB2YXIgbFN1bSA9IDA7XG4gICAgICAgIHZhciBtdHIgPSAwO1xuICAgICAgICB2YXIgZG1wID0gMDtcbiAgICAgICAgdmFyIGRtbSA9IDA7XG4gICAgICAgIHZhciBkeFN1bSA9IDA7XG4gICAgICAgIHZhciBhZHggPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBkbWkgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcmV2S0xpbmVEYXRhID0gKF9hID0gZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGE7XG4gICAgICAgICAgICB2YXIgcHJlQ2xvc2UgPSBwcmV2S0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgIHZhciBsb3cgPSBrTGluZURhdGEubG93O1xuICAgICAgICAgICAgdmFyIGhsID0gaGlnaCAtIGxvdztcbiAgICAgICAgICAgIHZhciBoY3kgPSBNYXRoLmFicyhoaWdoIC0gcHJlQ2xvc2UpO1xuICAgICAgICAgICAgdmFyIGxjeSA9IE1hdGguYWJzKHByZUNsb3NlIC0gbG93KTtcbiAgICAgICAgICAgIHZhciBoaHkgPSBoaWdoIC0gcHJldktMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgdmFyIGx5bCA9IHByZXZLTGluZURhdGEubG93IC0gbG93O1xuICAgICAgICAgICAgdmFyIHRyID0gTWF0aC5tYXgoTWF0aC5tYXgoaGwsIGhjeSksIGxjeSk7XG4gICAgICAgICAgICB2YXIgaCA9IChoaHkgPiAwICYmIGhoeSA+IGx5bCkgPyBoaHkgOiAwO1xuICAgICAgICAgICAgdmFyIGwgPSAobHlsID4gMCAmJiBseWwgPiBoaHkpID8gbHlsIDogMDtcbiAgICAgICAgICAgIHRyU3VtICs9IHRyO1xuICAgICAgICAgICAgaFN1bSArPSBoO1xuICAgICAgICAgICAgbFN1bSArPSBsO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtdHIgPSBtdHIgLSBtdHIgLyBwYXJhbXNbMF0gKyB0cjtcbiAgICAgICAgICAgICAgICAgICAgZG1wID0gZG1wIC0gZG1wIC8gcGFyYW1zWzBdICsgaDtcbiAgICAgICAgICAgICAgICAgICAgZG1tID0gZG1tIC0gZG1tIC8gcGFyYW1zWzBdICsgbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG10ciA9IHRyU3VtO1xuICAgICAgICAgICAgICAgICAgICBkbXAgPSBoU3VtO1xuICAgICAgICAgICAgICAgICAgICBkbW0gPSBsU3VtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGRpID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbWRpID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobXRyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBkaSA9IGRtcCAqIDEwMCAvIG10cjtcbiAgICAgICAgICAgICAgICAgICAgbWRpID0gZG1tICogMTAwIC8gbXRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkbWkucGRpID0gcGRpO1xuICAgICAgICAgICAgICAgIGRtaS5tZGkgPSBtZGk7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobWRpICsgcGRpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoKG1kaSAtIHBkaSkpIC8gKG1kaSArIHBkaSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4U3VtICs9IGR4O1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAqIDIgLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gcGFyYW1zWzBdICogMiAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkeCA9IChhZHggKiAocGFyYW1zWzBdIC0gMSkgKyBkeCkgLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHggPSBkeFN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkbWkuYWR4ID0gYWR4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKiAyICsgcGFyYW1zWzFdIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG1pLmFkeHIgPSAoKChfYiA9IHJlc3VsdFtpIC0gKHBhcmFtc1sxXSAtIDEpXS5hZHgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICsgYWR4KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkbWkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICpcbiAqIEVNViDnroDmmJPms6LliqjmjIfmoIdcbiAqIOWFrOW8j++8mlxuICogQT3vvIjku4rml6XmnIDpq5gr5LuK5pel5pyA5L2O77yJLzJcbiAqIEI977yI5YmN5pel5pyA6auYK+WJjeaXpeacgOS9ju+8iS8yXG4gKiBDPeS7iuaXpeacgOmrmC3ku4rml6XmnIDkvY5cbiAqIEVNPe+8iEEtQu+8iSpDL+S7iuaXpeaIkOS6pOminVxuICogRU1WPU7ml6XlhoVFTeeahOe0r+WSjFxuICogTUFFTVY9RU1W55qETeaXpeeahOeugOWNleenu+WKqOW5s+Wdh1xuICpcbiAqL1xudmFyIGVhc2VPZk1vdmVtZW50VmFsdWUgPSB7XG4gICAgbmFtZTogJ0VNVicsXG4gICAgc2hvcnROYW1lOiAnRU1WJyxcbiAgICBjYWxjUGFyYW1zOiBbMTQsIDldLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdlbXYnLCB0aXRsZTogJ0VNVjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFFbXYnLCB0aXRsZTogJ01BRU1WOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgZW12VmFsdWVTdW0gPSAwO1xuICAgICAgICB2YXIgZW12VmFsdWVMaXN0ID0gW107XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGVtdiA9IHt9O1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZLTGluZURhdGEgPSBkYXRhTGlzdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICB2YXIgdm9sdW1lID0gKF9hID0ga0xpbmVEYXRhLnZvbHVtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VNb3ZlZCA9IChoaWdoICsgbG93KSAvIDIgLSAocHJldktMaW5lRGF0YS5oaWdoICsgcHJldktMaW5lRGF0YS5sb3cpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lID09PSAwIHx8IGhpZ2ggLSBsb3cgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW12LmVtdiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSB2b2x1bWUgLyAxMDAwMDAwMDAgLyAoaGlnaCAtIGxvdyk7XG4gICAgICAgICAgICAgICAgICAgIGVtdi5lbXYgPSBkaXN0YW5jZU1vdmVkIC8gcmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtdlZhbHVlU3VtICs9IGVtdi5lbXY7XG4gICAgICAgICAgICAgICAgZW12VmFsdWVMaXN0LnB1c2goZW12LmVtdik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtdi5tYUVtdiA9IGVtdlZhbHVlU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICBlbXZWYWx1ZVN1bSAtPSBlbXZWYWx1ZUxpc3RbaSAtIHBhcmFtc1swXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtdjtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEVNQSDmjIfmlbDnp7vliqjlubPlnYdcbiAqL1xudmFyIGV4cG9uZW50aWFsTW92aW5nQXZlcmFnZSA9IHtcbiAgICBuYW1lOiAnRU1BJyxcbiAgICBzaG9ydE5hbWU6ICdFTUEnLFxuICAgIHNlcmllczogSW5kaWNhdG9yU2VyaWVzLlByaWNlLFxuICAgIGNhbGNQYXJhbXM6IFs2LCAxMiwgMjBdLFxuICAgIHByZWNpc2lvbjogMixcbiAgICBzaG91bGRPaGxjOiB0cnVlLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdlbWExJywgdGl0bGU6ICdFTUE2OiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdlbWEyJywgdGl0bGU6ICdFTUExMjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnZW1hMycsIHRpdGxlOiAnRU1BMjA6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICByZWdlbmVyYXRlRmlndXJlczogZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gKHsga2V5OiBcImVtYVwiLmNvbmNhdChpICsgMSksIHRpdGxlOiBcIkVNQVwiLmNvbmNhdChwLCBcIjogXCIpLCB0eXBlOiAnbGluZScgfSk7IH0pOyB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcywgZmlndXJlcyA9IGluZGljYXRvci5maWd1cmVzO1xuICAgICAgICB2YXIgY2xvc2VTdW0gPSAwO1xuICAgICAgICB2YXIgZW1hVmFsdWVzID0gW107XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIGVtYSA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgY2xvc2VTdW0gKz0gY2xvc2U7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFWYWx1ZXNbaW5kZXhdID0gKDIgKiBjbG9zZSArIChwIC0gMSkgKiBlbWFWYWx1ZXNbaW5kZXhdKSAvIChwICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFWYWx1ZXNbaW5kZXhdID0gY2xvc2VTdW0gLyBwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtYVtmaWd1cmVzW2luZGV4XS5rZXldID0gZW1hVmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbWE7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBtdG1cbiAqIOWFrOW8jyBNVE3vvIhO5pel77yJPUPvvI1DTlxuICovXG52YXIgbW9tZW50dW0gPSB7XG4gICAgbmFtZTogJ01UTScsXG4gICAgc2hvcnROYW1lOiAnTVRNJyxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDZdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdtdG0nLCB0aXRsZTogJ01UTTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFNdG0nLCB0aXRsZTogJ01BTVRNOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgbXRtU3VtID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBtdG0gPSB7fTtcbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgICAgIHZhciBhZ29DbG9zZSA9IGRhdGFMaXN0W2kgLSBwYXJhbXNbMF1dLmNsb3NlO1xuICAgICAgICAgICAgICAgIG10bS5tdG0gPSBjbG9zZV8xIC0gYWdvQ2xvc2U7XG4gICAgICAgICAgICAgICAgbXRtU3VtICs9IG10bS5tdG07XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzFdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtdG0ubWFNdG0gPSBtdG1TdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIG10bVN1bSAtPSAoKF9hID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLm10bSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobXRtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1BIOenu+WKqOW5s+Wdh1xuICovXG52YXIgbW92aW5nQXZlcmFnZSA9IHtcbiAgICBuYW1lOiAnTUEnLFxuICAgIHNob3J0TmFtZTogJ01BJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5QcmljZSxcbiAgICBjYWxjUGFyYW1zOiBbNSwgMTAsIDMwLCA2MF0sXG4gICAgcHJlY2lzaW9uOiAyLFxuICAgIHNob3VsZE9obGM6IHRydWUsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ21hMScsIHRpdGxlOiAnTUE1OiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTInLCB0aXRsZTogJ01BMTA6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMycsIHRpdGxlOiAnTUEzMDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWE0JywgdGl0bGU6ICdNQTYwOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgcmVnZW5lcmF0ZUZpZ3VyZXM6IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuICh7IGtleTogXCJtYVwiLmNvbmNhdChpICsgMSksIHRpdGxlOiBcIk1BXCIuY29uY2F0KHAsIFwiOiBcIiksIHR5cGU6ICdsaW5lJyB9KTsgfSk7IH0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zLCBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXM7XG4gICAgICAgIHZhciBjbG9zZVN1bXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgbWEgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjbG9zZVN1bXNbaW5kZXhdID0gKChfYSA9IGNsb3NlU3Vtc1tpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgY2xvc2U7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFbZmlndXJlc1tpbmRleF0ua2V5XSA9IGNsb3NlU3Vtc1tpbmRleF0gLyBwO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVN1bXNbaW5kZXhdIC09IGRhdGFMaXN0W2kgLSAocCAtIDEpXS5jbG9zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1BQ0TvvJrlj4LmlbDlv6vnur/np7vliqjlubPlnYfjgIHmhaLnur/np7vliqjlubPlnYfjgIHnp7vliqjlubPlnYfvvIxcbiAqIOm7mOiupOWPguaVsOWAvDEy44CBMjbjgIE544CCXG4gKiDlhazlvI/vvJrikojpppblhYjliIbliKvorqHnrpflh7rmlLbnm5jku7cxMuaXpeaMh+aVsOW5s+a7keenu+WKqOW5s+Wdh+e6v+S4jjI25pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2H57q/77yM5YiG5Yir6K6w5Li6RU1BKDEy77yJ5LiORU1BKDI277yJ44CCXG4gKiDikonmsYLov5nkuKTmnaHmjIfmlbDlubPmu5Hnp7vliqjlubPlnYfnur/nmoTlt67vvIzljbPvvJpESUZGID0gRU1BKFNIT1JUKSDvvI0gRU1BKExPTkcp44CCXG4gKiDikorlho3orqHnrpdESUZG55qETeaXpeeahOW5s+Wdh+eahOaMh+aVsOW5s+a7keenu+WKqOW5s+Wdh+e6v++8jOiusOS4ukRFQeOAglxuICog4pKL5pyA5ZCO55SoRElGRuWHj0RFQe+8jOW+l01BQ0TjgIJNQUNE6YCa5bi457uY5Yi25oiQ5Zu057uV6Zu26L2057q/5rOi5Yqo55qE5p+x5b2i5Zu+44CCTUFDROafseeKtuWkp+S6jjDmtqjpopzoibLvvIzlsI/kuo4w6LeM6aKc6Imy44CCXG4gKi9cbnZhciBtb3ZpbmdBdmVyYWdlQ29udmVyZ2VuY2VEaXZlcmdlbmNlID0ge1xuICAgIG5hbWU6ICdNQUNEJyxcbiAgICBzaG9ydE5hbWU6ICdNQUNEJyxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDI2LCA5XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnZGlmJywgdGl0bGU6ICdESUY6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2RlYScsIHRpdGxlOiAnREVBOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnbWFjZCcsXG4gICAgICAgICAgICB0aXRsZTogJ01BQ0Q6ICcsXG4gICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgIGJhc2VWYWx1ZTogMCxcbiAgICAgICAgICAgIHN0eWxlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGluZGljYXRvciA9IF9hLmluZGljYXRvciwgZGVmYXVsdFN0eWxlcyA9IF9hLmRlZmF1bHRTdHlsZXM7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBkYXRhLnByZXYsIGN1cnJlbnQgPSBkYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZNYWNkID0gKF9iID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2Lm1hY2QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TWFjZCA9IChfYyA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5tYWNkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE1hY2QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2JhcnNbMF0udXBDb2xvcicsIChkZWZhdWx0U3R5bGVzLmJhcnMpWzBdLnVwQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TWFjZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS5kb3duQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5iYXJzKVswXS5kb3duQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS5ub0NoYW5nZUNvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0ubm9DaGFuZ2VDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHByZXZNYWNkIDwgY3VycmVudE1hY2QgPyBQb2x5Z29uVHlwZS5TdHJva2UgOiBQb2x5Z29uVHlwZS5GaWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBzdHlsZSwgY29sb3I6IGNvbG9yLCBib3JkZXJDb2xvcjogY29sb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgY2xvc2VTdW0gPSAwO1xuICAgICAgICB2YXIgZW1hU2hvcnQgPSAwO1xuICAgICAgICB2YXIgZW1hTG9uZyA9IDA7XG4gICAgICAgIHZhciBkaWYgPSAwO1xuICAgICAgICB2YXIgZGlmU3VtID0gMDtcbiAgICAgICAgdmFyIGRlYSA9IDA7XG4gICAgICAgIHZhciBtYXhQZXJpb2QgPSBNYXRoLm1heChwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIG1hY2QgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIGNsb3NlU3VtICs9IGNsb3NlO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWFTaG9ydCA9ICgyICogY2xvc2UgKyAocGFyYW1zWzBdIC0gMSkgKiBlbWFTaG9ydCkgLyAocGFyYW1zWzBdICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbWFTaG9ydCA9IGNsb3NlU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1sxXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IHBhcmFtc1sxXSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1hTG9uZyA9ICgyICogY2xvc2UgKyAocGFyYW1zWzFdIC0gMSkgKiBlbWFMb25nKSAvIChwYXJhbXNbMV0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYUxvbmcgPSBjbG9zZVN1bSAvIHBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBtYXhQZXJpb2QgLSAxKSB7XG4gICAgICAgICAgICAgICAgZGlmID0gZW1hU2hvcnQgLSBlbWFMb25nO1xuICAgICAgICAgICAgICAgIG1hY2QuZGlmID0gZGlmO1xuICAgICAgICAgICAgICAgIGRpZlN1bSArPSBkaWY7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gbWF4UGVyaW9kICsgcGFyYW1zWzJdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IG1heFBlcmlvZCArIHBhcmFtc1syXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYSA9IChkaWYgKiAyICsgZGVhICogKHBhcmFtc1syXSAtIDEpKSAvIChwYXJhbXNbMl0gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYSA9IGRpZlN1bSAvIHBhcmFtc1syXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYWNkLm1hY2QgPSAoZGlmIC0gZGVhKSAqIDI7XG4gICAgICAgICAgICAgICAgICAgIG1hY2QuZGVhID0gZGVhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWNkO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogT0JWXG4gKiBPQlYgPSBSRUYoT0JWKSArIHNpZ24gKiBWXG4gKi9cbnZhciBvbkJhbGFuY2VWb2x1bWUgPSB7XG4gICAgbmFtZTogJ09CVicsXG4gICAgc2hvcnROYW1lOiAnT0JWJyxcbiAgICBjYWxjUGFyYW1zOiBbMzBdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdvYnYnLCB0aXRsZTogJ09CVjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFPYnYnLCB0aXRsZTogJ01BT0JWOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgb2J2U3VtID0gMDtcbiAgICAgICAgdmFyIG9sZE9idiA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICB2YXIgcHJldktMaW5lRGF0YSA9IChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhO1xuICAgICAgICAgICAgaWYgKGtMaW5lRGF0YS5jbG9zZSA8IHByZXZLTGluZURhdGEuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbGRPYnYgLT0gKChfYiA9IGtMaW5lRGF0YS52b2x1bWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa0xpbmVEYXRhLmNsb3NlID4gcHJldktMaW5lRGF0YS5jbG9zZSkge1xuICAgICAgICAgICAgICAgIG9sZE9idiArPSAoKF9jID0ga0xpbmVEYXRhLnZvbHVtZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2J2ID0geyBvYnY6IG9sZE9idiB9O1xuICAgICAgICAgICAgb2J2U3VtICs9IG9sZE9idjtcbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBvYnYubWFPYnYgPSBvYnZTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgb2J2U3VtIC09ICgoX2QgPSByZXN1bHRbaSAtIChwYXJhbXNbMF0gLSAxKV0ub2J2KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9idik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiDku7fph4/otovlir/mjIfmoIdcbiAqIOWFrOW8jzpcbiAqIFggPSAoQ0xPU0UgLSBSRUYoQ0xPU0UsIDEpKSAvIFJFRihDTE9TRSwgMSkgKiBWT0xVTUVcbiAqIFBWVCA9IFNVTShYKVxuICpcbiAqL1xudmFyIHByaWNlQW5kVm9sdW1lVHJlbmQgPSB7XG4gICAgbmFtZTogJ1BWVCcsXG4gICAgc2hvcnROYW1lOiAnUFZUJyxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAncHZ0JywgdGl0bGU6ICdQVlQ6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBwdnQgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHZhciB2b2x1bWUgPSAoX2EgPSBrTGluZURhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgICAgICAgICAgdmFyIHByZXZDbG9zZSA9ICgoX2IgPSBkYXRhTGlzdFtpIC0gMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGtMaW5lRGF0YSkuY2xvc2U7XG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSBwcmV2Q2xvc2UgKiB2b2x1bWU7XG4gICAgICAgICAgICBpZiAodG90YWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gKGNsb3NlIC0gcHJldkNsb3NlKSAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICs9IHg7XG4gICAgICAgICAgICBwdnQucHZ0ID0gc3VtO1xuICAgICAgICAgICAgcmV0dXJuIHB2dDtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFBTWVxuICog5YWs5byP77yaUFNZPU7ml6XlhoXnmoTkuIrmtqjlpKnmlbAvTsOXMTAwJeOAglxuICovXG52YXIgcHN5Y2hvbG9naWNhbExpbmUgPSB7XG4gICAgbmFtZTogJ1BTWScsXG4gICAgc2hvcnROYW1lOiAnUFNZJyxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDZdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdwc3knLCB0aXRsZTogJ1BTWTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFQc3knLCB0aXRsZTogJ01BUFNZOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgdXBDb3VudCA9IDA7XG4gICAgICAgIHZhciBwc3lTdW0gPSAwO1xuICAgICAgICB2YXIgdXBMaXN0ID0gW107XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIHBzeSA9IHt9O1xuICAgICAgICAgICAgdmFyIHByZXZDbG9zZSA9ICgoX2EgPSBkYXRhTGlzdFtpIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGtMaW5lRGF0YSkuY2xvc2U7XG4gICAgICAgICAgICB2YXIgdXBGbGFnID0ga0xpbmVEYXRhLmNsb3NlIC0gcHJldkNsb3NlID4gMCA/IDEgOiAwO1xuICAgICAgICAgICAgdXBMaXN0LnB1c2godXBGbGFnKTtcbiAgICAgICAgICAgIHVwQ291bnQgKz0gdXBGbGFnO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIHBzeS5wc3kgPSB1cENvdW50IC8gcGFyYW1zWzBdICogMTAwO1xuICAgICAgICAgICAgICAgIHBzeVN1bSArPSBwc3kucHN5O1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1sxXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHN5Lm1hUHN5ID0gcHN5U3VtIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICBwc3lTdW0gLT0gKChfYiA9IHJlc3VsdFtpIC0gKHBhcmFtc1sxXSAtIDEpXS5wc3kpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cENvdW50IC09IHVwTGlzdFtpIC0gKHBhcmFtc1swXSAtIDEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBzeSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiDlj5jliqjnjofmjIfmoIdcbiAqIOWFrOW8j++8mlJPQyA9IChDTE9TRSAtIFJFRihDTE9TRSwgTikpIC8gUkVGKENMT1NFLCBOKVxuICovXG52YXIgcmF0ZU9mQ2hhbmdlID0ge1xuICAgIG5hbWU6ICdST0MnLFxuICAgIHNob3J0TmFtZTogJ1JPQycsXG4gICAgY2FsY1BhcmFtczogWzEyLCA2XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAncm9jJywgdGl0bGU6ICdST0M6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hUm9jJywgdGl0bGU6ICdNQVJPQzogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgcm9jU3VtID0gMDtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIHJvYyA9IHt9O1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgICAgIHZhciBhZ29DbG9zZSA9ICgoX2EgPSBkYXRhTGlzdFtpIC0gcGFyYW1zWzBdXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0YUxpc3RbaSAtIChwYXJhbXNbMF0gLSAxKV0pLmNsb3NlO1xuICAgICAgICAgICAgICAgIGlmIChhZ29DbG9zZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByb2Mucm9jID0gKGNsb3NlXzEgLSBhZ29DbG9zZSkgLyBhZ29DbG9zZSAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvYy5yb2MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb2NTdW0gKz0gcm9jLnJvYztcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxICsgcGFyYW1zWzFdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb2MubWFSb2MgPSByb2NTdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJvY1N1bSAtPSAoKF9iID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLnJvYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm9jKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJTSVxuICogUlNJID0gU1VNKE1BWChDTE9TRSAtIFJFRihDTE9TRSwxKSwwKSxOKSAvIFNVTShBQlMoQ0xPU0UgLSBSRUYoQ0xPU0UsMSkpLE4pIMOXIDEwMFxuICovXG52YXIgcmVsYXRpdmVTdHJlbmd0aEluZGV4ID0ge1xuICAgIG5hbWU6ICdSU0knLFxuICAgIHNob3J0TmFtZTogJ1JTSScsXG4gICAgY2FsY1BhcmFtczogWzYsIDEyLCAyNF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ3JzaTEnLCB0aXRsZTogJ1JTSTE6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ3JzaTInLCB0aXRsZTogJ1JTSTI6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ3JzaTMnLCB0aXRsZTogJ1JTSTM6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICByZWdlbmVyYXRlRmlndXJlczogZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgdmFyIG51bSA9IGluZGV4ICsgMTtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBcInJzaVwiLmNvbmNhdChudW0pLCB0aXRsZTogXCJSU0lcIi5jb25jYXQobnVtLCBcIjogXCIpLCB0eXBlOiAnbGluZScgfTtcbiAgICB9KTsgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIGZpZ3VyZXMgPSBpbmRpY2F0b3IuZmlndXJlcztcbiAgICAgICAgdmFyIHN1bUNsb3NlQXMgPSBbXTtcbiAgICAgICAgdmFyIHN1bUNsb3NlQnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcnNpID0ge307XG4gICAgICAgICAgICB2YXIgcHJldkNsb3NlID0gKChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhKS5jbG9zZTtcbiAgICAgICAgICAgIHZhciB0bXAgPSBrTGluZURhdGEuY2xvc2UgLSBwcmV2Q2xvc2U7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAodG1wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1DbG9zZUFzW2luZGV4XSA9ICgoX2EgPSBzdW1DbG9zZUFzW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyB0bXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdW1DbG9zZUJzW2luZGV4XSA9ICgoX2IgPSBzdW1DbG9zZUJzW2luZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyBNYXRoLmFicyh0bXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VtQ2xvc2VCc1tpbmRleF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzaVtmaWd1cmVzW2luZGV4XS5rZXldID0gMTAwIC0gKDEwMC4wIC8gKDEgKyBzdW1DbG9zZUFzW2luZGV4XSAvIHN1bUNsb3NlQnNbaW5kZXhdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByc2lbZmlndXJlc1tpbmRleF0ua2V5XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFnb0RhdGEgPSBkYXRhTGlzdFtpIC0gKHAgLSAxKV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZ29QcmVEYXRhID0gKF9jID0gZGF0YUxpc3RbaSAtIHBdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBhZ29EYXRhO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWdvVG1wID0gYWdvRGF0YS5jbG9zZSAtIGFnb1ByZURhdGEuY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZ29UbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1DbG9zZUFzW2luZGV4XSAtPSBhZ29UbXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1DbG9zZUJzW2luZGV4XSAtPSBNYXRoLmFicyhhZ29UbXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcnNpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogc21hXG4gKi9cbnZhciBzaW1wbGVNb3ZpbmdBdmVyYWdlID0ge1xuICAgIG5hbWU6ICdTTUEnLFxuICAgIHNob3J0TmFtZTogJ1NNQScsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXG4gICAgY2FsY1BhcmFtczogWzEyLCAyXSxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ3NtYScsIHRpdGxlOiAnU01BOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgc2hvdWxkT2hsYzogdHJ1ZSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBjbG9zZVN1bSA9IDA7XG4gICAgICAgIHZhciBzbWFWYWx1ZSA9IDA7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIHNtYSA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgY2xvc2VTdW0gKz0gY2xvc2U7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYVZhbHVlID0gKGNsb3NlICogcGFyYW1zWzFdICsgc21hVmFsdWUgKiAocGFyYW1zWzBdIC0gcGFyYW1zWzFdICsgMSkpIC8gKHBhcmFtc1swXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc21hVmFsdWUgPSBjbG9zZVN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc21hLnNtYSA9IHNtYVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNtYTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEtESlxuICpcbiAqIOW9k+aXpUvlgLw9Mi8zw5fliY3kuIDml6VL5YC8KzEvM8OX5b2T5pelUlNWXG4gKiDlvZPml6VE5YC8PTIvM8OX5YmN5LiA5pelROWAvCsxLzPDl+W9k+aXpUvlgLxcbiAqIOiLpeaXoOWJjeS4gOaXpUsg5YC85LiOROWAvO+8jOWImeWPr+WIhuWIq+eUqDUw5p2l5Luj5pu/44CCXG4gKiBK5YC8PTMq5b2T5pelS+WAvC0yKuW9k+aXpUTlgLxcbiAqL1xudmFyIHN0b2NoID0ge1xuICAgIG5hbWU6ICdLREonLFxuICAgIHNob3J0TmFtZTogJ0tESicsXG4gICAgY2FsY1BhcmFtczogWzksIDMsIDNdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdrJywgdGl0bGU6ICdLOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdkJywgdGl0bGU6ICdEOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdqJywgdGl0bGU6ICdKOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgdmFyIGtkaiA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBsaG4gPSBnZXRNYXhNaW4oZGF0YUxpc3Quc2xpY2UoaSAtIChwYXJhbXNbMF0gLSAxKSwgaSArIDEpLCAnaGlnaCcsICdsb3cnKTtcbiAgICAgICAgICAgICAgICB2YXIgaG4gPSBsaG5bMF07XG4gICAgICAgICAgICAgICAgdmFyIGxuID0gbGhuWzFdO1xuICAgICAgICAgICAgICAgIHZhciBoblN1YkxuID0gaG4gLSBsbjtcbiAgICAgICAgICAgICAgICB2YXIgcnN2ID0gKGNsb3NlIC0gbG4pIC8gKGhuU3ViTG4gPT09IDAgPyAxIDogaG5TdWJMbikgKiAxMDA7XG4gICAgICAgICAgICAgICAga2RqLmsgPSAoKHBhcmFtc1sxXSAtIDEpICogKChfYiA9IChfYSA9IHJlc3VsdFtpIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiA1MCkgKyByc3YpIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIGtkai5kID0gKChwYXJhbXNbMl0gLSAxKSAqICgoX2QgPSAoX2MgPSByZXN1bHRbaSAtIDFdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogNTApICsga2RqLmspIC8gcGFyYW1zWzJdO1xuICAgICAgICAgICAgICAgIGtkai5qID0gMy4wICoga2RqLmsgLSAyLjAgKiBrZGouZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtkaik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHN0b3BBbmRSZXZlcnNlID0ge1xuICAgIG5hbWU6ICdTQVInLFxuICAgIHNob3J0TmFtZTogJ1NBUicsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXG4gICAgY2FsY1BhcmFtczogWzIsIDIsIDIwXSxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgc2hvdWxkT2hsYzogdHJ1ZSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ3NhcicsXG4gICAgICAgICAgICB0aXRsZTogJ1NBUjogJyxcbiAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgc3R5bGVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGluZGljYXRvciA9IF9hLmluZGljYXRvciwgZGVmYXVsdFN0eWxlcyA9IF9hLmRlZmF1bHRTdHlsZXM7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBkYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNhciA9IChfYiA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5zYXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIHZhciBoYWxmSEwgPSAoKChfYyA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5oaWdoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSArICgoX2QgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQubG93KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSkgLyAyO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHNhciA8IGhhbGZITFxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdjaXJjbGVzWzBdLnVwQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5jaXJjbGVzKVswXS51cENvbG9yKVxuICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdjaXJjbGVzWzBdLmRvd25Db2xvcicsIChkZWZhdWx0U3R5bGVzLmNpcmNsZXMpWzBdLmRvd25Db2xvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29sb3I6IGNvbG9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIHN0YXJ0QWYgPSBwYXJhbXNbMF0gLyAxMDA7XG4gICAgICAgIHZhciBzdGVwID0gcGFyYW1zWzFdIC8gMTAwO1xuICAgICAgICB2YXIgbWF4QWYgPSBwYXJhbXNbMl0gLyAxMDA7XG4gICAgICAgIC8vIOWKoOmAn+WboOWtkFxuICAgICAgICB2YXIgYWYgPSBzdGFydEFmO1xuICAgICAgICAvLyDmnoHlgLxcbiAgICAgICAgdmFyIGVwID0gLTEwMDtcbiAgICAgICAgLy8g5Yik5pat5piv5LiK5rao6L+Y5piv5LiL6LeMICBmYWxzZe+8muS4i+i3jFxuICAgICAgICB2YXIgaXNJbmNyZWFzaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBzYXIgPSAwO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIC8vIOS4iuS4gOS4quWRqOacn+eahHNhclxuICAgICAgICAgICAgdmFyIHByZVNhciA9IHNhcjtcbiAgICAgICAgICAgIHZhciBoaWdoID0ga0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICB2YXIgbG93ID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgIGlmIChpc0luY3JlYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyDkuIrmtqhcbiAgICAgICAgICAgICAgICBpZiAoZXAgPT09IC0xMDAgfHwgZXAgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOWIneWni+WMluWAvFxuICAgICAgICAgICAgICAgICAgICBlcCA9IGhpZ2g7XG4gICAgICAgICAgICAgICAgICAgIGFmID0gTWF0aC5taW4oYWYgKyBzdGVwLCBtYXhBZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhciA9IHByZVNhciArIGFmICogKGVwIC0gcHJlU2FyKTtcbiAgICAgICAgICAgICAgICB2YXIgbG93TWluID0gTWF0aC5taW4oZGF0YUxpc3RbTWF0aC5tYXgoMSwgaSkgLSAxXS5sb3csIGxvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHNhciA+IGtMaW5lRGF0YS5sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FyID0gZXA7XG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOWIneWni+WMluWAvFxuICAgICAgICAgICAgICAgICAgICBhZiA9IHN0YXJ0QWY7XG4gICAgICAgICAgICAgICAgICAgIGVwID0gLTEwMDtcbiAgICAgICAgICAgICAgICAgICAgaXNJbmNyZWFzaW5nID0gIWlzSW5jcmVhc2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2FyID4gbG93TWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhciA9IGxvd01pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXAgPT09IC0xMDAgfHwgZXAgPiBsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5Yid5aeL5YyW5YC8XG4gICAgICAgICAgICAgICAgICAgIGVwID0gbG93O1xuICAgICAgICAgICAgICAgICAgICBhZiA9IE1hdGgubWluKGFmICsgc3RlcCwgbWF4QWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYXIgPSBwcmVTYXIgKyBhZiAqIChlcCAtIHByZVNhcik7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hNYXggPSBNYXRoLm1heChkYXRhTGlzdFtNYXRoLm1heCgxLCBpKSAtIDFdLmhpZ2gsIGhpZ2gpO1xuICAgICAgICAgICAgICAgIGlmIChzYXIgPCBrTGluZURhdGEuaGlnaCkge1xuICAgICAgICAgICAgICAgICAgICBzYXIgPSBlcDtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5Yid5aeL5YyW5YC8XG4gICAgICAgICAgICAgICAgICAgIGFmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZXAgPSAtMTAwO1xuICAgICAgICAgICAgICAgICAgICBpc0luY3JlYXNpbmcgPSAhaXNJbmNyZWFzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzYXIgPCBoaWdoTWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNhciA9IGhpZ2hNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaGlnaDogaGlnaCwgbG93OiBsb3csIHNhcjogc2FyIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOip3d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIHRyaXhcbiAqXG4gKiBUUj3mlLbnm5jku7fnmoRO5pel5oyH5pWw56e75Yqo5bmz5Z2H55qETuaXpeaMh+aVsOenu+WKqOW5s+Wdh+eahE7ml6XmjIfmlbDnp7vliqjlubPlnYfvvJtcbiAqIFRSSVg9KFRSLeaYqOaXpVRSKS/mmKjml6VUUioxMDDvvJtcbiAqIE1BVFJJWD1UUklY55qETeaXpeeugOWNleenu+WKqOW5s+Wdh++8m1xuICog6buY6K6k5Y+C5pWwTuiuvuS4ujEy77yM6buY6K6k5Y+C5pWwTeiuvuS4ujnvvJtcbiAqIOm7mOiupOWPguaVsDEy44CBOVxuICog5YWs5byP77yaTVRSOj1FTUEoRU1BKEVNQShDTE9TRSxOKSxOKSxOKVxuICogVFJJWDooTVRSLVJFRihNVFIsMSkpL1JFRihNVFIsMSkqMTAwO1xuICogVFJNQTpNQShUUklYLE0pXG4gKlxuICovXG52YXIgdHJpcGxlRXhwb25lbnRpYWxseVNtb290aGVkQXZlcmFnZSA9IHtcbiAgICBuYW1lOiAnVFJJWCcsXG4gICAgc2hvcnROYW1lOiAnVFJJWCcsXG4gICAgY2FsY1BhcmFtczogWzEyLCA5XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAndHJpeCcsIHRpdGxlOiAnVFJJWDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFUcml4JywgdGl0bGU6ICdNQVRSSVg6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBjbG9zZVN1bSA9IDA7XG4gICAgICAgIHZhciBlbWExID0gMDtcbiAgICAgICAgdmFyIGVtYTIgPSAwO1xuICAgICAgICB2YXIgb2xkVHIgPSAwO1xuICAgICAgICB2YXIgZW1hMVN1bSA9IDA7XG4gICAgICAgIHZhciBlbWEyU3VtID0gMDtcbiAgICAgICAgdmFyIHRyaXhTdW0gPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHRyaXggPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIGNsb3NlU3VtICs9IGNsb3NlO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWExID0gKDIgKiBjbG9zZSArIChwYXJhbXNbMF0gLSAxKSAqIGVtYTEpIC8gKHBhcmFtc1swXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW1hMSA9IGNsb3NlU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbWExU3VtICs9IGVtYTE7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICogMiAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gKiAyIC0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1hMiA9ICgyICogZW1hMSArIChwYXJhbXNbMF0gLSAxKSAqIGVtYTIpIC8gKHBhcmFtc1swXSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1hMiA9IGVtYTFTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW1hMlN1bSArPSBlbWEyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKiAzIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cml4VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gKiAzIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyID0gKDIgKiBlbWEyICsgKHBhcmFtc1swXSAtIDEpICogb2xkVHIpIC8gKHBhcmFtc1swXSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXhWYWx1ZSA9ICh0ciAtIG9sZFRyKSAvIG9sZFRyICogMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIgPSBlbWEyU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVHIgPSB0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXgudHJpeCA9IHRyaXhWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXhTdW0gKz0gdHJpeFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICogMyArIHBhcmFtc1sxXSAtIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cml4Lm1hVHJpeCA9IHRyaXhTdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpeFN1bSAtPSAoKF9hID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLnRyaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHJpeCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Vm9sdW1lRmlndXJlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogJ3ZvbHVtZScsXG4gICAgICAgIHRpdGxlOiAnVk9MVU1FOiAnLFxuICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgYmFzZVZhbHVlOiAwLFxuICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBpbmRpY2F0b3IgPSBfYS5pbmRpY2F0b3IsIGRlZmF1bHRTdHlsZXMgPSBfYS5kZWZhdWx0U3R5bGVzO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBkYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS5ub0NoYW5nZUNvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0ubm9DaGFuZ2VDb2xvcik7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmNsb3NlID4gY3VycmVudC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2JhcnNbMF0udXBDb2xvcicsIChkZWZhdWx0U3R5bGVzLmJhcnMpWzBdLnVwQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50LmNsb3NlIDwgY3VycmVudC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2JhcnNbMF0uZG93bkNvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0uZG93bkNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjb2xvcjogY29sb3IgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG52YXIgdm9sdW1lID0ge1xuICAgIG5hbWU6ICdWT0wnLFxuICAgIHNob3J0TmFtZTogJ1ZPTCcsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuVm9sdW1lLFxuICAgIGNhbGNQYXJhbXM6IFs1LCAxMCwgMjBdLFxuICAgIHNob3VsZEZvcm1hdEJpZ051bWJlcjogdHJ1ZSxcbiAgICBwcmVjaXNpb246IDAsXG4gICAgbWluVmFsdWU6IDAsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ21hMScsIHRpdGxlOiAnTUE1OiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTInLCB0aXRsZTogJ01BMTA6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMycsIHRpdGxlOiAnTUEyMDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIGdldFZvbHVtZUZpZ3VyZSgpXG4gICAgXSxcbiAgICByZWdlbmVyYXRlRmlndXJlczogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgZmlndXJlcyA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuICh7IGtleTogXCJtYVwiLmNvbmNhdChpICsgMSksIHRpdGxlOiBcIk1BXCIuY29uY2F0KHAsIFwiOiBcIiksIHR5cGU6ICdsaW5lJyB9KTsgfSk7XG4gICAgICAgIGZpZ3VyZXMucHVzaChnZXRWb2x1bWVGaWd1cmUoKSk7XG4gICAgICAgIHJldHVybiBmaWd1cmVzO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zLCBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXM7XG4gICAgICAgIHZhciB2b2xTdW1zID0gW107XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHZvbHVtZSA9IChfYSA9IGtMaW5lRGF0YS52b2x1bWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICB2YXIgdm9sID0geyB2b2x1bWU6IHZvbHVtZSwgb3Blbjoga0xpbmVEYXRhLm9wZW4sIGNsb3NlOiBrTGluZURhdGEuY2xvc2UgfTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdm9sU3Vtc1tpbmRleF0gPSAoKF9hID0gdm9sU3Vtc1tpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgdm9sdW1lO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvbFtmaWd1cmVzW2luZGV4XS5rZXldID0gdm9sU3Vtc1tpbmRleF0gLyBwO1xuICAgICAgICAgICAgICAgICAgICB2b2xTdW1zW2luZGV4XSAtPSAoKF9iID0gZGF0YUxpc3RbaSAtIChwIC0gMSldLnZvbHVtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdm9sO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVlJcbiAqIFZSPe+8iFVWUysxLzJQVlPvvIkv77yIRFZTKzEvMlBWU++8iVxuICogMjTlpKnku6XmnaXlh6HmmK/ogqHku7fkuIrmtqjpgqPkuIDlpKnnmoTmiJDkuqTph4/pg73np7DkuLpBVu+8jOWwhjI05aSp5YaF55qEQVbmgLvlkoznm7jliqDlkI7np7DkuLpVVlNcbiAqIDI05aSp5Lul5p2l5Yeh5piv6IKh5Lu35LiL6LeM6YKj5LiA5aSp55qE5oiQ5Lqk6YeP6YO956ew5Li6QlbvvIzlsIYyNOWkqeWGheeahEJW5oC75ZKM55u45Yqg5ZCO56ew5Li6RFZTXG4gKiAyNOWkqeS7peadpeWHoeaYr+iCoeS7t+S4jea2qOS4jei3jO+8jOWImemCo+S4gOWkqeeahOaIkOS6pOmHj+mDveensOS4ukNW77yM5bCGMjTlpKnlhoXnmoRDVuaAu+WSjOebuOWKoOWQjuensOS4ulBWU1xuICpcbiAqL1xudmFyIHZvbHVtZVJhdGlvID0ge1xuICAgIG5hbWU6ICdWUicsXG4gICAgc2hvcnROYW1lOiAnVlInLFxuICAgIGNhbGNQYXJhbXM6IFsyNiwgNl0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ3ZyJywgdGl0bGU6ICdWUjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFWcicsIHRpdGxlOiAnTUFWUjogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIHV2cyA9IDA7XG4gICAgICAgIHZhciBkdnMgPSAwO1xuICAgICAgICB2YXIgcHZzID0gMDtcbiAgICAgICAgdmFyIHZyU3VtID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICB2YXIgdnIgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHZhciBwcmVDbG9zZSA9ICgoX2EgPSBkYXRhTGlzdFtpIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGtMaW5lRGF0YSkuY2xvc2U7XG4gICAgICAgICAgICB2YXIgdm9sdW1lID0gKF9iID0ga0xpbmVEYXRhLnZvbHVtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgICAgIGlmIChjbG9zZSA+IHByZUNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdXZzICs9IHZvbHVtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlIDwgcHJlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBkdnMgKz0gdm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHZzICs9IHZvbHVtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlB2cyA9IHB2cyAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGR2cyArIGhhbGZQdnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdnIudnIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdnIudnIgPSAodXZzICsgaGFsZlB2cykgLyAoZHZzICsgaGFsZlB2cykgKiAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZyU3VtICs9IHZyLnZyO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1sxXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdnIubWFWciA9IHZyU3VtIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICB2clN1bSAtPSAoKF9jID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLnZyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFnb0RhdGEgPSBkYXRhTGlzdFtpIC0gKHBhcmFtc1swXSAtIDEpXTtcbiAgICAgICAgICAgICAgICB2YXIgYWdvUHJlRGF0YSA9IChfZCA9IGRhdGFMaXN0W2kgLSBwYXJhbXNbMF1dKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBhZ29EYXRhO1xuICAgICAgICAgICAgICAgIHZhciBhZ29DbG9zZSA9IGFnb0RhdGEuY2xvc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFnb1ZvbHVtZSA9IChfZSA9IGFnb0RhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChhZ29DbG9zZSA+IGFnb1ByZURhdGEuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXZzIC09IGFnb1ZvbHVtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWdvQ2xvc2UgPCBhZ29QcmVEYXRhLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGR2cyAtPSBhZ29Wb2x1bWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwdnMgLT0gYWdvVm9sdW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdSXG4gKiDlhazlvI8gV1IoTikgPSAxMDAgKiBbIEMgLSBISUdIKE4pIF0gLyBbIEhJR0goTiktTE9XKE4pIF1cbiAqL1xudmFyIHdpbGxpYW1zUiA9IHtcbiAgICBuYW1lOiAnV1InLFxuICAgIHNob3J0TmFtZTogJ1dSJyxcbiAgICBjYWxjUGFyYW1zOiBbNiwgMTAsIDE0XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnd3IxJywgdGl0bGU6ICdXUjE6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ3dyMicsIHRpdGxlOiAnV1IyOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICd3cjMnLCB0aXRsZTogJ1dSMzogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIHJlZ2VuZXJhdGVGaWd1cmVzOiBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiAoeyBrZXk6IFwid3JcIi5jb25jYXQoaSArIDEpLCB0aXRsZTogXCJXUlwiLmNvbmNhdChpICsgMSwgXCI6IFwiKSwgdHlwZTogJ2xpbmUnIH0pOyB9KTsgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIGZpZ3VyZXMgPSBpbmRpY2F0b3IuZmlndXJlcztcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgd3IgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmFtIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBobG4gPSBnZXRNYXhNaW4oZGF0YUxpc3Quc2xpY2UoaSAtIHAsIGkgKyAxKSwgJ2hpZ2gnLCAnbG93Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBobiA9IGhsblswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxuID0gaGxuWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaG5TdWJMbiA9IGhuIC0gbG47XG4gICAgICAgICAgICAgICAgICAgIHdyW2ZpZ3VyZXNbaW5kZXhdLmtleV0gPSBoblN1YkxuID09PSAwID8gMCA6IChjbG9zZSAtIGhuKSAvIGhuU3ViTG4gKiAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gd3I7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGluZGljYXRvcnMgPSB7fTtcbnZhciBleHRlbnNpb25zJDIgPSBbXG4gICAgYXZlcmFnZVByaWNlLCBhd2Vzb21lT3NjaWxsYXRvciwgYmlhcywgYm9sbGluZ2VyQmFuZHMsIGJyYXIsXG4gICAgYnVsbEFuZEJlYXJJbmRleCwgY29tbW9kaXR5Q2hhbm5lbEluZGV4LCBjdXJyZW50UmF0aW8sIGRpZmZlcmVudE9mTW92aW5nQXZlcmFnZSxcbiAgICBkaXJlY3Rpb25hbE1vdmVtZW50SW5kZXgsIGVhc2VPZk1vdmVtZW50VmFsdWUsIGV4cG9uZW50aWFsTW92aW5nQXZlcmFnZSwgbW9tZW50dW0sXG4gICAgbW92aW5nQXZlcmFnZSwgbW92aW5nQXZlcmFnZUNvbnZlcmdlbmNlRGl2ZXJnZW5jZSwgb25CYWxhbmNlVm9sdW1lLCBwcmljZUFuZFZvbHVtZVRyZW5kLFxuICAgIHBzeWNob2xvZ2ljYWxMaW5lLCByYXRlT2ZDaGFuZ2UsIHJlbGF0aXZlU3RyZW5ndGhJbmRleCwgc2ltcGxlTW92aW5nQXZlcmFnZSxcbiAgICBzdG9jaCwgc3RvcEFuZFJldmVyc2UsIHRyaXBsZUV4cG9uZW50aWFsbHlTbW9vdGhlZEF2ZXJhZ2UsIHZvbHVtZSwgdm9sdW1lUmF0aW8sIHdpbGxpYW1zUlxuXTtcbmV4dGVuc2lvbnMkMi5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICBpbmRpY2F0b3JzW2luZGljYXRvci5uYW1lXSA9IEluZGljYXRvckltcC5leHRlbmQoaW5kaWNhdG9yKTtcbn0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJJbmRpY2F0b3IoaW5kaWNhdG9yKSB7XG4gICAgaW5kaWNhdG9yc1tpbmRpY2F0b3IubmFtZV0gPSBJbmRpY2F0b3JJbXAuZXh0ZW5kKGluZGljYXRvcik7XG59XG5mdW5jdGlvbiBnZXRJbmRpY2F0b3JDbGFzcyhuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBpbmRpY2F0b3JzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSW5kaWNhdG9ycygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaW5kaWNhdG9ycyk7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGZpYm9uYWNjaUxpbmUgPSB7XG4gICAgbmFtZTogJ2ZpYm9uYWNjaUxpbmUnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBjaGFydCA9IF9hLmNoYXJ0LCBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nLCBvdmVybGF5ID0gX2Eub3ZlcmxheSwgeUF4aXMgPSBfYS55QXhpcztcbiAgICAgICAgdmFyIHBvaW50cyA9IG92ZXJsYXkucG9pbnRzO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHByZWNpc2lvbl8xID0gMDtcbiAgICAgICAgICAgIGlmICgoX2IgPSB5QXhpcyA9PT0gbnVsbCB8fCB5QXhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogeUF4aXMuaXNJbkNhbmRsZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uXzEgPSBjaGFydC5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnQuZ2V0SW5kaWNhdG9ycyh7IHBhbmVJZDogb3ZlcmxheS5wYW5lSWQgfSk7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uXzEgPSBNYXRoLm1heChwcmVjaXNpb25fMSwgaW5kaWNhdG9yLnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZXNfMSA9IFtdO1xuICAgICAgICAgICAgdmFyIHRleHRzXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydFhfMSA9IDA7XG4gICAgICAgICAgICB2YXIgZW5kWF8xID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSAmJiBpc051bWJlcihwb2ludHNbMF0udmFsdWUpICYmIGlzTnVtYmVyKHBvaW50c1sxXS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudHMgPSBbMSwgMC43ODYsIDAuNjE4LCAwLjUsIDAuMzgyLCAwLjIzNiwgMF07XG4gICAgICAgICAgICAgICAgdmFyIHlEaWZfMSA9IGNvb3JkaW5hdGVzWzBdLnkgLSBjb29yZGluYXRlc1sxXS55O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZURpZl8xID0gcG9pbnRzWzBdLnZhbHVlIC0gcG9pbnRzWzFdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHBlcmNlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGNvb3JkaW5hdGVzWzFdLnkgKyB5RGlmXzEgKiBwZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFydC5nZXREZWNpbWFsRm9sZCgpLmZvcm1hdChjaGFydC5nZXRUaG91c2FuZHNTZXBhcmF0b3IoKS5mb3JtYXQoKCgoX2EgPSBwb2ludHNbMV0udmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgdmFsdWVEaWZfMSAqIHBlcmNlbnQpLnRvRml4ZWQocHJlY2lzaW9uXzEpKSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzXzEucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBzdGFydFhfMSwgeTogeSB9LCB7IHg6IGVuZFhfMSwgeTogeSB9XSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHNfMS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0WF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIuY29uY2F0KHZhbHVlLCBcIiAoXCIpLmNvbmNhdCgocGVyY2VudCAqIDEwMCkudG9GaXhlZCgxKSwgXCIlKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lOiAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBsaW5lc18xXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hlY2tFdmVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB0ZXh0c18xXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaG9yaXpvbnRhbFJheUxpbmUgPSB7XG4gICAgbmFtZTogJ2hvcml6b250YWxSYXlMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDMsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0geyB4OiAwLCB5OiBjb29yZGluYXRlc1swXS55IH07XG4gICAgICAgIGlmIChpc1ZhbGlkKGNvb3JkaW5hdGVzWzFdKSAmJiBjb29yZGluYXRlc1swXS54IDwgY29vcmRpbmF0ZXNbMV0ueCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZS54ID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IFtjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZV0gfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50UHJlc3NlZE1vdmU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIHBvaW50c1swXS52YWx1ZSA9IHBlcmZvcm1Qb2ludC52YWx1ZTtcbiAgICAgICAgcG9pbnRzWzFdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmc6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSBfYS5jdXJyZW50U3RlcCwgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIGlmIChjdXJyZW50U3RlcCA9PT0gMikge1xuICAgICAgICAgICAgcG9pbnRzWzBdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaG9yaXpvbnRhbFNlZ21lbnQgPSB7XG4gICAgbmFtZTogJ2hvcml6b250YWxTZWdtZW50JyxcbiAgICB0b3RhbFN0ZXA6IDMsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBsaW5lc1xuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50UHJlc3NlZE1vdmU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIHBvaW50c1swXS52YWx1ZSA9IHBlcmZvcm1Qb2ludC52YWx1ZTtcbiAgICAgICAgcG9pbnRzWzFdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmc6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSBfYS5jdXJyZW50U3RlcCwgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIGlmIChjdXJyZW50U3RlcCA9PT0gMikge1xuICAgICAgICAgICAgcG9pbnRzWzBdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaG9yaXpvbnRhbFN0cmFpZ2h0TGluZSA9IHtcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFN0cmFpZ2h0TGluZScsXG4gICAgdG90YWxTdGVwOiAyLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkaW5hdGVzWzBdLnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBib3VuZGluZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjb29yZGluYXRlc1swXS55XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBFdmVudGZ1bCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudGZ1bCgpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBFdmVudGZ1bC5wcm90b3R5cGUucmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Muc2V0KG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2tzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY2FsbGJhY2spICYmIHRoaXMuY2hlY2tFdmVudE9uKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2ZW50LCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRXZlbnRmdWwucHJvdG90eXBlLmNoZWNrRXZlbnRPbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5fY2hpbGRyZW4pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChmdWwuY2hlY2tFdmVudE9uKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0uZGlzcGF0Y2hFdmVudChuYW1lLCBldmVudCwgb3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vbkV2ZW50KG5hbWUsIGV2ZW50LCBvdGhlcik7XG4gICAgfTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoZXZlbnRmdWwpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChldmVudGZ1bCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRXZlbnRmdWwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50ZnVsO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgREVWSUFUSU9OID0gMjtcbnZhciBGaWd1cmVJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpZ3VyZUltcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWd1cmVJbXAoZmlndXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmF0dHJzID0gZmlndXJlLmF0dHJzO1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBmaWd1cmUuc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpZ3VyZUltcC5wcm90b3R5cGUuY2hlY2tFdmVudE9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRXZlbnRPbkltcChldmVudCwgdGhpcy5hdHRycywgdGhpcy5zdHlsZXMpO1xuICAgIH07XG4gICAgRmlndXJlSW1wLnByb3RvdHlwZS5zZXRBdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmlndXJlSW1wLnByb3RvdHlwZS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEZpZ3VyZUltcC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdGhpcy5kcmF3SW1wKGN0eCwgdGhpcy5hdHRycywgdGhpcy5zdHlsZXMpO1xuICAgIH07XG4gICAgRmlndXJlSW1wLmV4dGVuZCA9IGZ1bmN0aW9uIChmaWd1cmUpIHtcbiAgICAgICAgdmFyIEN1c3RvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDdXN0b20sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b20oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ3VzdG9tLnByb3RvdHlwZS5jaGVja0V2ZW50T25JbXAgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZSwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWd1cmUuY2hlY2tFdmVudE9uKGNvb3JkaW5hdGUsIGF0dHJzLCBzdHlsZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEN1c3RvbS5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBmaWd1cmUuZHJhdyhjdHgsIGF0dHJzLCBzdHlsZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDdXN0b207XG4gICAgICAgIH0oRmlndXJlSW1wKSk7XG4gICAgICAgIHJldHVybiBDdXN0b207XG4gICAgfTtcbiAgICByZXR1cm4gRmlndXJlSW1wO1xufShFdmVudGZ1bCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9uTGluZShjb29yZGluYXRlLCBhdHRycykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gbGluZXMuY29uY2F0KGF0dHJzKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBsaW5lc18xID0gX192YWx1ZXMobGluZXMpLCBsaW5lc18xXzEgPSBsaW5lc18xLm5leHQoKTsgIWxpbmVzXzFfMS5kb25lOyBsaW5lc18xXzEgPSBsaW5lc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGxpbmVfMSA9IGxpbmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGxpbmVfMS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNvb3JkaW5hdGUueCA9PT0gY3VycmVudENvb3JkaW5hdGUueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByZXZDb29yZGluYXRlLnkgLSBjb29yZGluYXRlLnkpICsgTWF0aC5hYnMoY3VycmVudENvb3JkaW5hdGUueSAtIGNvb3JkaW5hdGUueSkgLSBNYXRoLmFicyhwcmV2Q29vcmRpbmF0ZS55IC0gY3VycmVudENvb3JkaW5hdGUueSkgPCBERVZJQVRJT04gKyBERVZJQVRJT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjb29yZGluYXRlLnggLSBwcmV2Q29vcmRpbmF0ZS54KSA8IERFVklBVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtiID0gZ2V0TGluZWFyU2xvcGVJbnRlcmNlcHQocHJldkNvb3JkaW5hdGUsIGN1cnJlbnRDb29yZGluYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdChrYiwgY29vcmRpbmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeURpZiA9IE1hdGguYWJzKHkgLSBjb29yZGluYXRlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByZXZDb29yZGluYXRlLnggLSBjb29yZGluYXRlLngpICsgTWF0aC5hYnMoY3VycmVudENvb3JkaW5hdGUueCAtIGNvb3JkaW5hdGUueCkgLSBNYXRoLmFicyhwcmV2Q29vcmRpbmF0ZS54IC0gY3VycmVudENvb3JkaW5hdGUueCkgPCBERVZJQVRJT04gKyBERVZJQVRJT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5RGlmICogeURpZiAvIChrYlswXSAqIGtiWzBdICsgMSkgPCBERVZJQVRJT04gKiBERVZJQVRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxpbmVzXzFfMSAmJiAhbGluZXNfMV8xLmRvbmUgJiYgKF9hID0gbGluZXNfMS5yZXR1cm4pKSBfYS5jYWxsKGxpbmVzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdChrYiwgY29vcmRpbmF0ZSkge1xuICAgIGlmIChrYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZS54ICoga2JbMF0gKyBrYlsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGUueTtcbn1cbi8qKlxuICog6I635Y+W54K55Zyo5Lik54K55Yaz5a6a55qE5LiA5qyh5Ye95pWw5LiK55qEeeWAvFxuICogQHBhcmFtIGNvb3JkaW5hdGUxXG4gKiBAcGFyYW0gY29vcmRpbmF0ZTJcbiAqIEBwYXJhbSB0YXJnZXRDb29yZGluYXRlXG4gKi9cbmZ1bmN0aW9uIGdldExpbmVhcllGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyLCB0YXJnZXRDb29yZGluYXRlKSB7XG4gICAgdmFyIGtiID0gZ2V0TGluZWFyU2xvcGVJbnRlcmNlcHQoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKTtcbiAgICByZXR1cm4gZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdChrYiwgdGFyZ2V0Q29vcmRpbmF0ZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lYXJTbG9wZUludGVyY2VwdChjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIpIHtcbiAgICB2YXIgZGlmWCA9IGNvb3JkaW5hdGUxLnggLSBjb29yZGluYXRlMi54O1xuICAgIGlmIChkaWZYICE9PSAwKSB7XG4gICAgICAgIHZhciBrID0gKGNvb3JkaW5hdGUxLnkgLSBjb29yZGluYXRlMi55KSAvIGRpZlg7XG4gICAgICAgIHZhciBiID0gY29vcmRpbmF0ZTEueSAtIGsgKiBjb29yZGluYXRlMS54O1xuICAgICAgICByZXR1cm4gW2ssIGJdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIGNvb3JkaW5hdGVzLCBzbW9vdGgpIHtcbiAgICB2YXIgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBzbW9vdGhQYXJhbSA9IGlzTnVtYmVyKHNtb290aCkgPyAoc21vb3RoID4gMCAmJiBzbW9vdGggPCAxID8gc21vb3RoIDogMCkgOiAoc21vb3RoID8gMC41IDogMCk7XG4gICAgaWYgKChzbW9vdGhQYXJhbSA+IDApICYmIGxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIGNweDAgPSBjb29yZGluYXRlc1swXS54O1xuICAgICAgICB2YXIgY3B5MCA9IGNvb3JkaW5hdGVzWzBdLnk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJldkNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpIC0gMV07XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgICAgdmFyIG5leHRDb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGR4MDEgPSBjb29yZGluYXRlLnggLSBwcmV2Q29vcmRpbmF0ZS54O1xuICAgICAgICAgICAgdmFyIGR5MDEgPSBjb29yZGluYXRlLnkgLSBwcmV2Q29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgdmFyIGR4MTIgPSBuZXh0Q29vcmRpbmF0ZS54IC0gY29vcmRpbmF0ZS54O1xuICAgICAgICAgICAgdmFyIGR5MTIgPSBuZXh0Q29vcmRpbmF0ZS55IC0gY29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgdmFyIGR4MDIgPSBuZXh0Q29vcmRpbmF0ZS54IC0gcHJldkNvb3JkaW5hdGUueDtcbiAgICAgICAgICAgIHZhciBkeTAyID0gbmV4dENvb3JkaW5hdGUueSAtIHByZXZDb29yZGluYXRlLnk7XG4gICAgICAgICAgICB2YXIgcHJldlNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoZHgwMSAqIGR4MDEgKyBkeTAxICogZHkwMSk7XG4gICAgICAgICAgICB2YXIgbmV4dFNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoZHgxMiAqIGR4MTIgKyBkeTEyICogZHkxMik7XG4gICAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aFJhdGlvID0gbmV4dFNlZ21lbnRMZW5ndGggLyAobmV4dFNlZ21lbnRMZW5ndGggKyBwcmV2U2VnbWVudExlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbmV4dENweCA9IGNvb3JkaW5hdGUueCArIGR4MDIgKiBzbW9vdGhQYXJhbSAqIHNlZ21lbnRMZW5ndGhSYXRpbztcbiAgICAgICAgICAgIHZhciBuZXh0Q3B5ID0gY29vcmRpbmF0ZS55ICsgZHkwMiAqIHNtb290aFBhcmFtICogc2VnbWVudExlbmd0aFJhdGlvO1xuICAgICAgICAgICAgbmV4dENweCA9IE1hdGgubWluKG5leHRDcHgsIE1hdGgubWF4KG5leHRDb29yZGluYXRlLngsIGNvb3JkaW5hdGUueCkpO1xuICAgICAgICAgICAgbmV4dENweSA9IE1hdGgubWluKG5leHRDcHksIE1hdGgubWF4KG5leHRDb29yZGluYXRlLnksIGNvb3JkaW5hdGUueSkpO1xuICAgICAgICAgICAgbmV4dENweCA9IE1hdGgubWF4KG5leHRDcHgsIE1hdGgubWluKG5leHRDb29yZGluYXRlLngsIGNvb3JkaW5hdGUueCkpO1xuICAgICAgICAgICAgbmV4dENweSA9IE1hdGgubWF4KG5leHRDcHksIE1hdGgubWluKG5leHRDb29yZGluYXRlLnksIGNvb3JkaW5hdGUueSkpO1xuICAgICAgICAgICAgZHgwMiA9IG5leHRDcHggLSBjb29yZGluYXRlLng7XG4gICAgICAgICAgICBkeTAyID0gbmV4dENweSAtIGNvb3JkaW5hdGUueTtcbiAgICAgICAgICAgIHZhciBjcHgxID0gY29vcmRpbmF0ZS54IC0gZHgwMiAqIHByZXZTZWdtZW50TGVuZ3RoIC8gbmV4dFNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICB2YXIgY3B5MSA9IGNvb3JkaW5hdGUueSAtIGR5MDIgKiBwcmV2U2VnbWVudExlbmd0aCAvIG5leHRTZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgY3B4MSA9IE1hdGgubWluKGNweDEsIE1hdGgubWF4KHByZXZDb29yZGluYXRlLngsIGNvb3JkaW5hdGUueCkpO1xuICAgICAgICAgICAgY3B5MSA9IE1hdGgubWluKGNweTEsIE1hdGgubWF4KHByZXZDb29yZGluYXRlLnksIGNvb3JkaW5hdGUueSkpO1xuICAgICAgICAgICAgY3B4MSA9IE1hdGgubWF4KGNweDEsIE1hdGgubWluKHByZXZDb29yZGluYXRlLngsIGNvb3JkaW5hdGUueCkpO1xuICAgICAgICAgICAgY3B5MSA9IE1hdGgubWF4KGNweTEsIE1hdGgubWluKHByZXZDb29yZGluYXRlLnksIGNvb3JkaW5hdGUueSkpO1xuICAgICAgICAgICAgZHgwMiA9IGNvb3JkaW5hdGUueCAtIGNweDE7XG4gICAgICAgICAgICBkeTAyID0gY29vcmRpbmF0ZS55IC0gY3B5MTtcbiAgICAgICAgICAgIG5leHRDcHggPSBjb29yZGluYXRlLnggKyBkeDAyICogbmV4dFNlZ21lbnRMZW5ndGggLyBwcmV2U2VnbWVudExlbmd0aDtcbiAgICAgICAgICAgIG5leHRDcHkgPSBjb29yZGluYXRlLnkgKyBkeTAyICogbmV4dFNlZ21lbnRMZW5ndGggLyBwcmV2U2VnbWVudExlbmd0aDtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS55KTtcbiAgICAgICAgICAgIGNweDAgPSBuZXh0Q3B4O1xuICAgICAgICAgICAgY3B5MCA9IG5leHRDcHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RDb29yZGluYXRlID0gY29vcmRpbmF0ZXNbbGVuZ3RoIC0gMV07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNweDAsIGNweTAsIGxhc3RDb29yZGluYXRlLngsIGxhc3RDb29yZGluYXRlLnksIGxhc3RDb29yZGluYXRlLngsIGxhc3RDb29yZGluYXRlLnkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1tpXS54LCBjb29yZGluYXRlc1tpXS55KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gbGluZXMuY29uY2F0KGF0dHJzKTtcbiAgICB2YXIgX2EgPSBzdHlsZXMuc3R5bGUsIHN0eWxlID0gX2EgPT09IHZvaWQgMCA/IExpbmVUeXBlLlNvbGlkIDogX2EsIF9iID0gc3R5bGVzLnNtb290aCwgc21vb3RoID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gc3R5bGVzLnNpemUsIHNpemUgPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLCBfZCA9IHN0eWxlcy5jb2xvciwgY29sb3IgPSBfZCA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfZCwgX2UgPSBzdHlsZXMuZGFzaGVkVmFsdWUsIGRhc2hlZFZhbHVlID0gX2UgPT09IHZvaWQgMCA/IFsyLCAyXSA6IF9lO1xuICAgIGN0eC5saW5lV2lkdGggPSBzaXplO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGlmIChzdHlsZSA9PT0gTGluZVR5cGUuRGFzaGVkKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZWRWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIH1cbiAgICB2YXIgY29ycmVjdGlvbiA9IHNpemUgJSAyID09PSAxID8gMC41IDogMDtcbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAoY29vcmRpbmF0ZXNbMF0ueCA9PT0gY29vcmRpbmF0ZXNbMV0ueCB8fFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlc1swXS55ID09PSBjb29yZGluYXRlc1sxXS55KSkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ueCA9PT0gY29vcmRpbmF0ZXNbMV0ueCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNvb3JkaW5hdGVzWzBdLnggKyBjb3JyZWN0aW9uLCBjb29yZGluYXRlc1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1sxXS54ICsgY29ycmVjdGlvbiwgY29vcmRpbmF0ZXNbMV0ueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGNvb3JkaW5hdGVzWzBdLngsIGNvb3JkaW5hdGVzWzBdLnkgKyBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1sxXS54LCBjb29yZGluYXRlc1sxXS55ICsgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29vcmRpbmF0ZXNbMF0ueCwgY29vcmRpbmF0ZXNbMF0ueSk7XG4gICAgICAgICAgICAgICAgbGluZVRvKGN0eCwgY29vcmRpbmF0ZXMsIHNtb290aCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG52YXIgbGluZSA9IHtcbiAgICBuYW1lOiAnbGluZScsXG4gICAgY2hlY2tFdmVudE9uOiBjaGVja0Nvb3JkaW5hdGVPbkxpbmUsXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICBkcmF3TGluZShjdHgsIGF0dHJzLCBzdHlsZXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiDojrflj5blubPooYznur9cbiAqIEBwYXJhbSBjb29yZGluYXRlc1xuICogQHBhcmFtIGJvdW5kaW5nXG4gKiBAcGFyYW0gZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyYWxsZWxMaW5lcyhjb29yZGluYXRlcywgYm91bmRpbmcsIGV4dGVuZFBhcmFsbGVsTGluZUNvdW50KSB7XG4gICAgdmFyIGNvdW50ID0gZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnQgIT09IG51bGwgJiYgZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnQgIT09IHZvaWQgMCA/IGV4dGVuZFBhcmFsbGVsTGluZUNvdW50IDogMDtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ueCA9PT0gY29vcmRpbmF0ZXNbMV0ueCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgICAgICAgICB2YXIgZW5kWSA9IGJvdW5kaW5nLmhlaWdodDtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goeyBjb29yZGluYXRlczogW3sgeDogY29vcmRpbmF0ZXNbMF0ueCwgeTogc3RhcnRZIH0sIHsgeDogY29vcmRpbmF0ZXNbMF0ueCwgeTogZW5kWSB9XSB9KTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBjb29yZGluYXRlc1syXS54LCB5OiBzdGFydFkgfSwgeyB4OiBjb29yZGluYXRlc1syXS54LCB5OiBlbmRZIH1dIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNvb3JkaW5hdGVzWzBdLnggLSBjb29yZGluYXRlc1syXS54O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGRpc3RhbmNlICogKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBjb29yZGluYXRlc1swXS54ICsgZCwgeTogc3RhcnRZIH0sIHsgeDogY29vcmRpbmF0ZXNbMF0ueCArIGQsIHk6IGVuZFkgfV0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgICAgICAgICB2YXIgZW5kWCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGtiID0gZ2V0TGluZWFyU2xvcGVJbnRlcmNlcHQoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgICAgIHZhciBrID0ga2JbMF07XG4gICAgICAgICAgICB2YXIgYiA9IGtiWzFdO1xuICAgICAgICAgICAgbGluZXMucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBzdGFydFgsIHk6IHN0YXJ0WCAqIGsgKyBiIH0sIHsgeDogZW5kWCwgeTogZW5kWCAqIGsgKyBiIH1dIH0pO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYjEgPSBjb29yZGluYXRlc1syXS55IC0gayAqIGNvb3JkaW5hdGVzWzJdLng7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBzdGFydFgsIHk6IHN0YXJ0WCAqIGsgKyBiMSB9LCB7IHg6IGVuZFgsIHk6IGVuZFggKiBrICsgYjEgfV0gfSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYiAtIGIxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYjIgPSBiICsgZGlzdGFuY2UgKiAoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WCwgeTogc3RhcnRYICogayArIGIyIH0sIHsgeDogZW5kWCwgeTogZW5kWCAqIGsgKyBiMiB9XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxudmFyIHBhcmFsbGVsU3RyYWlnaHRMaW5lID0ge1xuICAgIG5hbWU6ICdwYXJhbGxlbFN0cmFpZ2h0TGluZScsXG4gICAgdG90YWxTdGVwOiA0LFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczogZ2V0UGFyYWxsZWxMaW5lcyhjb29yZGluYXRlcywgYm91bmRpbmcpXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgcHJpY2VDaGFubmVsTGluZSA9IHtcbiAgICBuYW1lOiAncHJpY2VDaGFubmVsTGluZScsXG4gICAgdG90YWxTdGVwOiA0LFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczogZ2V0UGFyYWxsZWxMaW5lcyhjb29yZGluYXRlcywgYm91bmRpbmcsIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgcHJpY2VMaW5lID0ge1xuICAgIG5hbWU6ICdwcmljZUxpbmUnLFxuICAgIHRvdGFsU3RlcDogMixcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBjaGFydCA9IF9hLmNoYXJ0LCBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nLCBvdmVybGF5ID0gX2Eub3ZlcmxheSwgeUF4aXMgPSBfYS55QXhpcztcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIGlmICgoX2IgPSB5QXhpcyA9PT0gbnVsbCB8fCB5QXhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogeUF4aXMuaXNJbkNhbmRsZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBjaGFydC5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnQuZ2V0SW5kaWNhdG9ycyh7IHBhbmVJZDogb3ZlcmxheS5wYW5lSWQgfSk7XG4gICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KHByZWNpc2lvbiwgaW5kaWNhdG9yLnByZWNpc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSAob3ZlcmxheS5wb2ludHMpWzBdLnZhbHVlLCB2YWx1ZSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvb3JkaW5hdGVzOiBbY29vcmRpbmF0ZXNbMF0sIHsgeDogYm91bmRpbmcud2lkdGgsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfV0gfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgaWdub3JlRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29vcmRpbmF0ZXNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogY29vcmRpbmF0ZXNbMF0ueSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hhcnQuZ2V0RGVjaW1hbEZvbGQoKS5mb3JtYXQoY2hhcnQuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkuZm9ybWF0KHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uKSkpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlbGluZTogJ2JvdHRvbSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRSYXlMaW5lKGNvb3JkaW5hdGVzLCBib3VuZGluZykge1xuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGlmIChjb29yZGluYXRlc1swXS54ID09PSBjb29yZGluYXRlc1sxXS54ICYmIGNvb3JkaW5hdGVzWzBdLnkgIT09IGNvb3JkaW5hdGVzWzFdLnkpIHtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS55IDwgY29vcmRpbmF0ZXNbMV0ueSkge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IGJvdW5kaW5nLmhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb29yZGluYXRlc1swXS54LFxuICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb29yZGluYXRlc1swXS54ID4gY29vcmRpbmF0ZXNbMV0ueCkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGdldExpbmVhcllGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdLCB7IHg6IDAsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0ge1xuICAgICAgICAgICAgICAgIHg6IGJvdW5kaW5nLndpZHRoLFxuICAgICAgICAgICAgICAgIHk6IGdldExpbmVhcllGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdLCB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiBjb29yZGluYXRlc1swXS55IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGVzOiBbY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVdIH07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbnZhciByYXlMaW5lID0ge1xuICAgIG5hbWU6ICdyYXlMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDMsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBnZXRSYXlMaW5lKGNvb3JkaW5hdGVzLCBib3VuZGluZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBzZWdtZW50ID0ge1xuICAgIG5hbWU6ICdzZWdtZW50JyxcbiAgICB0b3RhbFN0ZXA6IDMsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgc3RyYWlnaHRMaW5lID0ge1xuICAgIG5hbWU6ICdzdHJhaWdodExpbmUnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcywgYm91bmRpbmcgPSBfYS5ib3VuZGluZztcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzWzBdLnggPT09IGNvb3JkaW5hdGVzWzFdLngpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBib3VuZGluZy5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGdldExpbmVhcllGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdLCB7IHg6IDAsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGJvdW5kaW5nLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBnZXRMaW5lYXJZRnJvbUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSwgeyB4OiBib3VuZGluZy53aWR0aCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHZlcnRpY2FsUmF5TGluZSA9IHtcbiAgICBuYW1lOiAndmVydGljYWxSYXlMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDMsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0geyB4OiBjb29yZGluYXRlc1swXS54LCB5OiAwIH07XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ueSA8IGNvb3JkaW5hdGVzWzFdLnkpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPSBib3VuZGluZy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogW2Nvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlXSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRQcmVzc2VkTW92ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgcG9pbnRzWzBdLnRpbWVzdGFtcCA9IHBlcmZvcm1Qb2ludC50aW1lc3RhbXA7XG4gICAgICAgIHBvaW50c1swXS5kYXRhSW5kZXggPSBwZXJmb3JtUG9pbnQuZGF0YUluZGV4O1xuICAgICAgICBwb2ludHNbMV0udGltZXN0YW1wID0gcGVyZm9ybVBvaW50LnRpbWVzdGFtcDtcbiAgICAgICAgcG9pbnRzWzFdLmRhdGFJbmRleCA9IHBlcmZvcm1Qb2ludC5kYXRhSW5kZXg7XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RlcCA9IF9hLmN1cnJlbnRTdGVwLCBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVwID09PSAyKSB7XG4gICAgICAgICAgICBwb2ludHNbMF0udGltZXN0YW1wID0gcGVyZm9ybVBvaW50LnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHBvaW50c1swXS5kYXRhSW5kZXggPSBwZXJmb3JtUG9pbnQuZGF0YUluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgdmVydGljYWxTZWdtZW50ID0ge1xuICAgIG5hbWU6ICd2ZXJ0aWNhbFNlZ21lbnQnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHBlcmZvcm1FdmVudFByZXNzZWRNb3ZlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IF9hLnBvaW50cywgcGVyZm9ybVBvaW50ID0gX2EucGVyZm9ybVBvaW50O1xuICAgICAgICBwb2ludHNbMF0udGltZXN0YW1wID0gcGVyZm9ybVBvaW50LnRpbWVzdGFtcDtcbiAgICAgICAgcG9pbnRzWzBdLmRhdGFJbmRleCA9IHBlcmZvcm1Qb2ludC5kYXRhSW5kZXg7XG4gICAgICAgIHBvaW50c1sxXS50aW1lc3RhbXAgPSBwZXJmb3JtUG9pbnQudGltZXN0YW1wO1xuICAgICAgICBwb2ludHNbMV0uZGF0YUluZGV4ID0gcGVyZm9ybVBvaW50LmRhdGFJbmRleDtcbiAgICB9LFxuICAgIHBlcmZvcm1FdmVudE1vdmVGb3JEcmF3aW5nOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGVwID0gX2EuY3VycmVudFN0ZXAsIHBvaW50cyA9IF9hLnBvaW50cywgcGVyZm9ybVBvaW50ID0gX2EucGVyZm9ybVBvaW50O1xuICAgICAgICBpZiAoY3VycmVudFN0ZXAgPT09IDIpIHtcbiAgICAgICAgICAgIHBvaW50c1swXS50aW1lc3RhbXAgPSBwZXJmb3JtUG9pbnQudGltZXN0YW1wO1xuICAgICAgICAgICAgcG9pbnRzWzBdLmRhdGFJbmRleCA9IHBlcmZvcm1Qb2ludC5kYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB2ZXJ0aWNhbFN0cmFpZ2h0TGluZSA9IHtcbiAgICBuYW1lOiAndmVydGljYWxTdHJhaWdodExpbmUnLFxuICAgIHRvdGFsU3RlcDogMixcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcywgYm91bmRpbmcgPSBfYS5ib3VuZGluZztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZGluYXRlc1swXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjb29yZGluYXRlc1swXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGJvdW5kaW5nLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHNpbXBsZUFubm90YXRpb24gPSB7XG4gICAgbmFtZTogJ3NpbXBsZUFubm90YXRpb24nLFxuICAgIHRvdGFsU3RlcDogMixcbiAgICBzdHlsZXM6IHtcbiAgICAgICAgbGluZTogeyBzdHlsZTogTGluZVR5cGUuRGFzaGVkIH1cbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBfYS5vdmVybGF5LCBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzO1xuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoaXNWYWxpZChvdmVybGF5LmV4dGVuZERhdGEpKSB7XG4gICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24ob3ZlcmxheS5leHRlbmREYXRhKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSAoKF9iID0gb3ZlcmxheS5leHRlbmREYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gKG92ZXJsYXkuZXh0ZW5kRGF0YShvdmVybGF5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvb3JkaW5hdGVzWzBdLng7XG4gICAgICAgIHZhciBzdGFydFkgPSBjb29yZGluYXRlc1swXS55IC0gNjtcbiAgICAgICAgdmFyIGxpbmVFbmRZID0gc3RhcnRZIC0gNTA7XG4gICAgICAgIHZhciBhcnJvd0VuZFkgPSBsaW5lRW5kWSAtIDU7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvb3JkaW5hdGVzOiBbeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSB9LCB7IHg6IHN0YXJ0WCwgeTogbGluZUVuZFkgfV0gfSxcbiAgICAgICAgICAgICAgICBpZ25vcmVFdmVudDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncG9seWdvbicsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WCwgeTogbGluZUVuZFkgfSwgeyB4OiBzdGFydFggLSA0LCB5OiBhcnJvd0VuZFkgfSwgeyB4OiBzdGFydFggKyA0LCB5OiBhcnJvd0VuZFkgfV0gfSxcbiAgICAgICAgICAgICAgICBpZ25vcmVFdmVudDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgeDogc3RhcnRYLCB5OiBhcnJvd0VuZFksIHRleHQ6IHRleHQsIGFsaWduOiAnY2VudGVyJywgYmFzZWxpbmU6ICdib3R0b20nIH0sXG4gICAgICAgICAgICAgICAgaWdub3JlRXZlbnQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBzaW1wbGVUYWcgPSB7XG4gICAgbmFtZTogJ3NpbXBsZVRhZycsXG4gICAgdG90YWxTdGVwOiAyLFxuICAgIHN0eWxlczoge1xuICAgICAgICBsaW5lOiB7IHN0eWxlOiBMaW5lVHlwZS5EYXNoZWQgfVxuICAgIH0sXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gX2EuYm91bmRpbmcsIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBib3VuZGluZy53aWR0aCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlnbm9yZUV2ZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlWUF4aXNGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgdmFyIGNoYXJ0ID0gX2EuY2hhcnQsIG92ZXJsYXkgPSBfYS5vdmVybGF5LCBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nLCB5QXhpcyA9IF9hLnlBeGlzO1xuICAgICAgICB2YXIgaXNGcm9tWmVybyA9IChfYiA9IHlBeGlzID09PSBudWxsIHx8IHlBeGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5QXhpcy5pc0Zyb21aZXJvKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIGlmIChpc0Zyb21aZXJvKSB7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB4ID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgaWYgKGlzVmFsaWQob3ZlcmxheS5leHRlbmREYXRhKSkge1xuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKG92ZXJsYXkuZXh0ZW5kRGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gKChfYyA9IG92ZXJsYXkuZXh0ZW5kRGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG92ZXJsYXkuZXh0ZW5kRGF0YShvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWQodGV4dCkgJiYgaXNOdW1iZXIob3ZlcmxheS5wb2ludHNbMF0udmFsdWUpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZm9ybWF0UHJlY2lzaW9uKG92ZXJsYXkucG9pbnRzWzBdLnZhbHVlLCBjaGFydC5nZXRQcmVjaXNpb24oKS5wcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3RleHQnLCBhdHRyczogeyB4OiB4LCB5OiBjb29yZGluYXRlc1swXS55LCB0ZXh0OiB0ZXh0LCBhbGlnbjogdGV4dEFsaWduLCBiYXNlbGluZTogJ21pZGRsZScgfSB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIG92ZXJsYXlzID0ge307XG52YXIgZXh0ZW5zaW9ucyQxID0gW1xuICAgIGZpYm9uYWNjaUxpbmUsIGhvcml6b250YWxSYXlMaW5lLCBob3Jpem9udGFsU2VnbWVudCwgaG9yaXpvbnRhbFN0cmFpZ2h0TGluZSxcbiAgICBwYXJhbGxlbFN0cmFpZ2h0TGluZSwgcHJpY2VDaGFubmVsTGluZSwgcHJpY2VMaW5lLCByYXlMaW5lLCBzZWdtZW50LFxuICAgIHN0cmFpZ2h0TGluZSwgdmVydGljYWxSYXlMaW5lLCB2ZXJ0aWNhbFNlZ21lbnQsIHZlcnRpY2FsU3RyYWlnaHRMaW5lLFxuICAgIHNpbXBsZUFubm90YXRpb24sIHNpbXBsZVRhZ1xuXTtcbmV4dGVuc2lvbnMkMS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgIG92ZXJsYXlzW3RlbXBsYXRlLm5hbWVdID0gT3ZlcmxheUltcC5leHRlbmQodGVtcGxhdGUpO1xufSk7XG5mdW5jdGlvbiByZWdpc3Rlck92ZXJsYXkodGVtcGxhdGUpIHtcbiAgICBvdmVybGF5c1t0ZW1wbGF0ZS5uYW1lXSA9IE92ZXJsYXlJbXAuZXh0ZW5kKHRlbXBsYXRlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJsYXlJbm5lckNsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IG92ZXJsYXlzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmxheUNsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IG92ZXJsYXlzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkT3ZlcmxheXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJsYXlzKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbGlnaHQgPSB7XG4gICAgZ3JpZDoge1xuICAgICAgICBob3Jpem9udGFsOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNFREVERUQnXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNFREVERUQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbmRsZToge1xuICAgICAgICBwcmljZU1hcms6IHtcbiAgICAgICAgICAgIGhpZ2g6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM3NjgwOEYnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG93OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjNzY4MDhGJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjRkVGRUZFJyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyNGMkYzRjUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5kaWNhdG9yOiB7XG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM3NjgwOEYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHhBeGlzOiB7XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tUZXh0OiB7XG4gICAgICAgICAgICBjb2xvcjogJyM3NjgwOEYnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHlBeGlzOiB7XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tUZXh0OiB7XG4gICAgICAgICAgICBjb2xvcjogJyM3NjgwOEYnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlcGFyYXRvcjoge1xuICAgICAgICBjb2xvcjogJyNEREREREQnXG4gICAgfSxcbiAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjNjg2RDc2JyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNjg2RDc2J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjNjg2RDc2JyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNjg2RDc2J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgZGFyayA9IHtcbiAgICBncmlkOiB7XG4gICAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnIzI5MjkyOSdcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnIzI5MjkyOSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuZGxlOiB7XG4gICAgICAgIHByaWNlTWFyazoge1xuICAgICAgICAgICAgaGlnaDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkyOUFBNSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb3c6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTAsIDEwLCAxMCwgLjYpJyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMTAsIDEwLCAxMCwgLjYpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGluZGljYXRvcjoge1xuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjOTI5QUE1J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB4QXhpczoge1xuICAgICAgICBheGlzTGluZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICAgICAgICB9LFxuICAgICAgICB0aWNrVGV4dDoge1xuICAgICAgICAgICAgY29sb3I6ICcjOTI5QUE1J1xuICAgICAgICB9LFxuICAgICAgICB0aWNrTGluZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICB5QXhpczoge1xuICAgICAgICBheGlzTGluZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICAgICAgICB9LFxuICAgICAgICB0aWNrVGV4dDoge1xuICAgICAgICAgICAgY29sb3I6ICcjOTI5QUE1J1xuICAgICAgICB9LFxuICAgICAgICB0aWNrTGluZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXBhcmF0b3I6IHtcbiAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICAgIH0sXG4gICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzM3M2E0MCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzM3M2E0MCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzM3M2E0MCcsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzM3M2E0MCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHN0eWxlcyA9IHtcbiAgICBsaWdodDogbGlnaHQsXG4gICAgZGFyazogZGFya1xufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKG5hbWUsIHNzKSB7XG4gICAgc3R5bGVzW25hbWVdID0gc3M7XG59XG5mdW5jdGlvbiBnZXRTdHlsZXMobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gc3R5bGVzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBQQU5FX01JTl9IRUlHSFQgPSAzMDtcbnZhciBQQU5FX0RFRkFVTFRfSEVJR0hUID0gMTAwO1xudmFyIFBhbmVJZENvbnN0YW50cyA9IHtcbiAgICBDQU5ETEU6ICdjYW5kbGVfcGFuZScsXG4gICAgSU5ESUNBVE9SOiAnaW5kaWNhdG9yX3BhbmVfJyxcbiAgICBYX0FYSVM6ICd4X2F4aXNfcGFuZSdcbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEJhclNwYWNlTGltaXRDb25zdGFudHMgPSB7XG4gICAgTUlOOiAxLFxuICAgIE1BWDogNTBcbn07XG52YXIgREVGQVVMVF9CQVJfU1BBQ0UgPSAxMDtcbnZhciBERUZBVUxUX09GRlNFVF9SSUdIVF9ESVNUQU5DRSA9IDgwO1xudmFyIEJBUl9HQVBfUkFUSU8gPSAwLjI7XG52YXIgU0NBTEVfTVVMVElQTElFUiA9IDEwO1xudmFyIERFRkFVTFRfTUlOX1RJTUVfU1BBTiA9IDE1ICogNjAgKiAxMDAwO1xudmFyIFN0b3JlSW1wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlSW1wKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0eWxlcyA9IGdldERlZmF1bHRTdHlsZXMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBhcGlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1c3RvbUFwaSA9IHtcbiAgICAgICAgICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGZvcm1hdCkgeyByZXR1cm4gZm9ybWF0VGltZXN0YW1wVG9TdHJpbmcoX3RoaXMuX2RhdGVUaW1lRm9ybWF0LCB0aW1lc3RhbXAsIGZvcm1hdCk7IH0sXG4gICAgICAgICAgICBmb3JtYXRCaWdOdW1iZXI6IGZvcm1hdEJpZ051bWJlclxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYWxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSAnZW4tVVMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhvdXNhbmRzIHNlcGFyYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yID0ge1xuICAgICAgICAgICAgc2lnbjogJywnLFxuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGZvcm1hdFRob3VzYW5kcyh2YWx1ZSwgX3RoaXMuX3Rob3VzYW5kc1NlcGFyYXRvci5zaWduKTsgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVjaW1hbCBmb2xkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZWNpbWFsRm9sZCA9IHtcbiAgICAgICAgICAgIHRocmVzaG9sZDogMyxcbiAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBmb3JtYXRGb2xkRGVjaW1hbCh2YWx1ZSwgX3RoaXMuX2RlY2ltYWxGb2xkLnRocmVzaG9sZCk7IH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaWNlIGFuZCB2b2x1bWUgcHJlY2lzaW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSB7IHByaWNlOiAyLCB2b2x1bWU6IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgc291cmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kYXRhTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZCBtb3JlIGRhdGEgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRNb3JlRGF0YUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIGxvYWRpbmcgZGF0YSBmbGFnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICogV2hldGhlciB0aGVyZSBhcmUgZm9yd2FyZCBhbmQgYmFja3dhcmQgbW9yZSBmbGFnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkRGF0YU1vcmUgPSB7IGZvcndhcmQ6IGZhbHNlLCBiYWNrd2FyZDogZmFsc2UgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIGVuYWJsZWQgZmxhZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fem9vbUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIGVuYWJsZWQgZmxhZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3RhbCBzcGFjZSBvZiBkcmF3aW5nIGFyZWFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdGFsQmFyU3BhY2UgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BhY2Ugb2NjdXBpZWQgYnkgYSBzaW5nbGUgcGllY2Ugb2YgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmFyU3BhY2UgPSBERUZBVUxUX0JBUl9TUEFDRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3RhbmNlIGZyb20gdGhlIGxhc3QgZGF0YSB0byB0aGUgcmlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0UmlnaHREaXN0YW5jZSA9IERFRkFVTFRfT0ZGU0VUX1JJR0hUX0RJU1RBTkNFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBiYXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgZnJvbSB0aGUgbGFzdCBkYXRhIHdoZW4gc2Nyb2xsaW5nIHN0YXJ0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RhcnRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbCBsaW1pdCByb2xlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPSAwIC8qIFNjcm9sbExpbWl0Um9sZS5CYXJDb3VudCAqLztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbCB0byB0aGUgbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCB2aXNpYmxlIGJhclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWluVmlzaWJsZUJhckNvdW50ID0geyBsZWZ0OiAyLCByaWdodDogMiB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIHRvIHRoZSBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IGRpc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYXhPZmZzZXREaXN0YW5jZSA9IHsgbGVmdDogNTAsIHJpZ2h0OiA1MCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgdmlzaWJsZSBhcmVhIGRhdGEgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZSA9IGdldERlZmF1bHRWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5fdGltZVdlaWdodFRpY2tNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3RpbWVXZWlnaHRUaWNrTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9taW5UaW1lU3BhbiA9IHsgY29tcGFyZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGNhbGM6IERFRkFVTFRfTUlOX1RJTUVfU1BBTiB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmlzaWJsZSBkYXRhIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VEYXRhTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmlzaWJsZSBoaWdoZXN0IGxvd2VzdCBwcmljZSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2UgPSBbXG4gICAgICAgICAgICB7IHg6IDAsIHByaWNlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9LFxuICAgICAgICAgICAgeyB4OiAwLCBwcmljZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfVxuICAgICAgICBdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3Jvc3NoYWlyIGluZm9cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nyb3NzaGFpciA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aXZlIHRvb2x0aXAgaWNvbiBpbmZvXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmVUb29sdGlwRmVhdHVyZUluZm8gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5kaWNhdG9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhc2sgc2NoZWR1bGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90YXNrU2NoZWR1bGVyID0gbmV3IFRhc2tTY2hlZHVsZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJsYXlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX292ZXJsYXlzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmxheSBpbmZvcm1hdGlvbiBpbiBwYWludGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVybGF5IGluZm9ybWF0aW9uIGJ5IHRoZSBtb3VzZSBwcmVzc2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVzc2VkT3ZlcmxheUluZm8gPSB7XG4gICAgICAgICAgICBwYW5lSWQ6ICcnLFxuICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIGZpZ3VyZVR5cGU6IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLyxcbiAgICAgICAgICAgIGZpZ3VyZUluZGV4OiAtMSxcbiAgICAgICAgICAgIGZpZ3VyZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmxheSBpbmZvcm1hdGlvbiBieSBob3ZlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJPdmVybGF5SW5mbyA9IHtcbiAgICAgICAgICAgIHBhbmVJZDogJycsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgZmlndXJlVHlwZTogMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovLFxuICAgICAgICAgICAgZmlndXJlSW5kZXg6IC0xLFxuICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVybGF5IGluZm9ybWF0aW9uIGJ5IHRoZSBtb3VzZSBjbGlja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2xpY2tPdmVybGF5SW5mbyA9IHtcbiAgICAgICAgICAgIHBhbmVJZDogJycsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgZmlndXJlVHlwZTogMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovLFxuICAgICAgICAgICAgZmlndXJlSW5kZXg6IC0xLFxuICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIHRoaXMuX2NhbGNPcHRpbWFsQmFyU3BhY2UoKTtcbiAgICAgICAgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA9IHRoaXMuX29mZnNldFJpZ2h0RGlzdGFuY2UgLyB0aGlzLl9iYXJTcGFjZTtcbiAgICAgICAgdmFyIF9hID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIHN0eWxlcyA9IF9hLnN0eWxlcywgbG9jYWxlID0gX2EubG9jYWxlLCB0aW1lem9uZSA9IF9hLnRpbWV6b25lLCBjdXN0b21BcGkgPSBfYS5jdXN0b21BcGksIHRob3VzYW5kc1NlcGFyYXRvciA9IF9hLnRob3VzYW5kc1NlcGFyYXRvciwgZGVjaW1hbEZvbGQgPSBfYS5kZWNpbWFsRm9sZDtcbiAgICAgICAgaWYgKGlzVmFsaWQoc3R5bGVzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcobG9jYWxlKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFRpbWV6b25lKHRpbWV6b25lICE9PSBudWxsICYmIHRpbWV6b25lICE9PSB2b2lkIDAgPyB0aW1lem9uZSA6ICcnKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY3VzdG9tQXBpKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXN0b21BcGkoY3VzdG9tQXBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZCh0aG91c2FuZHNTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRob3VzYW5kc1NlcGFyYXRvcih0aG91c2FuZHNTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKGRlY2ltYWxGb2xkKSkge1xuICAgICAgICAgICAgdGhpcy5zZXREZWNpbWFsRm9sZChkZWNpbWFsRm9sZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgc3R5bGVzID0gbnVsbDtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXMuX3N0eWxlcywgc3R5bGVzKTtcbiAgICAgICAgLy8gYGNhbmRsZS50b29sdGlwLmN1c3RvbWAgc2hvdWxkIG92ZXJyaWRlXG4gICAgICAgIGlmIChpc0FycmF5KChfYiA9IChfYSA9IHN0eWxlcyA9PT0gbnVsbCB8fCBzdHlsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlcy5jYW5kbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29sdGlwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VzdG9tKSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmNhbmRsZS50b29sdGlwLmN1c3RvbSA9IHN0eWxlcy5jYW5kbGUudG9vbHRpcC5jdXN0b207XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdHlsZXM7IH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldEN1c3RvbUFwaSA9IGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fY3VzdG9tQXBpLCBhcGkpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldEN1c3RvbUFwaSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1c3RvbUFwaTsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkgeyB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7IH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldExvY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2FsZTsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0VGltZXpvbmUgPSBmdW5jdGlvbiAodGltZXpvbmUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuX2RhdGVUaW1lRm9ybWF0KSB8fFxuICAgICAgICAgICAgKHRoaXMuZ2V0VGltZXpvbmUoKSAhPT0gdGltZXpvbmUpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aW1lem9uZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aW1lWm9uZSA9IHRpbWV6b25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGVUaW1lRm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0ZVRpbWVGb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nV2FybignJywgJycsICdUaW1lem9uZSBpcyBlcnJvciEhIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVUaW1lRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NpZnlUaW1lV2VpZ2h0VGlja3ModGhpcy5fZGF0YUxpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVUaW1lRm9ybWF0ID0gZGF0ZVRpbWVGb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRUaW1lem9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGVUaW1lRm9ybWF0LnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXREYXRlVGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lRm9ybWF0O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uICh0aG91c2FuZHNTZXBhcmF0b3IpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yLCB0aG91c2FuZHNTZXBhcmF0b3IpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Rob3VzYW5kc1NlcGFyYXRvcjsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0RGVjaW1hbEZvbGQgPSBmdW5jdGlvbiAoZGVjaW1hbEZvbGQpIHsgbWVyZ2UodGhpcy5fZGVjaW1hbEZvbGQsIGRlY2ltYWxGb2xkKTsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0RGVjaW1hbEZvbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWNpbWFsRm9sZDsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFByZWNpc2lvbiA9IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fcHJlY2lzaW9uLCBwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6ZUluZGljYXRvclNlcmllc1ByZWNpc2lvbigpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldERhdGFMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUxpc3Q7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0VmlzaWJsZVJhbmdlRGF0YUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUmFuZ2VEYXRhTGlzdDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRWaXNpYmxlUmFuZ2VIaWdoTG93UHJpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2U7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuYWRkRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBtb3JlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFkanVzdEZsYWcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGhDaGFuZ2UgPSAwO1xuICAgICAgICBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZGF0YUxlbmd0aENoYW5nZSA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2FkRGF0YVR5cGUuSW5pdDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTGlzdCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWREYXRhTW9yZS5iYWNrd2FyZCA9IChfYSA9IG1vcmUgPT09IG51bGwgfHwgbW9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9yZS5iYWNrd2FyZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWREYXRhTW9yZS5mb3J3YXJkID0gKF9iID0gbW9yZSA9PT0gbnVsbCB8fCBtb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3JlLmZvcndhcmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyh0aGlzLl9kYXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0T2Zmc2V0UmlnaHREaXN0YW5jZSh0aGlzLl9vZmZzZXRSaWdodERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIExvYWREYXRhVHlwZS5CYWNrd2FyZDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyhkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3QgPSB0aGlzLl9kYXRhTGlzdC5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWREYXRhTW9yZS5iYWNrd2FyZCA9IChfYyA9IG1vcmUgPT09IG51bGwgfHwgbW9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9yZS5iYWNrd2FyZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdEZsYWcgPSBkYXRhTGVuZ3RoQ2hhbmdlID4gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgTG9hZERhdGFUeXBlLkZvcndhcmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3QgPSBkYXRhLmNvbmNhdCh0aGlzLl9kYXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzKHRoaXMuX2RhdGFMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmZvcndhcmQgPSAoX2QgPSBtb3JlID09PSBudWxsIHx8IG1vcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vcmUuZm9yd2FyZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdEZsYWcgPSBkYXRhTGVuZ3RoQ2hhbmdlID4gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YUNvdW50ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXJlIGluZGl2aWR1YWwgZGF0YSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBkYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHZhciBsYXN0RGF0YVRpbWVzdGFtcCA9IGZvcm1hdFZhbHVlKHRoaXMuX2RhdGFMaXN0W2RhdGFDb3VudCAtIDFdLCAndGltZXN0YW1wJywgMCk7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wID4gbGFzdERhdGFUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyhbZGF0YV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFMaXN0LnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSB0aGlzLmdldExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50KC0tbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGhDaGFuZ2UgPSAxO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkanVzdEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZXN0YW1wID09PSBsYXN0RGF0YVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFMaXN0W2RhdGFDb3VudCAtIDFdID0gZGF0YTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGp1c3RGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgaWYgKGFkanVzdEZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENyb3NzaGFpcih0aGlzLl9jcm9zc2hhaXIsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVySW5kaWNhdG9ycyA9IHRoaXMuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyKHt9KTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkSW5kaWNhdG9yQ2FsY1Rhc2soaW5kaWNhdG9yLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5sYXlvdXQoe1xuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldExvYWRNb3JlRGF0YUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2xvYWRNb3JlRGF0YUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX2NhbGNPcHRpbWFsQmFyU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGVjaWFsQmFyU3BhY2UgPSA0O1xuICAgICAgICB2YXIgcmF0aW8gPSAxIC0gQkFSX0dBUF9SQVRJTyAqIE1hdGguYXRhbihNYXRoLm1heChzcGVjaWFsQmFyU3BhY2UsIHRoaXMuX2JhclNwYWNlKSAtIHNwZWNpYWxCYXJTcGFjZSkgLyAoTWF0aC5QSSAqIDAuNSk7XG4gICAgICAgIHZhciBnYXBCYXJTcGFjZSA9IE1hdGgubWluKE1hdGguZmxvb3IodGhpcy5fYmFyU3BhY2UgKiByYXRpbyksIE1hdGguZmxvb3IodGhpcy5fYmFyU3BhY2UpKTtcbiAgICAgICAgaWYgKGdhcEJhclNwYWNlICUgMiA9PT0gMCAmJiBnYXBCYXJTcGFjZSArIDIgPj0gdGhpcy5fYmFyU3BhY2UpIHtcbiAgICAgICAgICAgIC0tZ2FwQmFyU3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2FwQmFyU3BhY2UgPSBNYXRoLm1heCgxLCBnYXBCYXJTcGFjZSk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzID0gZnVuY3Rpb24gKG5ld0RhdGFMaXN0LCBpc1VwZGF0ZSkge1xuICAgICAgICB2YXIgYmFzZURhdGFJbmRleCA9IDA7XG4gICAgICAgIHZhciBwcmV2VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgaWYgKGlzVXBkYXRlICE9PSBudWxsICYmIGlzVXBkYXRlICE9PSB2b2lkIDAgPyBpc1VwZGF0ZSA6IGZhbHNlKSB7XG4gICAgICAgICAgICBiYXNlRGF0YUluZGV4ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgcHJldlRpbWVzdGFtcCA9IHRoaXMuX2RhdGFMaXN0W2Jhc2VEYXRhSW5kZXggLSAxXS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lV2VpZ2h0VGlja01hcC5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fbWluVGltZVNwYW4gPSB7IGNvbXBhcmU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBjYWxjOiBERUZBVUxUX01JTl9USU1FX1NQQU4gfTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyh0aGlzLl90aW1lV2VpZ2h0VGlja01hcCwgbmV3RGF0YUxpc3QsIHRoaXMuX2RhdGVUaW1lRm9ybWF0LCBiYXNlRGF0YUluZGV4LCB0aGlzLl9taW5UaW1lU3BhbiwgcHJldlRpbWVzdGFtcCk7XG4gICAgICAgIGlmICh0aGlzLl9taW5UaW1lU3Bhbi5jb21wYXJlICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgdGhpcy5fbWluVGltZVNwYW4uY2FsYyA9IHRoaXMuX21pblRpbWVTcGFuLmNvbXBhcmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGltZVdlaWdodFRpY2tMaXN0ID0gY3JlYXRlVGltZVdlaWdodFRpY2tMaXN0KHRoaXMuX3RpbWVXZWlnaHRUaWNrTWFwLCB0aGlzLl9iYXJTcGFjZSwgdGhpcy5fc3R5bGVzLnhBeGlzLnRpY2tUZXh0KTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRUaW1lV2VpZ2h0VGlja0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lV2VpZ2h0VGlja0xpc3Q7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX2FkanVzdFZpc2libGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB2YXIgdG90YWxCYXJDb3VudCA9IHRoaXMuX2RhdGFMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHZpc2libGVCYXJDb3VudCA9IHRoaXMuX3RvdGFsQmFyU3BhY2UgLyB0aGlzLl9iYXJTcGFjZTtcbiAgICAgICAgdmFyIGxlZnRNaW5WaXNpYmxlQmFyQ291bnQgPSAwO1xuICAgICAgICB2YXIgcmlnaHRNaW5WaXNpYmxlQmFyQ291bnQgPSAwO1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsTGltaXRSb2xlID09PSAxIC8qIFNjcm9sbExpbWl0Um9sZS5EaXN0YW5jZSAqLykge1xuICAgICAgICAgICAgbGVmdE1pblZpc2libGVCYXJDb3VudCA9ICh0aGlzLl90b3RhbEJhclNwYWNlIC0gdGhpcy5fbWF4T2Zmc2V0RGlzdGFuY2UucmlnaHQpIC8gdGhpcy5fYmFyU3BhY2U7XG4gICAgICAgICAgICByaWdodE1pblZpc2libGVCYXJDb3VudCA9ICh0aGlzLl90b3RhbEJhclNwYWNlIC0gdGhpcy5fbWF4T2Zmc2V0RGlzdGFuY2UubGVmdCkgLyB0aGlzLl9iYXJTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnRNaW5WaXNpYmxlQmFyQ291bnQgPSB0aGlzLl9taW5WaXNpYmxlQmFyQ291bnQubGVmdDtcbiAgICAgICAgICAgIHJpZ2h0TWluVmlzaWJsZUJhckNvdW50ID0gdGhpcy5fbWluVmlzaWJsZUJhckNvdW50LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxlZnRNaW5WaXNpYmxlQmFyQ291bnQgPSBNYXRoLm1heCgwLCBsZWZ0TWluVmlzaWJsZUJhckNvdW50KTtcbiAgICAgICAgcmlnaHRNaW5WaXNpYmxlQmFyQ291bnQgPSBNYXRoLm1heCgwLCByaWdodE1pblZpc2libGVCYXJDb3VudCk7XG4gICAgICAgIHZhciBtYXhSaWdodE9mZnNldEJhckNvdW50ID0gdmlzaWJsZUJhckNvdW50IC0gTWF0aC5taW4obGVmdE1pblZpc2libGVCYXJDb3VudCwgdG90YWxCYXJDb3VudCk7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID4gbWF4UmlnaHRPZmZzZXRCYXJDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA9IG1heFJpZ2h0T2Zmc2V0QmFyQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblJpZ2h0T2Zmc2V0QmFyQ291bnQgPSAtdG90YWxCYXJDb3VudCArIE1hdGgubWluKHJpZ2h0TWluVmlzaWJsZUJhckNvdW50LCB0b3RhbEJhckNvdW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPCBtaW5SaWdodE9mZnNldEJhckNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gbWluUmlnaHRPZmZzZXRCYXJDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG8gPSBNYXRoLnJvdW5kKHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgKyB0b3RhbEJhckNvdW50ICsgMC41KTtcbiAgICAgICAgdmFyIHJlYWxUbyA9IHRvO1xuICAgICAgICBpZiAodG8gPiB0b3RhbEJhckNvdW50KSB7XG4gICAgICAgICAgICB0byA9IHRvdGFsQmFyQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb20gPSBNYXRoLnJvdW5kKHRvIC0gdmlzaWJsZUJhckNvdW50KSAtIDE7XG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWxGcm9tID0gdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA+IDAgPyBNYXRoLnJvdW5kKHRvdGFsQmFyQ291bnQgKyB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IC0gdmlzaWJsZUJhckNvdW50KSAtIDEgOiBmcm9tO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2UgPSB7IGZyb206IGZyb20sIHRvOiB0bywgcmVhbEZyb206IHJlYWxGcm9tLCByZWFsVG86IHJlYWxUbyB9O1xuICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oQWN0aW9uVHlwZS5PblZpc2libGVSYW5nZUNoYW5nZSwgdGhpcy5fdmlzaWJsZVJhbmdlKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlRGF0YUxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlID0gW1xuICAgICAgICAgICAgeyB4OiAwLCBwcmljZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfSxcbiAgICAgICAgICAgIHsgeDogMCwgcHJpY2U6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIH1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlYWxGcm9tOyBpIDwgcmVhbFRvOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrTGluZURhdGEgPSB0aGlzLl9kYXRhTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5kYXRhSW5kZXhUb0Nvb3JkaW5hdGUoaSk7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VEYXRhTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGksXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXY6IChfYSA9IHRoaXMuX2RhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiBrTGluZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IChfYiA9IHRoaXMuX2RhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoga0xpbmVEYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChrTGluZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVswXS5wcmljZSA8IGtMaW5lRGF0YS5oaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVswXS5wcmljZSA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2VbMF0ueCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2VbMV0ucHJpY2UgPiBrTGluZURhdGEubG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVsxXS5wcmljZSA9IGtMaW5lRGF0YS5sb3c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVsxXS54ID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW9yZSBwcm9jZXNzaW5nIGFuZCBsb2FkaW5nLCBtb3JlIGxvYWRpbmcgaWYgdGhlcmUgYXJlIGNhbGxiYWNrIG1ldGhvZHMgYW5kIG5vIGRhdGEgaXMgYmVpbmcgbG9hZGVkXG4gICAgICAgIGlmICghdGhpcy5fbG9hZGluZyAmJiBpc1ZhbGlkKHRoaXMuX2xvYWRNb3JlRGF0YUNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkRGF0YU1vcmUuZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTG9hZERhdGFUeXBlLkZvcndhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSB0aGlzLl9kYXRhTGlzdFswXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSwgbW9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZERhdGEoZGF0YSwgTG9hZERhdGFUeXBlLkZvcndhcmQsIHsgZm9yd2FyZDogbW9yZSAhPT0gbnVsbCAmJiBtb3JlICE9PSB2b2lkIDAgPyBtb3JlIDogZmFsc2UsIGJhY2t3YXJkOiBtb3JlICE9PSBudWxsICYmIG1vcmUgIT09IHZvaWQgMCA/IG1vcmUgOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gdG90YWxCYXJDb3VudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkRGF0YU1vcmUuYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IExvYWREYXRhVHlwZS5CYWNrd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfZCA9IHRoaXMuX2RhdGFMaXN0W3RvdGFsQmFyQ291bnQgLSAxXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGF0YSwgbW9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZERhdGEoZGF0YSwgTG9hZERhdGFUeXBlLkJhY2t3YXJkLCB7IGZvcndhcmQ6IG1vcmUgIT09IG51bGwgJiYgbW9yZSAhPT0gdm9pZCAwID8gbW9yZSA6IGZhbHNlLCBiYWNrd2FyZDogbW9yZSAhPT0gbnVsbCAmJiBtb3JlICE9PSB2b2lkIDAgPyBtb3JlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRNb3JlRGF0YUNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRCYXJTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhcjogdGhpcy5fYmFyU3BhY2UsXG4gICAgICAgICAgICBoYWxmQmFyOiB0aGlzLl9iYXJTcGFjZSAvIDIsXG4gICAgICAgICAgICBnYXBCYXI6IHRoaXMuX2dhcEJhclNwYWNlLFxuICAgICAgICAgICAgaGFsZkdhcEJhcjogTWF0aC5mbG9vcih0aGlzLl9nYXBCYXJTcGFjZSAvIDIpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0QmFyU3BhY2UgPSBmdW5jdGlvbiAoYmFyU3BhY2UsIGFkanVzdEJlZm9yZUZ1bmMpIHtcbiAgICAgICAgaWYgKGJhclNwYWNlIDwgQmFyU3BhY2VMaW1pdENvbnN0YW50cy5NSU4gfHwgYmFyU3BhY2UgPiBCYXJTcGFjZUxpbWl0Q29uc3RhbnRzLk1BWCB8fCB0aGlzLl9iYXJTcGFjZSA9PT0gYmFyU3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYXJTcGFjZSA9IGJhclNwYWNlO1xuICAgICAgICB0aGlzLl90aW1lV2VpZ2h0VGlja0xpc3QgPSBjcmVhdGVUaW1lV2VpZ2h0VGlja0xpc3QodGhpcy5fdGltZVdlaWdodFRpY2tNYXAsIHRoaXMuX2JhclNwYWNlLCB0aGlzLl9zdHlsZXMueEF4aXMudGlja1RleHQpO1xuICAgICAgICB0aGlzLl9jYWxjT3B0aW1hbEJhclNwYWNlKCk7XG4gICAgICAgIGFkanVzdEJlZm9yZUZ1bmMgPT09IG51bGwgfHwgYWRqdXN0QmVmb3JlRnVuYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWRqdXN0QmVmb3JlRnVuYygpO1xuICAgICAgICB0aGlzLl9hZGp1c3RWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRDcm9zc2hhaXIodGhpcy5fY3Jvc3NoYWlyLCB7IG5vdEludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2NoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRUb3RhbEJhclNwYWNlID0gZnVuY3Rpb24gKHRvdGFsU3BhY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsQmFyU3BhY2UgIT09IHRvdGFsU3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsQmFyU3BhY2UgPSB0b3RhbFNwYWNlO1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLnNldENyb3NzaGFpcih0aGlzLl9jcm9zc2hhaXIsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UsIGlzVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFJpZ2h0RGlzdGFuY2UgPSB0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPT09IDEgLyogU2Nyb2xsTGltaXRSb2xlLkRpc3RhbmNlICovID8gTWF0aC5taW4odGhpcy5fbWF4T2Zmc2V0RGlzdGFuY2UucmlnaHQsIGRpc3RhbmNlKSA6IGRpc3RhbmNlO1xuICAgICAgICB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gdGhpcy5fb2Zmc2V0UmlnaHREaXN0YW5jZSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICBpZiAoaXNVcGRhdGUgIT09IG51bGwgJiYgaXNVcGRhdGUgIT09IHZvaWQgMCA/IGlzVXBkYXRlIDogZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFZpc2libGVSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRDcm9zc2hhaXIodGhpcy5fY3Jvc3NoYWlyLCB7IG5vdEludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC5sYXlvdXQoe1xuICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldEluaXRpYWxPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0UmlnaHREaXN0YW5jZTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCAqIHRoaXMuX2JhclNwYWNlKTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gZnVuY3Rpb24gKGJhckNvdW50KSB7XG4gICAgICAgIHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSBiYXJDb3VudDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRNYXhPZmZzZXRMZWZ0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsTGltaXRSb2xlID0gMSAvKiBTY3JvbGxMaW1pdFJvbGUuRGlzdGFuY2UgKi87XG4gICAgICAgIHRoaXMuX21heE9mZnNldERpc3RhbmNlLmxlZnQgPSBkaXN0YW5jZTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRNYXhPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbExpbWl0Um9sZSA9IDEgLyogU2Nyb2xsTGltaXRSb2xlLkRpc3RhbmNlICovO1xuICAgICAgICB0aGlzLl9tYXhPZmZzZXREaXN0YW5jZS5yaWdodCA9IGRpc3RhbmNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldExlZnRNaW5WaXNpYmxlQmFyQ291bnQgPSBmdW5jdGlvbiAoYmFyQ291bnQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsTGltaXRSb2xlID0gMCAvKiBTY3JvbGxMaW1pdFJvbGUuQmFyQ291bnQgKi87XG4gICAgICAgIHRoaXMuX21pblZpc2libGVCYXJDb3VudC5sZWZ0ID0gYmFyQ291bnQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0UmlnaHRNaW5WaXNpYmxlQmFyQ291bnQgPSBmdW5jdGlvbiAoYmFyQ291bnQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsTGltaXRSb2xlID0gMCAvKiBTY3JvbGxMaW1pdFJvbGUuQmFyQ291bnQgKi87XG4gICAgICAgIHRoaXMuX21pblZpc2libGVCYXJDb3VudC5yaWdodCA9IGJhckNvdW50O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFZpc2libGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSYW5nZTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zdGFydFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3RhbmNlQmFyQ291bnQgPSBkaXN0YW5jZSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB2YXIgcHJldkxhc3RCYXJSaWdodFNpZGVEaXN0YW5jZSA9IHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgKiB0aGlzLl9iYXJTcGFjZTtcbiAgICAgICAgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA9IHRoaXMuX3N0YXJ0TGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCAtIGRpc3RhbmNlQmFyQ291bnQ7XG4gICAgICAgIHRoaXMuX2FkanVzdFZpc2libGVSYW5nZSgpO1xuICAgICAgICB0aGlzLnNldENyb3NzaGFpcih0aGlzLl9jcm9zc2hhaXIsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVhbERpc3RhbmNlID0gTWF0aC5yb3VuZChwcmV2TGFzdEJhclJpZ2h0U2lkZURpc3RhbmNlIC0gdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCAqIHRoaXMuX2JhclNwYWNlKTtcbiAgICAgICAgaWYgKHJlYWxEaXN0YW5jZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25TY3JvbGwsIHsgZGlzdGFuY2U6IHJlYWxEaXN0YW5jZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldERhdGFCeURhdGFJbmRleCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fZGF0YUxpc3RbZGF0YUluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5jb29yZGluYXRlVG9GbG9hdEluZGV4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGRhdGFDb3VudCA9IHRoaXMuX2RhdGFMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGRlbHRhRnJvbVJpZ2h0ID0gKHRoaXMuX3RvdGFsQmFyU3BhY2UgLSB4KSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB2YXIgaW5kZXggPSBkYXRhQ291bnQgKyB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IC0gZGVsdGFGcm9tUmlnaHQ7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGluZGV4ICogMTAwMDAwMCkgLyAxMDAwMDAwO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmRhdGFJbmRleFRvVGltZXN0YW1wID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5RGF0YUluZGV4KGRhdGFJbmRleCk7XG4gICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkYXRhSW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhTGlzdFtsYXN0SW5kZXhdLnRpbWVzdGFtcCArIHRoaXMuX21pblRpbWVTcGFuLmNhbGMgKiAoZGF0YUluZGV4IC0gbGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFMaXN0WzBdLnRpbWVzdGFtcCAtIHRoaXMuX21pblRpbWVTcGFuLmNhbGMgKiBNYXRoLmFicyhkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnRpbWVzdGFtcFRvRGF0YUluZGV4ID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RUaW1lc3RhbXAgPSB0aGlzLl9kYXRhTGlzdFtsYXN0SW5kZXhdLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRpbWVzdGFtcCA+IGxhc3RUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0SW5kZXggKyBNYXRoLmZsb29yKCh0aW1lc3RhbXAgLSBsYXN0VGltZXN0YW1wKSAvIHRoaXMuX21pblRpbWVTcGFuLmNhbGMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdFRpbWVzdGFtcCA9IHRoaXMuX2RhdGFMaXN0WzBdLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRpbWVzdGFtcCA8IGZpcnN0VGltZXN0YW1wKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodGltZXN0YW1wIC0gZmlyc3RUaW1lc3RhbXApIC8gdGhpcy5fbWluVGltZVNwYW4uY2FsYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaE5lYXJlc3QodGhpcy5fZGF0YUxpc3QsICd0aW1lc3RhbXAnLCB0aW1lc3RhbXApO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmRhdGFJbmRleFRvQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGFDb3VudCA9IHRoaXMuX2RhdGFMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGRlbHRhRnJvbVJpZ2h0ID0gZGF0YUNvdW50ICsgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCAtIGRhdGFJbmRleDtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fdG90YWxCYXJTcGFjZSAtIChkZWx0YUZyb21SaWdodCAtIDAuNSkgKiB0aGlzLl9iYXJTcGFjZSArIDAuNSk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuY29vcmRpbmF0ZVRvRGF0YUluZGV4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmNvb3JkaW5hdGVUb0Zsb2F0SW5kZXgoeCkpIC0gMTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gKHNjYWxlLCBjb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLl96b29tRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB6b29tQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGUgIT09IG51bGwgJiYgY29vcmRpbmF0ZSAhPT0gdm9pZCAwID8gY29vcmRpbmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghaXNOdW1iZXIoem9vbUNvb3JkaW5hdGUgPT09IG51bGwgfHwgem9vbUNvb3JkaW5hdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHpvb21Db29yZGluYXRlLngpKSB7XG4gICAgICAgICAgICB6b29tQ29vcmRpbmF0ZSA9IHsgeDogKF9hID0gdGhpcy5fY3Jvc3NoYWlyLngpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX3RvdGFsQmFyU3BhY2UgLyAyIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSB6b29tQ29vcmRpbmF0ZS54O1xuICAgICAgICB2YXIgZmxvYXRJbmRleCA9IHRoaXMuY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh4KTtcbiAgICAgICAgdmFyIHByZXZCYXJTcGFjZSA9IHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB2YXIgYmFyU3BhY2UgPSB0aGlzLl9iYXJTcGFjZSArIHNjYWxlICogKHRoaXMuX2JhclNwYWNlIC8gU0NBTEVfTVVMVElQTElFUik7XG4gICAgICAgIHRoaXMuc2V0QmFyU3BhY2UoYmFyU3BhY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ICs9IChmbG9hdEluZGV4IC0gX3RoaXMuY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh4KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVhbFNjYWxlID0gdGhpcy5fYmFyU3BhY2UgLyBwcmV2QmFyU3BhY2U7XG4gICAgICAgIGlmIChyZWFsU2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbihBY3Rpb25UeXBlLk9uWm9vbSwgeyBzY2FsZTogcmVhbFNjYWxlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0Wm9vbUVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl96b29tRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuaXNab29tRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21FbmFibGVkO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFNjcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxFbmFibGVkID0gZW5hYmxlZDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5pc1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbmFibGVkO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldENyb3NzaGFpciA9IGZ1bmN0aW9uIChjcm9zc2hhaXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgbm90SW52YWxpZGF0ZSA9IF9iLm5vdEludmFsaWRhdGUsIG5vdEV4ZWN1dGVBY3Rpb24gPSBfYi5ub3RFeGVjdXRlQWN0aW9uLCBmb3JjZUludmFsaWRhdGUgPSBfYi5mb3JjZUludmFsaWRhdGU7XG4gICAgICAgIHZhciBjciA9IGNyb3NzaGFpciAhPT0gbnVsbCAmJiBjcm9zc2hhaXIgIT09IHZvaWQgMCA/IGNyb3NzaGFpciA6IHt9O1xuICAgICAgICB2YXIgcmVhbERhdGFJbmRleCA9IDA7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSAwO1xuICAgICAgICBpZiAoaXNOdW1iZXIoY3IueCkpIHtcbiAgICAgICAgICAgIHJlYWxEYXRhSW5kZXggPSB0aGlzLmNvb3JkaW5hdGVUb0RhdGFJbmRleChjci54KTtcbiAgICAgICAgICAgIGlmIChyZWFsRGF0YUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGRhdGFJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWFsRGF0YUluZGV4ID4gdGhpcy5fZGF0YUxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2RhdGFMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXggPSByZWFsRGF0YUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVhbERhdGFJbmRleCA9IHRoaXMuX2RhdGFMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBkYXRhSW5kZXggPSByZWFsRGF0YUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBrTGluZURhdGEgPSB0aGlzLl9kYXRhTGlzdFtkYXRhSW5kZXhdO1xuICAgICAgICB2YXIgcmVhbFggPSB0aGlzLmRhdGFJbmRleFRvQ29vcmRpbmF0ZShyZWFsRGF0YUluZGV4KTtcbiAgICAgICAgdmFyIHByZXZDcm9zc2hhaXIgPSB7IHg6IHRoaXMuX2Nyb3NzaGFpci54LCB5OiB0aGlzLl9jcm9zc2hhaXIueSwgcGFuZUlkOiB0aGlzLl9jcm9zc2hhaXIucGFuZUlkIH07XG4gICAgICAgIHRoaXMuX2Nyb3NzaGFpciA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjciksIHsgcmVhbFg6IHJlYWxYLCBrTGluZURhdGE6IGtMaW5lRGF0YSwgcmVhbERhdGFJbmRleDogcmVhbERhdGFJbmRleCwgZGF0YUluZGV4OiBkYXRhSW5kZXgsIHRpbWVzdGFtcDogKF9hID0gdGhpcy5kYXRhSW5kZXhUb1RpbWVzdGFtcChyZWFsRGF0YUluZGV4KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkIH0pO1xuICAgICAgICBpZiAocHJldkNyb3NzaGFpci54ICE9PSBjci54IHx8XG4gICAgICAgICAgICBwcmV2Q3Jvc3NoYWlyLnkgIT09IGNyLnkgfHxcbiAgICAgICAgICAgIHByZXZDcm9zc2hhaXIucGFuZUlkICE9PSBjci5wYW5lSWQgfHxcbiAgICAgICAgICAgIChmb3JjZUludmFsaWRhdGUgIT09IG51bGwgJiYgZm9yY2VJbnZhbGlkYXRlICE9PSB2b2lkIDAgPyBmb3JjZUludmFsaWRhdGUgOiBmYWxzZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGtMaW5lRGF0YSkgJiYgIShub3RFeGVjdXRlQWN0aW9uICE9PSBudWxsICYmIG5vdEV4ZWN1dGVBY3Rpb24gIT09IHZvaWQgMCA/IG5vdEV4ZWN1dGVBY3Rpb24gOiBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5jcm9zc2hhaXJDaGFuZ2UodGhpcy5fY3Jvc3NoYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG5vdEludmFsaWRhdGUgIT09IG51bGwgJiYgbm90SW52YWxpZGF0ZSAhPT0gdm9pZCAwID8gbm90SW52YWxpZGF0ZSA6IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICog6I635Y+WY3Jvc3NoYWly5L+h5oGvXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0Q3Jvc3NoYWlyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NoYWlyO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldEFjdGl2ZVRvb2x0aXBGZWF0dXJlSW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRvb2x0aXBGZWF0dXJlSW5mbyA9IGluZm8gIT09IG51bGwgJiYgaW5mbyAhPT0gdm9pZCAwID8gaW5mbyA6IG51bGw7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0QWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmV4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2FjdGlvbnMuZ2V0KHR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhlY3V0ZShkYXRhKTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGlvbnMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnNldCh0eXBlLCBuZXcgQWN0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2FjdGlvbnMuZ2V0KHR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS51bnN1YnNjcmliZUFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5fYWN0aW9ucy5nZXQodHlwZSk7XG4gICAgICAgIGlmIChpc1ZhbGlkKGFjdGlvbikpIHtcbiAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZShjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuaGFzQWN0aW9uID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX2FjdGlvbnMuZ2V0KHR5cGUpO1xuICAgICAgICByZXR1cm4gaXNWYWxpZChhY3Rpb24pICYmICFhY3Rpb24uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLl9zb3J0SW5kaWNhdG9ycyA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNTdHJpbmcocGFuZUlkKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5faW5kaWNhdG9ycy5nZXQocGFuZUlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvcnQoZnVuY3Rpb24gKGkxLCBpMikgeyByZXR1cm4gaTEuekxldmVsIC0gaTIuekxldmVsOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAocGFuZUluZGljYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBwYW5lSW5kaWNhdG9ycy5zb3J0KGZ1bmN0aW9uIChpMSwgaTIpIHsgcmV0dXJuIGkxLnpMZXZlbCAtIGkyLnpMZXZlbDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLl9hZGRJbmRpY2F0b3JDYWxjVGFzayA9IGZ1bmN0aW9uIChpbmRpY2F0b3IsIGxvYWREYXRhVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90YXNrU2NoZWR1bGVyLmFkZFRhc2soe1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlVGFza0lkKGluZGljYXRvci5pZCksXG4gICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGluZGljYXRvci5vbkRhdGFTdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBJbmRpY2F0b3JEYXRhU3RhdGUuTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbG9hZERhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3I6IGluZGljYXRvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluZGljYXRvci5jYWxjSW1wKF90aGlzLl9kYXRhTGlzdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbmRpY2F0b3Iub25EYXRhU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGluZGljYXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBJbmRpY2F0b3JEYXRhU3RhdGUuUmVhZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbG9hZERhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbmRpY2F0b3Iub25EYXRhU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGluZGljYXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEluZGljYXRvckRhdGFTdGF0ZS5FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGxvYWREYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5hZGRJbmRpY2F0b3IgPSBmdW5jdGlvbiAoY3JlYXRlLCBwYW5lSWQsIGlzU3RhY2spIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjcmVhdGUubmFtZTtcbiAgICAgICAgdmFyIGZpbHRlckluZGljYXRvcnMgPSB0aGlzLmdldEluZGljYXRvcnNCeUZpbHRlcihjcmVhdGUpO1xuICAgICAgICBpZiAoZmlsdGVySW5kaWNhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhbmVJbmRpY2F0b3JzID0gdGhpcy5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZUlkKTtcbiAgICAgICAgdmFyIEluZGljYXRvckNsYXp6ID0gZ2V0SW5kaWNhdG9yQ2xhc3MobmFtZSk7XG4gICAgICAgIHZhciBpbmRpY2F0b3IgPSBuZXcgSW5kaWNhdG9yQ2xhenooKTtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemVJbmRpY2F0b3JTZXJpZXNQcmVjaXNpb24oaW5kaWNhdG9yKTtcbiAgICAgICAgaW5kaWNhdG9yLnBhbmVJZCA9IHBhbmVJZDtcbiAgICAgICAgaW5kaWNhdG9yLm92ZXJyaWRlKGNyZWF0ZSk7XG4gICAgICAgIGlmICghaXNTdGFjaykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmRpY2F0b3IoeyBwYW5lSWQ6IHBhbmVJZCB9KTtcbiAgICAgICAgICAgIHBhbmVJbmRpY2F0b3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcGFuZUluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzLnNldChwYW5lSWQsIHBhbmVJbmRpY2F0b3JzKTtcbiAgICAgICAgdGhpcy5fc29ydEluZGljYXRvcnMocGFuZUlkKTtcbiAgICAgICAgdGhpcy5fYWRkSW5kaWNhdG9yQ2FsY1Rhc2soaW5kaWNhdG9yLCBMb2FkRGF0YVR5cGUuSW5pdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldEluZGljYXRvcnNCeVBhbmVJZCA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5faW5kaWNhdG9ycy5nZXQocGFuZUlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICB2YXIgcGFuZUlkID0gZmlsdGVyLnBhbmVJZCwgbmFtZSA9IGZpbHRlci5uYW1lLCBpZCA9IGZpbHRlci5pZDtcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljYXRvci5pZCA9PT0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWlzVmFsaWQobmFtZSkgfHwgaW5kaWNhdG9yLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gW107XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIGluZGljYXRvcnMgPSBpbmRpY2F0b3JzLmNvbmNhdCh0aGlzLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lSWQpLmZpbHRlcihtYXRjaCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lSW5kaWNhdG9ycykge1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMgPSBpbmRpY2F0b3JzLmNvbmNhdChwYW5lSW5kaWNhdG9ycy5maWx0ZXIobWF0Y2gpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRpY2F0b3JzO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnJlbW92ZUluZGljYXRvciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZpbHRlckluZGljYXRvcnMgPSB0aGlzLmdldEluZGljYXRvcnNCeUZpbHRlcihmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXJJbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgdmFyIHBhbmVJbmRpY2F0b3JzID0gX3RoaXMuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkKGluZGljYXRvci5wYW5lSWQpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFuZUluZGljYXRvcnMuZmluZEluZGV4KGZ1bmN0aW9uIChpbnMpIHsgcmV0dXJuIGlucy5pZCA9PT0gaW5kaWNhdG9yLmlkOyB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rhc2tTY2hlZHVsZXIucmVtb3ZlVGFzayhnZW5lcmF0ZVRhc2tJZChpbmRpY2F0b3IuaWQpKTtcbiAgICAgICAgICAgICAgICBwYW5lSW5kaWNhdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmVJbmRpY2F0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmRpY2F0b3JzLmRlbGV0ZShpbmRpY2F0b3IucGFuZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmhhc0luZGljYXRvcnMgPSBmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRpY2F0b3JzLmhhcyhwYW5lSWQpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLl9zeW5jaHJvbml6ZUluZGljYXRvclNlcmllc1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcHJlY2lzaW9uLCBwcmljZVByZWNpc2lvbiA9IF9hLnByaWNlLCB2b2x1bWVQcmVjaXNpb24gPSBfYS52b2x1bWU7XG4gICAgICAgIHZhciBzeW5jaHJvbml6ZSA9IGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kaWNhdG9yLnNlcmllcykge1xuICAgICAgICAgICAgICAgIGNhc2UgSW5kaWNhdG9yU2VyaWVzLlByaWNlOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvci5zZXRTZXJpZXNQcmVjaXNpb24ocHJpY2VQcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBJbmRpY2F0b3JTZXJpZXMuVm9sdW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvci5zZXRTZXJpZXNQcmVjaXNpb24odm9sdW1lUHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNWYWxpZChpbmRpY2F0b3IpKSB7XG4gICAgICAgICAgICBzeW5jaHJvbml6ZShpbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lSW5kaWNhdG9ycykge1xuICAgICAgICAgICAgICAgIHBhbmVJbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBzeW5jaHJvbml6ZShpbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5vdmVycmlkZUluZGljYXRvciA9IGZ1bmN0aW9uIChvdmVycmlkZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlRmxhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgc29ydEZsYWcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZpbHRlckluZGljYXRvcnMgPSB0aGlzLmdldEluZGljYXRvcnNCeUZpbHRlcihvdmVycmlkZSk7XG4gICAgICAgIGZpbHRlckluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3Iub3ZlcnJpZGUob3ZlcnJpZGUpO1xuICAgICAgICAgICAgdmFyIF9hID0gaW5kaWNhdG9yLnNob3VsZFVwZGF0ZUltcCgpLCBjYWxjID0gX2EuY2FsYywgZHJhdyA9IF9hLmRyYXcsIHNvcnQgPSBfYS5zb3J0O1xuICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgICBzb3J0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJbmRpY2F0b3JDYWxjVGFzayhpbmRpY2F0b3IsIExvYWREYXRhVHlwZS5VcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgICAgIGlmIChzb3J0RmxhZykge1xuICAgICAgICAgICAgdGhpcy5fc29ydEluZGljYXRvcnMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgaWYgKHVwZGF0ZUZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmxheW91dCh7IHVwZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRPdmVybGF5c0J5RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBpZCA9IGZpbHRlci5pZCwgZ3JvdXBJZCA9IGZpbHRlci5ncm91cElkLCBwYW5lSWQgPSBmaWx0ZXIucGFuZUlkLCBuYW1lID0gZmlsdGVyLm5hbWU7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmxheS5pZCA9PT0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChncm91cElkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmxheS5ncm91cElkID09PSBncm91cElkICYmICghaXNWYWxpZChuYW1lKSB8fCBvdmVybGF5Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNWYWxpZChuYW1lKSB8fCBvdmVybGF5Lm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvdmVybGF5cyA9IFtdO1xuICAgICAgICBpZiAoaXNWYWxpZChwYW5lSWQpKSB7XG4gICAgICAgICAgICBvdmVybGF5cyA9IG92ZXJsYXlzLmNvbmNhdCh0aGlzLmdldE92ZXJsYXlzQnlQYW5lSWQocGFuZUlkKS5maWx0ZXIobWF0Y2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVPdmVybGF5cykge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzID0gb3ZlcmxheXMuY29uY2F0KHBhbmVPdmVybGF5cy5maWx0ZXIobWF0Y2gpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXkgPSAoX2EgPSB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3ZlcmxheTtcbiAgICAgICAgaWYgKGlzVmFsaWQocHJvZ3Jlc3NPdmVybGF5KSAmJiBtYXRjaChwcm9ncmVzc092ZXJsYXkpKSB7XG4gICAgICAgICAgICBvdmVybGF5cy5wdXNoKHByb2dyZXNzT3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJsYXlzO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldE92ZXJsYXlzQnlQYW5lSWQgPSBmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhwYW5lSWQpKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcmxheXNfMSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXNfMSA9IG92ZXJsYXlzXzEuY29uY2F0KHBhbmVPdmVybGF5cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5c18xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9vdmVybGF5cy5nZXQocGFuZUlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX3NvcnRPdmVybGF5cyA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNTdHJpbmcocGFuZUlkKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fb3ZlcmxheXMuZ2V0KHBhbmVJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb3J0KGZ1bmN0aW9uIChvMSwgbzIpIHsgcmV0dXJuIG8xLnpMZXZlbCAtIG8yLnpMZXZlbDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lT3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICBwYW5lT3ZlcmxheXMuc29ydChmdW5jdGlvbiAobzEsIG8yKSB7IHJldHVybiBvMS56TGV2ZWwgLSBvMi56TGV2ZWw7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5hZGRPdmVybGF5cyA9IGZ1bmN0aW9uIChvcywgYXBwb2ludFBhbmVGbGFncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlUGFuZUlkcyA9IFtdO1xuICAgICAgICB2YXIgaWRzID0gb3MubWFwKGZ1bmN0aW9uIChjcmVhdGUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoY3JlYXRlLmlkKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaW5kT3ZlcmxheSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2ggPSBfX3ZhbHVlcyhfdGhpcy5fb3ZlcmxheXMpLCBfaiA9IF9oLm5leHQoKTsgIV9qLmRvbmU7IF9qID0gX2gubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2sgPSBfX3JlYWQoX2oudmFsdWUsIDIpLCBvdmVybGF5cyA9IF9rWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBvdmVybGF5cy5maW5kKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLmlkID09PSBjcmVhdGUuaWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQob3ZlcmxheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaiAmJiAhX2ouZG9uZSAmJiAoX2EgPSBfaC5yZXR1cm4pKSBfYS5jYWxsKF9oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGZpbmRPdmVybGF5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBPdmVybGF5Q2xhenogPSBnZXRPdmVybGF5SW5uZXJDbGFzcyhjcmVhdGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChPdmVybGF5Q2xhenopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gKF9iID0gY3JlYXRlLmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjcmVhdGVJZChPVkVSTEFZX0lEX1BSRUZJWCk7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgT3ZlcmxheUNsYXp6KCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVJZCA9IChfYyA9IGNyZWF0ZS5wYW5lSWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFBhbmVJZENvbnN0YW50cy5DQU5ETEU7XG4gICAgICAgICAgICAgICAgY3JlYXRlLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgKF9kID0gY3JlYXRlLmdyb3VwSWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChjcmVhdGUuZ3JvdXBJZCA9IGlkKTtcbiAgICAgICAgICAgICAgICB2YXIgekxldmVsID0gX3RoaXMuZ2V0T3ZlcmxheXNCeVBhbmVJZChwYW5lSWQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAoX2UgPSBjcmVhdGUuekxldmVsKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAoY3JlYXRlLnpMZXZlbCA9IHpMZXZlbCk7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5vdmVycmlkZShjcmVhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlUGFuZUlkcy5pbmNsdWRlcyhwYW5lSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBhbmVJZHMucHVzaChwYW5lSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheS5pc0RyYXdpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IHsgcGFuZUlkOiBwYW5lSWQsIG92ZXJsYXk6IG92ZXJsYXksIGFwcG9pbnRQYW5lRmxhZzogYXBwb2ludFBhbmVGbGFnc1tpbmRleF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX292ZXJsYXlzLmhhcyhwYW5lSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb3ZlcmxheXMuc2V0KHBhbmVJZCwgW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfZiA9IF90aGlzLl9vdmVybGF5cy5nZXQocGFuZUlkKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnB1c2gob3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2cgPSBvdmVybGF5Lm9uRHJhd1N0YXJ0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuY2FsbChvdmVybGF5LCAoeyBvdmVybGF5OiBvdmVybGF5LCBjaGFydDogX3RoaXMuX2NoYXJ0IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlUGFuZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3J0T3ZlcmxheXMoKTtcbiAgICAgICAgICAgIHVwZGF0ZVBhbmVJZHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBwYW5lSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRQcm9ncmVzc092ZXJsYXlJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5wcm9ncmVzc092ZXJsYXlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbywgb3ZlcmxheSA9IF9iLm92ZXJsYXksIHBhbmVJZCA9IF9iLnBhbmVJZDtcbiAgICAgICAgICAgIGlmICghb3ZlcmxheS5pc0RyYXdpbmcoKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3ZlcmxheXMuaGFzKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheXMuc2V0KHBhbmVJZCwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9vdmVybGF5cy5nZXQocGFuZUlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2gob3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc29ydE92ZXJsYXlzKHBhbmVJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS51cGRhdGVQcm9ncmVzc092ZXJsYXlJbmZvID0gZnVuY3Rpb24gKHBhbmVJZCwgYXBwb2ludFBhbmVGbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKGFwcG9pbnRQYW5lRmxhZykgJiYgYXBwb2ludFBhbmVGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mby5hcHBvaW50UGFuZUZsYWcgPSBhcHBvaW50UGFuZUZsYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvLnBhbmVJZCA9IHBhbmVJZDtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT3ZlcmxheUluZm8ub3ZlcmxheS5vdmVycmlkZSh7IHBhbmVJZDogcGFuZUlkIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUub3ZlcnJpZGVPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3J0RmxhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgdXBkYXRlUGFuZUlkcyA9IFtdO1xuICAgICAgICB2YXIgZmlsdGVyT3ZlcmxheXMgPSB0aGlzLmdldE92ZXJsYXlzQnlGaWx0ZXIob3ZlcnJpZGUpO1xuICAgICAgICBmaWx0ZXJPdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICBvdmVybGF5Lm92ZXJyaWRlKG92ZXJyaWRlKTtcbiAgICAgICAgICAgIHZhciBfYSA9IG92ZXJsYXkuc2hvdWxkVXBkYXRlKCksIHNvcnQgPSBfYS5zb3J0LCBkcmF3ID0gX2EuZHJhdztcbiAgICAgICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICAgICAgc29ydEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnQgfHwgZHJhdykge1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlUGFuZUlkcy5pbmNsdWRlcyhvdmVybGF5LnBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFuZUlkcy5wdXNoKG92ZXJsYXkucGFuZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgaWYgKHNvcnRGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3J0T3ZlcmxheXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlUGFuZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVQYW5lSWRzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgcGFuZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8sIFBhbmVJZENvbnN0YW50cy5YX0FYSVMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnJlbW92ZU92ZXJsYXkgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVQYW5lSWRzID0gW107XG4gICAgICAgIHZhciBmaWx0ZXJPdmVybGF5cyA9IHRoaXMuZ2V0T3ZlcmxheXNCeUZpbHRlcihmaWx0ZXIpO1xuICAgICAgICBmaWx0ZXJPdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGFuZUlkID0gb3ZlcmxheS5wYW5lSWQ7XG4gICAgICAgICAgICB2YXIgcGFuZU92ZXJsYXlzID0gX3RoaXMuZ2V0T3ZlcmxheXNCeVBhbmVJZChvdmVybGF5LnBhbmVJZCk7XG4gICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uUmVtb3ZlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgeyBvdmVybGF5OiBvdmVybGF5LCBjaGFydDogX3RoaXMuX2NoYXJ0IH0pO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVQYW5lSWRzLmluY2x1ZGVzKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVQYW5lSWRzLnB1c2gocGFuZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVybGF5LmlzRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb2dyZXNzT3ZlcmxheUluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFuZU92ZXJsYXlzLmZpbmRJbmRleChmdW5jdGlvbiAobykgeyByZXR1cm4gby5pZCA9PT0gb3ZlcmxheS5pZDsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZU92ZXJsYXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmVPdmVybGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3ZlcmxheXMuZGVsZXRlKHBhbmVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlUGFuZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVQYW5lSWRzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgcGFuZUlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8sIFBhbmVJZENvbnN0YW50cy5YX0FYSVMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFByZXNzZWRPdmVybGF5SW5mbyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHRoaXMuX3ByZXNzZWRPdmVybGF5SW5mbyA9IGluZm87XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0UHJlc3NlZE92ZXJsYXlJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlc3NlZE92ZXJsYXlJbmZvO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldEhvdmVyT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoaW5mbywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLl9ob3Zlck92ZXJsYXlJbmZvLCBvdmVybGF5ID0gX2Iub3ZlcmxheSwgZmlndXJlVHlwZSA9IF9iLmZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4ID0gX2IuZmlndXJlSW5kZXgsIGZpZ3VyZSA9IF9iLmZpZ3VyZTtcbiAgICAgICAgdmFyIGluZm9PdmVybGF5ID0gaW5mby5vdmVybGF5O1xuICAgICAgICBpZiAoKG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5pZCkgIT09IChpbmZvT3ZlcmxheSA9PT0gbnVsbCB8fCBpbmZvT3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb092ZXJsYXkuaWQpIHx8XG4gICAgICAgICAgICBmaWd1cmVUeXBlICE9PSBpbmZvLmZpZ3VyZVR5cGUgfHxcbiAgICAgICAgICAgIGZpZ3VyZUluZGV4ICE9PSBpbmZvLmZpZ3VyZUluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9ob3Zlck92ZXJsYXlJbmZvID0gaW5mbztcbiAgICAgICAgICAgIGlmICgob3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVybGF5LmlkKSAhPT0gKGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5pZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlVXBkYXRlRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBzb3J0RmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkub3ZlcnJpZGUoeyB6TGV2ZWw6IG92ZXJsYXkuZ2V0UHJldlpMZXZlbCgpIH0pO1xuICAgICAgICAgICAgICAgICAgICBzb3J0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG92ZXJsYXkub25Nb3VzZUxlYXZlKSAmJiBjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25Nb3VzZUxlYXZlJywgZmlndXJlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5vbk1vdXNlTGVhdmUoX19hc3NpZ24oeyBjaGFydDogdGhpcy5fY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZTogZmlndXJlICE9PSBudWxsICYmIGZpZ3VyZSAhPT0gdm9pZCAwID8gZmlndXJlIDogdW5kZWZpbmVkIH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVVcGRhdGVGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5mb092ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb092ZXJsYXkuc2V0UHJldlpMZXZlbChpbmZvT3ZlcmxheS56TGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvT3ZlcmxheS5vdmVycmlkZSh7IHpMZXZlbDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaW5mb092ZXJsYXkub25Nb3VzZUVudGVyKSAmJiBjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25Nb3VzZUVudGVyJywgaW5mby5maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvT3ZlcmxheS5vbk1vdXNlRW50ZXIoX19hc3NpZ24oeyBjaGFydDogdGhpcy5fY2hhcnQsIG92ZXJsYXk6IGluZm9PdmVybGF5LCBmaWd1cmU6IChfYSA9IGluZm8uZmlndXJlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVVwZGF0ZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3J0RmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0T3ZlcmxheXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVVcGRhdGVGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRIb3Zlck92ZXJsYXlJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJPdmVybGF5SW5mbztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRDbGlja092ZXJsYXlJbmZvID0gZnVuY3Rpb24gKGluZm8sIGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB2YXIgX2cgPSB0aGlzLl9jbGlja092ZXJsYXlJbmZvLCBwYW5lSWQgPSBfZy5wYW5lSWQsIG92ZXJsYXkgPSBfZy5vdmVybGF5LCBmaWd1cmVUeXBlID0gX2cuZmlndXJlVHlwZSwgZmlndXJlID0gX2cuZmlndXJlLCBmaWd1cmVJbmRleCA9IF9nLmZpZ3VyZUluZGV4O1xuICAgICAgICB2YXIgaW5mb092ZXJsYXkgPSBpbmZvLm92ZXJsYXk7XG4gICAgICAgIGlmICgoISgoX2EgPSBpbmZvT3ZlcmxheSA9PT0gbnVsbCB8fCBpbmZvT3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb092ZXJsYXkuaXNEcmF3aW5nKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKSkgJiYgY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uQ2xpY2snLCBpbmZvLmZpZ3VyZSkpIHtcbiAgICAgICAgICAgIChfYiA9IGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbmZvT3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogdGhpcy5fY2hhcnQsIG92ZXJsYXk6IGluZm9PdmVybGF5LCBmaWd1cmU6IChfYyA9IGluZm8uZmlndXJlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQgfSwgZXZlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5pZCkgIT09IChpbmZvT3ZlcmxheSA9PT0gbnVsbCB8fCBpbmZvT3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb092ZXJsYXkuaWQpIHx8IGZpZ3VyZVR5cGUgIT09IGluZm8uZmlndXJlVHlwZSB8fCBmaWd1cmVJbmRleCAhPT0gaW5mby5maWd1cmVJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tPdmVybGF5SW5mbyA9IGluZm87XG4gICAgICAgICAgICBpZiAoKG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5pZCkgIT09IChpbmZvT3ZlcmxheSA9PT0gbnVsbCB8fCBpbmZvT3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb092ZXJsYXkuaWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvbkRlc2VsZWN0ZWQnLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5vbkRlc2VsZWN0ZWQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IHRoaXMuX2NoYXJ0LCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmU6IGZpZ3VyZSAhPT0gbnVsbCAmJiBmaWd1cmUgIT09IHZvaWQgMCA/IGZpZ3VyZSA6IHVuZGVmaW5lZCB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uU2VsZWN0ZWQnLCBpbmZvLmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9lID0gaW5mb092ZXJsYXkgPT09IG51bGwgfHwgaW5mb092ZXJsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9PdmVybGF5Lm9uU2VsZWN0ZWQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKGluZm9PdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiB0aGlzLl9jaGFydCwgb3ZlcmxheTogaW5mb092ZXJsYXksIGZpZ3VyZTogKF9mID0gaW5mby5maWd1cmUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHVuZGVmaW5lZCB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgaW5mby5wYW5lSWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lSWQgIT09IGluZm8ucGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBwYW5lSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRDbGlja092ZXJsYXlJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpY2tPdmVybGF5SW5mbztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5pc092ZXJsYXlFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlzLnNpemUgPT09IDAgJiYgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyA9PT0gbnVsbDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5pc092ZXJsYXlEcmF3aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJsYXkuaXNEcmF3aW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmNsZWFyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmJhY2t3YXJkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvYWREYXRhTW9yZS5mb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRhTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VEYXRhTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2UgPSBbXG4gICAgICAgICAgICB7IHg6IDAsIHByaWNlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9LFxuICAgICAgICAgICAgeyB4OiAwLCBwcmljZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2UgPSBnZXREZWZhdWx0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHRoaXMuX3RpbWVXZWlnaHRUaWNrTWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3RpbWVXZWlnaHRUaWNrTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9jcm9zc2hhaXIgPSB7fTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvID0gbnVsbDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRDaGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0O1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JlSW1wO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgV2lkZ2V0TmFtZUNvbnN0YW50cyA9IHtcbiAgICBNQUlOOiAnbWFpbicsXG4gICAgWF9BWElTOiAneEF4aXMnLFxuICAgIFlfQVhJUzogJ3lBeGlzJyxcbiAgICBTRVBBUkFUT1I6ICdzZXBhcmF0b3InXG59O1xudmFyIFJFQUxfU0VQQVJBVE9SX0hFSUdIVCA9IDc7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWREZXZpY2VQaXhlbENvbnRlbnRCb3goKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyaWVzLmV2ZXJ5KGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gJ2RldmljZVBpeGVsQ29udGVudEJveFNpemUnIGluIGVudHJ5OyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByby5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL2F2b2lkLW5ldyAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG52YXIgQ2FudmFzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbnZhcyhzdHlsZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkRGV2aWNlUGl4ZWxDb250ZW50Qm94ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fcGl4ZWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX3BpeGVsSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fbmV4dFBpeGVsV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9uZXh0UGl4ZWxIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0QW5pbWF0aW9uSWQgPSBERUZBVUxUX1JFUVVFU1RfSUQ7XG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhfdGhpcy5fZWxlbWVudCk7XG4gICAgICAgICAgICBfdGhpcy5fbmV4dFBpeGVsV2lkdGggPSBNYXRoLnJvdW5kKF90aGlzLl9lbGVtZW50LmNsaWVudFdpZHRoICogcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBfdGhpcy5fbmV4dFBpeGVsSGVpZ2h0ID0gTWF0aC5yb3VuZChfdGhpcy5fZWxlbWVudC5jbGllbnRIZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGNyZWF0ZURvbSgnY2FudmFzJywgc3R5bGUpO1xuICAgICAgICB0aGlzLl9jdHggPSB0aGlzLl9lbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlzU3VwcG9ydGVkRGV2aWNlUGl4ZWxDb250ZW50Qm94KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBfdGhpcy5fc3VwcG9ydGVkRGV2aWNlUGl4ZWxDb250ZW50Qm94ID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS50YXJnZXQgPT09IF90aGlzLl9lbGVtZW50OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBlbnRyeSA9PT0gbnVsbCB8fCBlbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cnkuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9uZXh0UGl4ZWxXaWR0aCA9IHNpemUuaW5saW5lU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9uZXh0UGl4ZWxIZWlnaHQgPSBzaXplLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcGl4ZWxXaWR0aCAhPT0gX3RoaXMuX25leHRQaXhlbFdpZHRoIHx8IF90aGlzLl9waXhlbEhlaWdodCAhPT0gX3RoaXMuX25leHRQaXhlbEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKF90aGlzLl9lbGVtZW50LCB7IGJveDogJ2RldmljZS1waXhlbC1jb250ZW50LWJveCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWVkaWFRdWVyeUxpc3QgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihyZXNvbHV0aW9uOiBcIi5jb25jYXQoZ2V0UGl4ZWxSYXRpbyhfdGhpcy5fZWxlbWVudCksIFwiZHBweClcIikpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZGVwcmVjYXRlZCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWVkaWFRdWVyeUxpc3QuYWRkTGlzdGVuZXIoX3RoaXMuX21lZGlhUXVlcnlMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChfKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgfVxuICAgIENhbnZhcy5wcm90b3R5cGUuX3Jlc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IF90aGlzLl9lbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IF90aGlzLl9lbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgX3RoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLl9waXhlbFdpZHRoID0gX3RoaXMuX25leHRQaXhlbFdpZHRoO1xuICAgICAgICAgICAgX3RoaXMuX3BpeGVsSGVpZ2h0ID0gX3RoaXMuX25leHRQaXhlbEhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50LndpZHRoID0gX3RoaXMuX25leHRQaXhlbFdpZHRoO1xuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnQuaGVpZ2h0ID0gX3RoaXMuX25leHRQaXhlbEhlaWdodDtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsUGl4ZWxSYXRpbyA9IF90aGlzLl9uZXh0UGl4ZWxXaWR0aCAvIHdpZHRoO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsUGl4ZWxSYXRpbyA9IF90aGlzLl9uZXh0UGl4ZWxIZWlnaHQgLyBoZWlnaHQ7XG4gICAgICAgICAgICBfdGhpcy5fY3R4LnNjYWxlKGhvcml6b250YWxQaXhlbFJhdGlvLCB2ZXJ0aWNhbFBpeGVsUmF0aW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUuX2V4ZWN1dGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEFuaW1hdGlvbklkID09PSBERUZBVUxUX1JFUVVFU1RfSUQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgX3RoaXMuX3dpZHRoLCBfdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmbiA9PT0gbnVsbCB8fCBmbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm4oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdEFuaW1hdGlvbklkID0gREVGQVVMVF9SRVFVRVNUX0lEO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHcsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9PSB3IHx8IHRoaXMuX2hlaWdodCAhPT0gaCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHcsIFwicHhcIik7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGgsIFwicHhcIik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRlZERldmljZVBpeGVsQ29udGVudEJveCkge1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0UGl4ZWxXaWR0aCA9IE1hdGgucm91bmQodyAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRQaXhlbEhlaWdodCA9IE1hdGgucm91bmQoaCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgfTtcbiAgICBDYW52YXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX21lZGlhUXVlcnlMaXN0KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1kZXByZWNhdGVkIC0tIGlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QucmVtb3ZlTGlzdGVuZXIodGhpcy5fbWVkaWFRdWVyeUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbnZhcztcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ib3VuZGluZyA9IGNyZWF0ZURlZmF1bHRCb3VuZGluZygpO1xuICAgICAgICBfdGhpcy5fcGFuZSA9IHBhbmU7XG4gICAgICAgIF90aGlzLl9yb290Q29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcbiAgICAgICAgX3RoaXMuX2NvbnRhaW5lciA9IF90aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICByb290Q29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLl9jb250YWluZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdpZGdldC5wcm90b3R5cGUuc2V0Qm91bmRpbmcgPSBmdW5jdGlvbiAoYm91bmRpbmcpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fYm91bmRpbmcsIGJvdW5kaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXaWRnZXQucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjsgfTtcbiAgICBXaWRnZXQucHJvdG90eXBlLmdldEJvdW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRpbmc7XG4gICAgfTtcbiAgICBXaWRnZXQucHJvdG90eXBlLmdldFBhbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYW5lO1xuICAgIH07XG4gICAgV2lkZ2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVJbXAodGhpcy5fY29udGFpbmVyLCB0aGlzLl9ib3VuZGluZywgbGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHZvaWQgMCA/IGxldmVsIDogMyAvKiBVcGRhdGVMZXZlbC5EcmF3ZXIgKi8pO1xuICAgIH07XG4gICAgV2lkZ2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb290Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gV2lkZ2V0O1xufShFdmVudGZ1bCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBEcmF3V2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3V2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYXdXaWRnZXQocm9vdENvbnRhaW5lciwgcGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290Q29udGFpbmVyLCBwYW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fbWFpbkNhbnZhcyA9IG5ldyBDYW52YXMoe1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgIHpJbmRleDogJzInLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlTWFpbihfdGhpcy5fbWFpbkNhbnZhcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlDYW52YXMgPSBuZXcgQ2FudmFzKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgICB6SW5kZXg6ICcyJyxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZU92ZXJsYXkoX3RoaXMuX292ZXJsYXlDYW52YXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLl9tYWluQ2FudmFzLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5fb3ZlcmxheUNhbnZhcy5nZXRFbGVtZW50KCkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdXaWRnZXQucHJvdG90eXBlLmNyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURvbSgnZGl2Jywge1xuICAgICAgICAgICAgbWFyZ2luOiAnMCcsXG4gICAgICAgICAgICBwYWRkaW5nOiAnMCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICB6SW5kZXg6ICcxJ1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERyYXdXaWRnZXQucHJvdG90eXBlLnVwZGF0ZUltcCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGJvdW5kaW5nLCBsZXZlbCkge1xuICAgICAgICB2YXIgd2lkdGggPSBib3VuZGluZy53aWR0aCwgaGVpZ2h0ID0gYm91bmRpbmcuaGVpZ2h0LCBsZWZ0ID0gYm91bmRpbmcubGVmdDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChsZWZ0LCBcInB4XCIpO1xuICAgICAgICB2YXIgbCA9IGxldmVsO1xuICAgICAgICB2YXIgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAod2lkdGggIT09IHcgfHwgaGVpZ2h0ICE9PSBoKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICBsID0gMyAvKiBVcGRhdGVMZXZlbC5EcmF3ZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChsKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogVXBkYXRlTGV2ZWwuTWFpbiAqLzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX21haW5DYW52YXMudXBkYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi86IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdmVybGF5Q2FudmFzLnVwZGF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMyAvKiBVcGRhdGVMZXZlbC5EcmF3ZXIgKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogVXBkYXRlTGV2ZWwuQWxsICovOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFpbkNhbnZhcy51cGRhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUNhbnZhcy51cGRhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdXaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21haW5DYW52YXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9vdmVybGF5Q2FudmFzLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIERyYXdXaWRnZXQucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKGluY2x1ZGVPdmVybGF5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Qm91bmRpbmcoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlRG9tKCdjYW52YXMnLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXMpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fbWFpbkNhbnZhcy5nZXRFbGVtZW50KCksIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAoaW5jbHVkZU92ZXJsYXkpIHtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fb3ZlcmxheUNhbnZhcy5nZXRFbGVtZW50KCksIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcbiAgICByZXR1cm4gRHJhd1dpZGdldDtcbn0oV2lkZ2V0KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT25DaXJjbGUoY29vcmRpbmF0ZSwgYXR0cnMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgY2lyY2xlcyA9IFtdO1xuICAgIGNpcmNsZXMgPSBjaXJjbGVzLmNvbmNhdChhdHRycyk7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgY2lyY2xlc18xID0gX192YWx1ZXMoY2lyY2xlcyksIGNpcmNsZXNfMV8xID0gY2lyY2xlc18xLm5leHQoKTsgIWNpcmNsZXNfMV8xLmRvbmU7IGNpcmNsZXNfMV8xID0gY2lyY2xlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNpcmNsZV8xID0gY2lyY2xlc18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgeCA9IGNpcmNsZV8xLngsIHkgPSBjaXJjbGVfMS55LCByID0gY2lyY2xlXzEucjtcbiAgICAgICAgICAgIHZhciBkaWZYID0gY29vcmRpbmF0ZS54IC0geDtcbiAgICAgICAgICAgIHZhciBkaWZZID0gY29vcmRpbmF0ZS55IC0geTtcbiAgICAgICAgICAgIGlmICghKGRpZlggKiBkaWZYICsgZGlmWSAqIGRpZlkgPiByICogcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNpcmNsZXNfMV8xICYmICFjaXJjbGVzXzFfMS5kb25lICYmIChfYSA9IGNpcmNsZXNfMS5yZXR1cm4pKSBfYS5jYWxsKGNpcmNsZXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3Q2lyY2xlKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgIHZhciBjaXJjbGVzID0gW107XG4gICAgY2lyY2xlcyA9IGNpcmNsZXMuY29uY2F0KGF0dHJzKTtcbiAgICB2YXIgX2EgPSBzdHlsZXMuc3R5bGUsIHN0eWxlID0gX2EgPT09IHZvaWQgMCA/IFBvbHlnb25UeXBlLkZpbGwgOiBfYSwgX2IgPSBzdHlsZXMuY29sb3IsIGNvbG9yID0gX2IgPT09IHZvaWQgMCA/ICdjdXJyZW50Q29sb3InIDogX2IsIF9jID0gc3R5bGVzLmJvcmRlclNpemUsIGJvcmRlclNpemUgPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLCBfZCA9IHN0eWxlcy5ib3JkZXJDb2xvciwgYm9yZGVyQ29sb3IgPSBfZCA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfZCwgX2UgPSBzdHlsZXMuYm9yZGVyU3R5bGUsIGJvcmRlclN0eWxlID0gX2UgPT09IHZvaWQgMCA/IExpbmVUeXBlLlNvbGlkIDogX2UsIF9mID0gc3R5bGVzLmJvcmRlckRhc2hlZFZhbHVlLCBib3JkZXJEYXNoZWRWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyBbMiwgMl0gOiBfZjtcbiAgICB2YXIgc29saWQgPSAoc3R5bGUgPT09IFBvbHlnb25UeXBlLkZpbGwgfHwgc3R5bGVzLnN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2VGaWxsKSAmJiAoIWlzU3RyaW5nKGNvbG9yKSB8fCAhaXNUcmFuc3BhcmVudChjb2xvcikpO1xuICAgIGlmIChzb2xpZCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGNpcmNsZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHIgPSBfYS5yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChzdHlsZSA9PT0gUG9seWdvblR5cGUuU3Ryb2tlIHx8IHN0eWxlcy5zdHlsZSA9PT0gUG9seWdvblR5cGUuU3Ryb2tlRmlsbCkgJiYgYm9yZGVyU2l6ZSA+IDAgJiYgIWlzVHJhbnNwYXJlbnQoYm9yZGVyQ29sb3IpKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyU2l6ZTtcbiAgICAgICAgaWYgKGJvcmRlclN0eWxlID09PSBMaW5lVHlwZS5EYXNoZWQpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGNpcmNsZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHIgPSBfYS5yO1xuICAgICAgICAgICAgaWYgKCFzb2xpZCB8fCByID4gYm9yZGVyU2l6ZSkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG52YXIgY2lyY2xlID0ge1xuICAgIG5hbWU6ICdjaXJjbGUnLFxuICAgIGNoZWNrRXZlbnRPbjogY2hlY2tDb29yZGluYXRlT25DaXJjbGUsXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICBkcmF3Q2lyY2xlKGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPblBvbHlnb24oY29vcmRpbmF0ZSwgYXR0cnMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLmNvbmNhdChhdHRycyk7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgcG9seWdvbnNfMSA9IF9fdmFsdWVzKHBvbHlnb25zKSwgcG9seWdvbnNfMV8xID0gcG9seWdvbnNfMS5uZXh0KCk7ICFwb2x5Z29uc18xXzEuZG9uZTsgcG9seWdvbnNfMV8xID0gcG9seWdvbnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uXzEgPSBwb2x5Z29uc18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IHBvbHlnb25fMS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoY29vcmRpbmF0ZXNbaV0ueSA+IGNvb3JkaW5hdGUueSkgIT09IChjb29yZGluYXRlc1tqXS55ID4gY29vcmRpbmF0ZS55KSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29vcmRpbmF0ZS54IDwgKGNvb3JkaW5hdGVzW2pdLnggLSBjb29yZGluYXRlc1tpXS54KSAqIChjb29yZGluYXRlLnkgLSBjb29yZGluYXRlc1tpXS55KSAvIChjb29yZGluYXRlc1tqXS55IC0gY29vcmRpbmF0ZXNbaV0ueSkgKyBjb29yZGluYXRlc1tpXS54KSkge1xuICAgICAgICAgICAgICAgICAgICBvbiA9ICFvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zXzFfMSAmJiAhcG9seWdvbnNfMV8xLmRvbmUgJiYgKF9hID0gcG9seWdvbnNfMS5yZXR1cm4pKSBfYS5jYWxsKHBvbHlnb25zXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd1BvbHlnb24oY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIHBvbHlnb25zID0gW107XG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoYXR0cnMpO1xuICAgIHZhciBfYSA9IHN0eWxlcy5zdHlsZSwgc3R5bGUgPSBfYSA9PT0gdm9pZCAwID8gUG9seWdvblR5cGUuRmlsbCA6IF9hLCBfYiA9IHN0eWxlcy5jb2xvciwgY29sb3IgPSBfYiA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfYiwgX2MgPSBzdHlsZXMuYm9yZGVyU2l6ZSwgYm9yZGVyU2l6ZSA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gc3R5bGVzLmJvcmRlckNvbG9yLCBib3JkZXJDb2xvciA9IF9kID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9kLCBfZSA9IHN0eWxlcy5ib3JkZXJTdHlsZSwgYm9yZGVyU3R5bGUgPSBfZSA9PT0gdm9pZCAwID8gTGluZVR5cGUuU29saWQgOiBfZSwgX2YgPSBzdHlsZXMuYm9yZGVyRGFzaGVkVmFsdWUsIGJvcmRlckRhc2hlZFZhbHVlID0gX2YgPT09IHZvaWQgMCA/IFsyLCAyXSA6IF9mO1xuICAgIGlmICgoc3R5bGUgPT09IFBvbHlnb25UeXBlLkZpbGwgfHwgc3R5bGVzLnN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2VGaWxsKSAmJlxuICAgICAgICAoIWlzU3RyaW5nKGNvbG9yKSB8fCAhaXNUcmFuc3BhcmVudChjb2xvcikpKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb29yZGluYXRlc1swXS54LCBjb29yZGluYXRlc1swXS55KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvb3JkaW5hdGVzW2ldLngsIGNvb3JkaW5hdGVzW2ldLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZSB8fCBzdHlsZXMuc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwpICYmIGJvcmRlclNpemUgPiAwICYmICFpc1RyYW5zcGFyZW50KGJvcmRlckNvbG9yKSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlclNpemU7XG4gICAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gTGluZVR5cGUuRGFzaGVkKSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNvb3JkaW5hdGVzWzBdLngsIGNvb3JkaW5hdGVzWzBdLnkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29vcmRpbmF0ZXNbaV0ueCwgY29vcmRpbmF0ZXNbaV0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciBwb2x5Z29uID0ge1xuICAgIG5hbWU6ICdwb2x5Z29uJyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uUG9seWdvbixcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdQb2x5Z29uKGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPblJlY3QoY29vcmRpbmF0ZSwgYXR0cnMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcmVjdHMgPSBbXTtcbiAgICByZWN0cyA9IHJlY3RzLmNvbmNhdChhdHRycyk7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgcmVjdHNfMSA9IF9fdmFsdWVzKHJlY3RzKSwgcmVjdHNfMV8xID0gcmVjdHNfMS5uZXh0KCk7ICFyZWN0c18xXzEuZG9uZTsgcmVjdHNfMV8xID0gcmVjdHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciByZWN0XzEgPSByZWN0c18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgeCA9IHJlY3RfMS54O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdF8xLndpZHRoO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgREVWSUFUSU9OICogMikge1xuICAgICAgICAgICAgICAgIHggLT0gREVWSUFUSU9OO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gREVWSUFUSU9OICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ID0gcmVjdF8xLnk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdF8xLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCBERVZJQVRJT04gKiAyKSB7XG4gICAgICAgICAgICAgICAgeSAtPSBERVZJQVRJT047XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gREVWSUFUSU9OICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlLnggPj0geCAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueCA8PSB4ICsgd2lkdGggJiZcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPj0geSAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZWN0c18xXzEgJiYgIXJlY3RzXzFfMS5kb25lICYmIChfYSA9IHJlY3RzXzEucmV0dXJuKSkgX2EuY2FsbChyZWN0c18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdSZWN0KGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcmVjdHMgPSBbXTtcbiAgICByZWN0cyA9IHJlY3RzLmNvbmNhdChhdHRycyk7XG4gICAgdmFyIF9iID0gc3R5bGVzLnN0eWxlLCBzdHlsZSA9IF9iID09PSB2b2lkIDAgPyBQb2x5Z29uVHlwZS5GaWxsIDogX2IsIF9jID0gc3R5bGVzLmNvbG9yLCBjb2xvciA9IF9jID09PSB2b2lkIDAgPyAndHJhbnNwYXJlbnQnIDogX2MsIF9kID0gc3R5bGVzLmJvcmRlclNpemUsIGJvcmRlclNpemUgPSBfZCA9PT0gdm9pZCAwID8gMSA6IF9kLCBfZSA9IHN0eWxlcy5ib3JkZXJDb2xvciwgYm9yZGVyQ29sb3IgPSBfZSA9PT0gdm9pZCAwID8gJ3RyYW5zcGFyZW50JyA6IF9lLCBfZiA9IHN0eWxlcy5ib3JkZXJTdHlsZSwgYm9yZGVyU3R5bGUgPSBfZiA9PT0gdm9pZCAwID8gTGluZVR5cGUuU29saWQgOiBfZiwgX2cgPSBzdHlsZXMuYm9yZGVyUmFkaXVzLCByID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZywgX2ggPSBzdHlsZXMuYm9yZGVyRGFzaGVkVmFsdWUsIGJvcmRlckRhc2hlZFZhbHVlID0gX2ggPT09IHZvaWQgMCA/IFsyLCAyXSA6IF9oO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2QsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgdmFyIGRyYXcgPSAoX2EgPSBjdHgucm91bmRSZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHgucmVjdDtcbiAgICB2YXIgc29saWQgPSAoc3R5bGUgPT09IFBvbHlnb25UeXBlLkZpbGwgfHwgc3R5bGVzLnN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2VGaWxsKSAmJiAoIWlzU3RyaW5nKGNvbG9yKSB8fCAhaXNUcmFuc3BhcmVudChjb2xvcikpO1xuICAgIGlmIChzb2xpZCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIHJlY3RzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3ID0gX2Eud2lkdGgsIGggPSBfYS5oZWlnaHQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBkcmF3LmNhbGwoY3R4LCB4LCB5LCB3LCBoLCByKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKHN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2UgfHwgc3R5bGVzLnN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2VGaWxsKSAmJiBib3JkZXJTaXplID4gMCAmJiAhaXNUcmFuc3BhcmVudChib3JkZXJDb2xvcikpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlclNpemU7XG4gICAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gTGluZVR5cGUuRGFzaGVkKSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ycmVjdGlvbl8xID0gYm9yZGVyU2l6ZSAlIDIgPT09IDEgPyAwLjUgOiAwO1xuICAgICAgICB2YXIgZG91YmxlQ29ycmVjdGlvbl8xID0gTWF0aC5yb3VuZChjb3JyZWN0aW9uXzEgKiAyKTtcbiAgICAgICAgcmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHcgPSBfYS53aWR0aCwgaCA9IF9hLmhlaWdodDtcbiAgICAgICAgICAgIGlmICh3ID4gYm9yZGVyU2l6ZSAqIDIgJiYgaCA+IGJvcmRlclNpemUgKiAyKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGRyYXcuY2FsbChjdHgsIHggKyBjb3JyZWN0aW9uXzEsIHkgKyBjb3JyZWN0aW9uXzEsIHcgLSBkb3VibGVDb3JyZWN0aW9uXzEsIGggLSBkb3VibGVDb3JyZWN0aW9uXzEsIHIpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciByZWN0ID0ge1xuICAgIG5hbWU6ICdyZWN0JyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uUmVjdCxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdSZWN0KGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRUZXh0UmVjdChhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIF9hID0gc3R5bGVzLnNpemUsIHNpemUgPSBfYSA9PT0gdm9pZCAwID8gMTIgOiBfYSwgX2IgPSBzdHlsZXMucGFkZGluZ0xlZnQsIHBhZGRpbmdMZWZ0ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBzdHlsZXMucGFkZGluZ1RvcCwgcGFkZGluZ1RvcCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gc3R5bGVzLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBzdHlsZXMucGFkZGluZ0JvdHRvbSwgcGFkZGluZ0JvdHRvbSA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gc3R5bGVzLndlaWdodCwgd2VpZ2h0ID0gX2YgPT09IHZvaWQgMCA/ICdub3JtYWwnIDogX2YsIGZhbWlseSA9IHN0eWxlcy5mYW1pbHk7XG4gICAgdmFyIHggPSBhdHRycy54LCB5ID0gYXR0cnMueSwgdGV4dCA9IGF0dHJzLnRleHQsIF9nID0gYXR0cnMuYWxpZ24sIGFsaWduID0gX2cgPT09IHZvaWQgMCA/ICdsZWZ0JyA6IF9nLCBfaCA9IGF0dHJzLmJhc2VsaW5lLCBiYXNlbGluZSA9IF9oID09PSB2b2lkIDAgPyAndG9wJyA6IF9oLCB3ID0gYXR0cnMud2lkdGgsIGggPSBhdHRycy5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gdyAhPT0gbnVsbCAmJiB3ICE9PSB2b2lkIDAgPyB3IDogKHBhZGRpbmdMZWZ0ICsgY2FsY1RleHRXaWR0aCh0ZXh0LCBzaXplLCB3ZWlnaHQsIGZhbWlseSkgKyBwYWRkaW5nUmlnaHQpO1xuICAgIHZhciBoZWlnaHQgPSBoICE9PSBudWxsICYmIGggIT09IHZvaWQgMCA/IGggOiAocGFkZGluZ1RvcCArIHNpemUgKyBwYWRkaW5nQm90dG9tKTtcbiAgICB2YXIgc3RhcnRYID0gMDtcbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICdzdGFydCc6IHtcbiAgICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2VuZCc6IHtcbiAgICAgICAgICAgIHN0YXJ0WCA9IHggLSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YXJ0WCA9IHggLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RhcnRZID0gMDtcbiAgICBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGNhc2UgJ2hhbmdpbmcnOiB7XG4gICAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgICAgICBjYXNlICdhbHBoYWJldGljJzoge1xuICAgICAgICAgICAgc3RhcnRZID0geSAtIGhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YXJ0WSA9IHkgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9uVGV4dChjb29yZGluYXRlLCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIHRleHRzID0gW107XG4gICAgdGV4dHMgPSB0ZXh0cy5jb25jYXQoYXR0cnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHRleHRzXzEgPSBfX3ZhbHVlcyh0ZXh0cyksIHRleHRzXzFfMSA9IHRleHRzXzEubmV4dCgpOyAhdGV4dHNfMV8xLmRvbmU7IHRleHRzXzFfMSA9IHRleHRzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dF8xID0gdGV4dHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0VGV4dFJlY3QodGV4dF8xLCBzdHlsZXMpLCB4ID0gX2IueCwgeSA9IF9iLnksIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlLnggPj0geCAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueCA8PSB4ICsgd2lkdGggJiZcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPj0geSAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0ZXh0c18xXzEgJiYgIXRleHRzXzFfMS5kb25lICYmIChfYSA9IHRleHRzXzEucmV0dXJuKSkgX2EuY2FsbCh0ZXh0c18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgIHZhciB0ZXh0cyA9IFtdO1xuICAgIHRleHRzID0gdGV4dHMuY29uY2F0KGF0dHJzKTtcbiAgICB2YXIgX2EgPSBzdHlsZXMuY29sb3IsIGNvbG9yID0gX2EgPT09IHZvaWQgMCA/ICdjdXJyZW50Q29sb3InIDogX2EsIF9iID0gc3R5bGVzLnNpemUsIHNpemUgPSBfYiA9PT0gdm9pZCAwID8gMTIgOiBfYiwgZmFtaWx5ID0gc3R5bGVzLmZhbWlseSwgd2VpZ2h0ID0gc3R5bGVzLndlaWdodCwgX2MgPSBzdHlsZXMucGFkZGluZ0xlZnQsIHBhZGRpbmdMZWZ0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBzdHlsZXMucGFkZGluZ1RvcCwgcGFkZGluZ1RvcCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gc3R5bGVzLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZTtcbiAgICB2YXIgcmVjdHMgPSB0ZXh0cy5tYXAoZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGdldFRleHRSZWN0KHRleHQsIHN0eWxlcyk7IH0pO1xuICAgIGRyYXdSZWN0KGN0eCwgcmVjdHMsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXMpLCB7IGNvbG9yOiBzdHlsZXMuYmFja2dyb3VuZENvbG9yIH0pKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQoc2l6ZSwgd2VpZ2h0LCBmYW1pbHkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICB0ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0LCBpbmRleCkge1xuICAgICAgICB2YXIgcmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQudGV4dCwgcmVjdC54ICsgcGFkZGluZ0xlZnQsIHJlY3QueSArIHBhZGRpbmdUb3AsIHJlY3Qud2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodCk7XG4gICAgfSk7XG59XG52YXIgdGV4dCA9IHtcbiAgICBuYW1lOiAndGV4dCcsXG4gICAgY2hlY2tFdmVudE9uOiBjaGVja0Nvb3JkaW5hdGVPblRleHQsXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICBkcmF3VGV4dChjdHgsIGF0dHJzLCBzdHlsZXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKSB7XG4gICAgdmFyIHhEaWYgPSBjb29yZGluYXRlMS54IC0gY29vcmRpbmF0ZTIueDtcbiAgICB2YXIgeURpZiA9IGNvb3JkaW5hdGUxLnkgLSBjb29yZGluYXRlMi55O1xuICAgIHJldHVybiBNYXRoLnNxcnQoeERpZiAqIHhEaWYgKyB5RGlmICogeURpZik7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT25BcmMoY29vcmRpbmF0ZSwgYXR0cnMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgYXJjcyA9IFtdO1xuICAgIGFyY3MgPSBhcmNzLmNvbmNhdChhdHRycyk7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgYXJjc18xID0gX192YWx1ZXMoYXJjcyksIGFyY3NfMV8xID0gYXJjc18xLm5leHQoKTsgIWFyY3NfMV8xLmRvbmU7IGFyY3NfMV8xID0gYXJjc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGFyY18xID0gYXJjc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZSwgYXJjXzEpIC0gYXJjXzEucikgPCBERVZJQVRJT04pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGFyY18xLnIsIHN0YXJ0QW5nbGUgPSBhcmNfMS5zdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGFyY18xLmVuZEFuZ2xlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENvb3JkaW5hdGVYID0gciAqIE1hdGguY29zKHN0YXJ0QW5nbGUpICsgYXJjXzEueDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb29yZGluYXRlWSA9IHIgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSArIGFyY18xLnk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvb3JkaW5hdGVYID0gciAqIE1hdGguY29zKGVuZEFuZ2xlKSArIGFyY18xLng7XG4gICAgICAgICAgICAgICAgdmFyIGVuZENvb3JkaW5hdGVZID0gciAqIE1hdGguc2luKGVuZEFuZ2xlKSArIGFyY18xLnk7XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUueCA8PSBNYXRoLm1heChzdGFydENvb3JkaW5hdGVYLCBlbmRDb29yZGluYXRlWCkgKyBERVZJQVRJT04gJiZcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ID49IE1hdGgubWluKHN0YXJ0Q29vcmRpbmF0ZVgsIGVuZENvb3JkaW5hdGVYKSAtIERFVklBVElPTiAmJlxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPD0gTWF0aC5tYXgoc3RhcnRDb29yZGluYXRlWSwgZW5kQ29vcmRpbmF0ZVkpICsgREVWSUFUSU9OICYmXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA+PSBNYXRoLm1pbihzdGFydENvb3JkaW5hdGVZLCBlbmRDb29yZGluYXRlWSkgLSBERVZJQVRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXJjc18xXzEgJiYgIWFyY3NfMV8xLmRvbmUgJiYgKF9hID0gYXJjc18xLnJldHVybikpIF9hLmNhbGwoYXJjc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIGFyY3MgPSBbXTtcbiAgICBhcmNzID0gYXJjcy5jb25jYXQoYXR0cnMpO1xuICAgIHZhciBfYSA9IHN0eWxlcy5zdHlsZSwgc3R5bGUgPSBfYSA9PT0gdm9pZCAwID8gTGluZVR5cGUuU29saWQgOiBfYSwgX2IgPSBzdHlsZXMuc2l6ZSwgc2l6ZSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsIF9jID0gc3R5bGVzLmNvbG9yLCBjb2xvciA9IF9jID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9jLCBfZCA9IHN0eWxlcy5kYXNoZWRWYWx1ZSwgZGFzaGVkVmFsdWUgPSBfZCA9PT0gdm9pZCAwID8gWzIsIDJdIDogX2Q7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgaWYgKHN0eWxlID09PSBMaW5lVHlwZS5EYXNoZWQpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlZFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgciA9IF9hLnIsIHN0YXJ0QW5nbGUgPSBfYS5zdGFydEFuZ2xlLCBlbmRBbmdsZSA9IF9hLmVuZEFuZ2xlO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9KTtcbn1cbnZhciBhcmMgPSB7XG4gICAgbmFtZTogJ2FyYycsXG4gICAgY2hlY2tFdmVudE9uOiBjaGVja0Nvb3JkaW5hdGVPbkFyYyxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdBcmMoY3R4LCBhdHRycywgc3R5bGVzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGRyYXdFbGxpcHRpY2FsQXJjKGN0eCwgeDEsIHkxLCBhcmdzLCBvZmZzZXRYLCBvZmZzZXRZLCBpc1JlbGF0aXZlKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKGFyZ3MsIDcpLCByeCA9IF9hWzBdLCByeSA9IF9hWzFdLCByb3RhdGlvbiA9IF9hWzJdLCBsYXJnZUFyY0ZsYWcgPSBfYVszXSwgc3dlZXBGbGFnID0gX2FbNF0sIHgyID0gX2FbNV0sIHkyID0gX2FbNl07XG4gICAgdmFyIHRhcmdldFggPSBpc1JlbGF0aXZlID8geDEgKyB4MiA6IHgyICsgb2Zmc2V0WDtcbiAgICB2YXIgdGFyZ2V0WSA9IGlzUmVsYXRpdmUgPyB5MSArIHkyIDogeTIgKyBvZmZzZXRZO1xuICAgIHZhciBzZWdtZW50cyA9IGVsbGlwdGljYWxBcmNUb0JlemllcnMoeDEsIHkxLCByeCwgcnksIHJvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgdGFyZ2V0WCwgdGFyZ2V0WSk7XG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCBzZWdtZW50WzNdLCBzZWdtZW50WzRdLCBzZWdtZW50WzVdKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVsbGlwdGljYWxBcmNUb0JlemllcnMoeDEsIHkxLCByeCwgcnksIHJvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeDIsIHkyKSB7XG4gICAgdmFyIF9hID0gY29tcHV0ZUVsbGlwdGljYWxBcmNQYXJhbWV0ZXJzKHgxLCB5MSwgcngsIHJ5LCByb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgyLCB5MiksIGN4ID0gX2EuY3gsIGN5ID0gX2EuY3ksIHN0YXJ0QW5nbGUgPSBfYS5zdGFydEFuZ2xlLCBkZWx0YUFuZ2xlID0gX2EuZGVsdGFBbmdsZTtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICB2YXIgbnVtU2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGVsdGFBbmdsZSkgLyAoTWF0aC5QSSAvIDIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRBbmdsZSArIChpICogZGVsdGFBbmdsZSkgLyBudW1TZWdtZW50cztcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0QW5nbGUgKyAoKGkgKyAxKSAqIGRlbHRhQW5nbGUpIC8gbnVtU2VnbWVudHM7XG4gICAgICAgIHZhciBiZXppZXIgPSBlbGxpcHRpY2FsQXJjVG9CZXppZXIoY3gsIGN5LCByeCwgcnksIHJvdGF0aW9uLCBzdGFydCwgZW5kKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChiZXppZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudHM7XG59XG5mdW5jdGlvbiBjb21wdXRlRWxsaXB0aWNhbEFyY1BhcmFtZXRlcnMoeDEsIHkxLCByeCwgcnksIHJvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeDIsIHkyKSB7XG4gICAgdmFyIHBoaSA9IChyb3RhdGlvbiAqIE1hdGguUEkpIC8gMTgwO1xuICAgIHZhciBkeCA9ICh4MSAtIHgyKSAvIDI7XG4gICAgdmFyIGR5ID0gKHkxIC0geTIpIC8gMjtcbiAgICB2YXIgeDFwID0gTWF0aC5jb3MocGhpKSAqIGR4ICsgTWF0aC5zaW4ocGhpKSAqIGR5O1xuICAgIHZhciB5MXAgPSAtTWF0aC5zaW4ocGhpKSAqIGR4ICsgTWF0aC5jb3MocGhpKSAqIGR5O1xuICAgIHZhciBsYW1iZGEgPSAoTWF0aC5wb3coeDFwLCAyKSkgLyAoTWF0aC5wb3cocngsIDIpKSArIChNYXRoLnBvdyh5MXAsIDIpKSAvIChNYXRoLnBvdyhyeSwgMikpO1xuICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgICAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICB9XG4gICAgdmFyIHNpZ24gPSBsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMTtcbiAgICB2YXIgbnVtZXJhdG9yID0gKE1hdGgucG93KHJ4LCAyKSkgKiAoTWF0aC5wb3cocnksIDIpKSAtIChNYXRoLnBvdyhyeCwgMikpICogKE1hdGgucG93KHkxcCwgMikpIC0gKE1hdGgucG93KHJ5LCAyKSkgKiAoTWF0aC5wb3coeDFwLCAyKSk7XG4gICAgdmFyIGRlbm9taW5hdG9yID0gKE1hdGgucG93KHJ4LCAyKSkgKiAoTWF0aC5wb3coeTFwLCAyKSkgKyAoTWF0aC5wb3cocnksIDIpKSAqIChNYXRoLnBvdyh4MXAsIDIpKTtcbiAgICB2YXIgY3hwID0gc2lnbiAqIE1hdGguc3FydChNYXRoLmFicyhudW1lcmF0b3IgLyBkZW5vbWluYXRvcikpICogKHJ4ICogeTFwIC8gcnkpO1xuICAgIHZhciBjeXAgPSBzaWduICogTWF0aC5zcXJ0KE1hdGguYWJzKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKSkgKiAoLXJ5ICogeDFwIC8gcngpO1xuICAgIHZhciBjeCA9IE1hdGguY29zKHBoaSkgKiBjeHAgLSBNYXRoLnNpbihwaGkpICogY3lwICsgKHgxICsgeDIpIC8gMjtcbiAgICB2YXIgY3kgPSBNYXRoLnNpbihwaGkpICogY3hwICsgTWF0aC5jb3MocGhpKSAqIGN5cCArICh5MSArIHkyKSAvIDI7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKCh5MXAgLSBjeXApIC8gcnksICh4MXAgLSBjeHApIC8gcngpO1xuICAgIHZhciBkZWx0YUFuZ2xlID0gTWF0aC5hdGFuMigoLXkxcCAtIGN5cCkgLyByeSwgKC14MXAgLSBjeHApIC8gcngpIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoZGVsdGFBbmdsZSA8IDAgJiYgc3dlZXBGbGFnID09PSAxKSB7XG4gICAgICAgIGRlbHRhQW5nbGUgKz0gMiAqIE1hdGguUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlbHRhQW5nbGUgPiAwICYmIHN3ZWVwRmxhZyA9PT0gMCkge1xuICAgICAgICBkZWx0YUFuZ2xlIC09IDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICByZXR1cm4geyBjeDogY3gsIGN5OiBjeSwgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSwgZGVsdGFBbmdsZTogZGVsdGFBbmdsZSB9O1xufVxuLyoqXG4gKiBFbGxpcHNlIGFyYyBzZWdtZW50IHRvIEJlemllciBjdXJ2ZVxuICogQHBhcmFtIGN4XG4gKiBAcGFyYW0gY3lcbiAqIEBwYXJhbSByeFxuICogQHBhcmFtIHJ5XG4gKiBAcGFyYW0gcm90YXRpb25cbiAqIEBwYXJhbSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gZW5kQW5nbGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVsbGlwdGljYWxBcmNUb0JlemllcihjeCwgY3ksIHJ4LCByeSwgcm90YXRpb24sIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgLy8g6K6h566X5o6n5Yi254K5XG4gICAgdmFyIGFscGhhID0gTWF0aC5zaW4oZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAqIChNYXRoLnNxcnQoNCArIDMgKiBNYXRoLnBvdyhNYXRoLnRhbigoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpLCAyKSkgLSAxKSAvIDM7XG4gICAgdmFyIGNvc1BoaSA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICB2YXIgc2luUGhpID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICAgIHZhciB4MSA9IGN4ICsgcnggKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIGNvc1BoaSAtIHJ5ICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiBzaW5QaGk7XG4gICAgdmFyIHkxID0gY3kgKyByeCAqIE1hdGguY29zKHN0YXJ0QW5nbGUpICogc2luUGhpICsgcnkgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIGNvc1BoaTtcbiAgICB2YXIgeDIgPSBjeCArIHJ4ICogTWF0aC5jb3MoZW5kQW5nbGUpICogY29zUGhpIC0gcnkgKiBNYXRoLnNpbihlbmRBbmdsZSkgKiBzaW5QaGk7XG4gICAgdmFyIHkyID0gY3kgKyByeCAqIE1hdGguY29zKGVuZEFuZ2xlKSAqIHNpblBoaSArIHJ5ICogTWF0aC5zaW4oZW5kQW5nbGUpICogY29zUGhpO1xuICAgIHZhciBjcDF4ID0geDEgKyBhbHBoYSAqICgtcnggKiBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIGNvc1BoaSAtIHJ5ICogTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiBzaW5QaGkpO1xuICAgIHZhciBjcDF5ID0geTEgKyBhbHBoYSAqICgtcnggKiBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHNpblBoaSArIHJ5ICogTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiBjb3NQaGkpO1xuICAgIHZhciBjcDJ4ID0geDIgLSBhbHBoYSAqICgtcnggKiBNYXRoLnNpbihlbmRBbmdsZSkgKiBjb3NQaGkgLSByeSAqIE1hdGguY29zKGVuZEFuZ2xlKSAqIHNpblBoaSk7XG4gICAgdmFyIGNwMnkgPSB5MiAtIGFscGhhICogKC1yeCAqIE1hdGguc2luKGVuZEFuZ2xlKSAqIHNpblBoaSArIHJ5ICogTWF0aC5jb3MoZW5kQW5nbGUpICogY29zUGhpKTtcbiAgICByZXR1cm4gW2NwMXgsIGNwMXksIGNwMngsIGNwMnksIHgyLCB5Ml07XG59XG5mdW5jdGlvbiBkcmF3UGF0aChjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICBwYXRocyA9IHBhdGhzLmNvbmNhdChhdHRycyk7XG4gICAgdmFyIF9hID0gc3R5bGVzLmxpbmVXaWR0aCwgbGluZVdpZHRoID0gX2EgPT09IHZvaWQgMCA/IDEgOiBfYSwgX2IgPSBzdHlsZXMuY29sb3IsIGNvbG9yID0gX2IgPT09IHZvaWQgMCA/ICdjdXJyZW50Q29sb3InIDogX2I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHBhdGggPSBfYS5wYXRoO1xuICAgICAgICB2YXIgY29tbWFuZHMgPSBwYXRoLm1hdGNoKC9bTUxIVkNTUVRBWl1bXk1MSFZDU1FUQVpdKi9naSk7XG4gICAgICAgIGlmIChpc1ZhbGlkKGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldFhfMSA9IHg7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WV8xID0geTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50WSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kWzBdO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gY29tbWFuZC5zbGljZSgxKS50cmltKCkuc3BsaXQoL1tcXHMsXSsvKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbMF0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbMV0gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBjdXJyZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGN1cnJlbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZICs9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBjdXJyZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGN1cnJlbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggPSBhcmdzWzBdICsgb2Zmc2V0WF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBhcmdzWzFdICsgb2Zmc2V0WV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50WCwgY3VycmVudFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZICs9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbMF0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50WCwgY3VycmVudFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBhcmdzWzBdICsgb2Zmc2V0WV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50WCwgY3VycmVudFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3NbMF0gKyBvZmZzZXRYXzEsIGFyZ3NbMV0gKyBvZmZzZXRZXzEsIGFyZ3NbMl0gKyBvZmZzZXRYXzEsIGFyZ3NbM10gKyBvZmZzZXRZXzEsIGFyZ3NbNF0gKyBvZmZzZXRYXzEsIGFyZ3NbNV0gKyBvZmZzZXRZXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggPSBhcmdzWzRdICsgb2Zmc2V0WF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBhcmdzWzVdICsgb2Zmc2V0WV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3VycmVudFggKyBhcmdzWzBdLCBjdXJyZW50WSArIGFyZ3NbMV0sIGN1cnJlbnRYICsgYXJnc1syXSwgY3VycmVudFkgKyBhcmdzWzNdLCBjdXJyZW50WCArIGFyZ3NbNF0sIGN1cnJlbnRZICsgYXJnc1s1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1s1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRYLCBjdXJyZW50WSwgYXJnc1swXSArIG9mZnNldFhfMSwgYXJnc1sxXSArIG9mZnNldFlfMSwgYXJnc1syXSArIG9mZnNldFhfMSwgYXJnc1szXSArIG9mZnNldFlfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbMl0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbM10gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjdXJyZW50WCwgY3VycmVudFksIGN1cnJlbnRYICsgYXJnc1swXSwgY3VycmVudFkgKyBhcmdzWzFdLCBjdXJyZW50WCArIGFyZ3NbMl0sIGN1cnJlbnRZICsgYXJnc1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGFyZ3NbMF0gKyBvZmZzZXRYXzEsIGFyZ3NbMV0gKyBvZmZzZXRZXzEsIGFyZ3NbMl0gKyBvZmZzZXRYXzEsIGFyZ3NbM10gKyBvZmZzZXRZXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggPSBhcmdzWzJdICsgb2Zmc2V0WF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBhcmdzWzNdICsgb2Zmc2V0WV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFggKyBhcmdzWzBdLCBjdXJyZW50WSArIGFyZ3NbMV0sIGN1cnJlbnRYICsgYXJnc1syXSwgY3VycmVudFkgKyBhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSArPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFgsIGN1cnJlbnRZLCBhcmdzWzBdICsgb2Zmc2V0WF8xLCBhcmdzWzFdICsgb2Zmc2V0WV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gYXJnc1swXSArIG9mZnNldFhfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZID0gYXJnc1sxXSArIG9mZnNldFlfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnRYLCBjdXJyZW50WSwgY3VycmVudFggKyBhcmdzWzBdLCBjdXJyZW50WSArIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZICs9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0VsbGlwdGljYWxBcmMoY3R4LCBjdXJyZW50WCwgY3VycmVudFksIGFyZ3MsIG9mZnNldFhfMSwgb2Zmc2V0WV8xLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbNV0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbNl0gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0VsbGlwdGljYWxBcmMoY3R4LCBjdXJyZW50WCwgY3VycmVudFksIGFyZ3MsIG9mZnNldFhfMSwgb2Zmc2V0WV8xLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGFyZ3NbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSArPSBhcmdzWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gc3RhcnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBzdGFydFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuc3R5bGUgPT09IFBhdGhUeXBlLkZpbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG52YXIgcGF0aCA9IHtcbiAgICBuYW1lOiAncGF0aCcsXG4gICAgY2hlY2tFdmVudE9uOiBjaGVja0Nvb3JkaW5hdGVPblJlY3QsXG4gICAgZHJhdzogZnVuY3Rpb24gKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICBkcmF3UGF0aChjdHgsIGF0dHJzLCBzdHlsZXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGZpZ3VyZXMgPSB7fTtcbnZhciBleHRlbnNpb25zID0gW2NpcmNsZSwgbGluZSwgcG9seWdvbiwgcmVjdCwgdGV4dCwgYXJjLCBwYXRoXTtcbmV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZmlndXJlKSB7XG4gICAgZmlndXJlc1tmaWd1cmUubmFtZV0gPSBGaWd1cmVJbXAuZXh0ZW5kKGZpZ3VyZSk7XG59KTtcbmZ1bmN0aW9uIGdldFN1cHBvcnRlZEZpZ3VyZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpZ3VyZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJGaWd1cmUoZmlndXJlKSB7XG4gICAgZmlndXJlc1tmaWd1cmUubmFtZV0gPSBGaWd1cmVJbXAuZXh0ZW5kKGZpZ3VyZSk7XG59XG5mdW5jdGlvbiBnZXRJbm5lckZpZ3VyZUNsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IGZpZ3VyZXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRGaWd1cmVDbGFzcyhuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBmaWd1cmVzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXcod2lkZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl93aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlldy5wcm90b3R5cGUuZ2V0V2lkZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fd2lkZ2V0OyB9O1xuICAgIFZpZXcucHJvdG90eXBlLmNyZWF0ZUZpZ3VyZSA9IGZ1bmN0aW9uIChjcmVhdGUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICB2YXIgRmlndXJlQ2xhenogPSBnZXRJbm5lckZpZ3VyZUNsYXNzKGNyZWF0ZS5uYW1lKTtcbiAgICAgICAgaWYgKEZpZ3VyZUNsYXp6ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlndXJlID0gbmV3IEZpZ3VyZUNsYXp6KGNyZWF0ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChldmVudEhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlndXJlLnJlZ2lzdGVyRXZlbnQoa2V5LCBldmVudEhhbmRsZXJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChmaWd1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZ3VyZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBleHRlbmQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dGVuZFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZHJhd0ltcChjdHgsIGV4dGVuZCk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlldztcbn0oRXZlbnRmdWwpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgR3JpZFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyaWRWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyaWRWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEdyaWRWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0LmdldFN0eWxlcygpLmdyaWQ7XG4gICAgICAgIHZhciBzaG93ID0gc3R5bGVzLnNob3c7XG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsU3R5bGVzID0gc3R5bGVzLmhvcml6b250YWw7XG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbFNob3cgPSBob3Jpem9udGFsU3R5bGVzLnNob3c7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbFNob3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB5QXhpcy5nZXRUaWNrcygpLm1hcChmdW5jdGlvbiAodGljaykgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogMCwgeTogdGljay5jb29yZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiBib3VuZGluZy53aWR0aCwgeTogdGljay5jb29yZCB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBob3Jpem9udGFsU3R5bGVzXG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmVydGljYWxTdHlsZXMgPSBzdHlsZXMudmVydGljYWw7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxTaG93ID0gdmVydGljYWxTdHlsZXMuc2hvdztcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbFNob3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0geEF4aXMuZ2V0VGlja3MoKS5tYXAoZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHRpY2suY29vcmQsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogdGljay5jb29yZCwgeTogYm91bmRpbmcuaGVpZ2h0IH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHZlcnRpY2FsU3R5bGVzXG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JpZFZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2hpbGRyZW5WaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGlsZHJlblZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hpbGRyZW5WaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENoaWxkcmVuVmlldy5wcm90b3R5cGUuZWFjaENoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgdmlzaWJsZVJhbmdlRGF0YUxpc3QgPSBjaGFydFN0b3JlLmdldFZpc2libGVSYW5nZURhdGFMaXN0KCk7XG4gICAgICAgIHZhciBiYXJTcGFjZSA9IGNoYXJ0U3RvcmUuZ2V0QmFyU3BhY2UoKTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSB2aXNpYmxlUmFuZ2VEYXRhTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkQ2FsbGJhY2sodmlzaWJsZVJhbmdlRGF0YUxpc3RbaW5kZXhdLCBiYXJTcGFjZSwgaW5kZXgpO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENoaWxkcmVuVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDYW5kbGVCYXJWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYW5kbGVCYXJWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZUJhclZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJndW1lbnRzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fYm91bmRDYW5kbGVCYXJDbGlja0V2ZW50ID0gZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25DYW5kbGVCYXJDbGljaywgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FuZGxlQmFyVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGlzTWFpbiA9IHBhbmUuZ2V0SWQoKSA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY2FuZGxlQmFyT3B0aW9ucyA9IHRoaXMuZ2V0Q2FuZGxlQmFyT3B0aW9ucygpO1xuICAgICAgICBpZiAoY2FuZGxlQmFyT3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHR5cGVfMSA9IGNhbmRsZUJhck9wdGlvbnMudHlwZSwgc3R5bGVzXzEgPSBjYW5kbGVCYXJPcHRpb25zLnN0eWxlcztcbiAgICAgICAgICAgIHZhciBvaGxjU2l6ZV8xID0gMDtcbiAgICAgICAgICAgIHZhciBoYWxmT2hsY1NpemVfMSA9IDA7XG4gICAgICAgICAgICBpZiAoY2FuZGxlQmFyT3B0aW9ucy50eXBlID09PSBDYW5kbGVUeXBlLk9obGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2FwQmFyID0gY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpLmdhcEJhcjtcbiAgICAgICAgICAgICAgICBvaGxjU2l6ZV8xID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5yb3VuZChnYXBCYXIgKiAwLjIpLCAxKSwgOCk7XG4gICAgICAgICAgICAgICAgaWYgKG9obGNTaXplXzEgPiAyICYmIG9obGNTaXplXzEgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9obGNTaXplXzEtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFsZk9obGNTaXplXzEgPSBNYXRoLmZsb29yKGhhbGZPaGxjU2l6ZV8xIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeUF4aXNfMSA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGRyZW4oZnVuY3Rpb24gKHZpc2libGVEYXRhLCBiYXJTcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHZpc2libGVEYXRhLngsIF9iID0gdmlzaWJsZURhdGEuZGF0YSwgY3VycmVudCA9IF9iLmN1cnJlbnQsIHByZXYgPSBfYi5wcmV2O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVuXzEgPSBjdXJyZW50Lm9wZW4sIGhpZ2ggPSBjdXJyZW50LmhpZ2gsIGxvdyA9IGN1cnJlbnQubG93LCBjbG9zZV8xID0gY3VycmVudC5jbG9zZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVQcmljZSA9IHN0eWxlc18xLmNvbXBhcmVSdWxlID09PSBDYW5kbGVDb2xvckNvbXBhcmVSdWxlLkN1cnJlbnRPcGVuID8gb3Blbl8xIDogKChfYSA9IHByZXYgPT09IG51bGwgfHwgcHJldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldi5jbG9zZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xvc2VfMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlXzEgPiBjb21wYXJlUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yc1swXSA9IHN0eWxlc18xLnVwQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMV0gPSBzdHlsZXNfMS51cEJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzJdID0gc3R5bGVzXzEudXBXaWNrQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VfMSA8IGNvbXBhcmVQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzBdID0gc3R5bGVzXzEuZG93bkNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzFdID0gc3R5bGVzXzEuZG93bkJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzJdID0gc3R5bGVzXzEuZG93bldpY2tDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yc1swXSA9IHN0eWxlc18xLm5vQ2hhbmdlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMV0gPSBzdHlsZXNfMS5ub0NoYW5nZUJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzJdID0gc3R5bGVzXzEubm9DaGFuZ2VXaWNrQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5ZID0geUF4aXNfMS5jb252ZXJ0VG9QaXhlbChvcGVuXzEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VZID0geUF4aXNfMS5jb252ZXJ0VG9QaXhlbChjbG9zZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaWNlWSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ZLCBjbG9zZVksXG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhpc18xLmNvbnZlcnRUb1BpeGVsKGhpZ2gpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXNfMS5jb252ZXJ0VG9QaXhlbChsb3cpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHByaWNlWS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0aW9uID0gYmFyU3BhY2UuZ2FwQmFyICUgMiA9PT0gMCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2FuZGxlVHlwZS5DYW5kbGVTb2xpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gX3RoaXMuX2NyZWF0ZVNvbGlkQmFyKHgsIHByaWNlWSwgYmFyU3BhY2UsIGNvbG9ycywgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhbmRsZVR5cGUuQ2FuZGxlU3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMgPSBfdGhpcy5fY3JlYXRlU3Ryb2tlQmFyKHgsIHByaWNlWSwgYmFyU3BhY2UsIGNvbG9ycywgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhbmRsZVR5cGUuQ2FuZGxlVXBTdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VfMSA+IG9wZW5fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cyA9IF90aGlzLl9jcmVhdGVTdHJva2VCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gX3RoaXMuX2NyZWF0ZVNvbGlkQmFyKHgsIHByaWNlWSwgYmFyU3BhY2UsIGNvbG9ycywgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYW5kbGVUeXBlLkNhbmRsZURvd25TdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Blbl8xID4gY2xvc2VfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cyA9IF90aGlzLl9jcmVhdGVTdHJva2VCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gX3RoaXMuX2NyZWF0ZVNvbGlkQmFyKHgsIHByaWNlWSwgYmFyU3BhY2UsIGNvbG9ycywgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYW5kbGVUeXBlLk9obGM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggLSBoYWxmT2hsY1NpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogb2hsY1NpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmljZVlbM10gLSBwcmljZVlbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCAtIGJhclNwYWNlLmhhbGZHYXBCYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9wZW5ZICsgb2hsY1NpemVfMSA+IHByaWNlWVszXSA/IHByaWNlWVszXSAtIG9obGNTaXplXzEgOiBvcGVuWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJhclNwYWNlLmhhbGZHYXBCYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogb2hsY1NpemVfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4ICsgaGFsZk9obGNTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNsb3NlWSArIG9obGNTaXplXzEgPiBwcmljZVlbM10gPyBwcmljZVlbM10gLSBvaGxjU2l6ZV8xIDogY2xvc2VZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFyU3BhY2UuaGFsZkdhcEJhciAtIGhhbGZPaGxjU2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9obGNTaXplXzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiBjb2xvcnNbMF0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VDbGlja0V2ZW50OiBfdGhpcy5fYm91bmRDYW5kbGVCYXJDbGlja0V2ZW50KHZpc2libGVEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5jcmVhdGVGaWd1cmUocmVjdCwgaGFuZGxlciAhPT0gbnVsbCAmJiBoYW5kbGVyICE9PSB2b2lkIDAgPyBoYW5kbGVyIDogdW5kZWZpbmVkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmRsZUJhclZpZXcucHJvdG90eXBlLmdldENhbmRsZUJhck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW5kbGVTdHlsZXMgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldFN0eWxlcygpLmNhbmRsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGNhbmRsZVN0eWxlcy50eXBlLFxuICAgICAgICAgICAgc3R5bGVzOiBjYW5kbGVTdHlsZXMuYmFyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDYW5kbGVCYXJWaWV3LnByb3RvdHlwZS5fY3JlYXRlU29saWRCYXIgPSBmdW5jdGlvbiAoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHByaWNlWVswXSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJpY2VZWzNdIC0gcHJpY2VZWzBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGNvbG9yc1syXSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4OiB4IC0gYmFyU3BhY2UuaGFsZkdhcEJhcixcbiAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzFdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFyU3BhY2UuZ2FwQmFyICsgY29ycmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgxLCBwcmljZVlbMl0gLSBwcmljZVlbMV0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvcnNbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICBDYW5kbGVCYXJWaWV3LnByb3RvdHlwZS5fY3JlYXRlU3Ryb2tlQmFyID0gZnVuY3Rpb24gKHgsIHByaWNlWSwgYmFyU3BhY2UsIGNvbG9ycywgY29ycmVjdGlvbikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICBhdHRyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByaWNlWVsxXSAtIHByaWNlWVswXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByaWNlWVszXSAtIHByaWNlWVsyXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGNvbG9yc1syXSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4OiB4IC0gYmFyU3BhY2UuaGFsZkdhcEJhcixcbiAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzFdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFyU3BhY2UuZ2FwQmFyICsgY29ycmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgxLCBwcmljZVlbMl0gLSBwcmljZVlbMV0pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLlN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHJldHVybiBDYW5kbGVCYXJWaWV3O1xufShDaGlsZHJlblZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSW5kaWNhdG9yVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5kaWNhdG9yVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmRpY2F0b3JWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluZGljYXRvclZpZXcucHJvdG90eXBlLmdldENhbmRsZUJhck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgaWYgKCF5QXhpcy5pc0luQ2FuZGxlKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kaWNhdG9yc18xID0gX192YWx1ZXMoaW5kaWNhdG9ycyksIGluZGljYXRvcnNfMV8xID0gaW5kaWNhdG9yc18xLm5leHQoKTsgIWluZGljYXRvcnNfMV8xLmRvbmU7IGluZGljYXRvcnNfMV8xID0gaW5kaWNhdG9yc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNhdG9yID0gaW5kaWNhdG9yc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3Iuc2hvdWxkT2hsYyAmJiBpbmRpY2F0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljYXRvclN0eWxlcyA9IGluZGljYXRvci5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuaW5kaWNhdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVSdWxlID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yU3R5bGVzLCAnb2hsYy5jb21wYXJlUnVsZScsIGRlZmF1bHRTdHlsZXMub2hsYy5jb21wYXJlUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBDb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvclN0eWxlcywgJ29obGMudXBDb2xvcicsIGRlZmF1bHRTdHlsZXMub2hsYy51cENvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3duQ29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3JTdHlsZXMsICdvaGxjLmRvd25Db2xvcicsIGRlZmF1bHRTdHlsZXMub2hsYy5kb3duQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vQ2hhbmdlQ29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3JTdHlsZXMsICdvaGxjLm5vQ2hhbmdlQ29sb3InLCBkZWZhdWx0U3R5bGVzLm9obGMubm9DaGFuZ2VDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbmRsZVR5cGUuT2hsYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZVJ1bGU6IGNvbXBhcmVSdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cENvbG9yOiB1cENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3duQ29sb3I6IGRvd25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9DaGFuZ2VDb2xvcjogbm9DaGFuZ2VDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBCb3JkZXJDb2xvcjogdXBDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bkJvcmRlckNvbG9yOiBkb3duQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vQ2hhbmdlQm9yZGVyQ29sb3I6IG5vQ2hhbmdlQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwV2lja0NvbG9yOiB1cENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3duV2lja0NvbG9yOiBkb3duQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vQ2hhbmdlV2lja0NvbG9yOiBub0NoYW5nZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yc18xXzEgJiYgIWluZGljYXRvcnNfMV8xLmRvbmUgJiYgKF9hID0gaW5kaWNhdG9yc18xLnJldHVybikpIF9hLmNhbGwoaW5kaWNhdG9yc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSW5kaWNhdG9yVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kcmF3SW1wLmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIHhBeGlzID0gY2hhcnQuZ2V0WEF4aXNQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBjaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgdmFyIGRlZmF1bHRTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmluZGljYXRvcjtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3IuekxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpc0NvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci5kcmF3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzQ292ZXIgPSBpbmRpY2F0b3IuZHJhdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmc6IGJvdW5kaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXM6IHhBeGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzQ292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gaW5kaWNhdG9yLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZWFjaENoaWxkcmVuKGZ1bmN0aW9uIChkYXRhLCBiYXJTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZkdhcEJhciA9IGJhclNwYWNlLmhhbGZHYXBCYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gZGF0YS5kYXRhSW5kZXgsIHggPSBkYXRhLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlggPSB4QXhpcy5jb252ZXJ0VG9QaXhlbChkYXRhSW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0WCA9IHhBeGlzLmNvbnZlcnRUb1BpeGVsKGRhdGFJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEYXRhID0gKF9hID0gcmVzdWx0XzFbZGF0YUluZGV4IC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudERhdGEgPSAoX2IgPSByZXN1bHRfMVtkYXRhSW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHREYXRhID0gKF9jID0gcmVzdWx0XzFbZGF0YUluZGV4ICsgMV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkNvb3JkaW5hdGUgPSB7IHg6IHByZXZYIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudENvb3JkaW5hdGUgPSB7IHg6IHggfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q29vcmRpbmF0ZSA9IHsgeDogbmV4dFggfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljYXRvci5maWd1cmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBwcmV2RGF0YSA9PT0gbnVsbCB8fCBwcmV2RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocHJldlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q29vcmRpbmF0ZVtrZXldID0geUF4aXMuY29udmVydFRvUGl4ZWwocHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudERhdGEgPT09IG51bGwgfHwgY3VycmVudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvb3JkaW5hdGVba2V5XSA9IHlBeGlzLmNvbnZlcnRUb1BpeGVsKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHREYXRhID09PSBudWxsIHx8IG5leHREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0RGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb29yZGluYXRlW2tleV0gPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaEZpZ3VyZXMoaW5kaWNhdG9yLCBkYXRhSW5kZXgsIGRlZmF1bHRTdHlsZXMsIGZ1bmN0aW9uIChmaWd1cmUsIGZpZ3VyZVN0eWxlcywgZmlndXJlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChjdXJyZW50RGF0YSA9PT0gbnVsbCB8fCBjdXJyZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERhdGFbZmlndXJlLmtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVkgPSBjdXJyZW50Q29vcmRpbmF0ZVtmaWd1cmUua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gKF9hID0gZmlndXJlLmF0dHJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChmaWd1cmUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcHJldjogcHJldkRhdGEsIGN1cnJlbnQ6IGN1cnJlbnREYXRhLCBuZXh0OiBuZXh0RGF0YSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTogeyBwcmV2OiBwcmV2Q29vcmRpbmF0ZSwgY3VycmVudDogY3VycmVudENvb3JkaW5hdGUsIG5leHQ6IG5leHRDb29yZGluYXRlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZzogYm91bmRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXJTcGFjZTogYmFyU3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpczogeEF4aXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChhdHRycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjaXJjbGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzID0geyB4OiB4LCB5OiB2YWx1ZVksIHI6IE1hdGgubWF4KDEsIGhhbGZHYXBCYXIpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiYXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVmFsdWUgPSAoX2IgPSBmaWd1cmUuYmFzZVZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB5QXhpcy5nZXRSYW5nZSgpLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVmFsdWVZID0geUF4aXMuY29udmVydFRvUGl4ZWwoYmFzZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGJhc2VWYWx1ZVkgLSB2YWx1ZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVZhbHVlICE9PSAoY3VycmVudERhdGEgPT09IG51bGwgfHwgY3VycmVudERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnREYXRhW2ZpZ3VyZS5rZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVkgPiBiYXNlVmFsdWVZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYmFzZVZhbHVlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdmFsdWVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCAtIGhhbGZHYXBCYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KDEsIGhhbGZHYXBCYXIgKiAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsaW5lJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQobGluZXNfMVtmaWd1cmVJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc18xW2ZpZ3VyZUluZGV4XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihjdXJyZW50Q29vcmRpbmF0ZVtmaWd1cmUua2V5XSkgJiYgaXNOdW1iZXIobmV4dENvb3JkaW5hdGVbZmlndXJlLmtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc18xW2ZpZ3VyZUluZGV4XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHg6IGN1cnJlbnRDb29yZGluYXRlLngsIHk6IGN1cnJlbnRDb29yZGluYXRlW2ZpZ3VyZS5rZXldIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogbmV4dENvb3JkaW5hdGUueCwgeTogbmV4dENvb3JkaW5hdGVbZmlndXJlLmtleV0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBmaWd1cmVTdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpZ3VyZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChhdHRycykgJiYgdHlwZSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUgPT09ICdiYXInID8gJ3JlY3QnIDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBmaWd1cmVTdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBsaW5lIGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgbGluZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VMaW5lcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtpdGVtc1swXS5jb29yZGluYXRlc1swXSwgaXRlbXNbMF0uY29vcmRpbmF0ZXNbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBpdGVtc1swXS5zdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE1lcmdlTGluZSA9IG1lcmdlTGluZXNbbWVyZ2VMaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RNZXJnZUxpbmVMYXN0Q29vcmRpbmF0ZSA9IGxhc3RNZXJnZUxpbmUuY29vcmRpbmF0ZXNbbGFzdE1lcmdlTGluZS5jb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RNZXJnZUxpbmVMYXN0Q29vcmRpbmF0ZS54ID09PSBjdXJyZW50LmNvb3JkaW5hdGVzWzBdLnggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXJnZUxpbmVMYXN0Q29vcmRpbmF0ZS55ID09PSBjdXJyZW50LmNvb3JkaW5hdGVzWzBdLnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXJnZUxpbmUuc3R5bGVzLnN0eWxlID09PSBjdXJyZW50LnN0eWxlcy5zdHlsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lcmdlTGluZS5zdHlsZXMuY29sb3IgPT09IGN1cnJlbnQuc3R5bGVzLmNvbG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVyZ2VMaW5lLnN0eWxlcy5zaXplID09PSBjdXJyZW50LnN0eWxlcy5zaXplICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVyZ2VMaW5lLnN0eWxlcy5zbW9vdGggPT09IGN1cnJlbnQuc3R5bGVzLnNtb290aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IGxhc3RNZXJnZUxpbmUuc3R5bGVzLmRhc2hlZFZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSAoKF9iID0gY3VycmVudC5zdHlsZXMuZGFzaGVkVmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBsYXN0TWVyZ2VMaW5lLnN0eWxlcy5kYXNoZWRWYWx1ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzFdKSA9PT0gKChfZCA9IGN1cnJlbnQuc3R5bGVzLmRhc2hlZFZhbHVlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVyZ2VMaW5lLmNvb3JkaW5hdGVzLnB1c2goY3VycmVudC5jb29yZGluYXRlc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUxpbmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbY3VycmVudC5jb29yZGluYXRlc1swXSwgY3VycmVudC5jb29yZGluYXRlc1sxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBjdXJyZW50LnN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBzdHlsZXMgPSBfYS5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZGljYXRvclZpZXc7XG59KENhbmRsZUJhclZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ3Jvc3NoYWlyTGluZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENyb3NzaGFpckxpbmVWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENyb3NzaGFpckxpbmVWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENyb3NzaGFpckxpbmVWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuY3Jvc3NoYWlyO1xuICAgICAgICBpZiAoaXNTdHJpbmcoY3Jvc3NoYWlyLnBhbmVJZCkgJiYgc3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgIGlmIChjcm9zc2hhaXIucGFuZUlkID09PSBwYW5lLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGNyb3NzaGFpci55O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBib3VuZGluZy53aWR0aCwgeTogeSB9XG4gICAgICAgICAgICAgICAgXSwgc3R5bGVzLmhvcml6b250YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHggPSBjcm9zc2hhaXIucmVhbFg7XG4gICAgICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIFtcbiAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IGJvdW5kaW5nLmhlaWdodCB9XG4gICAgICAgICAgICBdLCBzdHlsZXMudmVydGljYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDcm9zc2hhaXJMaW5lVmlldy5wcm90b3R5cGUuX2RyYXdMaW5lID0gZnVuY3Rpb24gKGN0eCwgY29vcmRpbmF0ZXMsIHN0eWxlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChzdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZXMgPSBzdHlsZXMubGluZTtcbiAgICAgICAgICAgIGlmIChsaW5lU3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogbGluZVN0eWxlc1xuICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ3Jvc3NoYWlyTGluZVZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSW5kaWNhdG9yVG9vbHRpcFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZGljYXRvclRvb2x0aXBWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZGljYXRvclRvb2x0aXBWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3VtZW50cyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2JvdW5kRmVhdHVyZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmVJbmZvKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3IgPSBjdXJyZW50RmVhdHVyZUluZm8uaW5kaWNhdG9yLCBvdGhlcnMgPSBfX3Jlc3QoY3VycmVudEZlYXR1cmVJbmZvLCBbXCJpbmRpY2F0b3JcIl0pO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoaW5kaWNhdG9yKSkge1xuICAgICAgICAgICAgICAgIChfYSA9IGluZGljYXRvci5vbkNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbmRpY2F0b3IsIF9fYXNzaWduKHsgdGFyZ2V0OiBJbmRpY2F0b3JFdmVudFRhcmdldC5GZWF0dXJlLCBjaGFydDogcGFuZS5nZXRDaGFydCgpLCBpbmRpY2F0b3I6IGluZGljYXRvciB9LCBvdGhlcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuZXhlY3V0ZUFjdGlvbihBY3Rpb25UeXBlLk9uQ2FuZGxlVG9vbHRpcEZlYXR1cmVDbGljaywgY3VycmVudEZlYXR1cmVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgICAgICBfdGhpcy5fYm91bmRGZWF0dXJlTW91c2VNb3ZlRXZlbnQgPSBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmVJbmZvKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuc2V0QWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvKGN1cnJlbnRGZWF0dXJlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbmRpY2F0b3JUb29sdGlwVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY3Jvc3NoYWlyLmtMaW5lRGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgdmFyIF9hID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5pbmRpY2F0b3IudG9vbHRpcCwgb2Zmc2V0TGVmdCA9IF9hLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IF9hLm9mZnNldFRvcCwgb2Zmc2V0UmlnaHQgPSBfYS5vZmZzZXRSaWdodDtcbiAgICAgICAgICAgIHRoaXMuZHJhd0luZGljYXRvclRvb2x0aXAoY3R4LCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIGJvdW5kaW5nLndpZHRoIC0gb2Zmc2V0UmlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmRpY2F0b3JUb29sdGlwVmlldy5wcm90b3R5cGUuZHJhd0luZGljYXRvclRvb2x0aXAgPSBmdW5jdGlvbiAoY3R4LCBsZWZ0LCB0b3AsIG1heFdpZHRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuaW5kaWNhdG9yO1xuICAgICAgICB2YXIgdG9vbHRpcFN0eWxlcyA9IHN0eWxlcy50b29sdGlwO1xuICAgICAgICBpZiAodGhpcy5pc0RyYXdUb29sdGlwKGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCksIHRvb2x0aXBTdHlsZXMpKSB7XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9ycyA9IGNoYXJ0U3RvcmUuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkKHBhbmUuZ2V0SWQoKSk7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcFRleHRTdHlsZXNfMSA9IHRvb2x0aXBTdHlsZXMudGV4dDtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZSb3dIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0geyB4OiBsZWZ0LCB5OiB0b3AgfTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRJbmRpY2F0b3JUb29sdGlwRGF0YShpbmRpY2F0b3IpLCBuYW1lID0gX2EubmFtZSwgY2FsY1BhcmFtc1RleHQgPSBfYS5jYWxjUGFyYW1zVGV4dCwgbGVnZW5kcyA9IF9hLmxlZ2VuZHMsIGZlYXR1cmVzID0gX2EuZmVhdHVyZXM7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVWYWxpZCA9IG5hbWUubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kVmFsaWQgPSBsZWdlbmRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVWYWxpZCB8fCBsZWdlbmRWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX3RoaXMuY2xhc3NpZnlUb29sdGlwRmVhdHVyZXMoZmVhdHVyZXMpLCAzKSwgbGVmdEZlYXR1cmVzID0gX2JbMF0sIG1pZGRsZUZlYXR1cmVzID0gX2JbMV0sIHJpZ2h0RmVhdHVyZXMgPSBfYlsyXTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IF90aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBGZWF0dXJlcyhjdHgsIGxlZnRGZWF0dXJlcywgY29vcmRpbmF0ZSwgaW5kaWNhdG9yLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxjUGFyYW1zVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IFwiXCIuY29uY2F0KHRleHQpLmNvbmNhdChjYWxjUGFyYW1zVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gX3RoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcExlZ2VuZHMoY3R4LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogeyB0ZXh0OiAnJywgY29sb3I6IHRvb2x0aXBUZXh0U3R5bGVzXzEuY29sb3IgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgdGV4dDogdGV4dCwgY29sb3I6IHRvb2x0aXBUZXh0U3R5bGVzXzEuY29sb3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGNvb3JkaW5hdGUsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoLCB0b29sdGlwVGV4dFN0eWxlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gX3RoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzKGN0eCwgbWlkZGxlRmVhdHVyZXMsIGNvb3JkaW5hdGUsIGluZGljYXRvciwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBfdGhpcy5kcmF3U3RhbmRhcmRUb29sdGlwTGVnZW5kcyhjdHgsIGxlZ2VuZHMsIGNvb3JkaW5hdGUsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoLCB0b29sdGlwU3R5bGVzLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgcmlnaHQgaWNvbnNcbiAgICAgICAgICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IF90aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBGZWF0dXJlcyhjdHgsIHJpZ2h0RmVhdHVyZXMsIGNvb3JkaW5hdGUsIGluZGljYXRvciwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBjb29yZGluYXRlLnkgKyBwcmV2Um93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3A7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JUb29sdGlwVmlldy5wcm90b3R5cGUuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzID0gZnVuY3Rpb24gKGN0eCwgZmVhdHVyZXMsIGNvb3JkaW5hdGUsIGluZGljYXRvciwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB3aWR0aF8xID0gMDtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfMSA9IDA7XG4gICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZmVhdHVyZS5tYXJnaW5MZWZ0LCBtYXJnaW5MZWZ0ID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgX2IgPSBmZWF0dXJlLm1hcmdpblRvcCwgbWFyZ2luVG9wID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBmZWF0dXJlLm1hcmdpblJpZ2h0LCBtYXJnaW5SaWdodCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gZmVhdHVyZS5tYXJnaW5Cb3R0b20sIG1hcmdpbkJvdHRvbSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gZmVhdHVyZS5wYWRkaW5nTGVmdCwgcGFkZGluZ0xlZnQgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lLCBfZiA9IGZlYXR1cmUucGFkZGluZ1RvcCwgcGFkZGluZ1RvcCA9IF9mID09PSB2b2lkIDAgPyAwIDogX2YsIF9nID0gZmVhdHVyZS5wYWRkaW5nUmlnaHQsIHBhZGRpbmdSaWdodCA9IF9nID09PSB2b2lkIDAgPyAwIDogX2csIF9oID0gZmVhdHVyZS5wYWRkaW5nQm90dG9tLCBwYWRkaW5nQm90dG9tID0gX2ggPT09IHZvaWQgMCA/IDAgOiBfaCwgX2ogPSBmZWF0dXJlLnNpemUsIHNpemUgPSBfaiA9PT0gdm9pZCAwID8gMCA6IF9qLCB0eXBlID0gZmVhdHVyZS50eXBlLCBpY29uRm9udCA9IGZlYXR1cmUuaWNvbkZvbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFRvb2x0aXBGZWF0dXJlVHlwZS5JY29uRm9udCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQoc2l6ZSwgJ25vcm1hbCcsIGljb25Gb250LmZhbWlseSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChpY29uRm9udC5jb250ZW50KS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IHNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpZHRoXzEgKz0gKG1hcmdpbkxlZnQgKyBwYWRkaW5nTGVmdCArIGNvbnRlbnRXaWR0aCArIHBhZGRpbmdSaWdodCArIG1hcmdpblJpZ2h0KTtcbiAgICAgICAgICAgICAgICBoZWlnaHRfMSA9IE1hdGgubWF4KGhlaWdodF8xLCBtYXJnaW5Ub3AgKyBwYWRkaW5nVG9wICsgc2l6ZSArIHBhZGRpbmdCb3R0b20gKyBtYXJnaW5Cb3R0b20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZS54ICsgd2lkdGhfMSA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgKz0gcHJldlJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gaGVpZ2h0XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gTWF0aC5tYXgocHJldlJvd0hlaWdodCwgaGVpZ2h0XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgICAgIHZhciBwYW5lSWRfMSA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVGZWF0dXJlSW5mb18xID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5nZXRBY3RpdmVUb29sdGlwRmVhdHVyZUluZm8oKTtcbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgdmFyIF9lID0gZmVhdHVyZS5tYXJnaW5MZWZ0LCBtYXJnaW5MZWZ0ID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZSwgX2YgPSBmZWF0dXJlLm1hcmdpblRvcCwgbWFyZ2luVG9wID0gX2YgPT09IHZvaWQgMCA/IDAgOiBfZiwgX2cgPSBmZWF0dXJlLm1hcmdpblJpZ2h0LCBtYXJnaW5SaWdodCA9IF9nID09PSB2b2lkIDAgPyAwIDogX2csIF9oID0gZmVhdHVyZS5wYWRkaW5nTGVmdCwgcGFkZGluZ0xlZnQgPSBfaCA9PT0gdm9pZCAwID8gMCA6IF9oLCBfaiA9IGZlYXR1cmUucGFkZGluZ1RvcCwgcGFkZGluZ1RvcCA9IF9qID09PSB2b2lkIDAgPyAwIDogX2osIF9rID0gZmVhdHVyZS5wYWRkaW5nUmlnaHQsIHBhZGRpbmdSaWdodCA9IF9rID09PSB2b2lkIDAgPyAwIDogX2ssIF9sID0gZmVhdHVyZS5wYWRkaW5nQm90dG9tLCBwYWRkaW5nQm90dG9tID0gX2wgPT09IHZvaWQgMCA/IDAgOiBfbCwgYmFja2dyb3VuZENvbG9yID0gZmVhdHVyZS5iYWNrZ3JvdW5kQ29sb3IsIGFjdGl2ZUJhY2tncm91bmRDb2xvciA9IGZlYXR1cmUuYWN0aXZlQmFja2dyb3VuZENvbG9yLCBib3JkZXJSYWRpdXMgPSBmZWF0dXJlLmJvcmRlclJhZGl1cywgX20gPSBmZWF0dXJlLnNpemUsIHNpemUgPSBfbSA9PT0gdm9pZCAwID8gMCA6IF9tLCBjb2xvciA9IGZlYXR1cmUuY29sb3IsIGFjdGl2ZUNvbG9yID0gZmVhdHVyZS5hY3RpdmVDb2xvciwgdHlwZSA9IGZlYXR1cmUudHlwZSwgaWNvbkZvbnQgPSBmZWF0dXJlLmljb25Gb250LCBwYXRoID0gZmVhdHVyZS5wYXRoO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSAoYWN0aXZlRmVhdHVyZUluZm9fMSA9PT0gbnVsbCB8fCBhY3RpdmVGZWF0dXJlSW5mb18xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVGZWF0dXJlSW5mb18xLnBhbmVJZCkgPT09IHBhbmVJZF8xICYmICgoX2EgPSBhY3RpdmVGZWF0dXJlSW5mb18xLmluZGljYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSA9PT0gKGluZGljYXRvciA9PT0gbnVsbCB8fCBpbmRpY2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZGljYXRvci5pZCkgJiYgYWN0aXZlRmVhdHVyZUluZm9fMS5mZWF0dXJlLmlkID09PSBmZWF0dXJlLmlkO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlQ2xpY2tFdmVudDogX3RoaXMuX2JvdW5kRmVhdHVyZUNsaWNrRXZlbnQoeyBwYW5lSWQ6IHBhbmVJZF8xLCBpbmRpY2F0b3I6IGluZGljYXRvciwgZmVhdHVyZTogZmVhdHVyZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgbW91c2VNb3ZlRXZlbnQ6IF90aGlzLl9ib3VuZEZlYXR1cmVNb3VzZU1vdmVFdmVudCh7IHBhbmVJZDogcGFuZUlkXzEsIGluZGljYXRvcjogaW5kaWNhdG9yLCBmZWF0dXJlOiBmZWF0dXJlIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxDb2xvciA9IGFjdGl2ZSA/IChhY3RpdmVDb2xvciAhPT0gbnVsbCAmJiBhY3RpdmVDb2xvciAhPT0gdm9pZCAwID8gYWN0aXZlQ29sb3IgOiBjb2xvcikgOiBjb2xvcjtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxCYWNrZ3JvdW5kQ29sb3IgPSBhY3RpdmUgPyAoYWN0aXZlQmFja2dyb3VuZENvbG9yICE9PSBudWxsICYmIGFjdGl2ZUJhY2tncm91bmRDb2xvciAhPT0gdm9pZCAwID8gYWN0aXZlQmFja2dyb3VuZENvbG9yIDogYmFja2dyb3VuZENvbG9yKSA6IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gVG9vbHRpcEZlYXR1cmVUeXBlLkljb25Gb250KSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0ZXh0OiBpY29uRm9udC5jb250ZW50LCB4OiBjb29yZGluYXRlLnggKyBtYXJnaW5MZWZ0LCB5OiBjb29yZGluYXRlLnkgKyBtYXJnaW5Ub3AgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBwYWRkaW5nTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiBwYWRkaW5nVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk6IGljb25Gb250LmZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZmluYWxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZpbmFsQmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGV2ZW50SGFuZGxlcikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChpY29uRm9udC5jb250ZW50KS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB4OiBjb29yZGluYXRlLnggKyBtYXJnaW5MZWZ0LCB5OiBjb29yZGluYXRlLnkgKyBtYXJnaW5Ub3AsIHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBwYWRkaW5nTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiBwYWRkaW5nVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogcGFkZGluZ1JpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGZpbmFsQmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGV2ZW50SGFuZGxlcikpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBwYXRoOiBwYXRoLnBhdGgsIHg6IGNvb3JkaW5hdGUueCArIG1hcmdpbkxlZnQgKyBwYWRkaW5nTGVmdCwgeTogY29vcmRpbmF0ZS55ICsgbWFyZ2luVG9wICsgcGFkZGluZ1RvcCwgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHBhdGguc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBwYXRoLmxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZmluYWxDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFdpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ICs9IChtYXJnaW5MZWZ0ICsgcGFkZGluZ0xlZnQgKyBjb250ZW50V2lkdGggKyBwYWRkaW5nUmlnaHQgKyBtYXJnaW5SaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldlJvd0hlaWdodDtcbiAgICB9O1xuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5kcmF3U3RhbmRhcmRUb29sdGlwTGVnZW5kcyA9IGZ1bmN0aW9uIChjdHgsIGxlZ2VuZHMsIGNvb3JkaW5hdGUsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxlZ2VuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG1hcmdpbkxlZnRfMSA9IHN0eWxlcy5tYXJnaW5MZWZ0LCBtYXJnaW5Ub3BfMSA9IHN0eWxlcy5tYXJnaW5Ub3AsIG1hcmdpblJpZ2h0XzEgPSBzdHlsZXMubWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbV8xID0gc3R5bGVzLm1hcmdpbkJvdHRvbSwgc2l6ZV8xID0gc3R5bGVzLnNpemUsIGZhbWlseV8xID0gc3R5bGVzLmZhbWlseSwgd2VpZ2h0XzEgPSBzdHlsZXMud2VpZ2h0O1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBjcmVhdGVGb250KHNpemVfMSwgd2VpZ2h0XzEsIGZhbWlseV8xKTtcbiAgICAgICAgICAgIGxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZVRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aXRsZS50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVUZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQodmFsdWUudGV4dCkud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsVGV4dFdpZHRoID0gdGl0bGVUZXh0V2lkdGggKyB2YWx1ZVRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IG1hcmdpblRvcF8xICsgc2l6ZV8xICsgbWFyZ2luQm90dG9tXzE7XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUueCArIG1hcmdpbkxlZnRfMSArIHRvdGFsVGV4dFdpZHRoICsgbWFyZ2luUmlnaHRfMSA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSArPSBwcmV2Um93SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBNYXRoLm1heChwcmV2Um93SGVpZ2h0LCBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlLnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgeDogY29vcmRpbmF0ZS54ICsgbWFyZ2luTGVmdF8xLCB5OiBjb29yZGluYXRlLnkgKyBtYXJnaW5Ub3BfMSwgdGV4dDogdGl0bGUudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiB0aXRsZS5jb2xvciwgc2l6ZTogc2l6ZV8xLCBmYW1pbHk6IGZhbWlseV8xLCB3ZWlnaHQ6IHdlaWdodF8xIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgeDogY29vcmRpbmF0ZS54ICsgbWFyZ2luTGVmdF8xICsgdGl0bGVUZXh0V2lkdGgsIHk6IGNvb3JkaW5hdGUueSArIG1hcmdpblRvcF8xLCB0ZXh0OiB2YWx1ZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogdmFsdWUuY29sb3IsIHNpemU6IHNpemVfMSwgZmFtaWx5OiBmYW1pbHlfMSwgd2VpZ2h0OiB3ZWlnaHRfMSB9XG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ICs9IChtYXJnaW5MZWZ0XzEgKyB0b3RhbFRleHRXaWR0aCArIG1hcmdpblJpZ2h0XzEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZSb3dIZWlnaHQ7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JUb29sdGlwVmlldy5wcm90b3R5cGUuaXNEcmF3VG9vbHRpcCA9IGZ1bmN0aW9uIChjcm9zc2hhaXIsIHN0eWxlcykge1xuICAgICAgICB2YXIgc2hvd1J1bGUgPSBzdHlsZXMuc2hvd1J1bGU7XG4gICAgICAgIHJldHVybiBzaG93UnVsZSA9PT0gVG9vbHRpcFNob3dSdWxlLkFsd2F5cyB8fFxuICAgICAgICAgICAgKHNob3dSdWxlID09PSBUb29sdGlwU2hvd1J1bGUuRm9sbG93Q3Jvc3MgJiYgaXNTdHJpbmcoY3Jvc3NoYWlyLnBhbmVJZCkpO1xuICAgIH07XG4gICAgSW5kaWNhdG9yVG9vbHRpcFZpZXcucHJvdG90eXBlLmdldEluZGljYXRvclRvb2x0aXBEYXRhID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5pbmRpY2F0b3I7XG4gICAgICAgIHZhciB0b29sdGlwU3R5bGVzID0gc3R5bGVzLnRvb2x0aXA7XG4gICAgICAgIHZhciBuYW1lID0gdG9vbHRpcFN0eWxlcy5zaG93TmFtZSA/IGluZGljYXRvci5zaG9ydE5hbWUgOiAnJztcbiAgICAgICAgdmFyIGNhbGNQYXJhbXNUZXh0ID0gJyc7XG4gICAgICAgIGlmICh0b29sdGlwU3R5bGVzLnNob3dQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBjYWxjUGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgICAgICBpZiAoY2FsY1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FsY1BhcmFtc1RleHQgPSBcIihcIi5jb25jYXQoY2FsY1BhcmFtcy5qb2luKCcsJyksIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9vbHRpcERhdGEgPSB7IG5hbWU6IG5hbWUsIGNhbGNQYXJhbXNUZXh0OiBjYWxjUGFyYW1zVGV4dCwgbGVnZW5kczogW10sIGZlYXR1cmVzOiB0b29sdGlwU3R5bGVzLmZlYXR1cmVzIH07XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBjaGFydFN0b3JlLmdldENyb3NzaGFpcigpLmRhdGFJbmRleDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluZGljYXRvci5yZXN1bHQ7XG4gICAgICAgIHZhciBjdXN0b21BcGkgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpO1xuICAgICAgICB2YXIgZGVjaW1hbEZvbGQgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7XG4gICAgICAgIHZhciB0aG91c2FuZHNTZXBhcmF0b3IgPSBjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpO1xuICAgICAgICB2YXIgbGVnZW5kcyA9IFtdO1xuICAgICAgICBpZiAoaW5kaWNhdG9yLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhXzEgPSAoX2IgPSAoX2EgPSByZXN1bHRbZGF0YUluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzdWx0W2RhdGFJbmRleCAtIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgICAgIGVhY2hGaWd1cmVzKGluZGljYXRvciwgZGF0YUluZGV4LCBzdHlsZXMsIGZ1bmN0aW9uIChmaWd1cmUsIGZpZ3VyZVN0eWxlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhmaWd1cmUudGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGZpZ3VyZVN0eWxlcy5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFfMVtmaWd1cmUua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmb3JtYXRQcmVjaXNpb24odmFsdWUsIGluZGljYXRvci5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci5zaG91bGRGb3JtYXRCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1c3RvbUFwaS5mb3JtYXRCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZHMucHVzaCh7IHRpdGxlOiB7IHRleHQ6IGZpZ3VyZS50aXRsZSwgY29sb3I6IGNvbG9yIH0sIHZhbHVlOiB7IHRleHQ6ICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSksIGNvbG9yOiBjb2xvciB9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbHRpcERhdGEubGVnZW5kcyA9IGxlZ2VuZHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaW5kaWNhdG9yLmNyZWF0ZVRvb2x0aXBEYXRhU291cmNlKSkge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgICAgICB2YXIgX2MgPSBpbmRpY2F0b3IuY3JlYXRlVG9vbHRpcERhdGFTb3VyY2Uoe1xuICAgICAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6IGluZGljYXRvcixcbiAgICAgICAgICAgICAgICBjcm9zc2hhaXI6IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCksXG4gICAgICAgICAgICAgICAgYm91bmRpbmc6IHdpZGdldC5nZXRCb3VuZGluZygpLFxuICAgICAgICAgICAgICAgIHhBeGlzOiBwYW5lLmdldENoYXJ0KCkuZ2V0WEF4aXNQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpLFxuICAgICAgICAgICAgICAgIHlBeGlzOiBwYW5lLmdldEF4aXNDb21wb25lbnQoKVxuICAgICAgICAgICAgfSksIGN1c3RvbU5hbWUgPSBfYy5uYW1lLCBjdXN0b21DYWxjUGFyYW1zVGV4dCA9IF9jLmNhbGNQYXJhbXNUZXh0LCBjdXN0b21MZWdlbmRzID0gX2MubGVnZW5kcywgY3VzdG9tRmVhdHVyZXMgPSBfYy5mZWF0dXJlcztcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhjdXN0b21OYW1lKSAmJiB0b29sdGlwU3R5bGVzLnNob3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERhdGEubmFtZSA9IGN1c3RvbU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoY3VzdG9tQ2FsY1BhcmFtc1RleHQpICYmIHRvb2x0aXBTdHlsZXMuc2hvd1BhcmFtcykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLmNhbGNQYXJhbXNUZXh0ID0gY3VzdG9tQ2FsY1BhcmFtc1RleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChjdXN0b21GZWF0dXJlcykpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5mZWF0dXJlcyA9IGN1c3RvbUZlYXR1cmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQoY3VzdG9tTGVnZW5kcykgJiYgaW5kaWNhdG9yLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW1pemVkTGVnZW5kc18xID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yXzEgPSBzdHlsZXMudG9vbHRpcC50ZXh0LmNvbG9yO1xuICAgICAgICAgICAgICAgIGN1c3RvbUxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSB7IHRleHQ6ICcnLCBjb2xvcjogY29sb3JfMSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZGF0YS50aXRsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLnRleHQgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHsgdGV4dDogJycsIGNvbG9yOiBjb2xvcl8xIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGV4dCA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKE51bWJlcih2YWx1ZS50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRleHQgPSBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdCh2YWx1ZS50ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVkTGVnZW5kc18xLnB1c2goeyB0aXRsZTogdGl0bGUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5sZWdlbmRzID0gb3B0aW1pemVkTGVnZW5kc18xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b29sdGlwRGF0YTtcbiAgICB9O1xuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5jbGFzc2lmeVRvb2x0aXBGZWF0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICB2YXIgbGVmdEZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciBtaWRkbGVGZWF0dXJlcyA9IFtdO1xuICAgICAgICB2YXIgcmlnaHRGZWF0dXJlcyA9IFtdO1xuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZlYXR1cmUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvb2x0aXBGZWF0dXJlUG9zaXRpb24uTGVmdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVG9vbHRpcEZlYXR1cmVQb3NpdGlvbi5NaWRkbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlRmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVG9vbHRpcEZlYXR1cmVQb3NpdGlvbi5SaWdodDoge1xuICAgICAgICAgICAgICAgICAgICByaWdodEZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbbGVmdEZlYXR1cmVzLCBtaWRkbGVGZWF0dXJlcywgcmlnaHRGZWF0dXJlc107XG4gICAgfTtcbiAgICByZXR1cm4gSW5kaWNhdG9yVG9vbHRpcFZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgT3ZlcmxheVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE92ZXJsYXlWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlWaWV3KHdpZGdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB3aWRnZXQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9pbml0RXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuX2luaXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IGNoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCdtb3VzZU1vdmVFdmVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheUluZm8gPSBjaGFydFN0b3JlLmdldFByb2dyZXNzT3ZlcmxheUluZm8oKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc092ZXJsYXlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBwcm9ncmVzc092ZXJsYXlJbmZvLm92ZXJsYXk7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheVBhbmVJZCA9IHByb2dyZXNzT3ZlcmxheUluZm8ucGFuZUlkO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnVwZGF0ZVByb2dyZXNzT3ZlcmxheUluZm8ocGFuZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NPdmVybGF5UGFuZUlkID0gcGFuZUlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvdmVybGF5LnBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzRHJhd2luZygpICYmIHByb2dyZXNzT3ZlcmxheVBhbmVJZCA9PT0gcGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZXZlbnRNb3ZlRm9yRHJhd2luZyhfdGhpcy5fY29vcmRpbmF0ZVRvUG9pbnQob3ZlcmxheSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gb3ZlcmxheS5vbkRyYXdpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvdmVybGF5IH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmlndXJlTW91c2VNb3ZlRXZlbnQob3ZlcmxheSwgMSAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Qb2ludCAqLywgaW5kZXgsIHsga2V5OiBcIlwiLmNvbmNhdChPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYLCBcInBvaW50X1wiKS5jb25jYXQoaW5kZXgpLCB0eXBlOiAnY2lyY2xlJywgYXR0cnM6IHt9IH0pKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0SG92ZXJPdmVybGF5SW5mbyh7XG4gICAgICAgICAgICAgICAgcGFuZUlkOiBwYW5lSWQsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWd1cmVUeXBlOiAwIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLk5vbmUgKi8sXG4gICAgICAgICAgICAgICAgZmlndXJlSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIGZpZ3VyZTogbnVsbFxuICAgICAgICAgICAgfSwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5yZWdpc3RlckV2ZW50KCdtb3VzZUNsaWNrRXZlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IGNoYXJ0U3RvcmUuZ2V0UHJvZ3Jlc3NPdmVybGF5SW5mbygpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzT3ZlcmxheUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IHByb2dyZXNzT3ZlcmxheUluZm8ub3ZlcmxheTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NPdmVybGF5UGFuZUlkID0gcHJvZ3Jlc3NPdmVybGF5SW5mby5wYW5lSWQ7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUudXBkYXRlUHJvZ3Jlc3NPdmVybGF5SW5mbyhwYW5lSWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPSBwYW5lSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG92ZXJsYXkucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNEcmF3aW5nKCkgJiYgcHJvZ3Jlc3NPdmVybGF5UGFuZUlkID09PSBwYW5lSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5ldmVudE1vdmVGb3JEcmF3aW5nKF90aGlzLl9jb29yZGluYXRlVG9Qb2ludChvdmVybGF5LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uRHJhd2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXkgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5uZXh0U3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXkuaXNEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUucHJvZ3Jlc3NPdmVybGF5Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IG92ZXJsYXkub25EcmF3RW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiBjaGFydCwgb3ZlcmxheTogb3ZlcmxheSB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmlndXJlTW91c2VDbGlja0V2ZW50KG92ZXJsYXksIDEgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuUG9pbnQgKi8sIGluZGV4LCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCwgXCJwb2ludF9cIikuY29uY2F0KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7fVxuICAgICAgICAgICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q2xpY2tPdmVybGF5SW5mbyh7XG4gICAgICAgICAgICAgICAgcGFuZUlkOiBwYW5lSWQsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWd1cmVUeXBlOiAwIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLk5vbmUgKi8sXG4gICAgICAgICAgICAgICAgZmlndXJlSW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgIGZpZ3VyZTogbnVsbFxuICAgICAgICAgICAgfSwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5yZWdpc3RlckV2ZW50KCdtb3VzZURvdWJsZUNsaWNrRXZlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXlJbmZvID0gY2hhcnRTdG9yZS5nZXRQcm9ncmVzc092ZXJsYXlJbmZvKCk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NPdmVybGF5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGF5ID0gcHJvZ3Jlc3NPdmVybGF5SW5mby5vdmVybGF5O1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPSBwcm9ncmVzc092ZXJsYXlJbmZvLnBhbmVJZDtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheS5pc0RyYXdpbmcoKSAmJiBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPT09IHBhbmVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmZvcmNlQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdmVybGF5LmlzRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnByb2dyZXNzT3ZlcmxheUNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uRHJhd0VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXkgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvdmVybGF5LnBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmlndXJlTW91c2VDbGlja0V2ZW50KG92ZXJsYXksIDEgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuUG9pbnQgKi8sIGluZGV4LCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCwgXCJwb2ludF9cIikuY29uY2F0KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7fVxuICAgICAgICAgICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkucmVnaXN0ZXJFdmVudCgnbW91c2VSaWdodENsaWNrRXZlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXlJbmZvID0gY2hhcnRTdG9yZS5nZXRQcm9ncmVzc092ZXJsYXlJbmZvKCk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NPdmVybGF5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGF5ID0gcHJvZ3Jlc3NPdmVybGF5SW5mby5vdmVybGF5O1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG92ZXJsYXkucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmlndXJlTW91c2VSaWdodENsaWNrRXZlbnQob3ZlcmxheSwgMSAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Qb2ludCAqLywgaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCwgXCJwb2ludF9cIikuY29uY2F0KGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLnJlZ2lzdGVyRXZlbnQoJ21vdXNlVXBFdmVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gY2hhcnRTdG9yZS5nZXRQcmVzc2VkT3ZlcmxheUluZm8oKSwgb3ZlcmxheSA9IF9iLm92ZXJsYXksIGZpZ3VyZSA9IF9iLmZpZ3VyZTtcbiAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvblByZXNzZWRNb3ZlRW5kJywgZmlndXJlKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uUHJlc3NlZE1vdmVFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmU6IGZpZ3VyZSAhPT0gbnVsbCAmJiBmaWd1cmUgIT09IHZvaWQgMCA/IGZpZ3VyZSA6IHVuZGVmaW5lZCB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0UHJlc3NlZE92ZXJsYXlJbmZvKHtcbiAgICAgICAgICAgICAgICBwYW5lSWQ6IHBhbmVJZCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgICAgIGZpZ3VyZVR5cGU6IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLyxcbiAgICAgICAgICAgICAgICBmaWd1cmVJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkucmVnaXN0ZXJFdmVudCgncHJlc3NlZE1vdXNlTW92ZUV2ZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIF9jID0gY2hhcnRTdG9yZS5nZXRQcmVzc2VkT3ZlcmxheUluZm8oKSwgb3ZlcmxheSA9IF9jLm92ZXJsYXksIGZpZ3VyZVR5cGUgPSBfYy5maWd1cmVUeXBlLCBmaWd1cmVJbmRleCA9IF9jLmZpZ3VyZUluZGV4LCBmaWd1cmUgPSBfYy5maWd1cmU7XG4gICAgICAgICAgICBpZiAob3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25QcmVzc2VkTW92aW5nJywgZmlndXJlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXkubG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gb3ZlcmxheS5vblByZXNzZWRNb3ZpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmU6IGZpZ3VyZSAhPT0gbnVsbCAmJiBmaWd1cmUgIT09IHZvaWQgMCA/IGZpZ3VyZSA6IHVuZGVmaW5lZCB9LCBldmVudCkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBfdGhpcy5fY29vcmRpbmF0ZVRvUG9pbnQob3ZlcmxheSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWd1cmVUeXBlID09PSAxIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLlBvaW50ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZXZlbnRQcmVzc2VkUG9pbnRNb3ZlKHBvaW50LCBmaWd1cmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmV2ZW50UHJlc3NlZE90aGVyTW92ZShwb2ludCwgX3RoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fY3JlYXRlRmlndXJlRXZlbnRzID0gZnVuY3Rpb24gKG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpIHtcbiAgICAgICAgaWYgKG92ZXJsYXkuaXNEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb3VzZU1vdmVFdmVudDogdGhpcy5fZmlndXJlTW91c2VNb3ZlRXZlbnQob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSksXG4gICAgICAgICAgICBtb3VzZURvd25FdmVudDogdGhpcy5fZmlndXJlTW91c2VEb3duRXZlbnQob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSksXG4gICAgICAgICAgICBtb3VzZUNsaWNrRXZlbnQ6IHRoaXMuX2ZpZ3VyZU1vdXNlQ2xpY2tFdmVudChvdmVybGF5LCBmaWd1cmVUeXBlLCBmaWd1cmVJbmRleCwgZmlndXJlKSxcbiAgICAgICAgICAgIG1vdXNlUmlnaHRDbGlja0V2ZW50OiB0aGlzLl9maWd1cmVNb3VzZVJpZ2h0Q2xpY2tFdmVudChvdmVybGF5LCBmaWd1cmVUeXBlLCBmaWd1cmVJbmRleCwgZmlndXJlKSxcbiAgICAgICAgICAgIG1vdXNlRG91YmxlQ2xpY2tFdmVudDogdGhpcy5fZmlndXJlTW91c2VEb3VibGVDbGlja0V2ZW50KG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuX2ZpZ3VyZU1vdXNlTW92ZUV2ZW50ID0gZnVuY3Rpb24gKG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgICAgICBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLnNldEhvdmVyT3ZlcmxheUluZm8oeyBwYW5lSWQ6IHBhbmUuZ2V0SWQoKSwgb3ZlcmxheTogb3ZlcmxheSwgZmlndXJlVHlwZTogZmlndXJlVHlwZSwgZmlndXJlOiBmaWd1cmUsIGZpZ3VyZUluZGV4OiBmaWd1cmVJbmRleCB9LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uTW91c2VFbnRlcicsIGZpZ3VyZSkgJiYgIW92ZXJsYXkuaXNEcmF3aW5nKCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuX2ZpZ3VyZU1vdXNlRG93bkV2ZW50ID0gZnVuY3Rpb24gKG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgb3ZlcmxheS5zdGFydFByZXNzZWRNb3ZlKF90aGlzLl9jb29yZGluYXRlVG9Qb2ludChvdmVybGF5LCBldmVudCkpO1xuICAgICAgICAgICAgaWYgKGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvblByZXNzZWRNb3ZlU3RhcnQnLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gb3ZlcmxheS5vblByZXNzZWRNb3ZlU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IHBhbmUuZ2V0Q2hhcnQoKSwgb3ZlcmxheTogb3ZlcmxheSwgZmlndXJlOiBmaWd1cmUgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLnNldFByZXNzZWRPdmVybGF5SW5mbyh7IHBhbmVJZDogcGFuZUlkLCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmVUeXBlOiBmaWd1cmVUeXBlLCBmaWd1cmVJbmRleDogZmlndXJlSW5kZXgsIGZpZ3VyZTogZmlndXJlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3ZlcmxheS5pc0RyYXdpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZmlndXJlTW91c2VDbGlja0V2ZW50ID0gZnVuY3Rpb24gKG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5zZXRDbGlja092ZXJsYXlJbmZvKHsgcGFuZUlkOiBwYW5lSWQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZVR5cGU6IGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4OiBmaWd1cmVJbmRleCwgZmlndXJlOiBmaWd1cmUgfSwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvbkNsaWNrJywgZmlndXJlKSAmJiAhb3ZlcmxheS5pc0RyYXdpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZmlndXJlTW91c2VEb3VibGVDbGlja0V2ZW50ID0gZnVuY3Rpb24gKG92ZXJsYXksIF9maWd1cmVUeXBlLCBfZmlndXJlSW5kZXgsIGZpZ3VyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uRG91YmxlQ2xpY2snLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gb3ZlcmxheS5vbkRvdWJsZUNsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnQpLCB7IGNoYXJ0OiBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKSwgZmlndXJlOiBmaWd1cmUsIG92ZXJsYXk6IG92ZXJsYXkgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3ZlcmxheS5pc0RyYXdpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZmlndXJlTW91c2VSaWdodENsaWNrRXZlbnQgPSBmdW5jdGlvbiAob3ZlcmxheSwgX2ZpZ3VyZVR5cGUsIF9maWd1cmVJbmRleCwgZmlndXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uUmlnaHRDbGljaycsIGZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSBvdmVybGF5Lm9uUmlnaHRDbGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogX3RoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCksIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZTogZmlndXJlIH0sIGV2ZW50KSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdmVybGF5LmlzRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLl9jb29yZGluYXRlVG9Qb2ludCA9IGZ1bmN0aW9uIChvLCBjb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHBvaW50ID0ge307XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBjaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVUb1BvaW50VGltZXN0YW1wRGF0YUluZGV4RmxhZygpKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0geEF4aXMuY29udmVydEZyb21QaXhlbChjb29yZGluYXRlLngpO1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IChfYSA9IGNoYXJ0U3RvcmUuZGF0YUluZGV4VG9UaW1lc3RhbXAoZGF0YUluZGV4KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcG9pbnQudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgcG9pbnQuZGF0YUluZGV4ID0gZGF0YUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVUb1BvaW50VmFsdWVGbGFnKCkpIHtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0geUF4aXMuY29udmVydEZyb21QaXhlbChjb29yZGluYXRlLnkpO1xuICAgICAgICAgICAgaWYgKG8ubW9kZSAhPT0gT3ZlcmxheU1vZGUuTm9ybWFsICYmIHBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSAmJiBpc051bWJlcihwb2ludC5kYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtMaW5lRGF0YSA9IGNoYXJ0U3RvcmUuZ2V0RGF0YUJ5RGF0YUluZGV4KHBvaW50LmRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGtMaW5lRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZVNlbnNpdGl2aXR5ID0gby5tb2RlU2Vuc2l0aXZpdHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IGtMaW5lRGF0YS5oaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tb2RlID09PSBPdmVybGF5TW9kZS5XZWFrTWFnbmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2hZID0geUF4aXMuY29udmVydFRvUGl4ZWwoa0xpbmVEYXRhLmhpZ2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmVmFsdWUgPSB5QXhpcy5jb252ZXJ0RnJvbVBpeGVsKGhpZ2hZIC0gbW9kZVNlbnNpdGl2aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBidWZmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwga0xpbmVEYXRhLmxvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ubW9kZSA9PT0gT3ZlcmxheU1vZGUuV2Vha01hZ25ldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3dZID0geUF4aXMuY29udmVydFRvUGl4ZWwoa0xpbmVEYXRhLmxvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZWYWx1ZSA9IHlBeGlzLmNvbnZlcnRGcm9tUGl4ZWwobG93WSAtIG1vZGVTZW5zaXRpdml0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gYnVmZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtMaW5lRGF0YS5sb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoa0xpbmVEYXRhLm9wZW4sIGtMaW5lRGF0YS5jbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oa0xpbmVEYXRhLm9wZW4sIGtMaW5lRGF0YS5jbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSBtYXggPCBrTGluZURhdGEuaGlnaCAtIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIGtMaW5lRGF0YS5sb3cgPCBtaW4gLSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtMaW5lRGF0YS5sb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXggLSB2YWx1ZSA8IHZhbHVlIC0gbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVUb1BvaW50VmFsdWVGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlVG9Qb2ludFRpbWVzdGFtcERhdGFJbmRleEZsYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXZlbnQsIG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5pc092ZXJsYXlEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXZlbnQobmFtZSwgZXZlbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50LmNhbGwodGhpcywgbmFtZSwgZXZlbnQsIG90aGVyKTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5jaGVja0V2ZW50T24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuZ2V0Q29tcGxldGVPdmVybGF5cygpO1xuICAgICAgICBvdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICAgICAgICBpZiAob3ZlcmxheS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdPdmVybGF5KGN0eCwgb3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvZ3Jlc3NPdmVybGF5ID0gdGhpcy5nZXRQcm9ncmVzc092ZXJsYXkoKTtcbiAgICAgICAgaWYgKGlzVmFsaWQocHJvZ3Jlc3NPdmVybGF5KSAmJiBwcm9ncmVzc092ZXJsYXkudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd092ZXJsYXkoY3R4LCBwcm9ncmVzc092ZXJsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuX2RyYXdPdmVybGF5ID0gZnVuY3Rpb24gKGN0eCwgb3ZlcmxheSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gb3ZlcmxheS5wb2ludHM7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBjaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihwb2ludC50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4ID0gY2hhcnRTdG9yZS50aW1lc3RhbXBUb0RhdGFJbmRleChwb2ludC50aW1lc3RhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ID0geEF4aXMuY29udmVydFRvUGl4ZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bWJlcihwb2ludC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPSAoX2EgPSB5QXhpcyA9PT0gbnVsbCB8fCB5QXhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogeUF4aXMuY29udmVydFRvUGl4ZWwocG9pbnQudmFsdWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHZhciBmaWd1cmVzID0gW10uY29uY2F0KHRoaXMuZ2V0RmlndXJlcyhvdmVybGF5LCBjb29yZGluYXRlcykpO1xuICAgICAgICAgICAgdGhpcy5kcmF3RmlndXJlcyhjdHgsIG92ZXJsYXksIGZpZ3VyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0RlZmF1bHRGaWd1cmVzKGN0eCwgb3ZlcmxheSwgY29vcmRpbmF0ZXMpO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmRyYXdGaWd1cmVzID0gZnVuY3Rpb24gKGN0eCwgb3ZlcmxheSwgZmlndXJlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmYXVsdFN0eWxlcyA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkub3ZlcmxheTtcbiAgICAgICAgZmlndXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWd1cmUsIGZpZ3VyZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpZ3VyZS50eXBlLCBzdHlsZXMgPSBmaWd1cmUuc3R5bGVzLCBhdHRycyA9IGZpZ3VyZS5hdHRycztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB2YXIgYXR0cnNBcnJheSA9IFtdLmNvbmNhdChhdHRycyk7XG4gICAgICAgICAgICBhdHRyc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKGF0cykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IF90aGlzLl9jcmVhdGVGaWd1cmVFdmVudHMob3ZlcmxheSwgMiAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5PdGhlciAqLywgZmlndXJlSW5kZXgsIGZpZ3VyZSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICB2YXIgc3MgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdFN0eWxlc1t0eXBlXSksIChfYSA9IG92ZXJsYXkuc3R5bGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbdHlwZV0pLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUsIGF0dHJzOiBhdHMsIHN0eWxlczogc3NcbiAgICAgICAgICAgICAgICB9LCBldmVudHMgIT09IG51bGwgJiYgZXZlbnRzICE9PSB2b2lkIDAgPyBldmVudHMgOiB1bmRlZmluZWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmdldENvbXBsZXRlT3ZlcmxheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHJldHVybiBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmdldE92ZXJsYXlzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5nZXRQcm9ncmVzc092ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBpbmZvID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5nZXRQcm9ncmVzc092ZXJsYXlJbmZvKCk7XG4gICAgICAgIGlmIChpc1ZhbGlkKGluZm8pICYmIGluZm8ucGFuZUlkID09PSBwYW5lLmdldElkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLm92ZXJsYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZ2V0RmlndXJlcyA9IGZ1bmN0aW9uIChvLCBjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gby5jcmVhdGVQb2ludEZpZ3VyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG8sIHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsIGJvdW5kaW5nOiBib3VuZGluZywgeEF4aXM6IHhBeGlzLCB5QXhpczogeUF4aXMgfSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmRyYXdEZWZhdWx0RmlndXJlcyA9IGZ1bmN0aW9uIChjdHgsIG92ZXJsYXksIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvdmVybGF5Lm5lZWREZWZhdWx0UG9pbnRGaWd1cmUpIHtcbiAgICAgICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgICAgICB2YXIgaG92ZXJPdmVybGF5SW5mb18xID0gY2hhcnRTdG9yZS5nZXRIb3Zlck92ZXJsYXlJbmZvKCk7XG4gICAgICAgICAgICB2YXIgY2xpY2tPdmVybGF5SW5mbyA9IGNoYXJ0U3RvcmUuZ2V0Q2xpY2tPdmVybGF5SW5mbygpO1xuICAgICAgICAgICAgaWYgKCgoKF9hID0gaG92ZXJPdmVybGF5SW5mb18xLm92ZXJsYXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgPT09IG92ZXJsYXkuaWQgJiYgaG92ZXJPdmVybGF5SW5mb18xLmZpZ3VyZVR5cGUgIT09IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLykgfHxcbiAgICAgICAgICAgICAgICAoKChfYiA9IGNsaWNrT3ZlcmxheUluZm8ub3ZlcmxheSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSA9PT0gb3ZlcmxheS5pZCAmJiBjbGlja092ZXJsYXlJbmZvLmZpZ3VyZVR5cGUgIT09IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkub3ZlcmxheTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gb3ZlcmxheS5zdHlsZXM7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50U3R5bGVzXzEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdFN0eWxlcy5wb2ludCksIHN0eWxlcyA9PT0gbnVsbCB8fCBzdHlsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlcy5wb2ludCk7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBwb2ludFN0eWxlc18xLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gcG9pbnRTdHlsZXNfMS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gcG9pbnRTdHlsZXNfMS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlclNpemUgPSBwb2ludFN0eWxlc18xLmJvcmRlclNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9iID0gaG92ZXJPdmVybGF5SW5mb18xLm92ZXJsYXkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgPT09IG92ZXJsYXkuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyT3ZlcmxheUluZm9fMS5maWd1cmVUeXBlID09PSAxIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLlBvaW50ICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gaG92ZXJPdmVybGF5SW5mb18xLmZpZ3VyZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmtleSkgPT09IFwiXCIuY29uY2F0KE9WRVJMQVlfRklHVVJFX0tFWV9QUkVGSVgsIFwicG9pbnRfXCIpLmNvbmNhdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IHBvaW50U3R5bGVzXzEuYWN0aXZlUmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBwb2ludFN0eWxlc18xLmFjdGl2ZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBwb2ludFN0eWxlc18xLmFjdGl2ZUJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyU2l6ZSA9IHBvaW50U3R5bGVzXzEuYWN0aXZlQm9yZGVyU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2UgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB4OiB4LCB5OiB5LCByOiByYWRpdXMgKyBib3JkZXJTaXplIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGJvcmRlckNvbG9yIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgKF9kID0gX3RoaXMuX2NyZWF0ZUZpZ3VyZUV2ZW50cyhvdmVybGF5LCAxIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLlBvaW50ICovLCBpbmRleCwge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYLCBcInBvaW50X1wiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB4OiB4LCB5OiB5LCByOiByYWRpdXMgKyBib3JkZXJTaXplIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGJvcmRlckNvbG9yIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCkpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIChfZiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHg6IHgsIHk6IHksIHI6IHJhZGl1cyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiBjb2xvciB9XG4gICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSW5kaWNhdG9yV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmRpY2F0b3JXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5kaWNhdG9yV2lkZ2V0KHJvb3RDb250YWluZXIsIHBhbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdENvbnRhaW5lciwgcGFuZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2dyaWRWaWV3ID0gbmV3IEdyaWRWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2luZGljYXRvclZpZXcgPSBuZXcgSW5kaWNhdG9yVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9jcm9zc2hhaXJMaW5lVmlldyA9IG5ldyBDcm9zc2hhaXJMaW5lVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl90b29sdGlwVmlldyA9IF90aGlzLmNyZWF0ZVRvb2x0aXBWaWV3KCk7XG4gICAgICAgIF90aGlzLl9vdmVybGF5VmlldyA9IG5ldyBPdmVybGF5VmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLl90b29sdGlwVmlldyk7XG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLl9vdmVybGF5Vmlldyk7XG4gICAgICAgIF90aGlzLmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZGljYXRvcldpZGdldC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjtcbiAgICB9O1xuICAgIEluZGljYXRvcldpZGdldC5wcm90b3R5cGUudXBkYXRlTWFpbiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGFuZSgpLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYWluQ29udGVudChjdHgpO1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yVmlldy5kcmF3KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9ncmlkVmlldy5kcmF3KGN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZGljYXRvcldpZGdldC5wcm90b3R5cGUuY3JlYXRlVG9vbHRpcFZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kaWNhdG9yVG9vbHRpcFZpZXcodGhpcyk7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JXaWRnZXQucHJvdG90eXBlLnVwZGF0ZU1haW5Db250ZW50ID0gZnVuY3Rpb24gKF9jdHgpIHtcbiAgICAgICAgLy8gdG8gZG8gaXRcbiAgICB9O1xuICAgIEluZGljYXRvcldpZGdldC5wcm90b3R5cGUudXBkYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGFuZSgpLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVZpZXcuZHJhdyhjdHgpO1xuICAgICAgICAgICAgdGhpcy5fY3Jvc3NoYWlyTGluZVZpZXcuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBWaWV3LmRyYXcoY3R4KTtcbiAgICB9O1xuICAgIHJldHVybiBJbmRpY2F0b3JXaWRnZXQ7XG59KERyYXdXaWRnZXQpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlQXJlYVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZUFyZWFWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZUFyZWFWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3VtZW50cyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3JpcHBsZVBvaW50ID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgIG5hbWU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgcjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZmlsbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9hbmltYXRpb25GcmFtZVRpbWUgPSAwO1xuICAgICAgICBfdGhpcy5fYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7IGl0ZXJhdGlvbkNvdW50OiBJbmZpbml0eSB9KS5kb0ZyYW1lKGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uRnJhbWVUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHZhciBwYW5lID0gX3RoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICAgICAgcGFuZS5nZXRDaGFydCgpLnVwZGF0ZVBhbmUoMCAvKiBVcGRhdGVMZXZlbC5NYWluICovLCBwYW5lLmdldElkKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYW5kbGVBcmVhVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIGRhdGFMaXN0ID0gY2hhcnQuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgdmFyIGxhc3REYXRhSW5kZXggPSBkYXRhTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydC5nZXRTdHlsZXMoKS5jYW5kbGUuYXJlYTtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgICAgIHZhciBtaW5ZID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciBhcmVhU3RhcnRYID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciByaXBwbGVQb2ludENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmVhY2hDaGlsZHJlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIHggPSBkYXRhLng7XG4gICAgICAgICAgICB2YXIga0xpbmVEYXRhID0gZGF0YS5kYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrTGluZURhdGEgPT09IG51bGwgfHwga0xpbmVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrTGluZURhdGFbc3R5bGVzLnZhbHVlXTtcbiAgICAgICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHlBeGlzLmNvbnZlcnRUb1BpeGVsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJlYVN0YXJ0WCA9PT0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJlYVN0YXJ0WCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goeyB4OiB4LCB5OiB5IH0pO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5kYXRhSW5kZXggPT09IGxhc3REYXRhSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlwcGxlUG9pbnRDb29yZGluYXRlID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBzdHlsZXMubGluZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZXMubGluZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNtb290aDogc3R5bGVzLnNtb290aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICAgICAgLy8gcmVuZGVyIGFyZWFcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gJyc7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShiYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50XzEgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgYm91bmRpbmcuaGVpZ2h0LCAwLCBtaW5ZKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfYS5vZmZzZXQsIGNvbG9yID0gX2EuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFkaWVudF8xLmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbG9yID0gZ3JhZGllbnRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhhcmVhU3RhcnRYLCBib3VuZGluZy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1swXS54LCBjb29yZGluYXRlc1swXS55KTtcbiAgICAgICAgICAgIGxpbmVUbyhjdHgsIGNvb3JkaW5hdGVzLCBzdHlsZXMuc21vb3RoKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0ueCwgYm91bmRpbmcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50U3R5bGVzID0gc3R5bGVzLnBvaW50O1xuICAgICAgICBpZiAocG9pbnRTdHlsZXMuc2hvdyAmJiBpc1ZhbGlkKHJpcHBsZVBvaW50Q29vcmRpbmF0ZSkpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4OiByaXBwbGVQb2ludENvb3JkaW5hdGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcmlwcGxlUG9pbnRDb29yZGluYXRlLnksXG4gICAgICAgICAgICAgICAgICAgIHI6IHBvaW50U3R5bGVzLnJhZGl1c1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZmlsbCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBwb2ludFN0eWxlcy5jb2xvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgdmFyIHJpcHBsZVJhZGl1cyA9IHBvaW50U3R5bGVzLnJpcHBsZVJhZGl1cztcbiAgICAgICAgICAgIGlmIChwb2ludFN0eWxlcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICByaXBwbGVSYWRpdXMgPSBwb2ludFN0eWxlcy5yYWRpdXMgKyB0aGlzLl9hbmltYXRpb25GcmFtZVRpbWUgLyBwb2ludFN0eWxlcy5hbmltYXRpb25EdXJhdGlvbiAqIChwb2ludFN0eWxlcy5yaXBwbGVSYWRpdXMgLSBwb2ludFN0eWxlcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbi5zZXREdXJhdGlvbihwb2ludFN0eWxlcy5hbmltYXRpb25EdXJhdGlvbikuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IHRoaXMuX3JpcHBsZVBvaW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2V0QXR0cnMoe1xuICAgICAgICAgICAgICAgIHg6IHJpcHBsZVBvaW50Q29vcmRpbmF0ZS54LFxuICAgICAgICAgICAgICAgIHk6IHJpcHBsZVBvaW50Q29vcmRpbmF0ZS55LFxuICAgICAgICAgICAgICAgIHI6IHJpcHBsZVJhZGl1c1xuICAgICAgICAgICAgfSkuc2V0U3R5bGVzKHsgc3R5bGU6ICdmaWxsJywgY29sb3I6IHBvaW50U3R5bGVzLnJpcHBsZUNvbG9yIH0pLmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYW5kbGVBcmVhVmlldy5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW5kbGVBcmVhVmlldztcbn0oQ2hpbGRyZW5WaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENhbmRsZUhpZ2hMb3dQcmljZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZUhpZ2hMb3dQcmljZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlSGlnaExvd1ByaWNlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDYW5kbGVIaWdoTG93UHJpY2VWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBwcmljZU1hcmtTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNhbmRsZS5wcmljZU1hcms7XG4gICAgICAgIHZhciBoaWdoUHJpY2VNYXJrU3R5bGVzID0gcHJpY2VNYXJrU3R5bGVzLmhpZ2g7XG4gICAgICAgIHZhciBsb3dQcmljZU1hcmtTdHlsZXMgPSBwcmljZU1hcmtTdHlsZXMubG93O1xuICAgICAgICBpZiAocHJpY2VNYXJrU3R5bGVzLnNob3cgJiYgKGhpZ2hQcmljZU1hcmtTdHlsZXMuc2hvdyB8fCBsb3dQcmljZU1hcmtTdHlsZXMuc2hvdykpIHtcbiAgICAgICAgICAgIHZhciBoaWdoZXN0TG93ZXN0UHJpY2UgPSBjaGFydFN0b3JlLmdldFZpc2libGVSYW5nZUhpZ2hMb3dQcmljZSgpO1xuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGNoYXJ0U3RvcmUuZ2V0UHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIHZhciBfYSA9IGhpZ2hlc3RMb3dlc3RQcmljZVswXSwgaGlnaCA9IF9hLnByaWNlLCBoaWdoWCA9IF9hLng7XG4gICAgICAgICAgICB2YXIgX2IgPSBoaWdoZXN0TG93ZXN0UHJpY2VbMV0sIGxvdyA9IF9iLnByaWNlLCBsb3dYID0gX2IueDtcbiAgICAgICAgICAgIHZhciBoaWdoWSA9IHlBeGlzLmNvbnZlcnRUb1BpeGVsKGhpZ2gpO1xuICAgICAgICAgICAgdmFyIGxvd1kgPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChsb3cpO1xuICAgICAgICAgICAgdmFyIGRlY2ltYWxGb2xkID0gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpO1xuICAgICAgICAgICAgdmFyIHRob3VzYW5kc1NlcGFyYXRvciA9IGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7XG4gICAgICAgICAgICBpZiAoaGlnaFByaWNlTWFya1N0eWxlcy5zaG93ICYmIGhpZ2ggIT09IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd01hcmsoY3R4LCBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oaGlnaCwgcHJlY2lzaW9uLnByaWNlKSkpLCB7IHg6IGhpZ2hYLCB5OiBoaWdoWSB9LCBoaWdoWSA8IGxvd1kgPyBbLTIsIC01XSA6IFsyLCA1XSwgaGlnaFByaWNlTWFya1N0eWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93UHJpY2VNYXJrU3R5bGVzLnNob3cgJiYgbG93ICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdNYXJrKGN0eCwgZGVjaW1hbEZvbGQuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKGxvdywgcHJlY2lzaW9uLnByaWNlKSkpLCB7IHg6IGxvd1gsIHk6IGxvd1kgfSwgaGlnaFkgPCBsb3dZID8gWzIsIDVdIDogWy0yLCAtNV0sIGxvd1ByaWNlTWFya1N0eWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmRsZUhpZ2hMb3dQcmljZVZpZXcucHJvdG90eXBlLl9kcmF3TWFyayA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIGNvb3JkaW5hdGUsIG9mZnNldHMsIHN0eWxlcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvb3JkaW5hdGUueDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGNvb3JkaW5hdGUueSArIG9mZnNldHNbMF07XG4gICAgICAgIChfYSA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzdGFydFggLSAyLCB5OiBzdGFydFkgKyBvZmZzZXRzWzBdIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc3RhcnRYLCB5OiBzdGFydFkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzdGFydFggKyAyLCB5OiBzdGFydFkgKyBvZmZzZXRzWzBdIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiBzdHlsZXMuY29sb3IgfVxuICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgdmFyIGxpbmVFbmRYID0gMDtcbiAgICAgICAgdmFyIHRleHRTdGFydFggPSAwO1xuICAgICAgICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZGdldCgpLmdldEJvdW5kaW5nKCkud2lkdGg7XG4gICAgICAgIGlmIChzdGFydFggPiB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgIGxpbmVFbmRYID0gc3RhcnRYIC0gNTtcbiAgICAgICAgICAgIHRleHRTdGFydFggPSBsaW5lRW5kWCAtIHN0eWxlcy50ZXh0T2Zmc2V0O1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVFbmRYID0gc3RhcnRYICsgNTtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIHRleHRTdGFydFggPSBsaW5lRW5kWCArIHN0eWxlcy50ZXh0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gc3RhcnRZICsgb2Zmc2V0c1sxXTtcbiAgICAgICAgKF9iID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc3RhcnRYLCB5OiB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogbGluZUVuZFgsIHk6IHkgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IHN0eWxlcy5jb2xvciB9XG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAoX2MgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHg6IHRleHRTdGFydFgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgYmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN0eWxlcy5jb2xvcixcbiAgICAgICAgICAgICAgICBzaXplOiBzdHlsZXMudGV4dFNpemUsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiBzdHlsZXMudGV4dEZhbWlseSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHN0eWxlcy50ZXh0V2VpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZHJhdyhjdHgpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZUhpZ2hMb3dQcmljZVZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlTGFzdFByaWNlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlTGFzdFByaWNlVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYW5kbGVMYXN0UHJpY2VWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhbmRsZUxhc3RQcmljZVZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgcHJpY2VNYXJrU3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5jYW5kbGUucHJpY2VNYXJrO1xuICAgICAgICB2YXIgbGFzdFByaWNlTWFya1N0eWxlcyA9IHByaWNlTWFya1N0eWxlcy5sYXN0O1xuICAgICAgICB2YXIgbGFzdFByaWNlTWFya0xpbmVTdHlsZXMgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLmxpbmU7XG4gICAgICAgIGlmIChwcmljZU1hcmtTdHlsZXMuc2hvdyAmJiBsYXN0UHJpY2VNYXJrU3R5bGVzLnNob3cgJiYgbGFzdFByaWNlTWFya0xpbmVTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB2YXIgZGF0YUxpc3QgPSBjaGFydFN0b3JlLmdldERhdGFMaXN0KCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2RhdGFMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VfMSA9IGRhdGEuY2xvc2UsIG9wZW5fMSA9IGRhdGEub3BlbjtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVByaWNlID0gbGFzdFByaWNlTWFya1N0eWxlcy5jb21wYXJlUnVsZSA9PT0gQ2FuZGxlQ29sb3JDb21wYXJlUnVsZS5DdXJyZW50T3BlbiA/IG9wZW5fMSA6ICgoX2IgPSAoX2EgPSBkYXRhTGlzdFtkYXRhTGlzdC5sZW5ndGggLSAyXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjbG9zZV8xKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpY2VZID0geUF4aXMuY29udmVydFRvTmljZVBpeGVsKGNsb3NlXzEpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZV8xID4gY29tcGFyZVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFzdFByaWNlTWFya1N0eWxlcy51cENvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZV8xIDwgY29tcGFyZVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFzdFByaWNlTWFya1N0eWxlcy5kb3duQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGxhc3RQcmljZU1hcmtTdHlsZXMubm9DaGFuZ2VDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogMCwgeTogcHJpY2VZIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiBib3VuZGluZy53aWR0aCwgeTogcHJpY2VZIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogbGFzdFByaWNlTWFya0xpbmVTdHlsZXMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBsYXN0UHJpY2VNYXJrTGluZVN0eWxlcy5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGFzaGVkVmFsdWU6IGxhc3RQcmljZU1hcmtMaW5lU3R5bGVzLmRhc2hlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZUxhc3RQcmljZVZpZXc7XG59KFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQXhpc1Bvc2l0aW9uO1xuKGZ1bmN0aW9uIChBeGlzUG9zaXRpb24pIHtcbiAgICBBeGlzUG9zaXRpb25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgQXhpc1Bvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG59KShBeGlzUG9zaXRpb24gfHwgKEF4aXNQb3NpdGlvbiA9IHt9KSk7XG5mdW5jdGlvbiBnZXREZWZhdWx0QXhpc1JhbmdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAwLFxuICAgICAgICByYW5nZTogMCxcbiAgICAgICAgcmVhbEZyb206IDAsXG4gICAgICAgIHJlYWxUbzogMCxcbiAgICAgICAgcmVhbFJhbmdlOiAwLFxuICAgICAgICBkaXNwbGF5RnJvbTogMCxcbiAgICAgICAgZGlzcGxheVRvOiAwLFxuICAgICAgICBkaXNwbGF5UmFuZ2U6IDBcbiAgICB9O1xufVxudmFyIEF4aXNJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXhpc0ltcChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxab29tRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gZ2V0RGVmYXVsdEF4aXNSYW5nZSgpO1xuICAgICAgICB0aGlzLl9wcmV2UmFuZ2UgPSBnZXREZWZhdWx0QXhpc1JhbmdlKCk7XG4gICAgICAgIHRoaXMuX3RpY2tzID0gW107XG4gICAgICAgIHRoaXMuX2F1dG9DYWxjVGlja0ZsYWcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIEF4aXNJbXAucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfTtcbiAgICBBeGlzSW1wLnByb3RvdHlwZS5idWlsZFRpY2tzID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ2FsY1RpY2tGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZSA9IHRoaXMuY3JlYXRlUmFuZ2VJbXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJldlJhbmdlLmZyb20gIT09IHRoaXMuX3JhbmdlLmZyb20gfHwgdGhpcy5fcHJldlJhbmdlLnRvICE9PSB0aGlzLl9yYW5nZS50byB8fCBmb3JjZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldlJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgICAgICAgICB0aGlzLl90aWNrcyA9IHRoaXMuY3JlYXRlVGlja3NJbXAoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlja3M7XG4gICAgfTtcbiAgICBBeGlzSW1wLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB0aGlzLl9hdXRvQ2FsY1RpY2tGbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgfTtcbiAgICBBeGlzSW1wLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JhbmdlOyB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLnNldEF1dG9DYWxjVGlja0ZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICB0aGlzLl9hdXRvQ2FsY1RpY2tGbGFnID0gZmxhZztcbiAgICB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLmdldEF1dG9DYWxjVGlja0ZsYWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hdXRvQ2FsY1RpY2tGbGFnOyB9O1xuICAgIHJldHVybiBBeGlzSW1wO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgemhDTiA9IHtcbiAgICB0aW1lOiAn5pe26Ze077yaJyxcbiAgICBvcGVuOiAn5byA77yaJyxcbiAgICBoaWdoOiAn6auY77yaJyxcbiAgICBsb3c6ICfkvY7vvJonLFxuICAgIGNsb3NlOiAn5pS277yaJyxcbiAgICB2b2x1bWU6ICfmiJDkuqTph4/vvJonLFxuICAgIHR1cm5vdmVyOiAn5oiQ5Lqk6aKd77yaJyxcbiAgICBjaGFuZ2U6ICfmtqjluYXvvJonXG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBlblVTID0ge1xuICAgIHRpbWU6ICdUaW1lOiAnLFxuICAgIG9wZW46ICdPcGVuOiAnLFxuICAgIGhpZ2g6ICdIaWdoOiAnLFxuICAgIGxvdzogJ0xvdzogJyxcbiAgICBjbG9zZTogJ0Nsb3NlOiAnLFxuICAgIHZvbHVtZTogJ1ZvbHVtZTogJyxcbiAgICB0dXJub3ZlcjogJ1R1cm5vdmVyOiAnLFxuICAgIGNoYW5nZTogJ0NoYW5nZTogJ1xufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbG9jYWxlcyA9IHtcbiAgICAnemgtQ04nOiB6aENOLFxuICAgICdlbi1VUyc6IGVuVVNcbn07XG5mdW5jdGlvbiByZWdpc3RlckxvY2FsZShsb2NhbGUsIGxzKSB7XG4gICAgbG9jYWxlc1tsb2NhbGVdID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxvY2FsZXNbbG9jYWxlXSksIGxzKTtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvY2FsZXMpO1xufVxuZnVuY3Rpb24gaTE4bihrZXksIGxvY2FsZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gbG9jYWxlc1tsb2NhbGVdW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGtleTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlVG9vbHRpcFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZVRvb2x0aXBWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZVRvb2x0aXBWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhbmRsZVRvb2x0aXBWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY3Jvc3NoYWlyLmtMaW5lRGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCk7XG4gICAgICAgICAgICB2YXIgY2FuZGxlU3R5bGVzID0gc3R5bGVzLmNhbmRsZTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JTdHlsZXMgPSBzdHlsZXMuaW5kaWNhdG9yO1xuICAgICAgICAgICAgaWYgKGNhbmRsZVN0eWxlcy50b29sdGlwLnNob3dUeXBlID09PSBUb29sdGlwU2hvd1R5cGUuUmVjdCAmJlxuICAgICAgICAgICAgICAgIGluZGljYXRvclN0eWxlcy50b29sdGlwLnNob3dUeXBlID09PSBUb29sdGlwU2hvd1R5cGUuUmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYXdDYW5kbGVUb29sdGlwID0gdGhpcy5pc0RyYXdUb29sdGlwKGNyb3NzaGFpciwgY2FuZGxlU3R5bGVzLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYXdJbmRpY2F0b3JUb29sdGlwID0gdGhpcy5pc0RyYXdUb29sdGlwKGNyb3NzaGFpciwgaW5kaWNhdG9yU3R5bGVzLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdSZWN0VG9vbHRpcChjdHgsIGlzRHJhd0NhbmRsZVRvb2x0aXAsIGlzRHJhd0luZGljYXRvclRvb2x0aXAsIGNhbmRsZVN0eWxlcy50b29sdGlwLm9mZnNldFRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYW5kbGVTdHlsZXMudG9vbHRpcC5zaG93VHlwZSA9PT0gVG9vbHRpcFNob3dUeXBlLlN0YW5kYXJkICYmXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yU3R5bGVzLnRvb2x0aXAuc2hvd1R5cGUgPT09IFRvb2x0aXBTaG93VHlwZS5TdGFuZGFyZCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNhbmRsZVN0eWxlcy50b29sdGlwLCBvZmZzZXRMZWZ0ID0gX2Eub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Eub2Zmc2V0VG9wLCBvZmZzZXRSaWdodCA9IF9hLm9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IGJvdW5kaW5nLndpZHRoIC0gb2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdGhpcy5fZHJhd0NhbmRsZVN0YW5kYXJkVG9vbHRpcChjdHgsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0luZGljYXRvclRvb2x0aXAoY3R4LCBvZmZzZXRMZWZ0LCB0b3BfMSwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FuZGxlU3R5bGVzLnRvb2x0aXAuc2hvd1R5cGUgPT09IFRvb2x0aXBTaG93VHlwZS5SZWN0ICYmXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yU3R5bGVzLnRvb2x0aXAuc2hvd1R5cGUgPT09IFRvb2x0aXBTaG93VHlwZS5TdGFuZGFyZCkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNhbmRsZVN0eWxlcy50b29sdGlwLCBvZmZzZXRMZWZ0ID0gX2Iub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Iub2Zmc2V0VG9wLCBvZmZzZXRSaWdodCA9IF9iLm9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IGJvdW5kaW5nLndpZHRoIC0gb2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvcF8yID0gdGhpcy5kcmF3SW5kaWNhdG9yVG9vbHRpcChjdHgsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYXdDYW5kbGVUb29sdGlwID0gdGhpcy5pc0RyYXdUb29sdGlwKGNyb3NzaGFpciwgY2FuZGxlU3R5bGVzLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdSZWN0VG9vbHRpcChjdHgsIGlzRHJhd0NhbmRsZVRvb2x0aXAsIGZhbHNlLCB0b3BfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBjYW5kbGVTdHlsZXMudG9vbHRpcCwgb2Zmc2V0TGVmdCA9IF9jLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IF9jLm9mZnNldFRvcCwgb2Zmc2V0UmlnaHQgPSBfYy5vZmZzZXRSaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgbWF4V2lkdGggPSBib3VuZGluZy53aWR0aCAtIG9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB0b3BfMyA9IHRoaXMuX2RyYXdDYW5kbGVTdGFuZGFyZFRvb2x0aXAoY3R4LCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCA9IHRoaXMuaXNEcmF3VG9vbHRpcChjcm9zc2hhaXIsIGluZGljYXRvclN0eWxlcy50b29sdGlwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3UmVjdFRvb2x0aXAoY3R4LCBmYWxzZSwgaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCwgdG9wXzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYW5kbGVUb29sdGlwVmlldy5wcm90b3R5cGUuX2RyYXdDYW5kbGVTdGFuZGFyZFRvb2x0aXAgPSBmdW5jdGlvbiAoY3R4LCBsZWZ0LCB0b3AsIG1heFdpZHRoKSB7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNhbmRsZTtcbiAgICAgICAgdmFyIHRvb2x0aXBTdHlsZXMgPSBzdHlsZXMudG9vbHRpcDtcbiAgICAgICAgdmFyIHRvb2x0aXBUZXh0U3R5bGVzID0gdG9vbHRpcFN0eWxlcy50ZXh0O1xuICAgICAgICB2YXIgcHJldlJvd0hlaWdodCA9IDA7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0geyB4OiBsZWZ0LCB5OiB0b3AgfTtcbiAgICAgICAgdmFyIGNyb3NzaGFpciA9IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCk7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhd1Rvb2x0aXAoY3Jvc3NoYWlyLCB0b29sdGlwU3R5bGVzKSkge1xuICAgICAgICAgICAgdmFyIGxlZ2VuZHMgPSB0aGlzLl9nZXRDYW5kbGVUb29sdGlwTGVnZW5kcygpO1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHRoaXMuY2xhc3NpZnlUb29sdGlwRmVhdHVyZXModG9vbHRpcFN0eWxlcy5mZWF0dXJlcyksIDMpLCBsZWZ0RmVhdHVyZXMgPSBfYVswXSwgbWlkZGxlRmVhdHVyZXMgPSBfYVsxXSwgcmlnaHRGZWF0dXJlcyA9IF9hWzJdO1xuICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IHRoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzKGN0eCwgbGVmdEZlYXR1cmVzLCBjb29yZGluYXRlLCBudWxsLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gdGhpcy5kcmF3U3RhbmRhcmRUb29sdGlwRmVhdHVyZXMoY3R4LCBtaWRkbGVGZWF0dXJlcywgY29vcmRpbmF0ZSwgbnVsbCwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgaWYgKGxlZ2VuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSB0aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBMZWdlbmRzKGN0eCwgbGVnZW5kcywgY29vcmRpbmF0ZSwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgsIHRvb2x0aXBUZXh0U3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSB0aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBGZWF0dXJlcyhjdHgsIHJpZ2h0RmVhdHVyZXMsIGNvb3JkaW5hdGUsIG51bGwsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZS55ICsgcHJldlJvd0hlaWdodDtcbiAgICB9O1xuICAgIENhbmRsZVRvb2x0aXBWaWV3LnByb3RvdHlwZS5fZHJhd1JlY3RUb29sdGlwID0gZnVuY3Rpb24gKGN0eCwgaXNEcmF3Q2FuZGxlVG9vbHRpcCwgaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCwgdG9wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCk7XG4gICAgICAgIHZhciBjYW5kbGVTdHlsZXMgPSBzdHlsZXMuY2FuZGxlO1xuICAgICAgICB2YXIgaW5kaWNhdG9yU3R5bGVzID0gc3R5bGVzLmluZGljYXRvcjtcbiAgICAgICAgdmFyIGNhbmRsZVRvb2x0aXBTdHlsZXMgPSBjYW5kbGVTdHlsZXMudG9vbHRpcDtcbiAgICAgICAgdmFyIGluZGljYXRvclRvb2x0aXBTdHlsZXMgPSBpbmRpY2F0b3JTdHlsZXMudG9vbHRpcDtcbiAgICAgICAgaWYgKGlzRHJhd0NhbmRsZVRvb2x0aXAgfHwgaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCkge1xuICAgICAgICAgICAgdmFyIGNhbmRsZUxlZ2VuZHMgPSB0aGlzLl9nZXRDYW5kbGVUb29sdGlwTGVnZW5kcygpO1xuICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBjYW5kbGVUb29sdGlwU3R5bGVzLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IGNhbmRsZVRvb2x0aXBTdHlsZXMub2Zmc2V0VG9wLCBvZmZzZXRSaWdodCA9IGNhbmRsZVRvb2x0aXBTdHlsZXMub2Zmc2V0UmlnaHQsIG9mZnNldEJvdHRvbSA9IGNhbmRsZVRvb2x0aXBTdHlsZXMub2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgdmFyIF9jID0gY2FuZGxlVG9vbHRpcFN0eWxlcy50ZXh0LCBiYXNlVGV4dE1hcmdpbkxlZnRfMSA9IF9jLm1hcmdpbkxlZnQsIGJhc2VUZXh0TWFyZ2luUmlnaHRfMSA9IF9jLm1hcmdpblJpZ2h0LCBiYXNlVGV4dE1hcmdpblRvcF8xID0gX2MubWFyZ2luVG9wLCBiYXNlVGV4dE1hcmdpbkJvdHRvbV8xID0gX2MubWFyZ2luQm90dG9tLCBiYXNlVGV4dFNpemVfMSA9IF9jLnNpemUsIGJhc2VUZXh0V2VpZ2h0XzEgPSBfYy53ZWlnaHQsIGJhc2VUZXh0RmFtaWx5XzEgPSBfYy5mYW1pbHk7XG4gICAgICAgICAgICB2YXIgX2QgPSBjYW5kbGVUb29sdGlwU3R5bGVzLnJlY3QsIHJlY3RQb3NpdGlvbiA9IF9kLnBvc2l0aW9uLCByZWN0UGFkZGluZ0xlZnQgPSBfZC5wYWRkaW5nTGVmdCwgcmVjdFBhZGRpbmdSaWdodF8xID0gX2QucGFkZGluZ1JpZ2h0LCByZWN0UGFkZGluZ1RvcCA9IF9kLnBhZGRpbmdUb3AsIHJlY3RQYWRkaW5nQm90dG9tID0gX2QucGFkZGluZ0JvdHRvbSwgcmVjdE9mZnNldExlZnQgPSBfZC5vZmZzZXRMZWZ0LCByZWN0T2Zmc2V0UmlnaHQgPSBfZC5vZmZzZXRSaWdodCwgcmVjdE9mZnNldFRvcCA9IF9kLm9mZnNldFRvcCwgcmVjdE9mZnNldEJvdHRvbSA9IF9kLm9mZnNldEJvdHRvbSwgcmVjdEJvcmRlclNpemVfMSA9IF9kLmJvcmRlclNpemUsIHJlY3RCb3JkZXJSYWRpdXMgPSBfZC5ib3JkZXJSYWRpdXMsIHJlY3RCb3JkZXJDb2xvciA9IF9kLmJvcmRlckNvbG9yLCByZWN0QmFja2dyb3VuZENvbG9yID0gX2QuY29sb3I7XG4gICAgICAgICAgICB2YXIgbWF4VGV4dFdpZHRoXzEgPSAwO1xuICAgICAgICAgICAgdmFyIHJlY3RXaWR0aF8xID0gMDtcbiAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0XzEgPSAwO1xuICAgICAgICAgICAgaWYgKGlzRHJhd0NhbmRsZVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQoYmFzZVRleHRTaXplXzEsIGJhc2VUZXh0V2VpZ2h0XzEsIGJhc2VUZXh0RmFtaWx5XzEpO1xuICAgICAgICAgICAgICAgIGNhbmRsZUxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCIuY29uY2F0KHRpdGxlLnRleHQpLmNvbmNhdCh2YWx1ZS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGggKyBiYXNlVGV4dE1hcmdpbkxlZnRfMSArIGJhc2VUZXh0TWFyZ2luUmlnaHRfMTtcbiAgICAgICAgICAgICAgICAgICAgbWF4VGV4dFdpZHRoXzEgPSBNYXRoLm1heChtYXhUZXh0V2lkdGhfMSwgbGFiZWxXaWR0aCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVjdEhlaWdodF8xICs9ICgoYmFzZVRleHRNYXJnaW5Cb3R0b21fMSArIGJhc2VUZXh0TWFyZ2luVG9wXzEgKyBiYXNlVGV4dFNpemVfMSkgKiBjYW5kbGVMZWdlbmRzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2UgPSBpbmRpY2F0b3JUb29sdGlwU3R5bGVzLnRleHQsIGluZGljYXRvclRleHRNYXJnaW5MZWZ0XzEgPSBfZS5tYXJnaW5MZWZ0LCBpbmRpY2F0b3JUZXh0TWFyZ2luUmlnaHRfMSA9IF9lLm1hcmdpblJpZ2h0LCBpbmRpY2F0b3JUZXh0TWFyZ2luVG9wXzEgPSBfZS5tYXJnaW5Ub3AsIGluZGljYXRvclRleHRNYXJnaW5Cb3R0b21fMSA9IF9lLm1hcmdpbkJvdHRvbSwgaW5kaWNhdG9yVGV4dFNpemVfMSA9IF9lLnNpemUsIGluZGljYXRvclRleHRXZWlnaHRfMSA9IF9lLndlaWdodCwgaW5kaWNhdG9yVGV4dEZhbWlseV8xID0gX2UuZmFtaWx5O1xuICAgICAgICAgICAgdmFyIGluZGljYXRvckxlZ2VuZHNBcnJheV8xID0gW107XG4gICAgICAgICAgICBpZiAoaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQoaW5kaWNhdG9yVGV4dFNpemVfMSwgaW5kaWNhdG9yVGV4dFdlaWdodF8xLCBpbmRpY2F0b3JUZXh0RmFtaWx5XzEpO1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b29sdGlwRGF0YUxlZ2VuZHMgPSBfdGhpcy5nZXRJbmRpY2F0b3JUb29sdGlwRGF0YShpbmRpY2F0b3IpLmxlZ2VuZHM7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckxlZ2VuZHNBcnJheV8xLnB1c2godG9vbHRpcERhdGFMZWdlbmRzKTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcERhdGFMZWdlbmRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBcIlwiLmNvbmNhdCh0aXRsZS50ZXh0KS5jb25jYXQodmFsdWUudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgaW5kaWNhdG9yVGV4dE1hcmdpbkxlZnRfMSArIGluZGljYXRvclRleHRNYXJnaW5SaWdodF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VGV4dFdpZHRoXzEgPSBNYXRoLm1heChtYXhUZXh0V2lkdGhfMSwgdGV4dFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RIZWlnaHRfMSArPSAoaW5kaWNhdG9yVGV4dE1hcmdpblRvcF8xICsgaW5kaWNhdG9yVGV4dE1hcmdpbkJvdHRvbV8xICsgaW5kaWNhdG9yVGV4dFNpemVfMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdFdpZHRoXzEgKz0gbWF4VGV4dFdpZHRoXzE7XG4gICAgICAgICAgICBpZiAocmVjdFdpZHRoXzEgIT09IDAgJiYgcmVjdEhlaWdodF8xICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNyb3NzaGFpciA9IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzQm91bmRpbmcgPSBwYW5lLmdldFlBeGlzV2lkZ2V0KCkuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICByZWN0V2lkdGhfMSArPSAocmVjdEJvcmRlclNpemVfMSAqIDIgKyByZWN0UGFkZGluZ0xlZnQgKyByZWN0UGFkZGluZ1JpZ2h0XzEpO1xuICAgICAgICAgICAgICAgIHJlY3RIZWlnaHRfMSArPSAocmVjdEJvcmRlclNpemVfMSAqIDIgKyByZWN0UGFkZGluZ1RvcCArIHJlY3RQYWRkaW5nQm90dG9tKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyWCA9IGJvdW5kaW5nLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgaXNQb2ludGVyID0gcmVjdFBvc2l0aW9uID09PSBDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uLlBvaW50ZXIgJiYgY3Jvc3NoYWlyLnBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRTtcbiAgICAgICAgICAgICAgICB2YXIgaXNMZWZ0ID0gKChfYSA9IGNyb3NzaGFpci5yZWFsWCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgPiBjZW50ZXJYO1xuICAgICAgICAgICAgICAgIHZhciByZWN0WF8xID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFsWCA9IGNyb3NzaGFpci5yZWFsWDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFhfMSA9IHJlYWxYIC0gcmVjdE9mZnNldFJpZ2h0IC0gcmVjdFdpZHRoXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xID0gcmVhbFggKyByZWN0T2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xID0gcmVjdE9mZnNldExlZnQgKyBvZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlBeGlzLmluc2lkZSAmJiB5QXhpcy5wb3NpdGlvbiA9PT0gQXhpc1Bvc2l0aW9uLkxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xICs9IHlBeGlzQm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xID0gYm91bmRpbmcud2lkdGggLSByZWN0T2Zmc2V0UmlnaHQgLSByZWN0V2lkdGhfMSAtIG9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlBeGlzLmluc2lkZSAmJiB5QXhpcy5wb3NpdGlvbiA9PT0gQXhpc1Bvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFhfMSAtPSB5QXhpc0JvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZWN0WSA9IHRvcCArIHJlY3RPZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgaWYgKGlzUG9pbnRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGNyb3NzaGFpci55O1xuICAgICAgICAgICAgICAgICAgICByZWN0WSA9IHkgLSByZWN0SGVpZ2h0XzEgLyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdFkgKyByZWN0SGVpZ2h0XzEgPiBib3VuZGluZy5oZWlnaHQgLSByZWN0T2Zmc2V0Qm90dG9tIC0gb2Zmc2V0Qm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WSA9IGJvdW5kaW5nLmhlaWdodCAtIHJlY3RPZmZzZXRCb3R0b20gLSByZWN0SGVpZ2h0XzEgLSBvZmZzZXRCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RZIDwgdG9wICsgcmVjdE9mZnNldFRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFkgPSB0b3AgKyByZWN0T2Zmc2V0VG9wICsgb2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFhfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHJlY3RZLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3RXaWR0aF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0SGVpZ2h0XzFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuU3Ryb2tlRmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZWN0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlY3RCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclNpemU6IHJlY3RCb3JkZXJTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3RCb3JkZXJSYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIHZhciBjYW5kbGVUZXh0WF8xID0gcmVjdFhfMSArIHJlY3RCb3JkZXJTaXplXzEgKyByZWN0UGFkZGluZ0xlZnQgKyBiYXNlVGV4dE1hcmdpbkxlZnRfMTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFlfMSA9IHJlY3RZICsgcmVjdEJvcmRlclNpemVfMSArIHJlY3RQYWRkaW5nVG9wO1xuICAgICAgICAgICAgICAgIGlmIChpc0RyYXdDYW5kbGVUb29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBjYW5kbGUgdGV4dHNcbiAgICAgICAgICAgICAgICAgICAgY2FuZGxlTGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFlfMSArPSBiYXNlVGV4dE1hcmdpblRvcF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNhbmRsZVRleHRYXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRleHRZXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRpdGxlLnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGJhc2VUZXh0U2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk6IGJhc2VUZXh0RmFtaWx5XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogYmFzZVRleHRXZWlnaHRfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJlY3RYXzEgKyByZWN0V2lkdGhfMSAtIHJlY3RCb3JkZXJTaXplXzEgLSBiYXNlVGV4dE1hcmdpblJpZ2h0XzEgLSByZWN0UGFkZGluZ1JpZ2h0XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRleHRZXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHZhbHVlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBiYXNlVGV4dFNpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5OiBiYXNlVGV4dEZhbWlseV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGJhc2VUZXh0V2VpZ2h0XzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRZXzEgKz0gKGJhc2VUZXh0U2l6ZV8xICsgYmFzZVRleHRNYXJnaW5Cb3R0b21fMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgaW5kaWNhdG9yIHRleHRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3JUZXh0WF8xID0gcmVjdFhfMSArIHJlY3RCb3JkZXJTaXplXzEgKyByZWN0UGFkZGluZ0xlZnQgKyBpbmRpY2F0b3JUZXh0TWFyZ2luTGVmdF8xO1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JMZWdlbmRzQXJyYXlfMS5mb3JFYWNoKGZ1bmN0aW9uIChsZWdlbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRZXzEgKz0gaW5kaWNhdG9yVGV4dE1hcmdpblRvcF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmRpY2F0b3JUZXh0WF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGV4dFlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRpdGxlLnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBpbmRpY2F0b3JUZXh0U2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5OiBpbmRpY2F0b3JUZXh0RmFtaWx5XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGluZGljYXRvclRleHRXZWlnaHRfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFhfMSArIHJlY3RXaWR0aF8xIC0gcmVjdEJvcmRlclNpemVfMSAtIGluZGljYXRvclRleHRNYXJnaW5SaWdodF8xIC0gcmVjdFBhZGRpbmdSaWdodF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGV4dFlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogJ3JpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB2YWx1ZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGluZGljYXRvclRleHRTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk6IGluZGljYXRvclRleHRGYW1pbHlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogaW5kaWNhdG9yVGV4dFdlaWdodF8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0WV8xICs9IChpbmRpY2F0b3JUZXh0U2l6ZV8xICsgaW5kaWNhdG9yVGV4dE1hcmdpbkJvdHRvbV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmRsZVRvb2x0aXBWaWV3LnByb3RvdHlwZS5fZ2V0Q2FuZGxlVG9vbHRpcExlZ2VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5jYW5kbGU7XG4gICAgICAgIHZhciBkYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgdmFyIGN1c3RvbUFwaSA9IGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCk7XG4gICAgICAgIHZhciBkZWNpbWFsRm9sZCA9IGNoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1NlcGFyYXRvciA9IGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7XG4gICAgICAgIHZhciBsb2NhbGUgPSBjaGFydFN0b3JlLmdldExvY2FsZSgpO1xuICAgICAgICB2YXIgX2cgPSBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLCBwcmljZVByZWNpc2lvbiA9IF9nLnByaWNlLCB2b2x1bWVQcmVjaXNpb24gPSBfZy52b2x1bWU7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSAoX2EgPSBjaGFydFN0b3JlLmdldENyb3NzaGFpcigpLmRhdGFJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgdmFyIHRvb2x0aXBTdHlsZXMgPSBzdHlsZXMudG9vbHRpcDtcbiAgICAgICAgdmFyIHRleHRDb2xvciA9IHRvb2x0aXBTdHlsZXMudGV4dC5jb2xvcjtcbiAgICAgICAgdmFyIHByZXYgPSAoX2IgPSBkYXRhTGlzdFtkYXRhSW5kZXggLSAxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBkYXRhTGlzdFtkYXRhSW5kZXhdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgdmFyIHByZXZDbG9zZSA9IChfYyA9IHByZXYgPT09IG51bGwgfHwgcHJldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldi5jbG9zZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3VycmVudC5jbG9zZTtcbiAgICAgICAgdmFyIGNoYW5nZVZhbHVlID0gY3VycmVudC5jbG9zZSAtIHByZXZDbG9zZTtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAne3RpbWV9JzogY3VzdG9tQXBpLmZvcm1hdERhdGUoY3VycmVudC50aW1lc3RhbXAsICdZWVlZLU1NLUREIEhIOm1tJywgRm9ybWF0RGF0ZVR5cGUuVG9vbHRpcCksXG4gICAgICAgICAgICAne29wZW59JzogZGVjaW1hbEZvbGQuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKGN1cnJlbnQub3BlbiwgcHJpY2VQcmVjaXNpb24pKSksXG4gICAgICAgICAgICAne2hpZ2h9JzogZGVjaW1hbEZvbGQuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKGN1cnJlbnQuaGlnaCwgcHJpY2VQcmVjaXNpb24pKSksXG4gICAgICAgICAgICAne2xvd30nOiBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oY3VycmVudC5sb3csIHByaWNlUHJlY2lzaW9uKSkpLFxuICAgICAgICAgICAgJ3tjbG9zZX0nOiBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oY3VycmVudC5jbG9zZSwgcHJpY2VQcmVjaXNpb24pKSksXG4gICAgICAgICAgICAne3ZvbHVtZX0nOiBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChjdXN0b21BcGkuZm9ybWF0QmlnTnVtYmVyKGZvcm1hdFByZWNpc2lvbigoX2QgPSBjdXJyZW50LnZvbHVtZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdG9vbHRpcFN0eWxlcy5kZWZhdWx0VmFsdWUsIHZvbHVtZVByZWNpc2lvbikpKSksXG4gICAgICAgICAgICAne3R1cm5vdmVyfSc6IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KGZvcm1hdFByZWNpc2lvbigoX2UgPSBjdXJyZW50LnR1cm5vdmVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSwgcHJpY2VQcmVjaXNpb24pKSksXG4gICAgICAgICAgICAne2NoYW5nZX0nOiBwcmV2Q2xvc2UgPT09IDAgPyB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSA6IFwiXCIuY29uY2F0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKGNoYW5nZVZhbHVlIC8gcHJldkNsb3NlICogMTAwKSksIFwiJVwiKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbGVnZW5kcyA9IChpc0Z1bmN0aW9uKHRvb2x0aXBTdHlsZXMuY3VzdG9tKVxuICAgICAgICAgICAgPyB0b29sdGlwU3R5bGVzLmN1c3RvbSh7IHByZXY6IHByZXYsIGN1cnJlbnQ6IGN1cnJlbnQsIG5leHQ6IChfZiA9IGRhdGFMaXN0W2RhdGFJbmRleCArIDFdKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsIH0sIHN0eWxlcylcbiAgICAgICAgICAgIDogdG9vbHRpcFN0eWxlcy5jdXN0b20pO1xuICAgICAgICByZXR1cm4gbGVnZW5kcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBfYS50aXRsZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0ID0geyB0ZXh0OiAnJywgY29sb3I6IHRleHRDb2xvciB9O1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRpdGxlKSkge1xuICAgICAgICAgICAgICAgIHQgPSBfX2Fzc2lnbih7fSwgdGl0bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdC50ZXh0ID0gdGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LnRleHQgPSBpMThuKHQudGV4dCwgbG9jYWxlKTtcbiAgICAgICAgICAgIHZhciB2ID0geyB0ZXh0OiB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSwgY29sb3I6IHRleHRDb2xvciB9O1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHYgPSBfX2Fzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdi50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSAveyhcXFMqKX0vLmV4ZWModi50ZXh0KTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IFwie1wiLmNvbmNhdChtYXRjaFsxXSwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgIHYudGV4dCA9IHYudGV4dC5yZXBsYWNlKGtleSwgKChfYiA9IG1hcHBpbmdba2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdG9vbHRpcFN0eWxlcy5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAne2NoYW5nZX0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuY29sb3IgPSBjaGFuZ2VWYWx1ZSA9PT0gMCA/IHN0eWxlcy5wcmljZU1hcmsubGFzdC5ub0NoYW5nZUNvbG9yIDogKGNoYW5nZVZhbHVlID4gMCA/IHN0eWxlcy5wcmljZU1hcmsubGFzdC51cENvbG9yIDogc3R5bGVzLnByaWNlTWFyay5sYXN0LmRvd25Db2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdGl0bGU6IHQsIHZhbHVlOiB2IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZVRvb2x0aXBWaWV3O1xufShJbmRpY2F0b3JUb29sdGlwVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDYW5kbGVXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZVdpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYW5kbGVXaWRnZXQocm9vdENvbnRhaW5lciwgcGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290Q29udGFpbmVyLCBwYW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2FuZGxlQmFyVmlldyA9IG5ldyBDYW5kbGVCYXJWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2NhbmRsZUFyZWFWaWV3ID0gbmV3IENhbmRsZUFyZWFWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2NhbmRsZUhpZ2hMb3dQcmljZVZpZXcgPSBuZXcgQ2FuZGxlSGlnaExvd1ByaWNlVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9jYW5kbGVMYXN0UHJpY2VMaW5lVmlldyA9IG5ldyBDYW5kbGVMYXN0UHJpY2VWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuX2NhbmRsZUJhclZpZXcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhbmRsZVdpZGdldC5wcm90b3R5cGUudXBkYXRlTWFpbkNvbnRlbnQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBjYW5kbGVTdHlsZXMgPSB0aGlzLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldFN0eWxlcygpLmNhbmRsZTtcbiAgICAgICAgaWYgKGNhbmRsZVN0eWxlcy50eXBlICE9PSBDYW5kbGVUeXBlLkFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmRsZUJhclZpZXcuZHJhdyhjdHgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuZGxlSGlnaExvd1ByaWNlVmlldy5kcmF3KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5kbGVBcmVhVmlldy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5kbGVBcmVhVmlldy5kcmF3KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuZGxlTGFzdFByaWNlTGluZVZpZXcuZHJhdyhjdHgpO1xuICAgIH07XG4gICAgQ2FuZGxlV2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVUb29sdGlwVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW5kbGVUb29sdGlwVmlldyh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDYW5kbGVXaWRnZXQ7XG59KEluZGljYXRvcldpZGdldCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBBeGlzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXhpc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQXhpc1ZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4LCBleHRlbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHZhciBheGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldEF4aXNTdHlsZXMocGFuZS5nZXRDaGFydCgpLmdldFN0eWxlcygpKTtcbiAgICAgICAgaWYgKHN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVzLmF4aXNMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHRoaXMuY3JlYXRlQXhpc0xpbmUoYm91bmRpbmcsIHN0eWxlcyksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLmF4aXNMaW5lXG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWV4dGVuZFswXSkge1xuICAgICAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuZ2V0VGlja3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLnRpY2tMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5jcmVhdGVUaWNrTGluZXModGlja3MsIGJvdW5kaW5nLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlcy50aWNrTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLnRpY2tUZXh0LnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRzID0gdGhpcy5jcmVhdGVUaWNrVGV4dHModGlja3MsIGJvdW5kaW5nLCBzdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogdGV4dHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlcy50aWNrVGV4dFxuICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBeGlzVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBZQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFlBeGlzVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBZQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWUF4aXNWaWV3LnByb3RvdHlwZS5nZXRBeGlzU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLnlBeGlzO1xuICAgIH07XG4gICAgWUF4aXNWaWV3LnByb3RvdHlwZS5jcmVhdGVBeGlzTGluZSA9IGZ1bmN0aW9uIChib3VuZGluZywgc3R5bGVzKSB7XG4gICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIHNpemUgPSBzdHlsZXMuYXhpc0xpbmUuc2l6ZTtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICBpZiAoeUF4aXMuaXNGcm9tWmVybygpKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSBib3VuZGluZy53aWR0aCAtIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgeyB4OiB4LCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4LCB5OiBib3VuZGluZy5oZWlnaHQgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgWUF4aXNWaWV3LnByb3RvdHlwZS5jcmVhdGVUaWNrTGluZXMgPSBmdW5jdGlvbiAodGlja3MsIGJvdW5kaW5nLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgYXhpc0xpbmVTdHlsZXMgPSBzdHlsZXMuYXhpc0xpbmU7XG4gICAgICAgIHZhciB0aWNrTGluZVN0eWxlcyA9IHN0eWxlcy50aWNrTGluZTtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgICAgIHZhciBlbmRYID0gMDtcbiAgICAgICAgaWYgKHlBeGlzLmlzRnJvbVplcm8oKSkge1xuICAgICAgICAgICAgc3RhcnRYID0gMDtcbiAgICAgICAgICAgIGlmIChheGlzTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgc3RhcnRYICs9IGF4aXNMaW5lU3R5bGVzLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRYID0gc3RhcnRYICsgdGlja0xpbmVTdHlsZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRYID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICBpZiAoYXhpc0xpbmVTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHN0YXJ0WCAtPSBheGlzTGluZVN0eWxlcy5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kWCA9IHN0YXJ0WCAtIHRpY2tMaW5lU3R5bGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3MubWFwKGZ1bmN0aW9uICh0aWNrKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICB7IHg6IHN0YXJ0WCwgeTogdGljay5jb29yZCB9LFxuICAgICAgICAgICAgICAgIHsgeDogZW5kWCwgeTogdGljay5jb29yZCB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFlBeGlzVmlldy5wcm90b3R5cGUuY3JlYXRlVGlja1RleHRzID0gZnVuY3Rpb24gKHRpY2tzLCBib3VuZGluZywgc3R5bGVzKSB7XG4gICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGF4aXNMaW5lU3R5bGVzID0gc3R5bGVzLmF4aXNMaW5lO1xuICAgICAgICB2YXIgdGlja0xpbmVTdHlsZXMgPSBzdHlsZXMudGlja0xpbmU7XG4gICAgICAgIHZhciB0aWNrVGV4dFN0eWxlcyA9IHN0eWxlcy50aWNrVGV4dDtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICBpZiAoeUF4aXMuaXNGcm9tWmVybygpKSB7XG4gICAgICAgICAgICB4ID0gdGlja1RleHRTdHlsZXMubWFyZ2luU3RhcnQ7XG4gICAgICAgICAgICBpZiAoYXhpc0xpbmVTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHggKz0gYXhpc0xpbmVTdHlsZXMuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgeCArPSB0aWNrTGluZVN0eWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gYm91bmRpbmcud2lkdGggLSB0aWNrVGV4dFN0eWxlcy5tYXJnaW5FbmQ7XG4gICAgICAgICAgICBpZiAoYXhpc0xpbmVTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHggLT0gYXhpc0xpbmVTdHlsZXMuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgeCAtPSB0aWNrTGluZVN0eWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKS5pc0Zyb21aZXJvKCkgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICByZXR1cm4gdGlja3MubWFwKGZ1bmN0aW9uICh0aWNrKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHRpY2suY29vcmQsXG4gICAgICAgICAgICB0ZXh0OiB0aWNrLnRleHQsXG4gICAgICAgICAgICBhbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgYmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBZQXhpc1ZpZXc7XG59KEF4aXNWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENhbmRsZUxhc3RQcmljZUxhYmVsVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZUxhc3RQcmljZUxhYmVsVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDYW5kbGVMYXN0UHJpY2VMYWJlbFZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgcHJpY2VNYXJrU3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5jYW5kbGUucHJpY2VNYXJrO1xuICAgICAgICB2YXIgbGFzdFByaWNlTWFya1N0eWxlcyA9IHByaWNlTWFya1N0eWxlcy5sYXN0O1xuICAgICAgICB2YXIgbGFzdFByaWNlTWFya1RleHRTdHlsZXMgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLnRleHQ7XG4gICAgICAgIGlmIChwcmljZU1hcmtTdHlsZXMuc2hvdyAmJiBsYXN0UHJpY2VNYXJrU3R5bGVzLnNob3cgJiYgbGFzdFByaWNlTWFya1RleHRTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGNoYXJ0U3RvcmUuZ2V0UHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YUxpc3RbZGF0YUxpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZGF0YS5jbG9zZSwgb3Blbl8xID0gZGF0YS5vcGVuO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlUHJpY2UgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLmNvbXBhcmVSdWxlID09PSBDYW5kbGVDb2xvckNvbXBhcmVSdWxlLkN1cnJlbnRPcGVuID8gb3Blbl8xIDogKChfYiA9IChfYSA9IGRhdGFMaXN0W2RhdGFMaXN0Lmxlbmd0aCAtIDJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNsb3NlXzEpO1xuICAgICAgICAgICAgICAgIHZhciBwcmljZVkgPSB5QXhpcy5jb252ZXJ0VG9OaWNlUGl4ZWwoY2xvc2VfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZV8xID4gY29tcGFyZVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGxhc3RQcmljZU1hcmtTdHlsZXMudXBDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VfMSA8IGNvbXBhcmVQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLmRvd25Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGxhc3RQcmljZU1hcmtTdHlsZXMubm9DaGFuZ2VDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzUmFuZ2UgPSB5QXhpcy5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0geUF4aXMuZGlzcGxheVZhbHVlVG9UZXh0KHlBeGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKHlBeGlzLnZhbHVlVG9SZWFsVmFsdWUoY2xvc2VfMSwgeyByYW5nZTogeUF4aXNSYW5nZSB9KSwgeyByYW5nZTogeUF4aXNSYW5nZSB9KSwgcHJlY2lzaW9uLnByaWNlKTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpLmZvcm1hdChjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpLmZvcm1hdCh0ZXh0KSk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxnaW4gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgaWYgKHlBeGlzLmlzRnJvbVplcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsZ2luID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxnaW4gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IHRleHRBbGdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsYXN0UHJpY2VNYXJrVGV4dFN0eWxlcyksIHsgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IgfSlcbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZUxhc3RQcmljZUxhYmVsVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBJbmRpY2F0b3JMYXN0VmFsdWVWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmRpY2F0b3JMYXN0VmFsdWVWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZGljYXRvckxhc3RWYWx1ZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5kaWNhdG9yTGFzdFZhbHVlVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmluZGljYXRvcjtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZU1hcmtTdHlsZXMgPSBkZWZhdWx0U3R5bGVzLmxhc3RWYWx1ZU1hcms7XG4gICAgICAgIHZhciBsYXN0VmFsdWVNYXJrVGV4dFN0eWxlcyA9IGxhc3RWYWx1ZU1hcmtTdHlsZXMudGV4dDtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZU1hcmtTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgdmFyIHlBeGlzXzEgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIHZhciB5QXhpc1JhbmdlXzEgPSB5QXhpc18xLmdldFJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgZGF0YUxpc3QgPSBjaGFydFN0b3JlLmdldERhdGFMaXN0KCk7XG4gICAgICAgICAgICB2YXIgZGF0YUluZGV4XzEgPSBkYXRhTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFwaV8xID0gY2hhcnRTdG9yZS5nZXRDdXN0b21BcGkoKTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsRm9sZF8xID0gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpO1xuICAgICAgICAgICAgdmFyIHRob3VzYW5kc1NlcGFyYXRvcl8xID0gY2hhcnRTdG9yZS5nZXRUaG91c2FuZHNTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5kaWNhdG9yLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IChfYiA9IChfYSA9IHJlc3VsdFtkYXRhSW5kZXhfMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc3VsdFtkYXRhSW5kZXhfMSAtIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSAmJiBpbmRpY2F0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlY2lzaW9uXzEgPSBpbmRpY2F0b3IucHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgICAgICBlYWNoRmlndXJlcyhpbmRpY2F0b3IsIGRhdGFJbmRleF8xLCBkZWZhdWx0U3R5bGVzLCBmdW5jdGlvbiAoZmlndXJlLCBmaWd1cmVTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ZpZ3VyZS5rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0geUF4aXNfMS5jb252ZXJ0VG9OaWNlUGl4ZWwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0geUF4aXNfMS5kaXNwbGF5VmFsdWVUb1RleHQoeUF4aXNfMS5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZSh5QXhpc18xLnZhbHVlVG9SZWFsVmFsdWUodmFsdWUsIHsgcmFuZ2U6IHlBeGlzUmFuZ2VfMSB9KSwgeyByYW5nZTogeUF4aXNSYW5nZV8xIH0pLCBwcmVjaXNpb25fMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci5zaG91bGRGb3JtYXRCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGN1c3RvbUFwaV8xLmZvcm1hdEJpZ051bWJlcih0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGRlY2ltYWxGb2xkXzEuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvcl8xLmZvcm1hdCh0ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlBeGlzXzEuaXNGcm9tWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlbGluZTogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGFzdFZhbHVlTWFya1RleHRTdHlsZXMpLCB7IGJhY2tncm91bmRDb2xvcjogZmlndXJlU3R5bGVzLmNvbG9yIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5kaWNhdG9yTGFzdFZhbHVlVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBPdmVybGF5WUF4aXNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdmVybGF5WUF4aXNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlZQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT3ZlcmxheVlBeGlzVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZVRvUG9pbnRUaW1lc3RhbXBEYXRhSW5kZXhGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBPdmVybGF5WUF4aXNWaWV3LnByb3RvdHlwZS5kcmF3RGVmYXVsdEZpZ3VyZXMgPSBmdW5jdGlvbiAoY3R4LCBvdmVybGF5LCBjb29yZGluYXRlcykge1xuICAgICAgICB0aGlzLmRyYXdGaWd1cmVzKGN0eCwgb3ZlcmxheSwgdGhpcy5nZXREZWZhdWx0RmlndXJlcyhvdmVybGF5LCBjb29yZGluYXRlcykpO1xuICAgIH07XG4gICAgT3ZlcmxheVlBeGlzVmlldy5wcm90b3R5cGUuZ2V0RGVmYXVsdEZpZ3VyZXMgPSBmdW5jdGlvbiAob3ZlcmxheSwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBjbGlja092ZXJsYXlJbmZvID0gY2hhcnRTdG9yZS5nZXRDbGlja092ZXJsYXlJbmZvKCk7XG4gICAgICAgIHZhciBmaWd1cmVzID0gW107XG4gICAgICAgIGlmIChvdmVybGF5Lm5lZWREZWZhdWx0WUF4aXNGaWd1cmUgJiZcbiAgICAgICAgICAgIG92ZXJsYXkuaWQgPT09ICgoX2EgPSBjbGlja092ZXJsYXlJbmZvLm92ZXJsYXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgJiZcbiAgICAgICAgICAgIGNsaWNrT3ZlcmxheUluZm8ucGFuZUlkID09PSBwYW5lLmdldElkKCkpIHtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICB2YXIgdG9wWV8xID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB2YXIgYm90dG9tWV8xID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB2YXIgaXNGcm9tWmVybyA9IHlBeGlzLmlzRnJvbVplcm8oKTtcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ25fMSA9ICdsZWZ0JztcbiAgICAgICAgICAgIHZhciB4XzEgPSAwO1xuICAgICAgICAgICAgaWYgKGlzRnJvbVplcm8pIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ25fMSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB4XzEgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduXzEgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIHhfMSA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY2ltYWxGb2xkXzEgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7XG4gICAgICAgICAgICB2YXIgdGhvdXNhbmRzU2VwYXJhdG9yXzEgPSBjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmRpbmF0ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBvdmVybGF5LnBvaW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BZXzEgPSBNYXRoLm1pbih0b3BZXzEsIGNvb3JkaW5hdGUueSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbVlfMSA9IE1hdGgubWF4KGJvdHRvbVlfMSwgY29vcmRpbmF0ZS55KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBkZWNpbWFsRm9sZF8xLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3JfMS5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKHBvaW50LnZhbHVlLCBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLnByaWNlKSkpO1xuICAgICAgICAgICAgICAgICAgICBmaWd1cmVzLnB1c2goeyB0eXBlOiAndGV4dCcsIGF0dHJzOiB7IHg6IHhfMSwgeTogY29vcmRpbmF0ZS55LCB0ZXh0OiB0ZXh0LCBhbGlnbjogdGV4dEFsaWduXzEsIGJhc2VsaW5lOiAnbWlkZGxlJyB9LCBpZ25vcmVFdmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZmlndXJlcy51bnNoaWZ0KHsgdHlwZTogJ3JlY3QnLCBhdHRyczogeyB4OiAwLCB5OiB0b3BZXzEsIHdpZHRoOiBib3VuZGluZy53aWR0aCwgaGVpZ2h0OiBib3R0b21ZXzEgLSB0b3BZXzEgfSwgaWdub3JlRXZlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZ3VyZXM7XG4gICAgfTtcbiAgICBPdmVybGF5WUF4aXNWaWV3LnByb3RvdHlwZS5nZXRGaWd1cmVzID0gZnVuY3Rpb24gKG92ZXJsYXksIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBvdmVybGF5LmNyZWF0ZVlBeGlzRmlndXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXksIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcywgYm91bmRpbmc6IGJvdW5kaW5nLCB4QXhpczogeEF4aXMsIHlBeGlzOiB5QXhpcyB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVlBeGlzVmlldztcbn0oT3ZlcmxheVZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gd2lkZ2V0LmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGNyb3NzaGFpciA9IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNyb3NzaGFpcjtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNyb3NzaGFpci5wYW5lSWQpICYmIHRoaXMuY29tcGFyZShjcm9zc2hhaXIsIHBhbmUuZ2V0SWQoKSkpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25TdHlsZXMgPSB0aGlzLmdldERpcmVjdGlvblN0eWxlcyhzdHlsZXMpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVzID0gZGlyZWN0aW9uU3R5bGVzLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvblN0eWxlcy5zaG93ICYmIHRleHRTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dChjcm9zc2hhaXIsIGNoYXJ0U3RvcmUsIGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQodGV4dFN0eWxlcy5zaXplLCB0ZXh0U3R5bGVzLndlaWdodCwgdGV4dFN0eWxlcy5mYW1pbHkpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogdGhpcy5nZXRUZXh0QXR0cnModGV4dCwgY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoLCBjcm9zc2hhaXIsIGJvdW5kaW5nLCBheGlzLCB0ZXh0U3R5bGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogdGV4dFN0eWxlc1xuICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoY3Jvc3NoYWlyLCBwYW5lSWQpIHtcbiAgICAgICAgcmV0dXJuIGNyb3NzaGFpci5wYW5lSWQgPT09IHBhbmVJZDtcbiAgICB9O1xuICAgIENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcucHJvdG90eXBlLmdldERpcmVjdGlvblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy5ob3Jpem9udGFsO1xuICAgIH07XG4gICAgQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldy5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChjcm9zc2hhaXIsIGNoYXJ0U3RvcmUsIGF4aXMpIHtcbiAgICAgICAgdmFyIHlBeGlzID0gYXhpcztcbiAgICAgICAgdmFyIHZhbHVlID0gYXhpcy5jb252ZXJ0RnJvbVBpeGVsKGNyb3NzaGFpci55KTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIHZhciBzaG91bGRGb3JtYXRCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHlBeGlzLmlzSW5DYW5kbGUoKSkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQoY3Jvc3NoYWlyLnBhbmVJZCk7XG4gICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KGluZGljYXRvci5wcmVjaXNpb24sIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgc2hvdWxkRm9ybWF0QmlnTnVtYmVyIHx8IChzaG91bGRGb3JtYXRCaWdOdW1iZXIgPSBpbmRpY2F0b3Iuc2hvdWxkRm9ybWF0QmlnTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5QXhpc1JhbmdlID0geUF4aXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIHRleHQgPSB5QXhpcy5kaXNwbGF5VmFsdWVUb1RleHQoeUF4aXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUoeUF4aXMudmFsdWVUb1JlYWxWYWx1ZSh2YWx1ZSwgeyByYW5nZTogeUF4aXNSYW5nZSB9KSwgeyByYW5nZTogeUF4aXNSYW5nZSB9KSwgcHJlY2lzaW9uKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgICAgIGlmIChzaG91bGRGb3JtYXRCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgIHRleHQgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpLmZvcm1hdEJpZ051bWJlcih0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpLmZvcm1hdChjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpLmZvcm1hdCh0ZXh0KSk7XG4gICAgfTtcbiAgICBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3LnByb3RvdHlwZS5nZXRUZXh0QXR0cnMgPSBmdW5jdGlvbiAodGV4dCwgX3RleHRXaWR0aCwgY3Jvc3NoYWlyLCBib3VuZGluZywgYXhpcywgX3N0eWxlcykge1xuICAgICAgICB2YXIgeUF4aXMgPSBheGlzO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGlmICh5QXhpcy5pc0Zyb21aZXJvKCkpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiBjcm9zc2hhaXIueSwgdGV4dDogdGV4dCwgYWxpZ246IHRleHRBbGlnbiwgYmFzZWxpbmU6ICdtaWRkbGUnIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBZQXhpc1dpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWUF4aXNXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWUF4aXNXaWRnZXQocm9vdENvbnRhaW5lciwgcGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290Q29udGFpbmVyLCBwYW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5feUF4aXNWaWV3ID0gbmV3IFlBeGlzVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9jYW5kbGVMYXN0UHJpY2VMYWJlbFZpZXcgPSBuZXcgQ2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2luZGljYXRvckxhc3RWYWx1ZVZpZXcgPSBuZXcgSW5kaWNhdG9yTGFzdFZhbHVlVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9vdmVybGF5WUF4aXNWaWV3ID0gbmV3IE92ZXJsYXlZQXhpc1ZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fY3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldyA9IG5ldyBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ25zLXJlc2l6ZSc7XG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLl9vdmVybGF5WUF4aXNWaWV3KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBZQXhpc1dpZGdldC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldE5hbWVDb25zdGFudHMuWV9BWElTO1xuICAgIH07XG4gICAgWUF4aXNXaWRnZXQucHJvdG90eXBlLnVwZGF0ZU1haW4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtaW5pbWl6ZSA9IHRoaXMuZ2V0UGFuZSgpLmdldE9wdGlvbnMoKS5zdGF0ZSA9PT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLztcbiAgICAgICAgdGhpcy5feUF4aXNWaWV3LmRyYXcoY3R4LCBtaW5pbWl6ZSk7XG4gICAgICAgIGlmICghbWluaW1pemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFBhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCkuaXNJbkNhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvckxhc3RWYWx1ZVZpZXcuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBZQXhpc1dpZGdldC5wcm90b3R5cGUudXBkYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGFuZSgpLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVlBeGlzVmlldy5kcmF3KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9jcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFlBeGlzV2lkZ2V0O1xufShEcmF3V2lkZ2V0KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFRJQ0tfQ09VTlQgPSA4O1xudmFyIFlBeGlzSW1wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhZQXhpc0ltcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBZQXhpc0ltcChwYXJlbnQsIHlBeGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMucG9zaXRpb24gPSBBeGlzUG9zaXRpb24uUmlnaHQ7XG4gICAgICAgIF90aGlzLmdhcCA9IHtcbiAgICAgICAgICAgIHRvcDogMC4yLFxuICAgICAgICAgICAgYm90dG9tOiAwLjFcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXMuZGVmYXVsdFJhbmdlOyB9O1xuICAgICAgICBfdGhpcy5taW5TcGFuID0gZnVuY3Rpb24gKHByZWNpc2lvbikgeyByZXR1cm4gaW5kZXgxMCgtcHJlY2lzaW9uKTsgfTtcbiAgICAgICAgX3RoaXMudmFsdWVUb1JlYWxWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgICAgIF90aGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgICAgX3RoaXMuZGlzcGxheVZhbHVlVG9SZWFsVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgICBfdGhpcy5yZWFsVmFsdWVUb1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgICAgX3RoaXMuZGlzcGxheVZhbHVlVG9UZXh0ID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVjaXNpb24pIHsgcmV0dXJuIGZvcm1hdFByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKTsgfTtcbiAgICAgICAgX3RoaXMub3ZlcnJpZGUoeUF4aXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uICh5QXhpcykge1xuICAgICAgICB2YXIgbmFtZSA9IHlBeGlzLm5hbWUsIGdhcCA9IHlBeGlzLmdhcCwgb3RoZXJzID0gX19yZXN0KHlBeGlzLCBbXCJuYW1lXCIsIFwiZ2FwXCJdKTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXMuZ2FwLCBnYXApO1xuICAgICAgICBtZXJnZSh0aGlzLCBvdGhlcnMpO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmNyZWF0ZVJhbmdlSW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFyZW50LmdldENoYXJ0KCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgcGFuZUlkID0gcGFyZW50LmdldElkKCk7XG4gICAgICAgIHZhciBtaW4gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgdmFyIG1heCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB2YXIgc2hvdWxkT2hsYyA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlY2lmeU1pbiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB2YXIgc3BlY2lmeU1heCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB2YXIgaW5kaWNhdG9yUHJlY2lzaW9uID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZUlkKTtcbiAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHNob3VsZE9obGMgfHwgKHNob3VsZE9obGMgPSBpbmRpY2F0b3Iuc2hvdWxkT2hsYyk7XG4gICAgICAgICAgICBpbmRpY2F0b3JQcmVjaXNpb24gPSBNYXRoLm1pbihpbmRpY2F0b3JQcmVjaXNpb24sIGluZGljYXRvci5wcmVjaXNpb24pO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGluZGljYXRvci5taW5WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZ5TWluID0gTWF0aC5taW4oc3BlY2lmeU1pbiwgaW5kaWNhdG9yLm1pblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bWJlcihpbmRpY2F0b3IubWF4VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmeU1heCA9IE1hdGgubWF4KHNwZWNpZnlNYXgsIGluZGljYXRvci5tYXhWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gNDtcbiAgICAgICAgdmFyIGluQ2FuZGxlID0gdGhpcy5pc0luQ2FuZGxlKCk7XG4gICAgICAgIGlmIChpbkNhbmRsZSkge1xuICAgICAgICAgICAgdmFyIHByaWNlUHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3JQcmVjaXNpb24gIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5taW4oaW5kaWNhdG9yUHJlY2lzaW9uLCBwcmljZVByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmljZVByZWNpc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3JQcmVjaXNpb24gIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gaW5kaWNhdG9yUHJlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2aXNpYmxlUmFuZ2VEYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0VmlzaWJsZVJhbmdlRGF0YUxpc3QoKTtcbiAgICAgICAgdmFyIGNhbmRsZVN0eWxlcyA9IGNoYXJ0LmdldFN0eWxlcygpLmNhbmRsZTtcbiAgICAgICAgdmFyIGlzQXJlYSA9IGNhbmRsZVN0eWxlcy50eXBlID09PSBDYW5kbGVUeXBlLkFyZWE7XG4gICAgICAgIHZhciBhcmVhVmFsdWVLZXkgPSBjYW5kbGVTdHlsZXMuYXJlYS52YWx1ZTtcbiAgICAgICAgdmFyIHNob3VsZENvbXBhcmVIaWdoTG93ID0gKGluQ2FuZGxlICYmICFpc0FyZWEpIHx8ICghaW5DYW5kbGUgJiYgc2hvdWxkT2hsYyk7XG4gICAgICAgIHZpc2libGVSYW5nZURhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKHZpc2libGVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gdmlzaWJsZURhdGEuZGF0YUluZGV4O1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB2aXNpYmxlRGF0YS5kYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRDb21wYXJlSGlnaExvdykge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGRhdGEubG93KTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhLmhpZ2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5DYW5kbGUgJiYgaXNBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbYXJlYVZhbHVlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLnJlc3VsdCwgZmlndXJlcyA9IF9hLmZpZ3VyZXM7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAoX2IgPSByZXN1bHRbZGF0YUluZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgICAgICAgICAgZmlndXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWd1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtmaWd1cmUua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWluICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBtYXggIT09IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihzcGVjaWZ5TWluLCBtaW4pO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoc3BlY2lmeU1heCwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICBtYXggPSAxMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdERpZmYgPSBtYXggLSBtaW47XG4gICAgICAgIHZhciBkZWZhdWx0UmFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBtaW4sXG4gICAgICAgICAgICB0bzogbWF4LFxuICAgICAgICAgICAgcmFuZ2U6IGRlZmF1bHREaWZmLFxuICAgICAgICAgICAgcmVhbEZyb206IG1pbixcbiAgICAgICAgICAgIHJlYWxUbzogbWF4LFxuICAgICAgICAgICAgcmVhbFJhbmdlOiBkZWZhdWx0RGlmZixcbiAgICAgICAgICAgIGRpc3BsYXlGcm9tOiBtaW4sXG4gICAgICAgICAgICBkaXNwbGF5VG86IG1heCxcbiAgICAgICAgICAgIGRpc3BsYXlSYW5nZTogZGVmYXVsdERpZmZcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSh7XG4gICAgICAgICAgICBjaGFydDogY2hhcnQsXG4gICAgICAgICAgICBwYW5lSWQ6IHBhbmVJZCxcbiAgICAgICAgICAgIGRlZmF1bHRSYW5nZTogZGVmYXVsdFJhbmdlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVhbEZyb20gPSByYW5nZS5yZWFsRnJvbTtcbiAgICAgICAgdmFyIHJlYWxUbyA9IHJhbmdlLnJlYWxUbztcbiAgICAgICAgdmFyIHJlYWxSYW5nZSA9IHJhbmdlLnJlYWxSYW5nZTtcbiAgICAgICAgdmFyIG1pblNwYW4gPSB0aGlzLm1pblNwYW4ocHJlY2lzaW9uKTtcbiAgICAgICAgaWYgKHJlYWxGcm9tID09PSByZWFsVG8gfHwgcmVhbFJhbmdlIDwgbWluU3Bhbikge1xuICAgICAgICAgICAgdmFyIG1pbkNoZWNrID0gc3BlY2lmeU1pbiA9PT0gcmVhbEZyb207XG4gICAgICAgICAgICB2YXIgbWF4Q2hlY2sgPSBzcGVjaWZ5TWF4ID09PSByZWFsVG87XG4gICAgICAgICAgICB2YXIgaGFsZlRpY2tDb3VudCA9IFRJQ0tfQ09VTlQgLyAyO1xuICAgICAgICAgICAgcmVhbEZyb20gPSBtaW5DaGVjayA/IHJlYWxGcm9tIDogKG1heENoZWNrID8gcmVhbEZyb20gLSBUSUNLX0NPVU5UICogbWluU3BhbiA6IHJlYWxGcm9tIC0gaGFsZlRpY2tDb3VudCAqIG1pblNwYW4pO1xuICAgICAgICAgICAgcmVhbFRvID0gbWF4Q2hlY2sgPyByZWFsVG8gOiAobWluQ2hlY2sgPyByZWFsVG8gKyBUSUNLX0NPVU5UICogbWluU3BhbiA6IHJlYWxUbyArIGhhbGZUaWNrQ291bnQgKiBtaW5TcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nYXAsIHRvcCA9IF9hLnRvcCwgYm90dG9tID0gX2EuYm90dG9tO1xuICAgICAgICB2YXIgdG9wUmF0ZSA9IHRvcDtcbiAgICAgICAgaWYgKHRvcFJhdGUgPj0gMSkge1xuICAgICAgICAgICAgdG9wUmF0ZSA9IHRvcFJhdGUgLyBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdHRvbVJhdGUgPSBib3R0b207XG4gICAgICAgIGlmIChib3R0b21SYXRlID49IDEpIHtcbiAgICAgICAgICAgIGJvdHRvbVJhdGUgPSBib3R0b21SYXRlIC8gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJlYWxSYW5nZSA9IHJlYWxUbyAtIHJlYWxGcm9tO1xuICAgICAgICByZWFsRnJvbSA9IHJlYWxGcm9tIC0gcmVhbFJhbmdlICogYm90dG9tUmF0ZTtcbiAgICAgICAgcmVhbFRvID0gcmVhbFRvICsgcmVhbFJhbmdlICogdG9wUmF0ZTtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLnJlYWxWYWx1ZVRvVmFsdWUocmVhbEZyb20sIHsgcmFuZ2U6IHJhbmdlIH0pO1xuICAgICAgICB2YXIgdG8gPSB0aGlzLnJlYWxWYWx1ZVRvVmFsdWUocmVhbFRvLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICAgICAgdmFyIGRpc3BsYXlGcm9tID0gdGhpcy5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZShyZWFsRnJvbSwgeyByYW5nZTogcmFuZ2UgfSk7XG4gICAgICAgIHZhciBkaXNwbGF5VG8gPSB0aGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKHJlYWxUbywgeyByYW5nZTogcmFuZ2UgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgcmFuZ2U6IHRvIC0gZnJvbSxcbiAgICAgICAgICAgIHJlYWxGcm9tOiByZWFsRnJvbSxcbiAgICAgICAgICAgIHJlYWxUbzogcmVhbFRvLFxuICAgICAgICAgICAgcmVhbFJhbmdlOiByZWFsVG8gLSByZWFsRnJvbSxcbiAgICAgICAgICAgIGRpc3BsYXlGcm9tOiBkaXNwbGF5RnJvbSxcbiAgICAgICAgICAgIGRpc3BsYXlUbzogZGlzcGxheVRvLFxuICAgICAgICAgICAgZGlzcGxheVJhbmdlOiBkaXNwbGF5VG8gLSBkaXNwbGF5RnJvbVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5piv5ZCm5piv6Jyh54Ob5Zu+6L20XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuaXNJbkNhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCkuZ2V0SWQoKSA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOaYr+WQpuS7jnnovbQw5byA5aeLXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuaXNGcm9tWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5wb3NpdGlvbiA9PT0gQXhpc1Bvc2l0aW9uLkxlZnQgJiYgdGhpcy5pbnNpZGUpIHx8XG4gICAgICAgICAgICAodGhpcy5wb3NpdGlvbiA9PT0gQXhpc1Bvc2l0aW9uLlJpZ2h0ICYmICF0aGlzLmluc2lkZSkpO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmNyZWF0ZVRpY2tzSW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICAgIHZhciBkaXNwbGF5RnJvbSA9IHJhbmdlLmRpc3BsYXlGcm9tLCBkaXNwbGF5VG8gPSByYW5nZS5kaXNwbGF5VG8sIGRpc3BsYXlSYW5nZSA9IHJhbmdlLmRpc3BsYXlSYW5nZTtcbiAgICAgICAgdmFyIHRpY2tzID0gW107XG4gICAgICAgIGlmIChkaXNwbGF5UmFuZ2UgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbmljZShkaXNwbGF5UmFuZ2UgLyBUSUNLX0NPVU5UKTtcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb25fMSA9IGdldFByZWNpc2lvbihpbnRlcnZhbCk7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSByb3VuZChNYXRoLmNlaWwoZGlzcGxheUZyb20gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCwgcHJlY2lzaW9uXzEpO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSByb3VuZChNYXRoLmZsb29yKGRpc3BsYXlUbyAvIGludGVydmFsKSAqIGludGVydmFsLCBwcmVjaXNpb25fMSk7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICAgICAgaWYgKGludGVydmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGYgPD0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGYudG9GaXhlZChwcmVjaXNpb25fMSk7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tzW25dID0geyB0ZXh0OiB2LCBjb29yZDogMCwgdmFsdWU6IHYgfTtcbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgICAgICBmICs9IGludGVydmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoX2IgPSAoX2EgPSBwYW5lLmdldFlBeGlzV2lkZ2V0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZygpLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgb3B0aW1hbFRpY2tzID0gW107XG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCk7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAwO1xuICAgICAgICB2YXIgc2hvdWxkRm9ybWF0QmlnTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5DYW5kbGUoKSkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgocHJlY2lzaW9uLCBpbmRpY2F0b3IucHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBzaG91bGRGb3JtYXRCaWdOdW1iZXIgfHwgKHNob3VsZEZvcm1hdEJpZ051bWJlciA9IGluZGljYXRvci5zaG91bGRGb3JtYXRCaWdOdW1iZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbUFwaSA9IGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCk7XG4gICAgICAgIHZhciB0aG91c2FuZHNTZXBhcmF0b3IgPSBjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpO1xuICAgICAgICB2YXIgZGVjaW1hbEZvbGQgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7XG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gc3R5bGVzLnhBeGlzLnRpY2tUZXh0LnNpemU7XG4gICAgICAgIHZhciB2YWxpZFkgPSBOYU47XG4gICAgICAgIHRpY2tzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2ID0gX3RoaXMuZGlzcGxheVZhbHVlVG9UZXh0KCt2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHZhciB5ID0gX3RoaXMuY29udmVydFRvUGl4ZWwoX3RoaXMucmVhbFZhbHVlVG9WYWx1ZShfdGhpcy5kaXNwbGF5VmFsdWVUb1JlYWxWYWx1ZSgrdmFsdWUsIHsgcmFuZ2U6IHJhbmdlIH0pLCB7IHJhbmdlOiByYW5nZSB9KSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRm9ybWF0QmlnTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdiA9IGN1c3RvbUFwaS5mb3JtYXRCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiA9IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KHYpKTtcbiAgICAgICAgICAgIHZhciB2YWxpZFlOdW1iZXIgPSBpc051bWJlcih2YWxpZFkpO1xuICAgICAgICAgICAgaWYgKHkgPiB0ZXh0SGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgeSA8IGhlaWdodCAtIHRleHRIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAoKHZhbGlkWU51bWJlciAmJiAoTWF0aC5hYnModmFsaWRZIC0geSkgPiB0ZXh0SGVpZ2h0ICogMikpIHx8ICF2YWxpZFlOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW1hbFRpY2tzLnB1c2goeyB0ZXh0OiB2LCBjb29yZDogeSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHZhbGlkWSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLmNyZWF0ZVRpY2tzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGlja3Moe1xuICAgICAgICAgICAgICAgIHJhbmdlOiB0aGlzLmdldFJhbmdlKCksXG4gICAgICAgICAgICAgICAgYm91bmRpbmc6IHRoaXMuZ2V0Qm91bmRpbmcoKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGlja3M6IG9wdGltYWxUaWNrc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGltYWxUaWNrcztcbiAgICB9O1xuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5nZXRBdXRvU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKTtcbiAgICAgICAgdmFyIHlBeGlzU3R5bGVzID0gc3R5bGVzLnlBeGlzO1xuICAgICAgICB2YXIgd2lkdGggPSB5QXhpc1N0eWxlcy5zaXplO1xuICAgICAgICBpZiAod2lkdGggIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5QXhpc1dpZHRoID0gMDtcbiAgICAgICAgaWYgKHlBeGlzU3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgIGlmICh5QXhpc1N0eWxlcy5heGlzTGluZS5zaG93KSB7XG4gICAgICAgICAgICAgICAgeUF4aXNXaWR0aCArPSB5QXhpc1N0eWxlcy5heGlzTGluZS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlBeGlzU3R5bGVzLnRpY2tMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1dpZHRoICs9IHlBeGlzU3R5bGVzLnRpY2tMaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5QXhpc1N0eWxlcy50aWNrVGV4dC5zaG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRXaWR0aF8xID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRpY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodGljaykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGhfMSA9IE1hdGgubWF4KHRleHRXaWR0aF8xLCBjYWxjVGV4dFdpZHRoKHRpY2sudGV4dCwgeUF4aXNTdHlsZXMudGlja1RleHQuc2l6ZSwgeUF4aXNTdHlsZXMudGlja1RleHQud2VpZ2h0LCB5QXhpc1N0eWxlcy50aWNrVGV4dC5mYW1pbHkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5QXhpc1dpZHRoICs9ICh5QXhpc1N0eWxlcy50aWNrVGV4dC5tYXJnaW5TdGFydCArIHlBeGlzU3R5bGVzLnRpY2tUZXh0Lm1hcmdpbkVuZCArIHRleHRXaWR0aF8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Jvc3NoYWlyU3R5bGVzID0gc3R5bGVzLmNyb3NzaGFpcjtcbiAgICAgICAgdmFyIGNyb3NzaGFpclZlcnRpY2FsVGV4dFdpZHRoID0gMDtcbiAgICAgICAgaWYgKGNyb3NzaGFpclN0eWxlcy5zaG93ICYmXG4gICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC5zaG93ICYmXG4gICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC50ZXh0LnNob3cpIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JQcmVjaXNpb25fMSA9IDA7XG4gICAgICAgICAgICB2YXIgc2hvdWxkRm9ybWF0QmlnTnVtYmVyXzEgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yUHJlY2lzaW9uXzEgPSBNYXRoLm1heChpbmRpY2F0b3IucHJlY2lzaW9uLCBpbmRpY2F0b3JQcmVjaXNpb25fMSk7XG4gICAgICAgICAgICAgICAgc2hvdWxkRm9ybWF0QmlnTnVtYmVyXzEgfHwgKHNob3VsZEZvcm1hdEJpZ051bWJlcl8xID0gaW5kaWNhdG9yLnNob3VsZEZvcm1hdEJpZ051bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSAyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkNhbmRsZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByaWNlUHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKS5wcmljZTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlTWFya1N0eWxlcyA9IHN0eWxlcy5pbmRpY2F0b3IubGFzdFZhbHVlTWFyaztcbiAgICAgICAgICAgICAgICBpZiAobGFzdFZhbHVlTWFya1N0eWxlcy5zaG93ICYmIGxhc3RWYWx1ZU1hcmtTdHlsZXMudGV4dC5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KGluZGljYXRvclByZWNpc2lvbl8xLCBwcmljZVByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmljZVByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBpbmRpY2F0b3JQcmVjaXNpb25fMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZVRleHQgPSBmb3JtYXRQcmVjaXNpb24odGhpcy5nZXRSYW5nZSgpLmRpc3BsYXlUbywgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICAgICAgaWYgKHNob3VsZEZvcm1hdEJpZ051bWJlcl8xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUZXh0ID0gY2hhcnRTdG9yZS5nZXRDdXN0b21BcGkoKS5mb3JtYXRCaWdOdW1iZXIodmFsdWVUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlVGV4dCA9IGNoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKS5mb3JtYXQodmFsdWVUZXh0KTtcbiAgICAgICAgICAgIGNyb3NzaGFpclZlcnRpY2FsVGV4dFdpZHRoICs9IChjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC50ZXh0LnBhZGRpbmdMZWZ0ICtcbiAgICAgICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC50ZXh0LnBhZGRpbmdSaWdodCArXG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyU3R5bGVzLmhvcml6b250YWwudGV4dC5ib3JkZXJTaXplICogMiArXG4gICAgICAgICAgICAgICAgY2FsY1RleHRXaWR0aCh2YWx1ZVRleHQsIGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnRleHQuc2l6ZSwgY3Jvc3NoYWlyU3R5bGVzLmhvcml6b250YWwudGV4dC53ZWlnaHQsIGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnRleHQuZmFtaWx5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHlBeGlzV2lkdGgsIGNyb3NzaGFpclZlcnRpY2FsVGV4dFdpZHRoKTtcbiAgICB9O1xuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5nZXRCb3VuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCkuZ2V0WUF4aXNXaWRnZXQoKS5nZXRCb3VuZGluZygpO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0Qm91bmRpbmcoKS5oZWlnaHQ7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIHJlYWxGcm9tID0gcmFuZ2UucmVhbEZyb20sIHJlYWxSYW5nZSA9IHJhbmdlLnJlYWxSYW5nZTtcbiAgICAgICAgdmFyIHJhdGUgPSB0aGlzLnJldmVyc2UgPyBwaXhlbCAvIGhlaWdodCA6IDEgLSBwaXhlbCAvIGhlaWdodDtcbiAgICAgICAgdmFyIHJlYWxWYWx1ZSA9IHJhdGUgKiByZWFsUmFuZ2UgKyByZWFsRnJvbTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbFZhbHVlVG9WYWx1ZShyZWFsVmFsdWUsIHsgcmFuZ2U6IHJhbmdlIH0pO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIHJlYWxWYWx1ZSA9IHRoaXMudmFsdWVUb1JlYWxWYWx1ZSh2YWx1ZSwgeyByYW5nZTogcmFuZ2UgfSk7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoX2IgPSAoX2EgPSB0aGlzLmdldFBhcmVudCgpLmdldFlBeGlzV2lkZ2V0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZygpLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgdmFyIHJlYWxGcm9tID0gcmFuZ2UucmVhbEZyb20sIHJlYWxSYW5nZSA9IHJhbmdlLnJlYWxSYW5nZTtcbiAgICAgICAgdmFyIHJhdGUgPSAocmVhbFZhbHVlIC0gcmVhbEZyb20pIC8gcmVhbFJhbmdlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlID8gTWF0aC5yb3VuZChyYXRlICogaGVpZ2h0KSA6IE1hdGgucm91bmQoKDEgLSByYXRlKSAqIGhlaWdodCk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuY29udmVydFRvTmljZVBpeGVsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoX2IgPSAoX2EgPSB0aGlzLmdldFBhcmVudCgpLmdldFlBeGlzV2lkZ2V0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZygpLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5jb252ZXJ0VG9QaXhlbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KGhlaWdodCAqIDAuMDUsIE1hdGgubWluKHBpeGVsLCBoZWlnaHQgKiAwLjk4KSkpO1xuICAgIH07XG4gICAgWUF4aXNJbXAuZXh0ZW5kID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBDdXN0b20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3VzdG9tKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHRlbXBsYXRlKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICAgICAgfShZQXhpc0ltcCkpO1xuICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgIH07XG4gICAgcmV0dXJuIFlBeGlzSW1wO1xufShBeGlzSW1wKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIG5vcm1hbCQxID0ge1xuICAgIG5hbWU6ICdub3JtYWwnXG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBwZXJjZW50YWdlID0ge1xuICAgIG5hbWU6ICdwZXJjZW50YWdlJyxcbiAgICBtaW5TcGFuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLnBvdygxMCwgLTIpOyB9LFxuICAgIGRpc3BsYXlWYWx1ZVRvVGV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBcIlwiLmNvbmNhdChmb3JtYXRQcmVjaXNpb24odmFsdWUsIDIpLCBcIiVcIik7IH0sXG4gICAgdmFsdWVUb1JlYWxWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHJhbmdlLmZyb20pIC8gcmFuZ2UucmFuZ2UgKiByYW5nZS5yZWFsUmFuZ2UgKyByYW5nZS5yZWFsRnJvbTtcbiAgICB9LFxuICAgIHJlYWxWYWx1ZVRvVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSByYW5nZS5yZWFsRnJvbSkgLyByYW5nZS5yZWFsUmFuZ2UgKiByYW5nZS5yYW5nZSArIHJhbmdlLmZyb207XG4gICAgfSxcbiAgICBjcmVhdGVSYW5nZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjaGFydCA9IF9hLmNoYXJ0LCBkZWZhdWx0UmFuZ2UgPSBfYS5kZWZhdWx0UmFuZ2U7XG4gICAgICAgIHZhciBrTGluZURhdGFMaXN0ID0gY2hhcnQuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgdmFyIHZpc2libGVSYW5nZSA9IGNoYXJ0LmdldFZpc2libGVSYW5nZSgpO1xuICAgICAgICB2YXIga0xpbmVEYXRhID0ga0xpbmVEYXRhTGlzdFt2aXNpYmxlUmFuZ2UuZnJvbV07XG4gICAgICAgIGlmIChpc1ZhbGlkKGtMaW5lRGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gZGVmYXVsdFJhbmdlLmZyb20sIHRvID0gZGVmYXVsdFJhbmdlLnRvLCByYW5nZSA9IGRlZmF1bHRSYW5nZS5yYW5nZTtcbiAgICAgICAgICAgIHZhciByZWFsRnJvbSA9IChkZWZhdWx0UmFuZ2UuZnJvbSAtIGtMaW5lRGF0YS5jbG9zZSkgLyBrTGluZURhdGEuY2xvc2UgKiAxMDA7XG4gICAgICAgICAgICB2YXIgcmVhbFRvID0gKGRlZmF1bHRSYW5nZS50byAtIGtMaW5lRGF0YS5jbG9zZSkgLyBrTGluZURhdGEuY2xvc2UgKiAxMDA7XG4gICAgICAgICAgICB2YXIgcmVhbFJhbmdlID0gcmVhbFRvIC0gcmVhbEZyb207XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICByZWFsRnJvbTogcmVhbEZyb20sXG4gICAgICAgICAgICAgICAgcmVhbFRvOiByZWFsVG8sXG4gICAgICAgICAgICAgICAgcmVhbFJhbmdlOiByZWFsUmFuZ2UsXG4gICAgICAgICAgICAgICAgZGlzcGxheUZyb206IHJlYWxGcm9tLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlUbzogcmVhbFRvLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlSYW5nZTogcmVhbFJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0UmFuZ2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbG9nYXJpdGhtID0ge1xuICAgIG5hbWU6ICdsb2dhcml0aG0nLFxuICAgIG1pblNwYW46IGZ1bmN0aW9uIChwcmVjaXNpb24pIHsgcmV0dXJuIDAuMDUgKiBpbmRleDEwKC1wcmVjaXNpb24pOyB9LFxuICAgIHZhbHVlVG9SZWFsVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAwID8gLWxvZzEwKE1hdGguYWJzKHZhbHVlKSkgOiBsb2cxMCh2YWx1ZSk7IH0sXG4gICAgcmVhbFZhbHVlVG9EaXNwbGF5VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAwID8gLWluZGV4MTAoTWF0aC5hYnModmFsdWUpKSA6IGluZGV4MTAodmFsdWUpOyB9LFxuICAgIGRpc3BsYXlWYWx1ZVRvUmVhbFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIDwgMCA/IC1sb2cxMChNYXRoLmFicyh2YWx1ZSkpIDogbG9nMTAodmFsdWUpOyB9LFxuICAgIHJlYWxWYWx1ZVRvVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAwID8gLWluZGV4MTAoTWF0aC5hYnModmFsdWUpKSA6IGluZGV4MTAodmFsdWUpOyB9LFxuICAgIGNyZWF0ZVJhbmdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRSYW5nZSA9IF9hLmRlZmF1bHRSYW5nZTtcbiAgICAgICAgdmFyIGZyb20gPSBkZWZhdWx0UmFuZ2UuZnJvbSwgdG8gPSBkZWZhdWx0UmFuZ2UudG8sIHJhbmdlID0gZGVmYXVsdFJhbmdlLnJhbmdlO1xuICAgICAgICB2YXIgcmVhbEZyb20gPSBmcm9tIDwgMCA/IC1sb2cxMChNYXRoLmFicyhmcm9tKSkgOiBsb2cxMChmcm9tKTtcbiAgICAgICAgdmFyIHJlYWxUbyA9IHRvIDwgMCA/IC1sb2cxMChNYXRoLmFicyh0bykpIDogbG9nMTAodG8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHJlYWxGcm9tOiByZWFsRnJvbSxcbiAgICAgICAgICAgIHJlYWxUbzogcmVhbFRvLFxuICAgICAgICAgICAgcmVhbFJhbmdlOiByZWFsVG8gLSByZWFsRnJvbSxcbiAgICAgICAgICAgIGRpc3BsYXlGcm9tOiBmcm9tLFxuICAgICAgICAgICAgZGlzcGxheVRvOiB0byxcbiAgICAgICAgICAgIGRpc3BsYXlSYW5nZTogcmFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB5QXhpc2VzID0ge1xuICAgIG5vcm1hbDogWUF4aXNJbXAuZXh0ZW5kKG5vcm1hbCQxKSxcbiAgICBwZXJjZW50YWdlOiBZQXhpc0ltcC5leHRlbmQocGVyY2VudGFnZSksXG4gICAgbG9nYXJpdGhtOiBZQXhpc0ltcC5leHRlbmQobG9nYXJpdGhtKVxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyWUF4aXMoYXhpcykge1xuICAgIHlBeGlzZXNbYXhpcy5uYW1lXSA9IFlBeGlzSW1wLmV4dGVuZChheGlzKTtcbn1cbmZ1bmN0aW9uIGdldFlBeGlzQ2xhc3MobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0geUF4aXNlc1tuYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeUF4aXNlcy5ub3JtYWw7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFBhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFuZShjaGFydCwgaWQpIHtcbiAgICAgICAgdGhpcy5fYm91bmRpbmcgPSBjcmVhdGVEZWZhdWx0Qm91bmRpbmcoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCb3VuZGluZyA9IGNyZWF0ZURlZmF1bHRCb3VuZGluZygpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY3JlYXRlRG9tKCdkaXYnLCB7XG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgbWFyZ2luOiAnMCcsXG4gICAgICAgICAgICBwYWRkaW5nOiAnMCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBQYW5lLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS5zZXRWaXNpYmxlID0gZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUgIT09IHZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFuZS5wcm90b3R5cGUuZ2V0VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH07XG4gICAgUGFuZS5wcm90b3R5cGUuZ2V0Q2hhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydDtcbiAgICB9O1xuICAgIFBhbmUucHJvdG90eXBlLmdldEJvdW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRpbmc7XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS5zZXRPcmlnaW5hbEJvdW5kaW5nID0gZnVuY3Rpb24gKGJvdW5kaW5nKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuX29yaWdpbmFsQm91bmRpbmcsIGJvdW5kaW5nKTtcbiAgICB9O1xuICAgIFBhbmUucHJvdG90eXBlLmdldE9yaWdpbmFsQm91bmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEJvdW5kaW5nO1xuICAgIH07XG4gICAgUGFuZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib3VuZGluZy5oZWlnaHQgIT09IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdCh0aGlzLl9ib3VuZGluZy5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbXAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHZvaWQgMCA/IGxldmVsIDogMyAvKiBVcGRhdGVMZXZlbC5EcmF3ZXIgKi8sIHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fYm91bmRpbmcpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhbmU7XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBEcmF3UGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHJhd1BhbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd1BhbmUoY2hhcnQsIGlkLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNoYXJ0LCBpZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3lBeGlzV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBpZDogJycsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IFBBTkVfTUlOX0hFSUdIVCxcbiAgICAgICAgICAgIGRyYWdFbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgb3JkZXI6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IFBBTkVfREVGQVVMVF9IRUlHSFQsXG4gICAgICAgICAgICBzdGF0ZTogXCJub3JtYWxcIiAvKiBQYW5lU3RhdGUuTm9ybWFsICovLFxuICAgICAgICAgICAgYXhpczogeyBuYW1lOiAnbm9ybWFsJywgc2Nyb2xsWm9vbUVuYWJsZWQ6IHRydWUgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgIF90aGlzLl9tYWluV2lkZ2V0ID0gX3RoaXMuY3JlYXRlTWFpbldpZGdldChjb250YWluZXIpO1xuICAgICAgICBfdGhpcy5feUF4aXNXaWRnZXQgPSBfdGhpcy5jcmVhdGVZQXhpc1dpZGdldChjb250YWluZXIpO1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdQYW5lLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgdmFyIHBhbmVJZCA9IHRoaXMuZ2V0SWQoKTtcbiAgICAgICAgaWYgKHBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSB8fCBwYW5lSWQgPT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpIHtcbiAgICAgICAgICAgIHZhciBheGlzTmFtZSA9IChfYSA9IG9wdGlvbnMuYXhpcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5fYXhpcykgfHxcbiAgICAgICAgICAgICAgICAoaXNWYWxpZChheGlzTmFtZSkgJiYgdGhpcy5fb3B0aW9ucy5heGlzLm5hbWUgIT09IGF4aXNOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXMgPSB0aGlzLmNyZWF0ZUF4aXNDb21wb25lbnQoYXhpc05hbWUgIT09IG51bGwgJiYgYXhpc05hbWUgIT09IHZvaWQgMCA/IGF4aXNOYW1lIDogJ25vcm1hbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuX2F4aXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpcyA9IHRoaXMuY3JlYXRlQXhpc0NvbXBvbmVudCgnbm9ybWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F4aXMgaW5zdGFuY2VvZiBZQXhpc0ltcCkge1xuICAgICAgICAgICAgdGhpcy5fYXhpcy5zZXRBdXRvQ2FsY1RpY2tGbGFnKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9heGlzLm92ZXJyaWRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zLmF4aXMpLCB7IG5hbWU6IChfYyA9IChfYiA9IG9wdGlvbnMuYXhpcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdub3JtYWwnIH0pKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHZhciBjdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIGlmICh0aGlzLmdldElkKCkgPT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuZ2V0TWFpbldpZGdldCgpLmdldENvbnRhaW5lcigpO1xuICAgICAgICAgICAgY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmdldFlBeGlzV2lkZ2V0KCkuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSAnbnMtcmVzaXplJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9lID0gKF9kID0gb3B0aW9ucy5heGlzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2Nyb2xsWm9vbUVuYWJsZWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vcHRpb25zOyB9O1xuICAgIERyYXdQYW5lLnByb3RvdHlwZS5nZXRBeGlzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXhpcztcbiAgICB9O1xuICAgIERyYXdQYW5lLnByb3RvdHlwZS5zZXRCb3VuZGluZyA9IGZ1bmN0aW9uIChyb290Qm91bmRpbmcsIG1haW5Cb3VuZGluZywgbGVmdFlBeGlzQm91bmRpbmcsIHJpZ2h0WUF4aXNCb3VuZGluZykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIG1lcmdlKHRoaXMuZ2V0Qm91bmRpbmcoKSwgcm9vdEJvdW5kaW5nKTtcbiAgICAgICAgdmFyIGNvbnRlbnRCb3VuZGluZyA9IHt9O1xuICAgICAgICBpZiAoaXNWYWxpZChyb290Qm91bmRpbmcuaGVpZ2h0KSkge1xuICAgICAgICAgICAgY29udGVudEJvdW5kaW5nLmhlaWdodCA9IHJvb3RCb3VuZGluZy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWQocm9vdEJvdW5kaW5nLnRvcCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRCb3VuZGluZy50b3AgPSByb290Qm91bmRpbmcudG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21haW5XaWRnZXQuc2V0Qm91bmRpbmcoY29udGVudEJvdW5kaW5nKTtcbiAgICAgICAgdmFyIG1haW5Cb3VuZGluZ1ZhbGlkID0gaXNWYWxpZChtYWluQm91bmRpbmcpO1xuICAgICAgICBpZiAobWFpbkJvdW5kaW5nVmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21haW5XaWRnZXQuc2V0Qm91bmRpbmcobWFpbkJvdW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZCh0aGlzLl95QXhpc1dpZGdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3lBeGlzV2lkZ2V0LnNldEJvdW5kaW5nKGNvbnRlbnRCb3VuZGluZyk7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSB0aGlzLl9heGlzO1xuICAgICAgICAgICAgaWYgKHlBeGlzLnBvc2l0aW9uID09PSBBeGlzUG9zaXRpb24uTGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGxlZnRZQXhpc0JvdW5kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95QXhpc1dpZGdldC5zZXRCb3VuZGluZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGVmdFlBeGlzQm91bmRpbmcpLCB7IGxlZnQ6IDAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHJpZ2h0WUF4aXNCb3VuZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feUF4aXNXaWRnZXQuc2V0Qm91bmRpbmcocmlnaHRZQXhpc0JvdW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5Cb3VuZGluZ1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95QXhpc1dpZGdldC5zZXRCb3VuZGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogKChfYSA9IG1haW5Cb3VuZGluZy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBtYWluQm91bmRpbmcud2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IG1haW5Cb3VuZGluZy5yaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9kID0gcmlnaHRZQXhpc0JvdW5kaW5nLndpZHRoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuZ2V0TWFpbldpZGdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21haW5XaWRnZXQ7IH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmdldFlBeGlzV2lkZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feUF4aXNXaWRnZXQ7IH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLnVwZGF0ZUltcCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX21haW5XaWRnZXQudXBkYXRlKGxldmVsKTtcbiAgICAgICAgKF9hID0gdGhpcy5feUF4aXNXaWRnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGUobGV2ZWwpO1xuICAgIH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fbWFpbldpZGdldC5kZXN0cm95KCk7XG4gICAgICAgIChfYSA9IHRoaXMuX3lBeGlzV2lkZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKGluY2x1ZGVPdmVybGF5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Qm91bmRpbmcoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlRG9tKCdjYW52YXMnLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXMpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBtYWluQm91bmRpbmcgPSB0aGlzLl9tYWluV2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fbWFpbldpZGdldC5nZXRJbWFnZShpbmNsdWRlT3ZlcmxheSksIG1haW5Cb3VuZGluZy5sZWZ0LCAwLCBtYWluQm91bmRpbmcud2lkdGgsIG1haW5Cb3VuZGluZy5oZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5feUF4aXNXaWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB5QXhpc0JvdW5kaW5nID0gdGhpcy5feUF4aXNXaWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5feUF4aXNXaWRnZXQuZ2V0SW1hZ2UoaW5jbHVkZU92ZXJsYXkpLCB5QXhpc0JvdW5kaW5nLmxlZnQsIDAsIHlBeGlzQm91bmRpbmcud2lkdGgsIHlBeGlzQm91bmRpbmcuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmNyZWF0ZVlBeGlzV2lkZ2V0ID0gZnVuY3Rpb24gKF9jb250YWluZXIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIERyYXdQYW5lO1xufShQYW5lKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEluZGljYXRvclBhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZGljYXRvclBhbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5kaWNhdG9yUGFuZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmRpY2F0b3JQYW5lLnByb3RvdHlwZS5jcmVhdGVBeGlzQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIFlBeGlzQ2xhc3MgPSBnZXRZQXhpc0NsYXNzKG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6ICdkZWZhdWx0Jyk7XG4gICAgICAgIHJldHVybiBuZXcgWUF4aXNDbGFzcyh0aGlzKTtcbiAgICB9O1xuICAgIEluZGljYXRvclBhbmUucHJvdG90eXBlLmNyZWF0ZU1haW5XaWRnZXQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5kaWNhdG9yV2lkZ2V0KGNvbnRhaW5lciwgdGhpcyk7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JQYW5lLnByb3RvdHlwZS5jcmVhdGVZQXhpc1dpZGdldCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBZQXhpc1dpZGdldChjb250YWluZXIsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZGljYXRvclBhbmU7XG59KERyYXdQYW5lKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENhbmRsZVBhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZVBhbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlUGFuZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDYW5kbGVQYW5lLnByb3RvdHlwZS5jcmVhdGVNYWluV2lkZ2V0ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENhbmRsZVdpZGdldChjb250YWluZXIsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZVBhbmU7XG59KEluZGljYXRvclBhbmUpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgWEF4aXNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYQXhpc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWEF4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFhBeGlzVmlldy5wcm90b3R5cGUuZ2V0QXhpc1N0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy54QXhpcztcbiAgICB9O1xuICAgIFhBeGlzVmlldy5wcm90b3R5cGUuY3JlYXRlQXhpc0xpbmUgPSBmdW5jdGlvbiAoYm91bmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgeyB4OiBib3VuZGluZy53aWR0aCwgeTogMCB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYQXhpc1ZpZXcucHJvdG90eXBlLmNyZWF0ZVRpY2tMaW5lcyA9IGZ1bmN0aW9uICh0aWNrcywgX2JvdW5kaW5nLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHRpY2tMaW5lU3R5bGVzID0gc3R5bGVzLnRpY2tMaW5lO1xuICAgICAgICB2YXIgYXhpc0xpbmVTaXplID0gc3R5bGVzLmF4aXNMaW5lLnNpemU7XG4gICAgICAgIHJldHVybiB0aWNrcy5tYXAoZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgIHsgeDogdGljay5jb29yZCwgeTogMCB9LFxuICAgICAgICAgICAgICAgIHsgeDogdGljay5jb29yZCwgeTogYXhpc0xpbmVTaXplICsgdGlja0xpbmVTdHlsZXMubGVuZ3RoIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgWEF4aXNWaWV3LnByb3RvdHlwZS5jcmVhdGVUaWNrVGV4dHMgPSBmdW5jdGlvbiAodGlja3MsIF9ib3VuZGluZywgc3R5bGVzKSB7XG4gICAgICAgIHZhciB0aWNrVGlja1N0eWxlcyA9IHN0eWxlcy50aWNrVGV4dDtcbiAgICAgICAgdmFyIGF4aXNMaW5lU2l6ZSA9IHN0eWxlcy5heGlzTGluZS5zaXplO1xuICAgICAgICB2YXIgdGlja0xpbmVMZW5ndGggPSBzdHlsZXMudGlja0xpbmUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGlja3MubWFwKGZ1bmN0aW9uICh0aWNrKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgeDogdGljay5jb29yZCxcbiAgICAgICAgICAgIHk6IGF4aXNMaW5lU2l6ZSArIHRpY2tMaW5lTGVuZ3RoICsgdGlja1RpY2tTdHlsZXMubWFyZ2luU3RhcnQsXG4gICAgICAgICAgICB0ZXh0OiB0aWNrLnRleHQsXG4gICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBiYXNlbGluZTogJ3RvcCdcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFhBeGlzVmlldztcbn0oQXhpc1ZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgT3ZlcmxheVhBeGlzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3ZlcmxheVhBeGlzVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdmVybGF5WEF4aXNWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE92ZXJsYXlYQXhpc1ZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVUb1BvaW50VGltZXN0YW1wRGF0YUluZGV4RmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBPdmVybGF5WEF4aXNWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlVG9Qb2ludFZhbHVlRmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgT3ZlcmxheVhBeGlzVmlldy5wcm90b3R5cGUuZ2V0Q29tcGxldGVPdmVybGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmdldE92ZXJsYXlzQnlQYW5lSWQoKTtcbiAgICB9O1xuICAgIE92ZXJsYXlYQXhpc1ZpZXcucHJvdG90eXBlLmdldFByb2dyZXNzT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmdldFByb2dyZXNzT3ZlcmxheUluZm8oKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm92ZXJsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgfTtcbiAgICBPdmVybGF5WEF4aXNWaWV3LnByb3RvdHlwZS5nZXREZWZhdWx0RmlndXJlcyA9IGZ1bmN0aW9uIChvdmVybGF5LCBjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBmaWd1cmVzID0gW107XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGNsaWNrT3ZlcmxheUluZm8gPSBjaGFydFN0b3JlLmdldENsaWNrT3ZlcmxheUluZm8oKTtcbiAgICAgICAgaWYgKG92ZXJsYXkubmVlZERlZmF1bHRYQXhpc0ZpZ3VyZSAmJiBvdmVybGF5LmlkID09PSAoKF9hID0gY2xpY2tPdmVybGF5SW5mby5vdmVybGF5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFhfMSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WF8xID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZGluYXRlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGxlZnRYXzEgPSBNYXRoLm1pbihsZWZ0WF8xLCBjb29yZGluYXRlLngpO1xuICAgICAgICAgICAgICAgIHJpZ2h0WF8xID0gTWF0aC5tYXgocmlnaHRYXzEsIGNvb3JkaW5hdGUueCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gb3ZlcmxheS5wb2ludHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihwb2ludC50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gY2hhcnRTdG9yZS5nZXRDdXN0b21BcGkoKS5mb3JtYXREYXRlKHBvaW50LnRpbWVzdGFtcCwgJ1lZWVktTU0tREQgSEg6bW0nLCBGb3JtYXREYXRlVHlwZS5Dcm9zc2hhaXIpO1xuICAgICAgICAgICAgICAgICAgICBmaWd1cmVzLnB1c2goeyB0eXBlOiAndGV4dCcsIGF0dHJzOiB7IHg6IGNvb3JkaW5hdGUueCwgeTogMCwgdGV4dDogdGV4dCwgYWxpZ246ICdjZW50ZXInIH0sIGlnbm9yZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmaWd1cmVzLnVuc2hpZnQoeyB0eXBlOiAncmVjdCcsIGF0dHJzOiB7IHg6IGxlZnRYXzEsIHk6IDAsIHdpZHRoOiByaWdodFhfMSAtIGxlZnRYXzEsIGhlaWdodDogd2lkZ2V0LmdldEJvdW5kaW5nKCkuaGVpZ2h0IH0sIGlnbm9yZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWd1cmVzO1xuICAgIH07XG4gICAgT3ZlcmxheVhBeGlzVmlldy5wcm90b3R5cGUuZ2V0RmlndXJlcyA9IGZ1bmN0aW9uIChvLCBjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gby5jcmVhdGVYQXhpc0ZpZ3VyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG8sIHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsIGJvdW5kaW5nOiBib3VuZGluZywgeEF4aXM6IHhBeGlzLCB5QXhpczogeUF4aXMgfSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIE92ZXJsYXlYQXhpc1ZpZXc7XG59KE92ZXJsYXlZQXhpc1ZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGNyb3NzaGFpcikge1xuICAgICAgICByZXR1cm4gaXNWYWxpZChjcm9zc2hhaXIudGltZXN0YW1wKTtcbiAgICB9O1xuICAgIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LnByb3RvdHlwZS5nZXREaXJlY3Rpb25TdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzdHlsZXMudmVydGljYWw7XG4gICAgfTtcbiAgICBDcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldy5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChjcm9zc2hhaXIsIGNoYXJ0U3RvcmUpIHtcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGNyb3NzaGFpci50aW1lc3RhbXA7XG4gICAgICAgIHJldHVybiBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpLmZvcm1hdERhdGUodGltZXN0YW1wLCAnWVlZWS1NTS1ERCBISDptbScsIEZvcm1hdERhdGVUeXBlLkNyb3NzaGFpcik7XG4gICAgfTtcbiAgICBDcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldy5wcm90b3R5cGUuZ2V0VGV4dEF0dHJzID0gZnVuY3Rpb24gKHRleHQsIHRleHRXaWR0aCwgY3Jvc3NoYWlyLCBib3VuZGluZywgX2F4aXMsIHN0eWxlcykge1xuICAgICAgICB2YXIgeCA9IGNyb3NzaGFpci5yZWFsWDtcbiAgICAgICAgdmFyIG9wdGltYWxYID0gMDtcbiAgICAgICAgdmFyIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGlmICh4IC0gdGV4dFdpZHRoIC8gMiAtIHN0eWxlcy5wYWRkaW5nTGVmdCA8IDApIHtcbiAgICAgICAgICAgIG9wdGltYWxYID0gMDtcbiAgICAgICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggKyB0ZXh0V2lkdGggLyAyICsgc3R5bGVzLnBhZGRpbmdSaWdodCA+IGJvdW5kaW5nLndpZHRoKSB7XG4gICAgICAgICAgICBvcHRpbWFsWCA9IGJvdW5kaW5nLndpZHRoO1xuICAgICAgICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW1hbFggPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IG9wdGltYWxYLCB5OiAwLCB0ZXh0OiB0ZXh0LCBhbGlnbjogYWxpZ24sIGJhc2VsaW5lOiAndG9wJyB9O1xuICAgIH07XG4gICAgcmV0dXJuIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3O1xufShDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFhBeGlzV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYQXhpc1dpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYQXhpc1dpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RDb250YWluZXIsIHBhbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl94QXhpc1ZpZXcgPSBuZXcgWEF4aXNWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlYQXhpc1ZpZXcgPSBuZXcgT3ZlcmxheVhBeGlzVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9jcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldyA9IG5ldyBDcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnO1xuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5fb3ZlcmxheVhBeGlzVmlldyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWEF4aXNXaWRnZXQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBXaWRnZXROYW1lQ29uc3RhbnRzLlhfQVhJUztcbiAgICB9O1xuICAgIFhBeGlzV2lkZ2V0LnByb3RvdHlwZS51cGRhdGVNYWluID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB0aGlzLl94QXhpc1ZpZXcuZHJhdyhjdHgpO1xuICAgIH07XG4gICAgWEF4aXNXaWRnZXQucHJvdG90eXBlLnVwZGF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlYQXhpc1ZpZXcuZHJhdyhjdHgpO1xuICAgICAgICB0aGlzLl9jcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldy5kcmF3KGN0eCk7XG4gICAgfTtcbiAgICByZXR1cm4gWEF4aXNXaWRnZXQ7XG59KERyYXdXaWRnZXQpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgWEF4aXNJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhBeGlzSW1wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhBeGlzSW1wKHBhcmVudCwgeEF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vdmVycmlkZSh4QXhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24gKHhBeGlzKSB7XG4gICAgICAgIHZhciBuYW1lID0geEF4aXMubmFtZSwgc2Nyb2xsWm9vbUVuYWJsZWQgPSB4QXhpcy5zY3JvbGxab29tRW5hYmxlZCwgY3JlYXRlVGlja3MgPSB4QXhpcy5jcmVhdGVUaWNrcztcbiAgICAgICAgaWYgKCFpc1N0cmluZyh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSBzY3JvbGxab29tRW5hYmxlZCAhPT0gbnVsbCAmJiBzY3JvbGxab29tRW5hYmxlZCAhPT0gdm9pZCAwID8gc2Nyb2xsWm9vbUVuYWJsZWQgOiB0aGlzLnNjcm9sbFpvb21FbmFibGVkO1xuICAgICAgICB0aGlzLmNyZWF0ZVRpY2tzID0gY3JlYXRlVGlja3MgIT09IG51bGwgJiYgY3JlYXRlVGlja3MgIT09IHZvaWQgMCA/IGNyZWF0ZVRpY2tzIDogdGhpcy5jcmVhdGVUaWNrcztcbiAgICB9O1xuICAgIFhBeGlzSW1wLnByb3RvdHlwZS5jcmVhdGVSYW5nZUltcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLmdldFBhcmVudCgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgdmlzaWJsZURhdGFSYW5nZSA9IGNoYXJ0U3RvcmUuZ2V0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHZhciByZWFsRnJvbSA9IHZpc2libGVEYXRhUmFuZ2UucmVhbEZyb20sIHJlYWxUbyA9IHZpc2libGVEYXRhUmFuZ2UucmVhbFRvO1xuICAgICAgICB2YXIgYWYgPSByZWFsRnJvbTtcbiAgICAgICAgdmFyIGF0ID0gcmVhbFRvO1xuICAgICAgICB2YXIgZGlmZiA9IHJlYWxUbyAtIHJlYWxGcm9tICsgMTtcbiAgICAgICAgdmFyIHJhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogYWYsXG4gICAgICAgICAgICB0bzogYXQsXG4gICAgICAgICAgICByYW5nZTogZGlmZixcbiAgICAgICAgICAgIHJlYWxGcm9tOiBhZixcbiAgICAgICAgICAgIHJlYWxUbzogYXQsXG4gICAgICAgICAgICByZWFsUmFuZ2U6IGRpZmYsXG4gICAgICAgICAgICBkaXNwbGF5RnJvbTogYWYsXG4gICAgICAgICAgICBkaXNwbGF5VG86IGF0LFxuICAgICAgICAgICAgZGlzcGxheVJhbmdlOiBkaWZmXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIFhBeGlzSW1wLnByb3RvdHlwZS5jcmVhdGVUaWNrc0ltcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRSYW5nZSgpLCByZWFsRnJvbSA9IF9hLnJlYWxGcm9tLCByZWFsVG8gPSBfYS5yZWFsVG87XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRQYXJlbnQoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGZvcm1hdERhdGUgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpLmZvcm1hdERhdGU7XG4gICAgICAgIHZhciB0aW1lV2VpZ2h0VGlja0xpc3QgPSBjaGFydFN0b3JlLmdldFRpbWVXZWlnaHRUaWNrTGlzdCgpO1xuICAgICAgICB2YXIgdGlja3MgPSBbXTtcbiAgICAgICAgdmFyIGZpdFRpY2tzID0gZnVuY3Rpb24gKGxpc3QsIHN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGlzdF8xID0gX192YWx1ZXMobGlzdCksIGxpc3RfMV8xID0gbGlzdF8xLm5leHQoKTsgIWxpc3RfMV8xLmRvbmU7IGxpc3RfMV8xID0gbGlzdF8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVdlaWdodFRpY2sgPSBsaXN0XzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVXZWlnaHRUaWNrLmRhdGFJbmRleCA+PSBzdGFydCAmJiB0aW1lV2VpZ2h0VGljay5kYXRhSW5kZXggPCByZWFsVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lV2VpZ2h0VGljay50aW1lc3RhbXAsIHdlaWdodCA9IHRpbWVXZWlnaHRUaWNrLndlaWdodCwgZGF0YUluZGV4ID0gdGltZVdlaWdodFRpY2suZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAod2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaW1lV2VpZ2h0Q29uc3RhbnRzLlllYXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGZvcm1hdERhdGUodGltZXN0YW1wLCAnWVlZWScsIEZvcm1hdERhdGVUeXBlLlhBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGltZVdlaWdodENvbnN0YW50cy5Nb250aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdZWVlZLU1NJywgRm9ybWF0RGF0ZVR5cGUuWEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaW1lV2VpZ2h0Q29uc3RhbnRzLkRheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdNTS1ERCcsIEZvcm1hdERhdGVUeXBlLlhBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGltZVdlaWdodENvbnN0YW50cy5Ib3VyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGltZVdlaWdodENvbnN0YW50cy5NaW51dGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGZvcm1hdERhdGUodGltZXN0YW1wLCAnSEg6bW0nLCBGb3JtYXREYXRlVHlwZS5YQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbWVXZWlnaHRDb25zdGFudHMuU2Vjb25kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXREYXRlKHRpbWVzdGFtcCwgJ0hIOm1tOnNzJywgRm9ybWF0RGF0ZVR5cGUuWEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdZWVlZLU1NLUREIEhIOm1tJywgRm9ybWF0RGF0ZVR5cGUuWEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZDogX3RoaXMuY29udmVydFRvUGl4ZWwoZGF0YUluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0XzFfMSAmJiAhbGlzdF8xXzEuZG9uZSAmJiAoX2EgPSBsaXN0XzEucmV0dXJuKSkgX2EuY2FsbChsaXN0XzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZpdFRpY2tzKHRpbWVXZWlnaHRUaWNrTGlzdCwgcmVhbEZyb20pO1xuICAgICAgICAvLyBGdXR1cmUgdGltZSB0aWNrXG4gICAgICAgIGlmICh0aW1lV2VpZ2h0VGlja0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJhclNwYWNlID0gY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpLmJhcjtcbiAgICAgICAgICAgIHZhciB0ZXh0U3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS54QXhpcy50aWNrVGV4dDtcbiAgICAgICAgICAgIHZhciBiYXJDb3VudCA9IGNhbGNCZXR3ZWVuVGltZVdlaWdodFRpY2tCYXJDb3VudChiYXJTcGFjZSwgdGV4dFN0eWxlcyk7XG4gICAgICAgICAgICB2YXIgc3RhcnREYXRhSW5kZXggPSB0aW1lV2VpZ2h0VGlja0xpc3RbdGltZVdlaWdodFRpY2tMaXN0Lmxlbmd0aCAtIDFdLmRhdGFJbmRleCArIGJhckNvdW50IC0gMTtcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0RGF0YUluZGV4OyBpIDwgcmVhbFRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gY2hhcnRTdG9yZS5kYXRhSW5kZXhUb1RpbWVzdGFtcChpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhTGlzdC5wdXNoKHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGFMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGNsYXNzaWZ5VGltZVdlaWdodFRpY2tzKG1hcCwgZGF0YUxpc3QsIGNoYXJ0U3RvcmUuZ2V0RGF0ZVRpbWVGb3JtYXQoKSwgc3RhcnREYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgIGZpdFRpY2tzKGNyZWF0ZVRpbWVXZWlnaHRUaWNrTGlzdChtYXAsIGJhclNwYWNlLCB0ZXh0U3R5bGVzKSwgc3RhcnREYXRhSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuY3JlYXRlVGlja3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaWNrcyh7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICAgICAgICBib3VuZGluZzogdGhpcy5nZXRCb3VuZGluZygpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUaWNrczogdGlja3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuICAgIFhBeGlzSW1wLnByb3RvdHlwZS5nZXRBdXRvU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0Q2hhcnQoKS5nZXRTdHlsZXMoKTtcbiAgICAgICAgdmFyIHhBeGlzU3R5bGVzID0gc3R5bGVzLnhBeGlzO1xuICAgICAgICB2YXIgaGVpZ2h0ID0geEF4aXNTdHlsZXMuc2l6ZTtcbiAgICAgICAgaWYgKGhlaWdodCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcm9zc2hhaXJTdHlsZXMgPSBzdHlsZXMuY3Jvc3NoYWlyO1xuICAgICAgICB2YXIgeEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBpZiAoeEF4aXNTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgaWYgKHhBeGlzU3R5bGVzLmF4aXNMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICB4QXhpc0hlaWdodCArPSB4QXhpc1N0eWxlcy5heGlzTGluZS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhBeGlzU3R5bGVzLnRpY2tMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICB4QXhpc0hlaWdodCArPSB4QXhpc1N0eWxlcy50aWNrTGluZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeEF4aXNTdHlsZXMudGlja1RleHQuc2hvdykge1xuICAgICAgICAgICAgICAgIHhBeGlzSGVpZ2h0ICs9ICh4QXhpc1N0eWxlcy50aWNrVGV4dC5tYXJnaW5TdGFydCArIHhBeGlzU3R5bGVzLnRpY2tUZXh0Lm1hcmdpbkVuZCArIHhBeGlzU3R5bGVzLnRpY2tUZXh0LnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjcm9zc2hhaXJWZXJ0aWNhbFRleHRIZWlnaHQgPSAwO1xuICAgICAgICBpZiAoY3Jvc3NoYWlyU3R5bGVzLnNob3cgJiZcbiAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC5zaG93ICYmXG4gICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMudmVydGljYWwudGV4dC5zaG93KSB7XG4gICAgICAgICAgICBjcm9zc2hhaXJWZXJ0aWNhbFRleHRIZWlnaHQgKz0gKGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC50ZXh0LnBhZGRpbmdUb3AgK1xuICAgICAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC50ZXh0LnBhZGRpbmdCb3R0b20gK1xuICAgICAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC50ZXh0LmJvcmRlclNpemUgKiAyICtcbiAgICAgICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMudmVydGljYWwudGV4dC5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoeEF4aXNIZWlnaHQsIGNyb3NzaGFpclZlcnRpY2FsVGV4dEhlaWdodCk7XG4gICAgfTtcbiAgICBYQXhpc0ltcC5wcm90b3R5cGUuZ2V0Qm91bmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpLmdldE1haW5XaWRnZXQoKS5nZXRCb3VuZGluZygpO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRUaW1lc3RhbXBGcm9tUGl4ZWwgPSBmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLmdldFBhcmVudCgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gY2hhcnRTdG9yZS5jb29yZGluYXRlVG9EYXRhSW5kZXgocGl4ZWwpO1xuICAgICAgICByZXR1cm4gY2hhcnRTdG9yZS5kYXRhSW5kZXhUb1RpbWVzdGFtcChkYXRhSW5kZXgpO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRUaW1lc3RhbXBUb1BpeGVsID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBjaGFydFN0b3JlLnRpbWVzdGFtcFRvRGF0YUluZGV4KHRpbWVzdGFtcCk7XG4gICAgICAgIHJldHVybiBjaGFydFN0b3JlLmRhdGFJbmRleFRvQ29vcmRpbmF0ZShkYXRhSW5kZXgpO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuY29vcmRpbmF0ZVRvRGF0YUluZGV4KHBpeGVsKTtcbiAgICB9O1xuICAgIFhBeGlzSW1wLnByb3RvdHlwZS5jb252ZXJ0VG9QaXhlbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5kYXRhSW5kZXhUb0Nvb3JkaW5hdGUodmFsdWUpO1xuICAgIH07XG4gICAgWEF4aXNJbXAuZXh0ZW5kID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBDdXN0b20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3VzdG9tKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHRlbXBsYXRlKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICAgICAgfShYQXhpc0ltcCkpO1xuICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgIH07XG4gICAgcmV0dXJuIFhBeGlzSW1wO1xufShBeGlzSW1wKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIG5vcm1hbCA9IHtcbiAgICBuYW1lOiAnbm9ybWFsJ1xufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgeEF4aXNlcyA9IHtcbiAgICBub3JtYWw6IFhBeGlzSW1wLmV4dGVuZChub3JtYWwpXG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJYQXhpcyhheGlzKSB7XG4gICAgeEF4aXNlc1theGlzLm5hbWVdID0gWEF4aXNJbXAuZXh0ZW5kKGF4aXMpO1xufVxuZnVuY3Rpb24gZ2V0WEF4aXNDbGFzcyhuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB4QXhpc2VzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB4QXhpc2VzLm5vcm1hbDtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgWEF4aXNQYW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYQXhpc1BhbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWEF4aXNQYW5lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFhBeGlzUGFuZS5wcm90b3R5cGUuY3JlYXRlQXhpc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBYQXhpc0NsYXNzID0gZ2V0WEF4aXNDbGFzcyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBYQXhpc0NsYXNzKHRoaXMpO1xuICAgIH07XG4gICAgWEF4aXNQYW5lLnByb3RvdHlwZS5jcmVhdGVNYWluV2lkZ2V0ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFhBeGlzV2lkZ2V0KGNvbnRhaW5lciwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gWEF4aXNQYW5lO1xufShEcmF3UGFuZSkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gcHJldmlvdXMgPiAod2FpdCApKSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBleHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxSMSA9IGFueSwgUjIgPSBhbnk+IChmdW5jOiAoLi4uYXJnczogYW55W10pID0+IFIxLCByZXNvbHZlcj86ICguLi5hcmdzOiBhbnlbXSkgPT4gUjIpOiAoLi4uYXJnczogYW55W10pID0+IFIxIHtcbi8vICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpIHx8IChpc1ZhbGlkKHJlc29sdmVyKSAmJiAhaXNGdW5jdGlvbihyZXNvbHZlcikpKSB7XG4vLyAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpXG4vLyAgIH1cbi8vICAgY29uc3QgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBhbnkge1xuLy8gICAgIGNvbnN0IGtleSA9IGlzRnVuY3Rpb24ocmVzb2x2ZXIpID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdXG4vLyAgICAgY29uc3QgY2FjaGUgPSBtZW1vaXplZC5jYWNoZVxuLy8gICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuLy8gICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpXG4vLyAgICAgfVxuLy8gICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncylcbi8vICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4vLyAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlXG4vLyAgICAgcmV0dXJuIHJlc3VsdFxuLy8gICB9XG4vLyAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbi8vICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwKSgpXG4vLyAgIHJldHVybiBtZW1vaXplZFxuLy8gfVxuLy8gbWVtb2l6ZS5DYWNoZSA9IE1hcFxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBTZXBhcmF0b3JXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcGFyYXRvcldpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXBhcmF0b3JXaWRnZXQocm9vdENvbnRhaW5lciwgcGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290Q29udGFpbmVyLCBwYW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZHJhZ0ZsYWcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2RyYWdTdGFydFkgPSAwO1xuICAgICAgICBfdGhpcy5fdG9wUGFuZUhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLl9ib3R0b21QYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuX3RvcFBhbmUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYm90dG9tUGFuZSA9IG51bGw7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2QgLS0gaWdub3JlXG4gICAgICAgIF90aGlzLl9wcmVzc2VkTW91c2VNb3ZlRXZlbnQgPSB0aHJvdHRsZShfdGhpcy5fcHJlc3NlZFRvdWNoTW91c2VNb3ZlRXZlbnQsIDIwKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgIF90aGlzLnJlZ2lzdGVyRXZlbnQoJ3RvdWNoU3RhcnRFdmVudCcsIF90aGlzLl9tb3VzZURvd25FdmVudC5iaW5kKF90aGlzKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLnJlZ2lzdGVyRXZlbnQoJ3RvdWNoTW92ZUV2ZW50JywgX3RoaXMuX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKF90aGlzKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLnJlZ2lzdGVyRXZlbnQoJ3RvdWNoRW5kRXZlbnQnLCBfdGhpcy5fbW91c2VVcEV2ZW50LmJpbmQoX3RoaXMpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAucmVnaXN0ZXJFdmVudCgnbW91c2VEb3duRXZlbnQnLCBfdGhpcy5fbW91c2VEb3duRXZlbnQuYmluZChfdGhpcykpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC5yZWdpc3RlckV2ZW50KCdtb3VzZVVwRXZlbnQnLCBfdGhpcy5fbW91c2VVcEV2ZW50LmJpbmQoX3RoaXMpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAucmVnaXN0ZXJFdmVudCgncHJlc3NlZE1vdXNlTW92ZUV2ZW50JywgX3RoaXMuX3ByZXNzZWRNb3VzZU1vdmVFdmVudC5iaW5kKF90aGlzKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLnJlZ2lzdGVyRXZlbnQoJ21vdXNlRW50ZXJFdmVudCcsIF90aGlzLl9tb3VzZUVudGVyRXZlbnQuYmluZChfdGhpcykpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC5yZWdpc3RlckV2ZW50KCdtb3VzZUxlYXZlRXZlbnQnLCBfdGhpcy5fbW91c2VMZWF2ZUV2ZW50LmJpbmQoX3RoaXMpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTZXBhcmF0b3JXaWRnZXQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBXaWRnZXROYW1lQ29uc3RhbnRzLlNFUEFSQVRPUjtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuY2hlY2tFdmVudE9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuX21vdXNlRG93bkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RyYWdGbGFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0WSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHRoaXMuX3RvcFBhbmUgPSBwYW5lLmdldFRvcFBhbmUoKTtcbiAgICAgICAgdGhpcy5fYm90dG9tUGFuZSA9IHBhbmUuZ2V0Qm90dG9tUGFuZSgpO1xuICAgICAgICB2YXIgZHJhd1BhbmVzID0gY2hhcnQuZ2V0RHJhd1BhbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLl90b3BQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSA9PT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZHJhd1BhbmVzLmZpbmRJbmRleChmdW5jdGlvbiAocGFuZSkgeyB2YXIgX2E7IHJldHVybiBwYW5lLmdldElkKCkgPT09ICgoX2EgPSBfdGhpcy5fdG9wUGFuZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldElkKCkpOyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVfMSA9IGRyYXdQYW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZV8xLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3BQYW5lID0gcGFuZV8xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvdHRvbVBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlID09PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBkcmF3UGFuZXMuZmluZEluZGV4KGZ1bmN0aW9uIChwYW5lKSB7IHZhciBfYTsgcmV0dXJuIHBhbmUuZ2V0SWQoKSA9PT0gKChfYSA9IF90aGlzLl9ib3R0b21QYW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SWQoKSk7IH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IGRyYXdQYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYW5lXzIgPSBkcmF3UGFuZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVfMi5nZXRPcHRpb25zKCkuc3RhdGUgIT09IFwibWluaW1pemVcIiAvKiBQYW5lU3RhdGUuTWluaW1pemUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm90dG9tUGFuZSA9IHBhbmVfMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RvcFBhbmVIZWlnaHQgPSB0aGlzLl90b3BQYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9ib3R0b21QYW5lSGVpZ2h0ID0gdGhpcy5fYm90dG9tUGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JXaWRnZXQucHJvdG90eXBlLl9tb3VzZVVwRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RyYWdGbGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RvcFBhbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9ib3R0b21QYW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdG9wUGFuZUhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX2JvdHRvbVBhbmVIZWlnaHQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fbW91c2VMZWF2ZUV2ZW50KCk7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JXaWRnZXQucHJvdG90eXBlLl9wcmVzc2VkVG91Y2hNb3VzZU1vdmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZHJhZ0Rpc3RhbmNlID0gZXZlbnQucGFnZVkgLSB0aGlzLl9kcmFnU3RhcnRZO1xuICAgICAgICB2YXIgaXNVcERyYWcgPSBkcmFnRGlzdGFuY2UgPCAwO1xuICAgICAgICBpZiAoaXNWYWxpZCh0aGlzLl90b3BQYW5lKSAmJiBpc1ZhbGlkKHRoaXMuX2JvdHRvbVBhbmUpKSB7XG4gICAgICAgICAgICB2YXIgYm90dG9tUGFuZU9wdGlvbnMgPSB0aGlzLl9ib3R0b21QYW5lLmdldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3BQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLyAmJlxuICAgICAgICAgICAgICAgIGJvdHRvbVBhbmVPcHRpb25zLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovICYmXG4gICAgICAgICAgICAgICAgYm90dG9tUGFuZU9wdGlvbnMuZHJhZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZFBhbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBpbmNyZWFzZWRQYW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydERyYWdJbmNyZWFzZWRQYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNVcERyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlZFBhbmUgPSB0aGlzLl90b3BQYW5lO1xuICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZWRQYW5lID0gdGhpcy5fYm90dG9tUGFuZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgPSB0aGlzLl90b3BQYW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWdJbmNyZWFzZWRQYW5lSGVpZ2h0ID0gdGhpcy5fYm90dG9tUGFuZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHVjZWRQYW5lID0gdGhpcy5fYm90dG9tUGFuZTtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVhc2VkUGFuZSA9IHRoaXMuX3RvcFBhbmU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhZ1JlZHVjZWRQYW5lSGVpZ2h0ID0gdGhpcy5fYm90dG9tUGFuZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnSW5jcmVhc2VkUGFuZUhlaWdodCA9IHRoaXMuX3RvcFBhbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkUGFuZU1pbkhlaWdodCA9IHJlZHVjZWRQYW5lLmdldE9wdGlvbnMoKS5taW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RHJhZ1JlZHVjZWRQYW5lSGVpZ2h0ID4gcmVkdWNlZFBhbmVNaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWRQYW5lSGVpZ2h0ID0gTWF0aC5tYXgoc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgLSBNYXRoLmFicyhkcmFnRGlzdGFuY2UpLCByZWR1Y2VkUGFuZU1pbkhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmSGVpZ2h0ID0gc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgLSByZWR1Y2VkUGFuZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlZFBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHJlZHVjZWRQYW5lSGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZWRQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBzdGFydERyYWdJbmNyZWFzZWRQYW5lSGVpZ2h0ICsgZGlmZkhlaWdodCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQYW5lID0gdGhpcy5nZXRQYW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFydCA9IGN1cnJlbnRQYW5lLmdldENoYXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmdldENoYXJ0U3RvcmUoKS5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25QYW5lRHJhZywgeyBwYW5lSWQ6IGN1cnJlbnRQYW5lLmdldElkKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlSGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuX21vdXNlRW50ZXJFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGJvdHRvbVBhbmUgPSBwYW5lLmdldEJvdHRvbVBhbmUoKTtcbiAgICAgICAgaWYgKGJvdHRvbVBhbmUuZ2V0T3B0aW9ucygpLmRyYWdFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnQuZ2V0U3R5bGVzKCkuc2VwYXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5zdHlsZS5iYWNrZ3JvdW5kID0gc3R5bGVzLmFjdGl2ZUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuX21vdXNlTGVhdmVFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kcmFnRmxhZykge1xuICAgICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRG9tKCdkaXYnLCB7XG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChSRUFMX1NFUEFSQVRPUl9IRUlHSFQsIFwicHhcIiksXG4gICAgICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAnLTNweCcsXG4gICAgICAgICAgICB6SW5kZXg6ICcyMCcsXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgIGN1cnNvcjogJ25zLXJlc2l6ZSdcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JXaWRnZXQucHJvdG90eXBlLnVwZGF0ZUltcCA9IGZ1bmN0aW9uIChjb250YWluZXIsIF9ib3VuZGluZywgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSA0IC8qIFVwZGF0ZUxldmVsLkFsbCAqLyB8fCBsZXZlbCA9PT0gMiAvKiBVcGRhdGVMZXZlbC5TZXBhcmF0b3IgKi8pIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldFN0eWxlcygpLnNlcGFyYXRvcjtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCgtTWF0aC5mbG9vcigoUkVBTF9TRVBBUkFUT1JfSEVJR0hUIC0gc3R5bGVzLnNpemUpIC8gMiksIFwicHhcIik7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoUkVBTF9TRVBBUkFUT1JfSEVJR0hULCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VwYXJhdG9yV2lkZ2V0O1xufShXaWRnZXQpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgU2VwYXJhdG9yUGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VwYXJhdG9yUGFuZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXBhcmF0b3JQYW5lKGNoYXJ0LCBpZCwgdG9wUGFuZSwgYm90dG9tUGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjaGFydCwgaWQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmdldENvbnRhaW5lcigpLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgIF90aGlzLl90b3BQYW5lID0gdG9wUGFuZTtcbiAgICAgICAgX3RoaXMuX2JvdHRvbVBhbmUgPSBib3R0b21QYW5lO1xuICAgICAgICBfdGhpcy5fc2VwYXJhdG9yV2lkZ2V0ID0gbmV3IFNlcGFyYXRvcldpZGdldChfdGhpcy5nZXRDb250YWluZXIoKSwgX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlcGFyYXRvclBhbmUucHJvdG90eXBlLnNldEJvdW5kaW5nID0gZnVuY3Rpb24gKHJvb3RCb3VuZGluZykge1xuICAgICAgICBtZXJnZSh0aGlzLmdldEJvdW5kaW5nKCksIHJvb3RCb3VuZGluZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUuZ2V0VG9wUGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvcFBhbmU7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS5zZXRUb3BQYW5lID0gZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgdGhpcy5fdG9wUGFuZSA9IHBhbmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUuZ2V0Qm90dG9tUGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdHRvbVBhbmU7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS5zZXRCb3R0b21QYW5lID0gZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgdGhpcy5fYm90dG9tUGFuZSA9IHBhbmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUuZ2V0V2lkZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VwYXJhdG9yV2lkZ2V0OyB9O1xuICAgIFNlcGFyYXRvclBhbmUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKF9pbmNsdWRlT3ZlcmxheSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldEJvdW5kaW5nKCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0Q2hhcnQoKS5nZXRTdHlsZXMoKS5zZXBhcmF0b3I7XG4gICAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVEb20oJ2NhbnZhcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlcy5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUudXBkYXRlSW1wID0gZnVuY3Rpb24gKGxldmVsLCBjb250YWluZXIsIGJvdW5kaW5nKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gNCAvKiBVcGRhdGVMZXZlbC5BbGwgKi8gfHwgbGV2ZWwgPT09IDIgLyogVXBkYXRlTGV2ZWwuU2VwYXJhdG9yICovKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRDaGFydCgpLmdldFN0eWxlcygpLnNlcGFyYXRvcjtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZXMuY29sb3I7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoYm91bmRpbmcuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1hcmdpbkxlZnQgPSBcIlwiLmNvbmNhdChib3VuZGluZy5sZWZ0LCBcInB4XCIpO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoYm91bmRpbmcud2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgICB0aGlzLl9zZXBhcmF0b3JXaWRnZXQudXBkYXRlKGxldmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlcGFyYXRvclBhbmU7XG59KFBhbmUpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc0ZGKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmaXJlZm94Jyk7XG59XG5mdW5jdGlvbiBpc0lPUygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL2lQaG9uZXxpUGFkfGlQb2R8aU9TLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgZXNsaW50LWNvbW1lbnRzL3JlcXVpcmUtZGVzY3JpcHRpb24gLS0gaWdub3JlICovXG52YXIgTWFuaGF0dGFuRGlzdGFuY2UgPSB7XG4gICAgQ2FuY2VsQ2xpY2s6IDUsXG4gICAgQ2FuY2VsVGFwOiA1LFxuICAgIERvdWJsZUNsaWNrOiA1LFxuICAgIERvdWJsZVRhcDogMzBcbn07XG52YXIgTW91c2VFdmVudEJ1dHRvbiA9IHtcbiAgICBMZWZ0OiAwLFxuICAgIE1pZGRsZTogMSxcbiAgICBSaWdodDogMlxufTtcbnZhciBUT1VDSF9NSU5fUkFESVVTID0gMTA7XG4vLyBUT0RPOiBnZXQgcmlkIG9mIGEgbG90IG9mIGJvb2xlYW4gZmxhZ3MsIHByb2JhYmx5IHdlIHNob3VsZCByZXBsYWNlIGl0IHdpdGggc29tZSBlbnVtXG52YXIgU3ludGhldGljRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ludGhldGljRXZlbnQodGFyZ2V0LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NsaWNrQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9jbGlja1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NsaWNrQ29vcmRpbmF0ZSA9IHsgeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCB5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICAgICAgdGhpcy5fdGFwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl90YXBUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl90YXBDb29yZGluYXRlID0geyB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIHk6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgICB0aGlzLl9sb25nVGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9uZ1RhcEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmVTdGFydENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl90b3VjaE1vdmVTdGFydENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl90b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhbmNlbENsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQ29udGV4dE1lbnUgPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydFBpbmNoRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9waW5jaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSAwO1xuICAgICAgICAvLyBmb3IgdG91Y2hzdGFydC90b3VjaG1vdmUvdG91Y2hlbmQgZXZlbnRzIHdlIGhhbmRsZSBvbmx5IGZpcnN0IHRvdWNoXG4gICAgICAgIC8vIGkuZS4gd2UgZG9uJ3Qgc3VwcG9ydCBzZXZlcmFsIGFjdGl2ZSB0b3VjaGVzIGF0IHRoZSBzYW1lIHRpbWUgKGV4Y2VwdCBwaW5jaCBldmVudClcbiAgICAgICAgdGhpcy5fYWN0aXZlVG91Y2hJZCA9IG51bGw7XG4gICAgICAgIC8vIGFjY2VwdCBhbGwgbW91c2UgbGVhdmUgZXZlbnRzIGlmIGl0J3Mgbm90IGFuIGlPUyBkZXZpY2VcbiAgICAgICAgLy8gc2VlIF9tb3VzZUVudGVySGFuZGxlciwgX21vdXNlTW92ZUhhbmRsZXIsIF9tb3VzZUxlYXZlSGFuZGxlclxuICAgICAgICB0aGlzLl9hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBGaXJlZm94IG1vdXNlIGV2ZW50cyBkb250J3QgZmlyZSBpZiB0aGUgbW91c2UgcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICogVG8gcHJldmVudCB0aGUgbW91c2UgZnJvbSBoYW5naW5nIHdoaWxlIHByZXNzZWQgd2UncmUgc3Vic2NyaWJpbmcgb24gdGhlIG1vdXNlbGVhdmUgZXZlbnQgb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQuXG4gICAgICAgICAqIFdlJ3JlIHN1YnNjcmliaW5nIG9uIG1vdXNlbGVhdmUsIGJ1dCB0aGlzIGV2ZW50IGlzIGFjdHVhbGx5IGZpcmVkIG9uIG1vdXNldXAgb3V0c2lkZSBvZiB0aGUgYnJvd3NlcidzIGJvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uRmlyZWZveE91dHNpZGVNb3VzZVVwID0gZnVuY3Rpb24gKG1vdXNlVXBFdmVudCkge1xuICAgICAgICAgICAgX3RoaXMuX21vdXNlVXBIYW5kbGVyKG1vdXNlVXBFdmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYWZhcmkgZG9lc24ndCBmaXJlIHRvdWNoc3RhcnQvbW91c2Vkb3duIGV2ZW50cyBvbiBkb3VibGUgdGFwIHNpbmNlIGlPUyAxMy5cbiAgICAgICAgICogVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAqIDEpIENhbGwgcHJldmVudERlZmF1bHQgaW4gdG91Y2hFbmQgaGFuZGxlci4gQnV0IGl0IGFsc28gcHJldmVudHMgY2xpY2sgZXZlbnQgZnJvbSBmaXJpbmcuXG4gICAgICAgICAqIDIpIEFkZCBsaXN0ZW5lciBvbiBkYmxjbGljayBldmVudCB0aGF0IGZpcmVzIHdpdGggdGhlIHByZWNlZGluZyBtb3VzZWRvd24vbW91c2V1cC5cbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvMTI1MDczXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbk1vYmlsZVNhZmFyaURvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGRibENsaWNrRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZmlyZXNUb3VjaEV2ZW50cyhkYmxDbGlja0V2ZW50KSkge1xuICAgICAgICAgICAgICAgICsrX3RoaXMuX3RhcENvdW50O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdGFwVGltZW91dElkICE9PSBudWxsICYmIF90aGlzLl90YXBDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hbmhhdHRhbkRpc3RhbmNlID0gX3RoaXMuX21vdXNlVG91Y2hNb3ZlV2l0aERvd25JbmZvKF90aGlzLl9nZXRDb29yZGluYXRlKGRibENsaWNrRXZlbnQpLCBfdGhpcy5fdGFwQ29vcmRpbmF0ZSkubWFuaGF0dGFuRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA8IE1hbmhhdHRhbkRpc3RhbmNlLkRvdWJsZVRhcCAmJiAhX3RoaXMuX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NFdmVudChfdGhpcy5fbWFrZUNvbXBhdEV2ZW50KGRibENsaWNrRXZlbnQpLCBfdGhpcy5faGFuZGxlci5kb3VibGVUYXBFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0VGFwVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrX3RoaXMuX2NsaWNrQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jbGlja1RpbWVvdXRJZCAhPT0gbnVsbCAmJiBfdGhpcy5fY2xpY2tDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hbmhhdHRhbkRpc3RhbmNlID0gX3RoaXMuX21vdXNlVG91Y2hNb3ZlV2l0aERvd25JbmZvKF90aGlzLl9nZXRDb29yZGluYXRlKGRibENsaWNrRXZlbnQpLCBfdGhpcy5fY2xpY2tDb29yZGluYXRlKS5tYW5oYXR0YW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgTWFuaGF0dGFuRGlzdGFuY2UuRG91YmxlQ2xpY2sgJiYgIV90aGlzLl9jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NFdmVudChfdGhpcy5fbWFrZUNvbXBhdEV2ZW50KGRibENsaWNrRXZlbnQpLCBfdGhpcy5faGFuZGxlci5tb3VzZURvdWJsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vdXNlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZU1vdXNlV2hlZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCgpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICB0aGlzLl9yZXNldENsaWNrVGltZW91dCgpO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZUVudGVySGFuZGxlciA9IGZ1bmN0aW9uIChlbnRlckV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAoX2EgPSB0aGlzLl91bnN1YnNjcmliZU1vdXNlbW92ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICAgIChfYiA9IHRoaXMuX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcyk7XG4gICAgICAgIChfYyA9IHRoaXMuX3Vuc3Vic2NyaWJlQ29udGV4dE1lbnUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIHZhciBib3VuZE1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLl9tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgdmFyIGJvdW5kTW91c2VXaGVlbCA9IHRoaXMuX21vdXNlV2hlZWxIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgYm91bmRNb3VzZVdoZWVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgYm91bmRNb3VzZVdoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIHZhciBib3VuZENvbnRleHRNZW51ID0gdGhpcy5fY29udGV4dE1lbnVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgX3RoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGJvdW5kQ29udGV4dE1lbnUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBib3VuZENvbnRleHRNZW51LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAodGhpcy5fZmlyZXNUb3VjaEV2ZW50cyhlbnRlckV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQoZW50ZXJFdmVudCksIHRoaXMuX2hhbmRsZXIubW91c2VFbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5fYWNjZXB0TW91c2VMZWF2ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3Jlc2V0Q2xpY2tUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jbGlja1RpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xpY2tDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2NsaWNrVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xpY2tDb29yZGluYXRlID0geyB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIHk6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9yZXNldFRhcFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXBUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90YXBUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fdGFwVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFwQ29vcmRpbmF0ZSA9IHsgeDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCB5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChtb3ZlRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlUHJlc3NlZCB8fCB0aGlzLl90b3VjaE1vdmVTdGFydENvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmlyZXNUb3VjaEV2ZW50cyhtb3ZlRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChtb3ZlRXZlbnQpLCB0aGlzLl9oYW5kbGVyLm1vdXNlTW92ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fYWNjZXB0TW91c2VMZWF2ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX21vdXNlV2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gKHdoZWVsRXZlbnQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHdoZWVsRXZlbnQuZGVsdGFYKSA+IE1hdGguYWJzKHdoZWVsRXZlbnQuZGVsdGFZKSkge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuX2hhbmRsZXIubW91c2VXaGVlbEhvcnRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdCh3aGVlbEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh3aGVlbEV2ZW50LmRlbHRhWCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLm1vdXNlV2hlZWxIb3J0RXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KHdoZWVsRXZlbnQpLCAtd2hlZWxFdmVudC5kZWx0YVgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuX2hhbmRsZXIubW91c2VXaGVlbFZlcnRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVsdGFZID0gLSh3aGVlbEV2ZW50LmRlbHRhWSAvIDEwMCk7XG4gICAgICAgICAgICBpZiAoZGVsdGFZID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQod2hlZWxFdmVudCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHdoZWVsRXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB3aGVlbEV2ZW50LkRPTV9ERUxUQV9QQUdFOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhWSAqPSAxMjA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZICo9IDMyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5zaWduKGRlbHRhWSkgKiBNYXRoLm1pbigxLCBNYXRoLmFicyhkZWx0YVkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLm1vdXNlV2hlZWxWZXJ0RXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KHdoZWVsRXZlbnQpLCBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fY29udGV4dE1lbnVIYW5kbGVyID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQobW91c2VFdmVudCk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3RvdWNoTW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAobW92ZUV2ZW50KSB7XG4gICAgICAgIHZhciB0b3VjaCA9IHRoaXMuX3RvdWNoV2l0aElkKG1vdmVFdmVudC5jaGFuZ2VkVG91Y2hlcywgdGhpcy5fYWN0aXZlVG91Y2hJZCk7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wID0gdGhpcy5fZXZlbnRUaW1lU3RhbXAobW92ZUV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0UGluY2hNaWRkbGVDb29yZGluYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBwaW5jaCBpZiBtb3ZlIGV2ZW50IGNvbWVzIGZhc3RlciB0aGFuIHRoZSBzZWNvbmQgdG91Y2hcbiAgICAgICAgdGhpcy5fcGluY2hQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbW92ZUluZm8gPSB0aGlzLl9tb3VzZVRvdWNoTW92ZVdpdGhEb3duSW5mbyh0aGlzLl9nZXRDb29yZGluYXRlKHRvdWNoKSwgdGhpcy5fdG91Y2hNb3ZlU3RhcnRDb29yZGluYXRlKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSBtb3ZlSW5mby54T2Zmc2V0LCB5T2Zmc2V0ID0gbW92ZUluZm8ueU9mZnNldCwgbWFuaGF0dGFuRGlzdGFuY2UgPSBtb3ZlSW5mby5tYW5oYXR0YW5EaXN0YW5jZTtcbiAgICAgICAgaWYgKCF0aGlzLl90b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlICYmIG1hbmhhdHRhbkRpc3RhbmNlIDwgTWFuaGF0dGFuRGlzdGFuY2UuQ2FuY2VsVGFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHdoZW4gY3VycmVudCBwb3NpdGlvbiBleGNlZWRlZCBtYW5oYXR0YW4gZGlzdGFuY2VcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsIGRyYWcgaXMgbW9yZSBpbXBvcnRhbnQgdGhhbiBob3Jpem9udGFsIGRyYWdcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Ugc2Nyb2xsIHRoZSBwYWdlIHZlcnRpY2FsbHkgb2Z0ZW4gdGhhbiBob3Jpem9udGFsbHlcbiAgICAgICAgICAgIHZhciBjb3JyZWN0ZWRYT2Zmc2V0ID0geE9mZnNldCAqIDAuNTtcbiAgICAgICAgICAgIC8vIGEgZHJhZyBjYW4gYmUgb25seSBpZiB0b3VjaCBwYWdlIHNjcm9sbCBpc24ndCBhbGxvd2VkXG4gICAgICAgICAgICB2YXIgaXNWZXJ0RHJhZyA9IHlPZmZzZXQgPj0gY29ycmVjdGVkWE9mZnNldCAmJiAhdGhpcy5fb3B0aW9ucy50cmVhdFZlcnREcmFnQXNQYWdlU2Nyb2xsKCk7XG4gICAgICAgICAgICB2YXIgaXNIb3J6RHJhZyA9IGNvcnJlY3RlZFhPZmZzZXQgPiB5T2Zmc2V0ICYmICF0aGlzLl9vcHRpb25zLnRyZWF0SG9yekRyYWdBc1BhZ2VTY3JvbGwoKTtcbiAgICAgICAgICAgIC8vIGlmIGRyYWcgZXZlbnQgaGFwcGVuZWQgdGhlbiB3ZSBzaG91bGQgcmV2ZXJ0IHByZXZlbnREZWZhdWx0IHN0YXRlIHRvIG9yaWdpbmFsIG9uZVxuICAgICAgICAgICAgLy8gYW5kIHRyeSB0byBwcm9jZXNzIHRoZSBkcmFnIGV2ZW50XG4gICAgICAgICAgICAvLyBlbHNlIHdlIHNob3VsZG4ndCBwcmV2ZW50IGRlZmF1bHQgb2YgdGhlIGV2ZW50IGFuZCBpZ25vcmUgcHJvY2Vzc2luZyB0aGUgZHJhZyBldmVudFxuICAgICAgICAgICAgaWYgKCFpc1ZlcnREcmFnICYmICFpc0hvcnpEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBpZiBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgbW9yZSB0aGF0IDUgLSB3ZSBzaG91bGQgY2FuY2VsIHRhcCBldmVudFxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0VGFwVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQobW92ZUV2ZW50LCB0b3VjaCksIHRoaXMuX2hhbmRsZXIudG91Y2hNb3ZlRXZlbnQpO1xuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHByZXZlbnQgZGVmYXVsdCBpbiBjYXNlIG9mIHRvdWNoIG9ubHlcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdChtb3ZlRXZlbnQpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VNb3ZlV2l0aERvd25IYW5kbGVyID0gZnVuY3Rpb24gKG1vdmVFdmVudCkge1xuICAgICAgICBpZiAobW92ZUV2ZW50LmJ1dHRvbiAhPT0gTW91c2VFdmVudEJ1dHRvbi5MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vdmVJbmZvID0gdGhpcy5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8odGhpcy5fZ2V0Q29vcmRpbmF0ZShtb3ZlRXZlbnQpLCB0aGlzLl9tb3VzZU1vdmVTdGFydENvb3JkaW5hdGUpO1xuICAgICAgICB2YXIgbWFuaGF0dGFuRGlzdGFuY2UgPSBtb3ZlSW5mby5tYW5oYXR0YW5EaXN0YW5jZTtcbiAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlID49IE1hbmhhdHRhbkRpc3RhbmNlLkNhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAvLyBpZiBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgbW9yZSB0aGF0IDUgLSB3ZSBzaG91bGQgY2FuY2VsIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxDbGljayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5fY2FuY2VsQ2xpY2sgaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGF0IG1pbmltdW0gbWFuaGF0dGFuIGRpc3RhbmNlIGlzIGFscmVhZHkgZXhjZWVkZWRcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQobW92ZUV2ZW50KSwgdGhpcy5faGFuZGxlci5wcmVzc2VkTW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX21vdXNlVG91Y2hNb3ZlV2l0aERvd25JbmZvID0gZnVuY3Rpb24gKGN1cnJlbnRDb29yZGluYXRlLCBzdGFydENvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSBNYXRoLmFicyhzdGFydENvb3JkaW5hdGUueCAtIGN1cnJlbnRDb29yZGluYXRlLngpO1xuICAgICAgICB2YXIgeU9mZnNldCA9IE1hdGguYWJzKHN0YXJ0Q29vcmRpbmF0ZS55IC0gY3VycmVudENvb3JkaW5hdGUueSk7XG4gICAgICAgIHZhciBtYW5oYXR0YW5EaXN0YW5jZSA9IHhPZmZzZXQgKyB5T2Zmc2V0O1xuICAgICAgICByZXR1cm4geyB4T2Zmc2V0OiB4T2Zmc2V0LCB5T2Zmc2V0OiB5T2Zmc2V0LCBtYW5oYXR0YW5EaXN0YW5jZTogbWFuaGF0dGFuRGlzdGFuY2UgfTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fdG91Y2hFbmRIYW5kbGVyID0gZnVuY3Rpb24gKHRvdWNoRW5kRXZlbnQpIHtcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5fdG91Y2hXaXRoSWQodG91Y2hFbmRFdmVudC5jaGFuZ2VkVG91Y2hlcywgdGhpcy5fYWN0aXZlVG91Y2hJZCk7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCAmJiB0b3VjaEVuZEV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZywgc29tZWhvdyB3ZSBtaXNzZWQgdGhlIHJlcXVpcmVkIHRvdWNoZW5kIGV2ZW50XG4gICAgICAgICAgICAvLyBwcm9iYWJseSB0aGUgYnJvd3NlciBoYXMgbm90IHNlbnQgdGhpcyBldmVudFxuICAgICAgICAgICAgdG91Y2ggPSB0b3VjaEVuZEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRvdWNoSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCA9IHRoaXMuX2V2ZW50VGltZVN0YW1wKHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICB0aGlzLl9jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoTW92ZVN0YXJ0Q29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGF0RXZlbnQgPSB0aGlzLl9tYWtlQ29tcGF0RXZlbnQodG91Y2hFbmRFdmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX2hhbmRsZXIudG91Y2hFbmRFdmVudCk7XG4gICAgICAgICsrdGhpcy5fdGFwQ291bnQ7XG4gICAgICAgIGlmICh0aGlzLl90YXBUaW1lb3V0SWQgIT09IG51bGwgJiYgdGhpcy5fdGFwQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGJvdGggY2xpY2tzIGFyZSBuZWFyIGVub3VnaFxuICAgICAgICAgICAgdmFyIG1hbmhhdHRhbkRpc3RhbmNlID0gdGhpcy5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8odGhpcy5fZ2V0Q29vcmRpbmF0ZSh0b3VjaCksIHRoaXMuX3RhcENvb3JkaW5hdGUpLm1hbmhhdHRhbkRpc3RhbmNlO1xuICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgTWFuaGF0dGFuRGlzdGFuY2UuRG91YmxlVGFwICYmICF0aGlzLl9jYW5jZWxUYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX2hhbmRsZXIuZG91YmxlVGFwRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci50YXBFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGZpcmUgbW91c2UgZXZlbnRzIGlmIHRhcCBoYW5kbGVyIHdhcyBleGVjdXRlZFxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgY2xpY2sgZXZlbnQgb24gbmV3IGRvbSBlbGVtZW50ICh3aG8gYXBwZWFyZWQgYWZ0ZXIgdGFwKVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX2hhbmRsZXIudGFwRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50LCBmb3IgZXhhbXBsZSwgc2FmYXJpJ3MgZGJsY2xpY2stdG8tem9vbSBvciBmYXN0LWNsaWNrIGFmdGVyIGxvbmctdGFwXG4gICAgICAgIC8vIHdlIGhhbmRsZSBtb3VzZURvdWJsZUNsaWNrRXZlbnQgaGVyZSBvdXJzZWx2ZXNcbiAgICAgICAgaWYgKHRoaXMuX3RhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2hFbmRFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvbmdUYXBBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nVGFwQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBuYXRpdmUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdCh0b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uIChtb3VzZVVwRXZlbnQpIHtcbiAgICAgICAgaWYgKG1vdXNlVXBFdmVudC5idXR0b24gIT09IE1vdXNlRXZlbnRCdXR0b24uTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXRFdmVudCA9IHRoaXMuX21ha2VDb21wYXRFdmVudChtb3VzZVVwRXZlbnQpO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmVTdGFydENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZGKCkpIHtcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3RhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbkZpcmVmb3hPdXRzaWRlTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZpcmVzVG91Y2hFdmVudHMobW91c2VVcEV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci5tb3VzZVVwRXZlbnQpO1xuICAgICAgICArK3RoaXMuX2NsaWNrQ291bnQ7XG4gICAgICAgIGlmICh0aGlzLl9jbGlja1RpbWVvdXRJZCAhPT0gbnVsbCAmJiB0aGlzLl9jbGlja0NvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCBib3RoIGNsaWNrcyBhcmUgbmVhciBlbm91Z2hcbiAgICAgICAgICAgIHZhciBtYW5oYXR0YW5EaXN0YW5jZSA9IHRoaXMuX21vdXNlVG91Y2hNb3ZlV2l0aERvd25JbmZvKHRoaXMuX2dldENvb3JkaW5hdGUobW91c2VVcEV2ZW50KSwgdGhpcy5fY2xpY2tDb29yZGluYXRlKS5tYW5oYXR0YW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGlmIChtYW5oYXR0YW5EaXN0YW5jZSA8IE1hbmhhdHRhbkRpc3RhbmNlLkRvdWJsZUNsaWNrICYmICF0aGlzLl9jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci5tb3VzZURvdWJsZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzZXRDbGlja1RpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoY29tcGF0RXZlbnQsIHRoaXMuX2hhbmRsZXIubW91c2VDbGlja0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9jbGVhckxvbmdUYXBUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbG9uZ1RhcFRpbWVvdXRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9sb25nVGFwVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5fbG9uZ1RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3RvdWNoU3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gKGRvd25FdmVudCkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVG91Y2hJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaCA9IGRvd25FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVG91Y2hJZCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wID0gdGhpcy5fZXZlbnRUaW1lU3RhbXAoZG93bkV2ZW50KTtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB0aGlzLl9jYW5jZWxUYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG91Y2hNb3ZlRXhjZWVkZWRNYW5oYXR0YW5EaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90b3VjaE1vdmVTdGFydENvb3JkaW5hdGUgPSB0aGlzLl9nZXRDb29yZGluYXRlKHRvdWNoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHZhciBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlcl8xID0gdGhpcy5fdG91Y2hNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyIGJvdW5kVG91Y2hFbmRIYW5kbGVyXzEgPSB0aGlzLl90b3VjaEVuZEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgYm91bmRUb3VjaE1vdmVXaXRoRG93bkhhbmRsZXJfMSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGJvdW5kVG91Y2hFbmRIYW5kbGVyXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlcl8xLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgYm91bmRUb3VjaEVuZEhhbmRsZXJfMSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICB0aGlzLl9sb25nVGFwVGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9sb25nVGFwSGFuZGxlci5iaW5kKHRoaXMsIGRvd25FdmVudCksIDUwMCAvKiBEZWxheS5Mb25nVGFwICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCwgdG91Y2gpLCB0aGlzLl9oYW5kbGVyLnRvdWNoU3RhcnRFdmVudCk7XG4gICAgICAgIGlmICh0aGlzLl90YXBUaW1lb3V0SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcENvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICB0aGlzLl90YXBUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0VGFwVGltZW91dC5iaW5kKHRoaXMpLCA1MDAgLyogRGVsYXkuUmVzZXRDbGljayAqLyk7XG4gICAgICAgICAgICB0aGlzLl90YXBDb29yZGluYXRlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZSh0b3VjaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VEb3duSGFuZGxlciA9IGZ1bmN0aW9uIChkb3duRXZlbnQpIHtcbiAgICAgICAgaWYgKGRvd25FdmVudC5idXR0b24gPT09IE1vdXNlRXZlbnRCdXR0b24uUmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KGRvd25FdmVudCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCksIHRoaXMuX2hhbmRsZXIubW91c2VSaWdodENsaWNrRXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb3duRXZlbnQuYnV0dG9uICE9PSBNb3VzZUV2ZW50QnV0dG9uLkxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl90YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChpc0ZGKCkpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbkZpcmVmb3hPdXRzaWRlTW91c2VVcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FuY2VsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW91c2VNb3ZlU3RhcnRDb29yZGluYXRlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZShkb3duRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyIGJvdW5kTW91c2VNb3ZlV2l0aERvd25IYW5kbGVyXzEgPSB0aGlzLl9tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHZhciBib3VuZE1vdXNlVXBIYW5kbGVyXzEgPSB0aGlzLl9tb3VzZVVwSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlcl8xKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZE1vdXNlVXBIYW5kbGVyXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZVdpdGhEb3duSGFuZGxlcl8xKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgYm91bmRNb3VzZVVwSGFuZGxlcl8xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3VzZVByZXNzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fZmlyZXNUb3VjaEV2ZW50cyhkb3duRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChkb3duRXZlbnQpLCB0aGlzLl9oYW5kbGVyLm1vdXNlRG93bkV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrVGltZW91dElkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0NvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICB0aGlzLl9jbGlja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fcmVzZXRDbGlja1RpbWVvdXQuYmluZCh0aGlzKSwgNTAwIC8qIERlbGF5LlJlc2V0Q2xpY2sgKi8pO1xuICAgICAgICAgICAgdGhpcy5fY2xpY2tDb29yZGluYXRlID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZShkb3duRXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fbW91c2VFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIERvIG5vdCBzaG93IGNvbnRleHQgbWVudSB3aGVuIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2NsZWFyTG9uZ1RhcFRpbWVvdXQuYmluZCh0aGlzKSk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkb2NfMSA9IHRoaXMuX3RhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyXzEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2hhbmRsZXIubW91c2VEb3duT3V0c2lkZUV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29tcG9zZWQgJiYgX3RoaXMuX3RhcmdldC5jb250YWlucyhldmVudC5jb21wb3NlZFBhdGgoKVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGV2ZW50LnRhcmdldCAhPT0gbnVsbCkgJiYgX3RoaXMuX3RhcmdldC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZXIubW91c2VEb3duT3V0c2lkZUV2ZW50KHsgeDogMCwgeTogMCwgcGFnZVg6IDAsIHBhZ2VZOiAwIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY18xLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvdXRzaWRlSGFuZGxlcl8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2NfMS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvdXRzaWRlSGFuZGxlcl8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkb2NfMS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvdXRzaWRlSGFuZGxlcl8xKTtcbiAgICAgICAgICAgIGRvY18xLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvdXRzaWRlSGFuZGxlcl8xLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSU9TKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBfdGhpcy5fb25Nb2JpbGVTYWZhcmlEb3VibGVDbGljayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5fb25Nb2JpbGVTYWZhcmlEb3VibGVDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9tb3VzZUxlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlci5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSBNb3VzZUV2ZW50QnV0dG9uLk1pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgaW5jb3JyZWN0IHNjcm9sbGluZyBldmVudFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2luaXRQaW5jaCgpO1xuICAgICAgICAvLyBIZXkgbW9iaWxlIFNhZmFyaSwgd2hhdCdzIHVwP1xuICAgICAgICAvLyBJZiBtb2JpbGUgU2FmYXJpIGRvZXNuJ3QgaGF2ZSBhbnkgdG91Y2htb3ZlIGhhbmRsZXIgd2l0aCBwYXNzaXZlPWZhbHNlXG4gICAgICAgIC8vIGl0IHRyZWF0cyBhIHRvdWNoc3RhcnQgYW5kIHRoZSBmb2xsb3dpbmcgdG91Y2htb3ZlIGV2ZW50cyBhcyBjYW5jZWxhYmxlPWZhbHNlLFxuICAgICAgICAvLyBzbyB3ZSBjYW4ndCBwcmV2ZW50IHRoZW0gKGFzIHNvb24gd2Ugc3Vic2NyaWJlIG9uIHRvdWNobW92ZSBpbnNpZGUgdG91Y2hzdGFydCdzIGhhbmRsZXIpLlxuICAgICAgICAvLyBBbmQgd2UnbGwgZ2V0IHNjcm9sbCBvZiB0aGUgcGFnZSBhbG9uZyB3aXRoIGNoYXJ0J3Mgb25lIGluc3RlYWQgb2Ygb25seSBjaGFydCdzIHNjcm9sbC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKCkgeyB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9pbml0UGluY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNWYWxpZCh0aGlzLl9oYW5kbGVyLnBpbmNoU3RhcnRFdmVudCkgJiZcbiAgICAgICAgICAgICFpc1ZhbGlkKHRoaXMuX2hhbmRsZXIucGluY2hFdmVudCkgJiZcbiAgICAgICAgICAgICFpc1ZhbGlkKHRoaXMuX2hhbmRsZXIucGluY2hFbmRFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpOyB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBfdGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChfdGhpcy5faGFuZGxlci5waW5jaEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBfdGhpcy5fZ2V0VG91Y2hEaXN0YW5jZShldmVudC50b3VjaGVzWzBdLCBldmVudC50b3VjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBjdXJyZW50RGlzdGFuY2UgLyBfdGhpcy5fc3RhcnRQaW5jaERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVyLnBpbmNoRXZlbnQoX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLl9zdGFydFBpbmNoTWlkZGxlQ29vcmRpbmF0ZSksIHsgcGFnZVg6IDAsIHBhZ2VZOiAwIH0pLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fY2hlY2tQaW5jaFN0YXRlKGV2ZW50LnRvdWNoZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fY2hlY2tQaW5jaFN0YXRlID0gZnVuY3Rpb24gKHRvdWNoZXMpIHtcbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5jaFByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9waW5jaFByZXZlbnRlZCB8fCB0aGlzLl9sb25nVGFwQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wUGluY2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGluY2godG91Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fc3RhcnRQaW5jaCA9IGZ1bmN0aW9uICh0b3VjaGVzKSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLl90YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0UGluY2hNaWRkbGVDb29yZGluYXRlID0ge1xuICAgICAgICAgICAgeDogKCh0b3VjaGVzWzBdLmNsaWVudFggLSBib3gubGVmdCkgKyAodG91Y2hlc1sxXS5jbGllbnRYIC0gYm94LmxlZnQpKSAvIDIsXG4gICAgICAgICAgICB5OiAoKHRvdWNoZXNbMF0uY2xpZW50WSAtIGJveC50b3ApICsgKHRvdWNoZXNbMV0uY2xpZW50WSAtIGJveC50b3ApKSAvIDJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3RhcnRQaW5jaERpc3RhbmNlID0gdGhpcy5fZ2V0VG91Y2hEaXN0YW5jZSh0b3VjaGVzWzBdLCB0b3VjaGVzWzFdKTtcbiAgICAgICAgaWYgKGlzVmFsaWQodGhpcy5faGFuZGxlci5waW5jaFN0YXJ0RXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnBpbmNoU3RhcnRFdmVudCh7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3N0b3BQaW5jaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0UGluY2hNaWRkbGVDb29yZGluYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICBpZiAoaXNWYWxpZCh0aGlzLl9oYW5kbGVyLnBpbmNoRW5kRXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnBpbmNoRW5kRXZlbnQoeyB4OiAwLCB5OiAwLCBwYWdlWDogMCwgcGFnZVk6IDAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VMZWF2ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIChfYSA9IHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgKF9iID0gdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzKTtcbiAgICAgICAgKF9jID0gdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9maXJlc1RvdWNoRXZlbnRzKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYWNjZXB0TW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgLy8gbW9iaWxlIFNhZmFyaSBzb21ldGltZXMgZW1pdHMgbW91c2UgbGVhdmUgZXZlbnQgZm9yIG5vIHJlYXNvbiwgdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSBpdCBpbiBvdGhlciB3YXlcbiAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlIHRoaXMgZXZlbnQgaWYgdGhlcmUgd2FzIG5vIG1vdXNlIG1vdmUgb3IgbW91c2UgZW50ZXIgZXZlbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChldmVudCksIHRoaXMuX2hhbmRsZXIubW91c2VMZWF2ZUV2ZW50KTtcbiAgICAgICAgLy8gYWNjZXB0IGFsbCBtb3VzZSBsZWF2ZSBldmVudHMgaWYgaXQncyBub3QgYW4gaU9TIGRldmljZVxuICAgICAgICB0aGlzLl9hY2NlcHRNb3VzZUxlYXZlID0gIWlzSU9TKCk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2xvbmdUYXBIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0b3VjaCA9IHRoaXMuX3RvdWNoV2l0aElkKGV2ZW50LnRvdWNoZXMsIHRoaXMuX2FjdGl2ZVRvdWNoSWQpO1xuICAgICAgICBpZiAodG91Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KGV2ZW50LCB0b3VjaCksIHRoaXMuX2hhbmRsZXIubG9uZ1RhcEV2ZW50KTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGFwID0gdHJ1ZTtcbiAgICAgICAgLy8gbG9uZyB0YXAgaXMgYWN0aXZlIHVudGlsIHRvdWNoZW5kIGV2ZW50IHdpdGggMCB0b3VjaGVzIG9jY3VycmVkXG4gICAgICAgIHRoaXMuX2xvbmdUYXBBY3RpdmUgPSB0cnVlO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9maXJlc1RvdWNoRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICBpZiAoaXNWYWxpZCgoX2EgPSBlLnNvdXJjZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcmVzVG91Y2hFdmVudHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgcmV0dXJuIGUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50VGltZVN0YW1wKGUpIDwgdGhpcy5fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgKyA1MDAgLyogRGVsYXkuUHJldmVudEZpcmVzVG91Y2hFdmVudHMgKi87XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3Byb2Nlc3NFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrLmNhbGwodGhpcy5faGFuZGxlciwgZXZlbnQpO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tYWtlQ29tcGF0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHRvdWNoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRvdWNoRXZlbnQgaGFzIG5vIGNsaWVudFgvWSBjb29yZGluYXRlczpcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB1c2UgdGhlIGxhc3QgVG91Y2ggaW5zdGVhZFxuICAgICAgICB2YXIgZXZlbnRMaWtlID0gdG91Y2ggIT09IG51bGwgJiYgdG91Y2ggIT09IHZvaWQgMCA/IHRvdWNoIDogZXZlbnQ7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLl90YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBldmVudExpa2UuY2xpZW50WCAtIGJveC5sZWZ0LFxuICAgICAgICAgICAgeTogZXZlbnRMaWtlLmNsaWVudFkgLSBib3gudG9wLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50TGlrZS5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudExpa2UucGFnZVksXG4gICAgICAgICAgICBpc1RvdWNoOiAhZXZlbnQudHlwZS5zdGFydHNXaXRoKCdtb3VzZScpICYmIGV2ZW50LnR5cGUgIT09ICdjb250ZXh0bWVudScgJiYgZXZlbnQudHlwZSAhPT0gJ2NsaWNrJyAmJiBldmVudC50eXBlICE9PSAnd2hlZWwnLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvdWNoc3RhcnQgaXMgcGFzc2l2ZSBhbmQgY2Fubm90IGJlIHByZXZlbnRlZFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fZ2V0VG91Y2hEaXN0YW5jZSA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgdmFyIHhEaWZmID0gcDEuY2xpZW50WCAtIHAyLmNsaWVudFg7XG4gICAgICAgIHZhciB5RGlmZiA9IHAxLmNsaWVudFkgLSBwMi5jbGllbnRZO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChldmVudExpa2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGV2ZW50TGlrZS5wYWdlWCxcbiAgICAgICAgICAgIHk6IGV2ZW50TGlrZS5wYWdlWVxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9ldmVudFRpbWVTdGFtcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGUudGltZXN0YW1wIGlzIGFsd2F5cyAwIG9uIGlQYWQgd2l0aCBtYWdpYyBtb3VzZSwgc28gd2UgdXNlIHBlcmZvcm1hbmNlLm5vdygpIGFzIGEgZmFsbGJhY2tcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgcmV0dXJuIChfYSA9IGUudGltZVN0YW1wKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fdG91Y2hXaXRoSWQgPSBmdW5jdGlvbiAodG91Y2hlcywgaWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRvdWNoZXNbaV0uaWRlbnRpZmllciA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTeW50aGV0aWNFdmVudDtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50KGNvbnRhaW5lciwgY2hhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8g5oOv5oCn5rua5Yqo5byA5aeL5pe26Ze0XG4gICAgICAgIHRoaXMuX2ZsaW5nU3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIOaDr+aAp+a7muWKqOWumuaXtuWZqFxuICAgICAgICB0aGlzLl9mbGluZ1Njcm9sbFJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIC8vIOW8gOWni+a7muWKqOaXtuWdkOagh+eCuVxuICAgICAgICB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICAvLyDlvIDlp4vop6bmkbjml7blnZDmoIdcbiAgICAgICAgdGhpcy5fdG91Y2hDb29yZGluYXRlID0gbnVsbDtcbiAgICAgICAgLy8g5piv5ZCm5piv5Y+W5raI5LqG5Y2B5a2X5YWJ5qCHXG4gICAgICAgIHRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyID0gZmFsc2U7XG4gICAgICAgIC8vIOaYr+WQpue8qeaUvui/h1xuICAgICAgICB0aGlzLl90b3VjaFpvb21lZCA9IGZhbHNlO1xuICAgICAgICAvLyDnlKjmnaXorrDlvZXmjY/lkIjnvKnmlL7nmoTlsLrlr7hcbiAgICAgICAgdGhpcy5fcGluY2hTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuX21vdXNlRG93bldpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXZZQXhpc1JhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5feEF4aXNTdGFydFNjYWxlQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5feEF4aXNTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuX3lBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fbW91c2VNb3ZlVHJpZ2dlcldpZGdldEluZm8gPSB7IHBhbmU6IG51bGwsIHdpZGdldDogbnVsbCB9O1xuICAgICAgICB0aGlzLl9ib3VuZEtleUJvYXJkRG93bkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRXF1YWwnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnpvb20oMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ01pbnVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS56b29tKC0wLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gX3RoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnN0YXJ0U2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5zY3JvbGwoLTMgKiBzdG9yZS5nZXRCYXJTcGFjZSgpLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gX3RoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnN0YXJ0U2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5zY3JvbGwoMyAqIHN0b3JlLmdldEJhclNwYWNlKCkuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KGNvbnRhaW5lciwgdGhpcywge1xuICAgICAgICAgICAgdHJlYXRWZXJ0RHJhZ0FzUGFnZVNjcm9sbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICB0cmVhdEhvcnpEcmFnQXNQYWdlU2Nyb2xsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleUJvYXJkRG93bkV2ZW50KTtcbiAgICB9XG4gICAgRXZlbnQucHJvdG90eXBlLnBpbmNoU3RhcnRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdG91Y2hab29tZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9waW5jaFNjYWxlID0gMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUucGluY2hFdmVudCA9IGZ1bmN0aW9uIChlLCBzY2FsZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9hLnBhbmUsIHdpZGdldCA9IF9hLndpZGdldDtcbiAgICAgICAgaWYgKChwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSkgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMgJiYgKHdpZGdldCA9PT0gbnVsbCB8fCB3aWRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpZGdldC5nZXROYW1lKCkpID09PSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU4pIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gKHNjYWxlIC0gdGhpcy5fcGluY2hTY2FsZSkgKiA1O1xuICAgICAgICAgICAgdGhpcy5fcGluY2hTY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnpvb20oem9vbVNjYWxlLCB7IHg6IGV2ZW50XzEueCwgeTogZXZlbnRfMS55IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLm1vdXNlV2hlZWxIb3J0RXZlbnQgPSBmdW5jdGlvbiAoXywgZGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICBzdG9yZS5zdGFydFNjcm9sbCgpO1xuICAgICAgICBzdG9yZS5zY3JvbGwoZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZVdoZWVsVmVydEV2ZW50ID0gZnVuY3Rpb24gKGUsIHNjYWxlKSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKS53aWRnZXQ7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICB2YXIgbmFtZSA9IHdpZGdldCA9PT0gbnVsbCB8fCB3aWRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgIGlmIChuYW1lID09PSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS56b29tKHNjYWxlLCB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VEb3duRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9hLnBhbmUsIHdpZGdldCA9IF9hLndpZGdldDtcbiAgICAgICAgdGhpcy5fbW91c2VEb3duV2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMiA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfMSkge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5TRVBBUkFUT1I6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZURvd25FdmVudCcsIGV2ZW50XzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF5QXhpcy5nZXRBdXRvQ2FsY1RpY2tGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHlBeGlzLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2WUF4aXNSYW5nZSA9IF9fYXNzaWduKHt9LCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRTY3JvbGxDb29yZGluYXRlID0geyB4OiBldmVudF8yLngsIHk6IGV2ZW50XzIueSB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZURvd25FdmVudCcsIGV2ZW50XzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzWEF4aXNTY3JvbGxTdGFydEV2ZW50KHdpZGdldCwgZXZlbnRfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NZQXhpc1NjYWxlU3RhcnRFdmVudCh3aWRnZXQsIGV2ZW50XzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VNb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIF9kID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSksIHBhbmUgPSBfZC5wYW5lLCB3aWRnZXQgPSBfZC53aWRnZXQ7XG4gICAgICAgIHZhciBldmVudCA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX21vdXNlTW92ZVRyaWdnZXJXaWRnZXRJbmZvLnBhbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRJZCgpKSAhPT0gKHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS5nZXRJZCgpKSB8fFxuICAgICAgICAgICAgKChfYiA9IHRoaXMuX21vdXNlTW92ZVRyaWdnZXJXaWRnZXRJbmZvLndpZGdldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5hbWUoKSkgIT09ICh3aWRnZXQgPT09IG51bGwgfHwgd2lkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aWRnZXQuZ2V0TmFtZSgpKSkge1xuICAgICAgICAgICAgd2lkZ2V0ID09PSBudWxsIHx8IHdpZGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRW50ZXJFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgIChfYyA9IHRoaXMuX21vdXNlTW92ZVRyaWdnZXJXaWRnZXRJbmZvLndpZGdldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc3BhdGNoRXZlbnQoJ21vdXNlTGVhdmVFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlTW92ZVRyaWdnZXJXaWRnZXRJbmZvID0geyBwYW5lOiBwYW5lLCB3aWRnZXQ6IHdpZGdldCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VNb3ZlRXZlbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcm9zc2hhaXIgPSB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc2hhaXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS5zZXRDcm9zc2hhaXIoY3Jvc3NoYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuU0VQQVJBVE9SOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VNb3ZlRXZlbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS5zZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUucHJlc3NlZE1vdXNlTW92ZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlRG93bldpZGdldCAhPT0gbnVsbCAmJiB0aGlzLl9tb3VzZURvd25XaWRnZXQuZ2V0TmFtZSgpID09PSBXaWRnZXROYW1lQ29uc3RhbnRzLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vdXNlRG93bldpZGdldC5kaXNwYXRjaEV2ZW50KCdwcmVzc2VkTW91c2VNb3ZlRXZlbnQnLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9jLnBhbmUsIHdpZGdldCA9IF9jLndpZGdldDtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKChfYSA9IHRoaXMuX21vdXNlRG93bldpZGdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhbmUoKS5nZXRJZCgpKSA9PT0gKHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS5nZXRJZCgpKSAmJlxuICAgICAgICAgICAgKChfYiA9IHRoaXMuX21vdXNlRG93bldpZGdldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5hbWUoKSkgPT09IHdpZGdldC5nZXROYW1lKCkpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8zID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8zID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZV8zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU46IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9pbml0LWRlY2xhcmF0aW9ucyAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3NzaGFpciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ3ByZXNzZWRNb3VzZU1vdmVFdmVudCcsIGV2ZW50XzMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc2hhaXIgPSB7IHg6IGV2ZW50XzMueCwgeTogZXZlbnRfMy55LCBwYW5lSWQ6IHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS5nZXRJZCgpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTWFpblNjcm9sbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnNldENyb3NzaGFpcihjcm9zc2hhaXIsIHsgZm9yY2VJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NYQXhpc1Njcm9sbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NZQXhpc1NjYWxpbmdFdmVudCh3aWRnZXQsIGV2ZW50XzMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VVcEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLndpZGdldDtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF80ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgbmFtZV80ID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZV80KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU46XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLlNFUEFSQVRPUjpcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VVcEV2ZW50JywgZXZlbnRfNCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3VzZURvd25XaWRnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmV2WUF4aXNSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZUNvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl94QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX3hBeGlzU2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl95QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSA9IDA7XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSkud2lkZ2V0O1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfNSA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZUNsaWNrRXZlbnQnLCBldmVudF81KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VSaWdodENsaWNrRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSkud2lkZ2V0O1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzYgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciBuYW1lXzUgPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjpcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VSaWdodENsaWNrRXZlbnQnLCBldmVudF82KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZURvdWJsZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9hLnBhbmUsIHdpZGdldCA9IF9hLndpZGdldDtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG5hbWVfNiA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfNikge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudF83ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VEb3VibGVDbGlja0V2ZW50JywgZXZlbnRfNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgheUF4aXMuZ2V0QXV0b0NhbGNUaWNrRmxhZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhpcy5zZXRBdXRvQ2FsY1RpY2tGbGFnKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VMZWF2ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuc2V0Q3Jvc3NoYWlyKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLnRvdWNoU3RhcnRFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSksIHBhbmUgPSBfYi5wYW5lLCB3aWRnZXQgPSBfYi53aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF84ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICAoX2EgPSBldmVudF84LnByZXZlbnREZWZhdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChldmVudF84KTtcbiAgICAgICAgICAgIHZhciBuYW1lXzcgPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZURvd25FdmVudCcsIGV2ZW50XzgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENhbmNlbENyb3NzaGFpciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRDcm9zc2hhaXIodW5kZWZpbmVkLCB7IG5vdEludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbGluZ1N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF5QXhpcy5nZXRBdXRvQ2FsY1RpY2tGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHlBeGlzLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2WUF4aXNSYW5nZSA9IF9fYXNzaWduKHt9LCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRTY3JvbGxDb29yZGluYXRlID0geyB4OiBldmVudF84LngsIHk6IGV2ZW50XzgueSB9O1xuICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnN0YXJ0U2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoWm9vbWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaENvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4RGlmID0gZXZlbnRfOC54IC0gdGhpcy5fdG91Y2hDb29yZGluYXRlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeURpZiA9IGV2ZW50XzgueSAtIHRoaXMuX3RvdWNoQ29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydCh4RGlmICogeERpZiArIHlEaWYgKiB5RGlmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYWRpdXMgPCBUT1VDSF9NSU5fUkFESVVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hDb29yZGluYXRlID0geyB4OiBldmVudF84LngsIHk6IGV2ZW50XzgueSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKHsgeDogZXZlbnRfOC54LCB5OiBldmVudF84LnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnNldENyb3NzaGFpcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzWEF4aXNTY3JvbGxTdGFydEV2ZW50KHdpZGdldCwgZXZlbnRfOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NZQXhpc1NjYWxlU3RhcnRFdmVudCh3aWRnZXQsIGV2ZW50XzgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUudG91Y2hNb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2IucGFuZSwgd2lkZ2V0ID0gX2Iud2lkZ2V0O1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfOSA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgKF9hID0gZXZlbnRfOS5wcmV2ZW50RGVmYXVsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnRfOSk7XG4gICAgICAgICAgICB2YXIgbmFtZV84ID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ3ByZXNzZWRNb3VzZU1vdmVFdmVudCcsIGV2ZW50XzkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnNldENyb3NzaGFpcih1bmRlZmluZWQsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaENvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKHsgeDogZXZlbnRfOS54LCB5OiBldmVudF85LnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTWFpblNjcm9sbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfOSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NYQXhpc1Njcm9sbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfOSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NZQXhpc1NjYWxpbmdFdmVudCh3aWRnZXQsIGV2ZW50XzkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUudG91Y2hFbmRFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKS53aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xMCA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgdmFyIG5hbWVfOSA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfOSkge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZVVwRXZlbnQnLCBldmVudF8xMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9mbGluZ1N0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGV2ZW50XzEwLnggLSB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2XzEgPSBkaXN0YW5jZSAvICh0aW1lID4gMCA/IHRpbWUgOiAxKSAqIDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPCAyMDAgJiYgTWF0aC5hYnModl8xKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVfMSA9IHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxpbmdTY3JvbGxfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlXzEuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlXzEuc2Nyb2xsKHZfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XzEgPSB2XzEgKiAoMSAtIDAuMDI1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2XzEpIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGluZ1Njcm9sbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxpbmdTY3JvbGxfMSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlVXBFdmVudCcsIGV2ZW50XzEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldllBeGlzUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5feEF4aXNTdGFydFNjYWxlQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl94QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl94QXhpc1NjYWxlID0gMTtcbiAgICAgICAgICAgIHRoaXMuX3lBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUudGFwRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9hLnBhbmUsIHdpZGdldCA9IF9hLndpZGdldDtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xMSA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZUNsaWNrRXZlbnQnLCBldmVudF8xMSk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LmdldE5hbWUoKSA9PT0gV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEyID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENhbmNlbENyb3NzaGFpciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKHVuZGVmaW5lZCwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyICYmICF0aGlzLl90b3VjaFpvb21lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hDb29yZGluYXRlID0geyB4OiBldmVudF8xMi54LCB5OiBldmVudF8xMi55IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnNldENyb3NzaGFpcih7IHg6IGV2ZW50XzEyLngsIHk6IGV2ZW50XzEyLnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfSwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN1bWVkIHx8IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3VtZWQ7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUuZG91YmxlVGFwRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvdWJsZUNsaWNrRXZlbnQoZSk7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubG9uZ1RhcEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSksIHBhbmUgPSBfYS5wYW5lLCB3aWRnZXQgPSBfYS53aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwgJiYgd2lkZ2V0LmdldE5hbWUoKSA9PT0gV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMTMgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSA9IHsgeDogZXZlbnRfMTMueCwgeTogZXZlbnRfMTMueSB9O1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnNldENyb3NzaGFpcih7IHg6IGV2ZW50XzEzLngsIHk6IGV2ZW50XzEzLnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUuX3Byb2Nlc3NNYWluU2Nyb2xsaW5nRXZlbnQgPSBmdW5jdGlvbiAod2lkZ2V0LCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhcnRTY3JvbGxDb29yZGluYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2WUF4aXNSYW5nZSAhPT0gbnVsbCAmJiAheUF4aXMuZ2V0QXV0b0NhbGNUaWNrRmxhZygpICYmIHlBeGlzLnNjcm9sbFpvb21FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5fcHJldllBeGlzUmFuZ2UsIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZV8xID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoeUF4aXMucmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV8xID0gdGhpcy5fc3RhcnRTY3JvbGxDb29yZGluYXRlLnkgLSBldmVudC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VfMSA9IGV2ZW50LnkgLSB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZGlzdGFuY2VfMSAvIGJvdW5kaW5nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgZGlmUmFuZ2UgPSByYW5nZSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGcm9tID0gZnJvbSArIGRpZlJhbmdlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdUbyA9IHRvICsgZGlmUmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JlYWxGcm9tID0geUF4aXMudmFsdWVUb1JlYWxWYWx1ZShuZXdGcm9tLCB7IHJhbmdlOiB0aGlzLl9wcmV2WUF4aXNSYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmVhbFRvID0geUF4aXMudmFsdWVUb1JlYWxWYWx1ZShuZXdUbywgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Rpc3BsYXlGcm9tID0geUF4aXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUobmV3UmVhbEZyb20sIHsgcmFuZ2U6IHRoaXMuX3ByZXZZQXhpc1JhbmdlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdEaXNwbGF5VG8gPSB5QXhpcy5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZShuZXdSZWFsVG8sIHsgcmFuZ2U6IHRoaXMuX3ByZXZZQXhpc1JhbmdlIH0pO1xuICAgICAgICAgICAgICAgIHlBeGlzLnNldFJhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogbmV3RnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ld1RvLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogbmV3VG8gLSBuZXdGcm9tLFxuICAgICAgICAgICAgICAgICAgICByZWFsRnJvbTogbmV3UmVhbEZyb20sXG4gICAgICAgICAgICAgICAgICAgIHJlYWxUbzogbmV3UmVhbFRvLFxuICAgICAgICAgICAgICAgICAgICByZWFsUmFuZ2U6IG5ld1JlYWxUbyAtIG5ld1JlYWxGcm9tLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RnJvbTogbmV3RGlzcGxheUZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUbzogbmV3RGlzcGxheVRvLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5UmFuZ2U6IG5ld0Rpc3BsYXlUbyAtIG5ld0Rpc3BsYXlGcm9tXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBldmVudC54IC0gdGhpcy5fc3RhcnRTY3JvbGxDb29yZGluYXRlLng7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuc2Nyb2xsKGRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9wcm9jZXNzWEF4aXNTY3JvbGxTdGFydEV2ZW50ID0gZnVuY3Rpb24gKHdpZGdldCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRG93bkV2ZW50JywgZXZlbnQpO1xuICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94QXhpc1N0YXJ0U2NhbGVDb29yZGluYXRlID0geyB4OiBldmVudC54LCB5OiBldmVudC55IH07XG4gICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gZXZlbnQucGFnZVg7XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5fcHJvY2Vzc1hBeGlzU2Nyb2xsaW5nRXZlbnQgPSBmdW5jdGlvbiAod2lkZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjb25zdW1lZCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdwcmVzc2VkTW91c2VNb3ZlRXZlbnQnLCBldmVudCk7XG4gICAgICAgIGlmICghY29uc3VtZWQpIHtcbiAgICAgICAgICAgIHZhciB4QXhpcyA9IHdpZGdldC5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgaWYgKHhBeGlzLnNjcm9sbFpvb21FbmFibGVkICYmIHRoaXMuX3hBeGlzU3RhcnRTY2FsZURpc3RhbmNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5feEF4aXNTdGFydFNjYWxlRGlzdGFuY2UgLyBldmVudC5wYWdlWDtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gKHNjYWxlIC0gdGhpcy5feEF4aXNTY2FsZSkgKiAxMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feEF4aXNTY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuem9vbSh6b29tU2NhbGUsIChfYSA9IHRoaXMuX3hBeGlzU3RhcnRTY2FsZUNvb3JkaW5hdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5fcHJvY2Vzc1lBeGlzU2NhbGVTdGFydEV2ZW50ID0gZnVuY3Rpb24gKHdpZGdldCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRG93bkV2ZW50JywgZXZlbnQpO1xuICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKS5nZXRSYW5nZSgpO1xuICAgICAgICB0aGlzLl9wcmV2WUF4aXNSYW5nZSA9IF9fYXNzaWduKHt9LCByYW5nZSk7XG4gICAgICAgIHRoaXMuX3lBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gZXZlbnQucGFnZVk7XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5fcHJvY2Vzc1lBeGlzU2NhbGluZ0V2ZW50ID0gZnVuY3Rpb24gKHdpZGdldCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ3ByZXNzZWRNb3VzZU1vdmVFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFjb25zdW1lZCkge1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gd2lkZ2V0LmdldFBhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJldllBeGlzUmFuZ2UgIT09IG51bGwgJiYgeUF4aXMuc2Nyb2xsWm9vbUVuYWJsZWQgJiYgdGhpcy5feUF4aXNTdGFydFNjYWxlRGlzdGFuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9wcmV2WUF4aXNSYW5nZSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZXZlbnQucGFnZVkgLyB0aGlzLl95QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSByYW5nZSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciBkaWZSYW5nZSA9IChuZXdSYW5nZSAtIHJhbmdlKSAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Zyb20gPSBmcm9tIC0gZGlmUmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RvID0gdG8gKyBkaWZSYW5nZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmVhbEZyb20gPSB5QXhpcy52YWx1ZVRvUmVhbFZhbHVlKG5ld0Zyb20sIHsgcmFuZ2U6IHRoaXMuX3ByZXZZQXhpc1JhbmdlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSZWFsVG8gPSB5QXhpcy52YWx1ZVRvUmVhbFZhbHVlKG5ld1RvLCB7IHJhbmdlOiB0aGlzLl9wcmV2WUF4aXNSYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlzcGxheUZyb20gPSB5QXhpcy5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZShuZXdSZWFsRnJvbSwgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Rpc3BsYXlUbyA9IHlBeGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKG5ld1JlYWxUbywgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgeUF4aXMuc2V0UmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBuZXdGcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3VG8sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBuZXdSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhbEZyb206IG5ld1JlYWxGcm9tLFxuICAgICAgICAgICAgICAgICAgICByZWFsVG86IG5ld1JlYWxUbyxcbiAgICAgICAgICAgICAgICAgICAgcmVhbFJhbmdlOiBuZXdSZWFsVG8gLSBuZXdSZWFsRnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZyb206IG5ld0Rpc3BsYXlGcm9tLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VG86IG5ld0Rpc3BsYXlUbyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVJhbmdlOiBuZXdEaXNwbGF5VG8gLSBuZXdEaXNwbGF5RnJvbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5fZmluZFdpZGdldEJ5RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIHZhciB4ID0gZXZlbnQueCwgeSA9IGV2ZW50Lnk7XG4gICAgICAgIHZhciBzZXBhcmF0b3JQYW5lcyA9IHRoaXMuX2NoYXJ0LmdldFNlcGFyYXRvclBhbmVzKCk7XG4gICAgICAgIHZhciBzZXBhcmF0b3JTaXplID0gdGhpcy5fY2hhcnQuZ2V0U3R5bGVzKCkuc2VwYXJhdG9yLnNpemU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzZXBhcmF0b3JQYW5lc18xID0gX192YWx1ZXMoc2VwYXJhdG9yUGFuZXMpLCBzZXBhcmF0b3JQYW5lc18xXzEgPSBzZXBhcmF0b3JQYW5lc18xLm5leHQoKTsgIXNlcGFyYXRvclBhbmVzXzFfMS5kb25lOyBzZXBhcmF0b3JQYW5lc18xXzEgPSBzZXBhcmF0b3JQYW5lc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChzZXBhcmF0b3JQYW5lc18xXzEudmFsdWUsIDIpLCBwYW5lXzEgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmcgPSBwYW5lXzEuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBib3VuZGluZy50b3AgLSBNYXRoLnJvdW5kKChSRUFMX1NFUEFSQVRPUl9IRUlHSFQgLSBzZXBhcmF0b3JTaXplKSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmICh4ID49IGJvdW5kaW5nLmxlZnQgJiYgeCA8PSBib3VuZGluZy5sZWZ0ICsgYm91bmRpbmcud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgeSA+PSB0b3BfMSAmJiB5IDw9IHRvcF8xICsgUkVBTF9TRVBBUkFUT1JfSEVJR0hUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhbmU6IHBhbmVfMSwgd2lkZ2V0OiBwYW5lXzEuZ2V0V2lkZ2V0KCkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3JQYW5lc18xXzEgJiYgIXNlcGFyYXRvclBhbmVzXzFfMS5kb25lICYmIChfYSA9IHNlcGFyYXRvclBhbmVzXzEucmV0dXJuKSkgX2EuY2FsbChzZXBhcmF0b3JQYW5lc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhd1BhbmVzID0gdGhpcy5fY2hhcnQuZ2V0RHJhd1BhbmVzKCk7XG4gICAgICAgIHZhciBwYW5lID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGRyYXdQYW5lc18xID0gX192YWx1ZXMoZHJhd1BhbmVzKSwgZHJhd1BhbmVzXzFfMSA9IGRyYXdQYW5lc18xLm5leHQoKTsgIWRyYXdQYW5lc18xXzEuZG9uZTsgZHJhd1BhbmVzXzFfMSA9IGRyYXdQYW5lc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gZHJhd1BhbmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmcgPSBwLmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gYm91bmRpbmcubGVmdCAmJiB4IDw9IGJvdW5kaW5nLmxlZnQgKyBib3VuZGluZy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICB5ID49IGJvdW5kaW5nLnRvcCAmJiB5IDw9IGJvdW5kaW5nLnRvcCArIGJvdW5kaW5nLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lID0gcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhd1BhbmVzXzFfMSAmJiAhZHJhd1BhbmVzXzFfMS5kb25lICYmIChfYiA9IGRyYXdQYW5lc18xLnJldHVybikpIF9iLmNhbGwoZHJhd1BhbmVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB3aWRnZXQgPSBudWxsO1xuICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHdpZGdldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFpbldpZGdldCA9IHBhbmUuZ2V0TWFpbldpZGdldCgpO1xuICAgICAgICAgICAgICAgIHZhciBtYWluQm91bmRpbmcgPSBtYWluV2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gbWFpbkJvdW5kaW5nLmxlZnQgJiYgeCA8PSBtYWluQm91bmRpbmcubGVmdCArIG1haW5Cb3VuZGluZy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICB5ID49IG1haW5Cb3VuZGluZy50b3AgJiYgeSA8PSBtYWluQm91bmRpbmcudG9wICsgbWFpbkJvdW5kaW5nLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBtYWluV2lkZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh3aWRnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzV2lkZ2V0ID0gcGFuZS5nZXRZQXhpc1dpZGdldCgpO1xuICAgICAgICAgICAgICAgIGlmICh5QXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXNCb3VuZGluZyA9IHlBeGlzV2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID49IHlBeGlzQm91bmRpbmcubGVmdCAmJiB4IDw9IHlBeGlzQm91bmRpbmcubGVmdCArIHlBeGlzQm91bmRpbmcud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPj0geUF4aXNCb3VuZGluZy50b3AgJiYgeSA8PSB5QXhpc0JvdW5kaW5nLnRvcCArIHlBeGlzQm91bmRpbmcuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSB5QXhpc1dpZGdldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYW5lOiBwYW5lLCB3aWRnZXQ6IHdpZGdldCB9O1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9tYWtlV2lkZ2V0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHdpZGdldCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gKF9hID0gd2lkZ2V0ID09PSBudWxsIHx8IHdpZGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2lkZ2V0LmdldEJvdW5kaW5nKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnQpLCB7IHg6IGV2ZW50LnggLSAoKF9iID0gYm91bmRpbmcgPT09IG51bGwgfHwgYm91bmRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kaW5nLmxlZnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApLCB5OiBldmVudC55IC0gKChfYyA9IGJvdW5kaW5nID09PSBudWxsIHx8IGJvdW5kaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib3VuZGluZy50b3ApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApIH0pO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlCb2FyZERvd25FdmVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50LmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudDtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERvbVBvc2l0aW9uO1xuKGZ1bmN0aW9uIChEb21Qb3NpdGlvbikge1xuICAgIERvbVBvc2l0aW9uW1wiUm9vdFwiXSA9IFwicm9vdFwiO1xuICAgIERvbVBvc2l0aW9uW1wiTWFpblwiXSA9IFwibWFpblwiO1xuICAgIERvbVBvc2l0aW9uW1wiWUF4aXNcIl0gPSBcInlBeGlzXCI7XG59KShEb21Qb3NpdGlvbiB8fCAoRG9tUG9zaXRpb24gPSB7fSkpO1xudmFyIENoYXJ0SW1wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJ0SW1wKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jaGFydEJvdW5kaW5nID0gY3JlYXRlRGVmYXVsdEJvdW5kaW5nKCk7XG4gICAgICAgIHRoaXMuX2RyYXdQYW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9zZXBhcmF0b3JQYW5lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNvcnQ6IHRydWUsXG4gICAgICAgICAgICBtZWFzdXJlSGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VCdWlsZFlBeGlzVGljazogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGF5b3V0UGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NoYXJ0RXZlbnQgPSBuZXcgRXZlbnQodGhpcy5fY2hhcnRDb250YWluZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlID0gbmV3IFN0b3JlSW1wKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0UGFuZXMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2xheW91dCgpO1xuICAgIH1cbiAgICBDaGFydEltcC5wcm90b3R5cGUuX2luaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fY2hhcnRDb250YWluZXIgPSBjcmVhdGVEb20oJ2RpdicsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgICAgICAgYm9yZGVyU3R5bGU6ICdub25lJyxcbiAgICAgICAgICAgIGN1cnNvcjogJ2Nyb3NzaGFpcicsXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIHdlYmtpdFVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBtc1VzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIE1velVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIHdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jaGFydENvbnRhaW5lci50YWJJbmRleCA9IDE7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jaGFydENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NhY2hlQ2hhcnRCb3VuZGluZygpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLl9jYWNoZUNoYXJ0Qm91bmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0Qm91bmRpbmcud2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX2NoYXJ0Q29udGFpbmVyLmNsaWVudFdpZHRoKTtcbiAgICAgICAgdGhpcy5fY2hhcnRCb3VuZGluZy5oZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuX2NoYXJ0Q29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX2luaXRQYW5lcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGxheW91dCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sYXlvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFt7IHR5cGU6IFwiY2FuZGxlXCIgLyogTGF5b3V0Q2hpbGRUeXBlLkNhbmRsZSAqLyB9XTtcbiAgICAgICAgdmFyIGNyZWF0ZUNhbmRsZVBhbmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoX3RoaXMuX2NhbmRsZVBhbmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVPcHRpb25zXzEgPSAoX2EgPSBjaGlsZC5vcHRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgICAgICBtZXJnZShwYW5lT3B0aW9uc18xLCB7IGlkOiBQYW5lSWRDb25zdGFudHMuQ0FORExFIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jYW5kbGVQYW5lID0gX3RoaXMuX2NyZWF0ZVBhbmUoQ2FuZGxlUGFuZSwgUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSwgcGFuZU9wdGlvbnNfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAoX2IgPSBjaGlsZC5jb250ZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgICAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlSW5kaWNhdG9yKHYsIHRydWUsIHBhbmVPcHRpb25zXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3JlYXRlWEF4aXNQYW5lID0gZnVuY3Rpb24gKG9wcykge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKF90aGlzLl94QXhpc1BhbmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5fY3JlYXRlUGFuZShYQXhpc1BhbmUsIFBhbmVJZENvbnN0YW50cy5YX0FYSVMsIG9wcyAhPT0gbnVsbCAmJiBvcHMgIT09IHZvaWQgMCA/IG9wcyA6IHt9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5feEF4aXNQYW5lID0gcGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGF5b3V0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjYW5kbGVcIiAvKiBMYXlvdXRDaGlsZFR5cGUuQ2FuZGxlICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNhbmRsZVBhbmUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImluZGljYXRvclwiIC8qIExheW91dENoaWxkVHlwZS5JbmRpY2F0b3IgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAoX2EgPSBjaGlsZC5jb250ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVJZCA9IChfYyA9IChfYiA9IGNoaWxkLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lSWQgPSBjcmVhdGVJZChQYW5lSWRDb25zdGFudHMuSU5ESUNBVE9SKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lT3B0aW9uc18yID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNoaWxkLm9wdGlvbnMpLCB7IGlkOiBwYW5lSWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVJbmRpY2F0b3IodiwgdHJ1ZSwgcGFuZU9wdGlvbnNfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInhBeGlzXCIgLyogTGF5b3V0Q2hpbGRUeXBlLlhBeGlzICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVhBeGlzUGFuZShjaGlsZC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3JlYXRlQ2FuZGxlUGFuZSh7IH0pO1xuICAgICAgICBjcmVhdGVYQXhpc1BhbmUoeyBvcmRlcjogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX2NyZWF0ZVBhbmUgPSBmdW5jdGlvbiAoRHJhd1BhbmVDbGFzcywgaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhbmUgPSBuZXcgRHJhd1BhbmVDbGFzcyh0aGlzLCBpZCwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xuICAgICAgICB0aGlzLl9kcmF3UGFuZXMucHVzaChwYW5lKTtcbiAgICAgICAgcmV0dXJuIHBhbmU7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX3JlY2FsY3VsYXRlUGFuZUhlaWdodCA9IGZ1bmN0aW9uIChjdXJyZW50UGFuZSwgY3VycmVudEhlaWdodCwgY2hhbmdlSGVpZ2h0KSB7XG4gICAgICAgIGlmIChjaGFuZ2VIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsU3RhdGVQYW5lcyA9IHRoaXMuX2RyYXdQYW5lcy5maWx0ZXIoZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgIHZhciBwYW5lSWQgPSBwYW5lLmdldElkKCk7XG4gICAgICAgICAgICByZXR1cm4gKHBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlID09PSBcIm5vcm1hbFwiIC8qIFBhbmVTdGF0ZS5Ob3JtYWwgKi8gJiZcbiAgICAgICAgICAgICAgICBwYW5lSWQgIT09IGN1cnJlbnRQYW5lLmdldElkKCkgJiZcbiAgICAgICAgICAgICAgICBwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvdW50ID0gbm9ybWFsU3RhdGVQYW5lcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UGFuZS5nZXRJZCgpICE9PSBQYW5lSWRDb25zdGFudHMuQ0FORExFICYmXG4gICAgICAgICAgICBpc1ZhbGlkKHRoaXMuX2NhbmRsZVBhbmUpICYmXG4gICAgICAgICAgICB0aGlzLl9jYW5kbGVQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSA9PT0gXCJub3JtYWxcIiAvKiBQYW5lU3RhdGUuTm9ybWFsICovKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fY2FuZGxlUGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkhlaWdodCA9IHRoaXMuX2NhbmRsZVBhbmUuZ2V0T3B0aW9ucygpLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gaGVpZ2h0ICsgY2hhbmdlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPCBtaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gbWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0IC09IChoZWlnaHQgKyBjaGFuZ2VIZWlnaHQgLSBuZXdIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5kbGVQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nSGVpZ2h0XzEgPSBjaGFuZ2VIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbm9ybWFsU3RhdGVQYW5lQ2hhbmdlSGVpZ2h0XzEgPSBNYXRoLmZsb29yKGNoYW5nZUhlaWdodCAvIGNvdW50KTtcbiAgICAgICAgICAgIG5vcm1hbFN0YXRlUGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGNvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBoZWlnaHQgKyByZW1haW5pbmdIZWlnaHRfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGhlaWdodCArIG5vcm1hbFN0YXRlUGFuZUNoYW5nZUhlaWdodF8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3SGVpZ2h0IDwgcGFuZS5nZXRPcHRpb25zKCkubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHBhbmUuZ2V0T3B0aW9ucygpLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogbmV3SGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0hlaWdodF8xIC09IChuZXdIZWlnaHQgLSBoZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocmVtYWluaW5nSGVpZ2h0XzEpID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgLT0gcmVtYWluaW5nSGVpZ2h0XzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IGN1cnJlbnRIZWlnaHQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldERyYXdQYW5lQnlJZCA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgaWYgKHBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmRsZVBhbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3hBeGlzUGFuZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuX2RyYXdQYW5lcy5maW5kKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmdldElkKCkgPT09IHBhbmVJZDsgfSk7XG4gICAgICAgIHJldHVybiBwYW5lICE9PSBudWxsICYmIHBhbmUgIT09IHZvaWQgMCA/IHBhbmUgOiBudWxsO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0Q2hhcnRTdG9yZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmU7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFhBeGlzUGFuZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3hBeGlzUGFuZTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0RHJhd1BhbmVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHJhd1BhbmVzOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRTZXBhcmF0b3JQYW5lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlcGFyYXRvclBhbmVzOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuc29ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuc29ydCA9IG9wdGlvbnMuc29ydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gb3B0aW9ucy5tZWFzdXJlSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5tZWFzdXJlSGVpZ2h0ID0gb3B0aW9ucy5tZWFzdXJlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2MgPSBvcHRpb25zLm1lYXN1cmVXaWR0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMubWVhc3VyZVdpZHRoID0gb3B0aW9ucy5tZWFzdXJlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IG9wdGlvbnMudXBkYXRlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy51cGRhdGUgPSBvcHRpb25zLnVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9lID0gb3B0aW9ucy5idWlsZFlBeGlzVGljaykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMuYnVpbGRZQXhpc1RpY2sgPSBvcHRpb25zLmJ1aWxkWUF4aXNUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2YgPSBvcHRpb25zLmJ1aWxkWUF4aXNUaWNrKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5mb3JjZUJ1aWxkWUF4aXNUaWNrID0gb3B0aW9ucy5mb3JjZUJ1aWxkWUF4aXNUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0UGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0UGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xheW91dCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9sYXlvdXRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIC8vIHRvZG9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX2xheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fbGF5b3V0T3B0aW9ucywgc29ydCA9IF9hLnNvcnQsIG1lYXN1cmVIZWlnaHQgPSBfYS5tZWFzdXJlSGVpZ2h0LCBtZWFzdXJlV2lkdGggPSBfYS5tZWFzdXJlV2lkdGgsIHVwZGF0ZSA9IF9hLnVwZGF0ZSwgYnVpbGRZQXhpc1RpY2sgPSBfYS5idWlsZFlBeGlzVGljaywgZm9yY2VCdWlsZFlBeGlzVGljayA9IF9hLmZvcmNlQnVpbGRZQXhpc1RpY2s7XG4gICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICB3aGlsZSAoaXNWYWxpZCh0aGlzLl9jaGFydENvbnRhaW5lci5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2NoYXJ0Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VwYXJhdG9yUGFuZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldE9wdGlvbnMoKS5vcmRlciAtIGIuZ2V0T3B0aW9ucygpLm9yZGVyOyB9KTtcbiAgICAgICAgICAgIHZhciBwcmV2UGFuZV8xID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUuZ2V0SWQoKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChwcmV2UGFuZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvclBhbmUgPSBuZXcgU2VwYXJhdG9yUGFuZShfdGhpcywgJycsIHByZXZQYW5lXzEsIHBhbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvclBhbmUuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlcGFyYXRvclBhbmVzLnNldChwYW5lLCBzZXBhcmF0b3JQYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2UGFuZV8xID0gcGFuZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0Q29udGFpbmVyLmFwcGVuZENoaWxkKHBhbmUuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYXN1cmVIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbEhlaWdodCA9IHRoaXMuX2NoYXJ0Qm91bmRpbmcuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvclNpemVfMSA9IHRoaXMuZ2V0U3R5bGVzKCkuc2VwYXJhdG9yLnNpemU7XG4gICAgICAgICAgICB2YXIgeEF4aXNIZWlnaHQgPSB0aGlzLl94QXhpc1BhbmUuZ2V0QXhpc0NvbXBvbmVudCgpLmdldEF1dG9TaXplKCk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nSGVpZ2h0XzIgPSB0b3RhbEhlaWdodCAtIHhBeGlzSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0hlaWdodF8yIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0hlaWdodF8yID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdIZWlnaHRfMiAtPSBzZXBhcmF0b3JTaXplXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMgJiYgcGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuQ0FORExFICYmIHBhbmUuZ2V0VmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lSGVpZ2h0ID0gcGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVIZWlnaHQgPiByZW1haW5pbmdIZWlnaHRfMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZUhlaWdodCA9IHJlbWFpbmluZ0hlaWdodF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSGVpZ2h0XzIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nSGVpZ2h0XzIgLT0gcGFuZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBwYW5lSGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2FuZGxlUGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogTWF0aC5tYXgocmVtYWluaW5nSGVpZ2h0XzIsIDApIH0pO1xuICAgICAgICAgICAgdGhpcy5feEF4aXNQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiB4QXhpc0hlaWdodCB9KTtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JQYW5lID0gX3RoaXMuX3NlcGFyYXRvclBhbmVzLmdldChwYW5lKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChzZXBhcmF0b3JQYW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBzZXBhcmF0b3JTaXplXzEsIHRvcDogdG9wXzEgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcF8xICs9IHNlcGFyYXRvclNpemVfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRCb3VuZGluZyh7IHRvcDogdG9wXzEgfSk7XG4gICAgICAgICAgICAgICAgdG9wXzEgKz0gcGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JjZU1lYXN1cmVXaWR0aCA9IG1lYXN1cmVXaWR0aDtcbiAgICAgICAgaWYgKGJ1aWxkWUF4aXNUaWNrIHx8IGZvcmNlQnVpbGRZQXhpc1RpY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKS5idWlsZFRpY2tzKGZvcmNlQnVpbGRZQXhpc1RpY2spO1xuICAgICAgICAgICAgICAgIGZvcmNlTWVhc3VyZVdpZHRoIHx8IChmb3JjZU1lYXN1cmVXaWR0aCA9IHN1Y2Nlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmNlTWVhc3VyZVdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxXaWR0aCA9IHRoaXMuX2NoYXJ0Qm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRTdHlsZXMoKTtcbiAgICAgICAgICAgIHZhciBsZWZ0WUF4aXNXaWR0aF8xID0gMDtcbiAgICAgICAgICAgIHZhciBsZWZ0WUF4aXNPdXRzaWRlXzEgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WUF4aXNXaWR0aF8xID0gMDtcbiAgICAgICAgICAgIHZhciByaWdodFlBeGlzT3V0c2lkZV8xID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmUuZ2V0SWQoKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2lkZSA9IHlBeGlzLmluc2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlBeGlzV2lkdGggPSB5QXhpcy5nZXRBdXRvU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeUF4aXMucG9zaXRpb24gPT09IEF4aXNQb3NpdGlvbi5MZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0WUF4aXNXaWR0aF8xID0gTWF0aC5tYXgobGVmdFlBeGlzV2lkdGhfMSwgeUF4aXNXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFlBeGlzT3V0c2lkZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodFlBeGlzV2lkdGhfMSA9IE1hdGgubWF4KHJpZ2h0WUF4aXNXaWR0aF8xLCB5QXhpc1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFlBeGlzT3V0c2lkZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtYWluV2lkdGggPSB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgdmFyIG1haW5MZWZ0ID0gMDtcbiAgICAgICAgICAgIHZhciBtYWluUmlnaHQgPSAwO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgICAgICAgICBpZiAobGVmdFlBeGlzT3V0c2lkZV8xKSB7XG4gICAgICAgICAgICAgICAgbWFpbldpZHRoIC09IGxlZnRZQXhpc1dpZHRoXzE7XG4gICAgICAgICAgICAgICAgbWFpbkxlZnQgPSBsZWZ0WUF4aXNXaWR0aF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgICAgICAgICBpZiAocmlnaHRZQXhpc091dHNpZGVfMSkge1xuICAgICAgICAgICAgICAgIG1haW5XaWR0aCAtPSByaWdodFlBeGlzV2lkdGhfMTtcbiAgICAgICAgICAgICAgICBtYWluUmlnaHQgPSByaWdodFlBeGlzV2lkdGhfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0VG90YWxCYXJTcGFjZShtYWluV2lkdGgpO1xuICAgICAgICAgICAgdmFyIHBhbmVCb3VuZGluZ18xID0geyB3aWR0aDogdG90YWxXaWR0aCB9O1xuICAgICAgICAgICAgdmFyIG1haW5Cb3VuZGluZ18xID0geyB3aWR0aDogbWFpbldpZHRoLCBsZWZ0OiBtYWluTGVmdCwgcmlnaHQ6IG1haW5SaWdodCB9O1xuICAgICAgICAgICAgdmFyIGxlZnRZQXhpc0JvdW5kaW5nXzEgPSB7IHdpZHRoOiBsZWZ0WUF4aXNXaWR0aF8xIH07XG4gICAgICAgICAgICB2YXIgcmlnaHRZQXhpc0JvdW5kaW5nXzEgPSB7IHdpZHRoOiByaWdodFlBeGlzV2lkdGhfMSB9O1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckZpbGwgPSBzdHlsZXMuc2VwYXJhdG9yLmZpbGw7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQm91bmRpbmdfMSA9IHt9O1xuICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3JGaWxsKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yQm91bmRpbmdfMSA9IG1haW5Cb3VuZGluZ18xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yQm91bmRpbmdfMSA9IHBhbmVCb3VuZGluZ18xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuX3NlcGFyYXRvclBhbmVzLmdldChwYW5lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEJvdW5kaW5nKHNlcGFyYXRvckJvdW5kaW5nXzEpO1xuICAgICAgICAgICAgICAgIHBhbmUuc2V0Qm91bmRpbmcocGFuZUJvdW5kaW5nXzEsIG1haW5Cb3VuZGluZ18xLCBsZWZ0WUF4aXNCb3VuZGluZ18xLCByaWdodFlBeGlzQm91bmRpbmdfMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl94QXhpc1BhbmUuZ2V0QXhpc0NvbXBvbmVudCgpLmJ1aWxkVGlja3ModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhbmUoNCAvKiBVcGRhdGVMZXZlbC5BbGwgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzb3J0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lYXN1cmVIZWlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiBmYWxzZSxcbiAgICAgICAgICAgIHVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBidWlsZFlBeGlzVGljazogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnVwZGF0ZVBhbmUgPSBmdW5jdGlvbiAobGV2ZWwsIHBhbmVJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNWYWxpZChwYW5lSWQpKSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVJZCk7XG4gICAgICAgICAgICBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUudXBkYXRlKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHBhbmUudXBkYXRlKGxldmVsKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlKGxldmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuY3Jvc3NoYWlyQ2hhbmdlID0gZnVuY3Rpb24gKGNyb3NzaGFpcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fY2hhcnRTdG9yZS5oYXNBY3Rpb24oQWN0aW9uVHlwZS5PbkNyb3NzaGFpckNoYW5nZSkpIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JEYXRhXzEgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYW5lSW5kaWNhdG9yRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gX3RoaXMuX2NoYXJ0U3RvcmUuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRpY2F0b3IucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBwYW5lSW5kaWNhdG9yRGF0YVtpbmRpY2F0b3IubmFtZV0gPSByZXN1bHRbKF9hID0gY3Jvc3NoYWlyLmRhdGFJbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluZGljYXRvckRhdGFfMVtpZF0gPSBwYW5lSW5kaWNhdG9yRGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNyb3NzaGFpci5wYW5lSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25Dcm9zc2hhaXJDaGFuZ2UsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjcm9zc2hhaXIpLCB7IGluZGljYXRvckRhdGE6IGluZGljYXRvckRhdGFfMSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXREb20gPSBmdW5jdGlvbiAocGFuZUlkLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoaXNWYWxpZChwYW5lSWQpKSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVJZCk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChwYW5lKSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiBEb21Qb3NpdGlvbi5Sb290O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRG9tUG9zaXRpb24uUm9vdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhbmUuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEb21Qb3NpdGlvbi5NYWluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFuZS5nZXRNYWluV2lkZ2V0KCkuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEb21Qb3NpdGlvbi5ZQXhpczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHBhbmUuZ2V0WUF4aXNXaWRnZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbnRhaW5lcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAocGFuZUlkLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoaXNWYWxpZChwYW5lSWQpKSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVJZCk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChwYW5lKSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiBEb21Qb3NpdGlvbi5Sb290O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRG9tUG9zaXRpb24uUm9vdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhbmUuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIERvbVBvc2l0aW9uLk1haW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYW5lLmdldE1haW5XaWRnZXQoKS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRG9tUG9zaXRpb24uWUF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBwYW5lLmdldFlBeGlzV2lkZ2V0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0Qm91bmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldFByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0UHJlY2lzaW9uKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0U3R5bGVzKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRTdHlsZXMoKTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0Q3VzdG9tQXBpID0gZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jaGFydFN0b3JlLnNldEN1c3RvbUFwaShhcGkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRDdXN0b21BcGkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRMb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldExvY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0TG9jYWxlKCk7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldFRpbWV6b25lID0gZnVuY3Rpb24gKHRpbWV6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0VGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRUaW1lem9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0VGltZXpvbmUoKTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gKHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jaGFydFN0b3JlLnNldFRob3VzYW5kc1NlcGFyYXRvcih0aG91c2FuZHNTZXBhcmF0b3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRUaG91c2FuZHNTZXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXREZWNpbWFsRm9sZCA9IGZ1bmN0aW9uIChkZWNpbWFsRm9sZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jaGFydFN0b3JlLnNldERlY2ltYWxGb2xkKGRlY2ltYWxGb2xkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0RGVjaW1hbEZvbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLl9zZXRPcHRpb25zID0gZnVuY3Rpb24gKGZ1Yykge1xuICAgICAgICBmdWMoKTtcbiAgICAgICAgdGhpcy5sYXlvdXQoe1xuICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlLFxuICAgICAgICAgICAgZm9yY2VCdWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0T2Zmc2V0UmlnaHREaXN0YW5jZShkaXN0YW5jZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0T2Zmc2V0UmlnaHREaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0T2Zmc2V0UmlnaHREaXN0YW5jZSgpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldE1heE9mZnNldExlZnREaXN0YW5jZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICBsb2dXYXJuKCdzZXRNYXhPZmZzZXRMZWZ0RGlzdGFuY2UnLCAnZGlzdGFuY2UnLCAnZGlzdGFuY2UgbXVzdCBncmVhdGVyIHRoYW4gemVybyEhIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0TWF4T2Zmc2V0TGVmdERpc3RhbmNlKGRpc3RhbmNlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRNYXhPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgIGxvZ1dhcm4oJ3NldE1heE9mZnNldFJpZ2h0RGlzdGFuY2UnLCAnZGlzdGFuY2UnLCAnZGlzdGFuY2UgbXVzdCBncmVhdGVyIHRoYW4gemVybyEhIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0TWF4T2Zmc2V0UmlnaHREaXN0YW5jZShkaXN0YW5jZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0TGVmdE1pblZpc2libGVCYXJDb3VudCA9IGZ1bmN0aW9uIChiYXJDb3VudCkge1xuICAgICAgICBpZiAoYmFyQ291bnQgPCAwKSB7XG4gICAgICAgICAgICBsb2dXYXJuKCdzZXRMZWZ0TWluVmlzaWJsZUJhckNvdW50JywgJ2JhckNvdW50JywgJ2JhckNvdW50IG11c3QgZ3JlYXRlciB0aGFuIHplcm8hISEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldExlZnRNaW5WaXNpYmxlQmFyQ291bnQoTWF0aC5jZWlsKGJhckNvdW50KSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0UmlnaHRNaW5WaXNpYmxlQmFyQ291bnQgPSBmdW5jdGlvbiAoYmFyQ291bnQpIHtcbiAgICAgICAgaWYgKGJhckNvdW50IDwgMCkge1xuICAgICAgICAgICAgbG9nV2Fybignc2V0UmlnaHRNaW5WaXNpYmxlQmFyQ291bnQnLCAnYmFyQ291bnQnLCAnYmFyQ291bnQgbXVzdCBncmVhdGVyIHRoYW4gemVybyEhIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0UmlnaHRNaW5WaXNpYmxlQmFyQ291bnQoTWF0aC5jZWlsKGJhckNvdW50KSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0QmFyU3BhY2UgPSBmdW5jdGlvbiAoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRCYXJTcGFjZShzcGFjZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0QmFyU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldEJhclNwYWNlKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0VmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRWaXNpYmxlUmFuZ2UoKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5jbGVhckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuY2xlYXJEYXRhKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0RGF0YUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldERhdGFMaXN0KCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuYXBwbHlOZXdEYXRhID0gZnVuY3Rpb24gKGRhdGEsIG1vcmUpIHtcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgIHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpLnNldEF1dG9DYWxjVGlja0ZsYWcodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG9hZERhdGFNb3JlID0geyBmb3J3YXJkOiBmYWxzZSwgYmFja3dhcmQ6IGZhbHNlIH07XG4gICAgICAgIGlmIChpc0Jvb2xlYW4obW9yZSkpIHtcbiAgICAgICAgICAgIGxvYWREYXRhTW9yZS5mb3J3YXJkID0gbW9yZTtcbiAgICAgICAgICAgIGxvYWREYXRhTW9yZS5iYWNrd2FyZCA9IG1vcmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2FkRGF0YU1vcmUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbG9hZERhdGFNb3JlKSwgbW9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5hZGREYXRhKGRhdGEsIExvYWREYXRhVHlwZS5Jbml0LCBsb2FkRGF0YU1vcmUpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnVwZGF0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLmFkZERhdGEoZGF0YSwgTG9hZERhdGFUeXBlLlVwZGF0ZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0TG9hZE1vcmVEYXRhQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRMb2FkTW9yZURhdGFDYWxsYmFjayhjYik7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuY3JlYXRlSW5kaWNhdG9yID0gZnVuY3Rpb24gKHZhbHVlLCBpc1N0YWNrLCBwYW5lT3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBpbmRpY2F0b3IgPSBpc1N0cmluZyh2YWx1ZSkgPyB7IG5hbWU6IHZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgaWYgKGdldEluZGljYXRvckNsYXNzKGluZGljYXRvci5uYW1lKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nV2FybignY3JlYXRlSW5kaWNhdG9yJywgJ3ZhbHVlJywgJ2luZGljYXRvciBub3Qgc3VwcG9ydGVkLCB5b3UgbWF5IG5lZWQgdG8gdXNlIHJlZ2lzdGVySW5kaWNhdG9yIHRvIGFkZCBvbmUhISEnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYW5lT3B0cyA9IHBhbmVPcHRpb25zICE9PSBudWxsICYmIHBhbmVPcHRpb25zICE9PSB2b2lkIDAgPyBwYW5lT3B0aW9ucyA6IHt9O1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHBhbmVPcHRzLmlkKSkge1xuICAgICAgICAgICAgcGFuZU9wdHMuaWQgPSBjcmVhdGVJZChQYW5lSWRDb25zdGFudHMuSU5ESUNBVE9SKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RyaW5nKGluZGljYXRvci5pZCkpIHtcbiAgICAgICAgICAgIGluZGljYXRvci5pZCA9IGNyZWF0ZUlkKGluZGljYXRvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY2hhcnRTdG9yZS5hZGRJbmRpY2F0b3IoaW5kaWNhdG9yLCBwYW5lT3B0cy5pZCwgaXNTdGFjayAhPT0gbnVsbCAmJiBpc1N0YWNrICE9PSB2b2lkIDAgPyBpc1N0YWNrIDogZmFsc2UpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkU29ydCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVPcHRzLmlkKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVQYW5lKEluZGljYXRvclBhbmUsIHBhbmVPcHRzLmlkLCBwYW5lT3B0cyk7XG4gICAgICAgICAgICAgICAgKF9hID0gcGFuZU9wdHMuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocGFuZU9wdHMuaGVpZ2h0ID0gUEFORV9ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkU29ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFBhbmVPcHRpb25zKHBhbmVPcHRzKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0KHtcbiAgICAgICAgICAgICAgICBzb3J0OiBzaG91bGRTb3J0LFxuICAgICAgICAgICAgICAgIG1lYXN1cmVIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2F0b3IuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUub3ZlcnJpZGVJbmRpY2F0b3IgPSBmdW5jdGlvbiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUub3ZlcnJpZGVJbmRpY2F0b3Iob3ZlcnJpZGUpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldEluZGljYXRvcnMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldEluZGljYXRvcnNCeUZpbHRlcihmaWx0ZXIgIT09IG51bGwgJiYgZmlsdGVyICE9PSB2b2lkIDAgPyBmaWx0ZXIgOiB7fSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUucmVtb3ZlSW5kaWNhdG9yID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX2NoYXJ0U3RvcmUucmVtb3ZlSW5kaWNhdG9yKGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IHt9KTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRNZWFzdXJlSGVpZ2h0XzEgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwYW5lSWRzXzEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuQ0FORExFICYmIHBhbmVJZCAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgICAgICAgICBwYW5lSWRzXzEucHVzaChwYW5lSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFuZUlkc18xLmZvckVhY2goZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2NoYXJ0U3RvcmUuaGFzSW5kaWNhdG9ycyhwYW5lSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9kcmF3UGFuZXMuZmluZEluZGV4KGZ1bmN0aW9uIChwYW5lKSB7IHJldHVybiBwYW5lLmdldElkKCkgPT09IHBhbmVJZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYW5lID0gX3RoaXMuX2RyYXdQYW5lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRNZWFzdXJlSGVpZ2h0XzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlY2FsY3VsYXRlUGFuZUhlaWdodChwYW5lLCAwLCBwYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kcmF3UGFuZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd1BhbmVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmRsZVBhbmUuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5kbGVQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiB0aGlzLl9jaGFydEJvdW5kaW5nLmhlaWdodCAtIHRoaXMuX3hBeGlzUGFuZS5nZXRCb3VuZGluZygpLmhlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGF5b3V0KHtcbiAgICAgICAgICAgICAgICBzb3J0OiBzaG91bGRNZWFzdXJlSGVpZ2h0XzEsXG4gICAgICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogc2hvdWxkTWVhc3VyZUhlaWdodF8xLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9yY2VCdWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3ZlcmxheXMgPSBbXTtcbiAgICAgICAgdmFyIGFwcG9pbnRQYW5lRmxhZ3MgPSBbXTtcbiAgICAgICAgdmFyIGJ1aWxkID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZChvdmVybGF5LnBhbmVJZCkgfHwgX3RoaXMuZ2V0RHJhd1BhbmVCeUlkKG92ZXJsYXkucGFuZUlkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkucGFuZUlkID0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRTtcbiAgICAgICAgICAgICAgICBhcHBvaW50UGFuZUZsYWdzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwb2ludFBhbmVGbGFncy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheXMucHVzaChvdmVybGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgYnVpbGQoeyBuYW1lOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IHsgbmFtZTogdiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1aWxkKG92ZXJsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWlsZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuX2NoYXJ0U3RvcmUuYWRkT3ZlcmxheXMob3ZlcmxheXMsIGFwcG9pbnRQYW5lRmxhZ3MpO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkc1swXTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRPdmVybGF5cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0T3ZlcmxheXNCeUZpbHRlcihmaWx0ZXIgIT09IG51bGwgJiYgZmlsdGVyICE9PSB2b2lkIDAgPyBmaWx0ZXIgOiB7fSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUub3ZlcnJpZGVPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLm92ZXJyaWRlT3ZlcmxheShvdmVycmlkZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUucmVtb3ZlT3ZlcmxheSA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUucmVtb3ZlT3ZlcmxheShmaWx0ZXIgIT09IG51bGwgJiYgZmlsdGVyICE9PSB2b2lkIDAgPyBmaWx0ZXIgOiB7fSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0UGFuZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgc2hvdWxkTWVhc3VyZUhlaWdodCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2hvdWxkTGF5b3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciB2YWxpZElkID0gaXNWYWxpZChvcHRpb25zLmlkKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoY3VycmVudFBhbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGFuZUlkID0gY3VycmVudFBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgIGlmICgodmFsaWRJZCAmJiBvcHRpb25zLmlkID09PSBjdXJyZW50UGFuZUlkKSB8fCAhdmFsaWRJZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihvcHRpb25zLmhlaWdodCkgJiYgb3B0aW9ucy5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gTWF0aC5tYXgoKF9iID0gb3B0aW9ucy5taW5IZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN1cnJlbnRQYW5lLmdldE9wdGlvbnMoKS5taW5IZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTGF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE1lYXN1cmVIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3JpZ2luYWxCb3VuZGluZyh7IGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLl9yZWNhbGN1bGF0ZVBhbmVIZWlnaHQoY3VycmVudFBhbmUsIGhlaWdodCwgLWhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQob3B0aW9ucy5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gb3B0aW9ucy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTWVhc3VyZUhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWF4aW1pemVcIiAvKiBQYW5lU3RhdGUuTWF4aW1pemUgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heGltaXplUGFuZSA9IHRoaXNfMS5fZHJhd1BhbmVzLmZpbmQoZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYW5lSWQgPSBwYW5lLmdldElkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFuZS5nZXRPcHRpb25zKCkuc3RhdGUgPT09IFwibWF4aW1pemVcIiAvKiBQYW5lU3RhdGUuTWF4aW1pemUgKi8gJiYgcGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKG1heGltaXplUGFuZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZS5nZXRPcHRpb25zKCkuc3RhdGUgPT09IFwibm9ybWFsXCIgLyogUGFuZVN0YXRlLk5vcm1hbCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLnNldE9yaWdpbmFsQm91bmRpbmcoeyBoZWlnaHQ6IGN1cnJlbnRQYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3B0aW9ucyh7IHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbEhlaWdodCA9IHRoaXNfMS5fY2hhcnRCb3VuZGluZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogdG90YWxIZWlnaHQgLSB0aGlzXzEuX3hBeGlzUGFuZS5nZXRCb3VuZGluZygpLmhlaWdodCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUuZ2V0SWQoKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyAmJiBwYW5lLmdldElkKCkgIT09IGN1cnJlbnRQYW5lSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogcGFuZS5nZXRPcmlnaW5hbEJvdW5kaW5nKCkuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY3VycmVudFBhbmUuZ2V0Qm91bmRpbmcoKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBjdXJyZW50UGFuZS5nZXRPcHRpb25zKCkuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VIZWlnaHQgPSBoZWlnaHQgLSBQQU5FX01JTl9IRUlHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IFwibWF4aW1pemVcIiAvKiBQYW5lU3RhdGUuTWF4aW1pemUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlaWdodCA9IGN1cnJlbnRQYW5lLmdldE9yaWdpbmFsQm91bmRpbmcoKS5oZWlnaHQgLSBQQU5FX01JTl9IRUlHSFQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5fcmVjYWxjdWxhdGVQYW5lSGVpZ2h0KGN1cnJlbnRQYW5lLCBQQU5FX01JTl9IRUlHSFQsIGNoYW5nZUhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IFwibm9ybWFsXCIgLyogUGFuZVN0YXRlLk5vcm1hbCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLnNldE9yaWdpbmFsQm91bmRpbmcoeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLnNldE9wdGlvbnMoeyBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUuZ2V0SWQoKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjdXJyZW50UGFuZS5nZXRPcmlnaW5hbEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLl9yZWNhbGN1bGF0ZVBhbmVIZWlnaHQoY3VycmVudFBhbmUsIGhlaWdodCwgY3VycmVudFBhbmUuZ2V0Qm91bmRpbmcoKS5oZWlnaHQgLSBoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZS5zZXRPcHRpb25zKHsgc3RhdGU6IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lLmdldElkKCkgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuX3NlcGFyYXRvclBhbmVzLmdldChwYW5lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQob3B0aW9ucy5heGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3BzID0gX19hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHMuc3RhdGU7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3B0aW9ucyhvcHMpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFuZUlkID09PSBvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5fZHJhd1BhbmVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGFuZSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShjdXJyZW50UGFuZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dCh7XG4gICAgICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogc2hvdWxkTWVhc3VyZUhlaWdodCxcbiAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvcmNlQnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0UGFuZU9wdGlvbnMgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXREcmF3UGFuZUJ5SWQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS5nZXRPcHRpb25zKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdQYW5lcy5tYXAoZnVuY3Rpb24gKHBhbmUpIHsgcmV0dXJuIHBhbmUuZ2V0T3B0aW9ucygpOyB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRab29tRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0Wm9vbUVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuaXNab29tRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuaXNab29tRW5hYmxlZCgpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldFNjcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldFNjcm9sbEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuaXNTY3JvbGxFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5pc1Njcm9sbEVuYWJsZWQoKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zY3JvbGxCeURpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlLCBhbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpc051bWJlcihhbmltYXRpb25EdXJhdGlvbikgJiYgYW5pbWF0aW9uRHVyYXRpb24gPiAwID8gYW5pbWF0aW9uRHVyYXRpb24gOiAwO1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnN0YXJ0U2Nyb2xsKCk7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHsgZHVyYXRpb246IGR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9uLmRvRnJhbWUoZnVuY3Rpb24gKGZyYW1lVGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc0Rpc3RhbmNlID0gZGlzdGFuY2UgKiAoZnJhbWVUaW1lIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGFydFN0b3JlLnNjcm9sbChwcm9ncmVzc0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNjcm9sbChkaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zY3JvbGxUb1JlYWxUaW1lID0gZnVuY3Rpb24gKGFuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBiYXJTcGFjZSA9IHRoaXMuX2NoYXJ0U3RvcmUuZ2V0QmFyU3BhY2UoKS5iYXI7XG4gICAgICAgIHZhciBkaWZCYXJDb3VudCA9IHRoaXMuX2NoYXJ0U3RvcmUuZ2V0TGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCgpIC0gdGhpcy5fY2hhcnRTdG9yZS5nZXRJbml0aWFsT2Zmc2V0UmlnaHREaXN0YW5jZSgpIC8gYmFyU3BhY2U7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGRpZkJhckNvdW50ICogYmFyU3BhY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnlEaXN0YW5jZShkaXN0YW5jZSwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNjcm9sbFRvRGF0YUluZGV4ID0gZnVuY3Rpb24gKGRhdGFJbmRleCwgYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gKHRoaXMuX2NoYXJ0U3RvcmUuZ2V0TGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCgpICsgKHRoaXMuZ2V0RGF0YUxpc3QoKS5sZW5ndGggLSAxIC0gZGF0YUluZGV4KSkgKiB0aGlzLl9jaGFydFN0b3JlLmdldEJhclNwYWNlKCkuYmFyO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5RGlzdGFuY2UoZGlzdGFuY2UsIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zY3JvbGxUb1RpbWVzdGFtcCA9IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGFuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBiaW5hcnlTZWFyY2hOZWFyZXN0KHRoaXMuZ2V0RGF0YUxpc3QoKSwgJ3RpbWVzdGFtcCcsIHRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9EYXRhSW5kZXgoZGF0YUluZGV4LCBhbmltYXRpb25EdXJhdGlvbik7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuem9vbUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChzY2FsZSwgY29vcmRpbmF0ZSwgYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaXNOdW1iZXIoYW5pbWF0aW9uRHVyYXRpb24pICYmIGFuaW1hdGlvbkR1cmF0aW9uID4gMCA/IGFuaW1hdGlvbkR1cmF0aW9uIDogMDtcbiAgICAgICAgdmFyIGJhclNwYWNlID0gdGhpcy5fY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpLmJhcjtcbiAgICAgICAgdmFyIHNjYWxlQmFyU3BhY2UgPSBiYXJTcGFjZSAqIHNjYWxlO1xuICAgICAgICB2YXIgZGlmU3BhY2UgPSBzY2FsZUJhclNwYWNlIC0gYmFyU3BhY2U7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvZ3Jlc3NCYXJTcGFjZV8xID0gMDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHsgZHVyYXRpb246IGR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9uLmRvRnJhbWUoZnVuY3Rpb24gKGZyYW1lVGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc0JhclNwYWNlID0gZGlmU3BhY2UgKiAoZnJhbWVUaW1lIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IChwcm9ncmVzc0JhclNwYWNlIC0gcHJldlByb2dyZXNzQmFyU3BhY2VfMSkgLyBfdGhpcy5fY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpLmJhciAqIFNDQUxFX01VTFRJUExJRVI7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuem9vbShzY2FsZSwgY29vcmRpbmF0ZSk7XG4gICAgICAgICAgICAgICAgcHJldlByb2dyZXNzQmFyU3BhY2VfMSA9IHByb2dyZXNzQmFyU3BhY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS56b29tKGRpZlNwYWNlIC8gYmFyU3BhY2UgKiBTQ0FMRV9NVUxUSVBMSUVSLCBjb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnpvb21BdERhdGFJbmRleCA9IGZ1bmN0aW9uIChzY2FsZSwgZGF0YUluZGV4LCBhbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuX2NoYXJ0U3RvcmUuZGF0YUluZGV4VG9Db29yZGluYXRlKGRhdGFJbmRleCk7XG4gICAgICAgIHRoaXMuem9vbUF0Q29vcmRpbmF0ZShzY2FsZSwgeyB4OiB4LCB5OiAwIH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS56b29tQXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAoc2NhbGUsIHRpbWVzdGFtcCwgYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGJpbmFyeVNlYXJjaE5lYXJlc3QodGhpcy5nZXREYXRhTGlzdCgpLCAndGltZXN0YW1wJywgdGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy56b29tQXREYXRhSW5kZXgoc2NhbGUsIGRhdGFJbmRleCwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKHBvaW50cywgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gZmlsdGVyICE9PSBudWxsICYmIGZpbHRlciAhPT0gdm9pZCAwID8gZmlsdGVyIDoge30sIF9jID0gX2IucGFuZUlkLCBwYW5lSWQgPSBfYyA9PT0gdm9pZCAwID8gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSA6IF9jLCBfZCA9IF9iLmFic29sdXRlLCBhYnNvbHV0ZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kO1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHBhbmVJZCAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldERyYXdQYW5lQnlJZChwYW5lSWQpO1xuICAgICAgICAgICAgaWYgKHBhbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdfMSA9IHBhbmUuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB2YXIgcHMgPSBbXS5jb25jYXQocG9pbnRzKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNfMSA9IHRoaXMuX3hBeGlzUGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzXzEgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IHBzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IHBvaW50LmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleCA9IF90aGlzLl9jaGFydFN0b3JlLnRpbWVzdGFtcFRvRGF0YUluZGV4KHBvaW50LnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueCA9IHhBeGlzXzEuY29udmVydFRvUGl4ZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHlBeGlzXzEuY29udmVydFRvUGl4ZWwocG9pbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS55ID0gYWJzb2x1dGUgPyBib3VuZGluZ18xLnRvcCArIHkgOiB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHBvaW50cykgPyBjb29yZGluYXRlcyA6ICgoX2EgPSBjb29yZGluYXRlc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmNvbnZlcnRGcm9tUGl4ZWwgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IHt9LCBfYyA9IF9iLnBhbmVJZCwgcGFuZUlkID0gX2MgPT09IHZvaWQgMCA/IFBhbmVJZENvbnN0YW50cy5DQU5ETEUgOiBfYywgX2QgPSBfYi5hYnNvbHV0ZSwgYWJzb2x1dGUgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICBpZiAocGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVJZCk7XG4gICAgICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ18yID0gcGFuZS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHZhciBjcyA9IFtdLmNvbmNhdChjb29yZGluYXRlcyk7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzXzIgPSB0aGlzLl94QXhpc1BhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIHZhciB5QXhpc18yID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gY3MubWFwKGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihjb29yZGluYXRlLngpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0geEF4aXNfMi5jb252ZXJ0RnJvbVBpeGVsKGNvb3JkaW5hdGUueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC50aW1lc3RhbXAgPSAoX2EgPSBfdGhpcy5fY2hhcnRTdG9yZS5kYXRhSW5kZXhUb1RpbWVzdGFtcChkYXRhSW5kZXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGNvb3JkaW5hdGUueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gYWJzb2x1dGUgPyBjb29yZGluYXRlLnkgLSBib3VuZGluZ18yLnRvcCA6IGNvb3JkaW5hdGUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnZhbHVlID0geUF4aXNfMi5jb252ZXJ0RnJvbVBpeGVsKHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheShjb29yZGluYXRlcykgPyBwb2ludHMgOiAoKF9hID0gcG9pbnRzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZXhlY3V0ZUFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEFjdGlvblR5cGUuT25Dcm9zc2hhaXJDaGFuZ2U6IHtcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NoYWlyID0gX19hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICAgICAgICAgIChfYSA9IGNyb3NzaGFpci5wYW5lSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjcm9zc2hhaXIucGFuZUlkID0gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRDcm9zc2hhaXIoY3Jvc3NoYWlyLCB7IG5vdEV4ZWN1dGVBY3Rpb246IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zdWJzY3JpYmVBY3Rpb24odHlwZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnVuc3Vic2NyaWJlQWN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUudW5zdWJzY3JpYmVBY3Rpb24odHlwZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldENvbnZlcnRQaWN0dXJlVXJsID0gZnVuY3Rpb24gKGluY2x1ZGVPdmVybGF5LCB0eXBlLCBiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fY2hhcnRCb3VuZGluZywgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlRG9tKCdjYW52YXMnLCB7XG4gICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXMpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwgJiYgYmFja2dyb3VuZENvbG9yICE9PSB2b2lkIDAgPyBiYWNrZ3JvdW5kQ29sb3IgOiAnI0ZGRkZGRic7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIG92ZXJsYXlGbGFnID0gaW5jbHVkZU92ZXJsYXkgIT09IG51bGwgJiYgaW5jbHVkZU92ZXJsYXkgIT09IHZvaWQgMCA/IGluY2x1ZGVPdmVybGF5IDogZmFsc2U7XG4gICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yUGFuZSA9IF90aGlzLl9zZXBhcmF0b3JQYW5lcy5nZXQocGFuZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChzZXBhcmF0b3JQYW5lKSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JCb3VuZGluZyA9IHNlcGFyYXRvclBhbmUuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHNlcGFyYXRvclBhbmUuZ2V0SW1hZ2Uob3ZlcmxheUZsYWcpLCBzZXBhcmF0b3JCb3VuZGluZy5sZWZ0LCBzZXBhcmF0b3JCb3VuZGluZy50b3AsIHNlcGFyYXRvckJvdW5kaW5nLndpZHRoLCBzZXBhcmF0b3JCb3VuZGluZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gcGFuZS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShwYW5lLmdldEltYWdlKG92ZXJsYXlGbGFnKSwgMCwgYm91bmRpbmcudG9wLCB3aWR0aCwgYm91bmRpbmcuaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvXCIuY29uY2F0KHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdm9pZCAwID8gdHlwZSA6ICdqcGVnJykpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVDaGFydEJvdW5kaW5nKCk7XG4gICAgICAgIHRoaXMubGF5b3V0KHtcbiAgICAgICAgICAgIG1lYXN1cmVIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlQnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRFdmVudC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICBwYW5lLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RyYXdQYW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9zZXBhcmF0b3JQYW5lcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fY2hhcnRDb250YWluZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIENoYXJ0SW1wO1xufSgpKTtcblxuLyoqXG4gKiAgICAgICBfX18gICAgICAgICAgIF9fXyAgICAgICAgICAgICAgICAgICBfX18gICAgICAgICAgIF9fXyAgICAgICAgICAgX19fICAgICAgICAgICBfX18gICAgICAgICAgIF9fXyAgICAgICAgICAgX19fICAgICAgICAgICBfX19cbiAqICAgICAgL1xcX19cXCAgICAgICAgIC9cXF9fXFwgICAgICBfX18gICAgICAgIC9cXF9fXFwgICAgICAgICAvXFwgIFxcICAgICAgICAgL1xcICBcXCAgICAgICAgIC9cXF9fXFwgICAgICAgICAvXFwgIFxcICAgICAgICAgL1xcICBcXCAgICAgICAgIC9cXCAgXFxcbiAqICAgICAvOi8gIC8gICAgICAgIC86LyAgLyAgICAgL1xcICBcXCAgICAgIC86OnwgIHwgICAgICAgLzo6XFwgIFxcICAgICAgIC86OlxcICBcXCAgICAgICAvOi8gIC8gICAgICAgIC86OlxcICBcXCAgICAgICAvOjpcXCAgXFwgICAgICAgIFxcOlxcICBcXFxuICogICAgLzovX18vICAgICAgICAvOi8gIC8gICAgICBcXDpcXCAgXFwgICAgLzp8OnwgIHwgICAgICAvOi9cXDpcXCAgXFwgICAgIC86L1xcOlxcICBcXCAgICAgLzovX18vICAgICAgICAvOi9cXDpcXCAgXFwgICAgIC86L1xcOlxcICBcXCAgICAgICAgXFw6XFwgIFxcXG4gKiAgIC86OlxcX19cXF9fX18gICAvOi8gIC8gICAgICAgLzo6XFxfX1xcICAvOi98OnwgIHxfXyAgIC86OlxcflxcOlxcICBcXCAgIC86LyAgXFw6XFwgIFxcICAgLzo6XFwgIFxcIF9fXyAgIC86OlxcflxcOlxcICBcXCAgIC86OlxcflxcOlxcICBcXCAgICAgICAvOjpcXCAgXFxcbiAqICAvOi9cXDo6Ojo6XFxfX1xcIC86L19fLyAgICAgX18vOi9cXC9fXy8gLzovIHw6fCAvXFxfX1xcIC86L1xcOlxcIFxcOlxcX19cXCAvOi9fXy8gXFw6XFxfX1xcIC86L1xcOlxcICAvXFxfX1xcIC86L1xcOlxcIFxcOlxcX19cXCAvOi9cXDpcXCBcXDpcXF9fXFwgICAgIC86L1xcOlxcX19cXFxuICogIFxcL198Onx+fnx+ICAgIFxcOlxcICBcXCAgICAvXFwvOi8gIC8gICAgXFwvX198OnwvOi8gIC8gXFw6XFx+XFw6XFwgXFwvX18vIFxcOlxcICBcXCAgXFwvX18vIFxcL19fXFw6XFwvOi8gIC8gXFwvX19cXDpcXC86LyAgLyBcXC9ffDo6XFwvOi8gIC8gICAgLzovICBcXC9fXy9cbiAqICAgICB8OnwgIHwgICAgICBcXDpcXCAgXFwgICBcXDo6L19fLyAgICAgICAgIHw6LzovICAvICAgXFw6XFwgXFw6XFxfX1xcICAgIFxcOlxcICBcXCAgICAgICAgICAgIFxcOjovICAvICAgICAgIFxcOjovICAvICAgICB8Onw6Oi8gIC8gICAgLzovICAvXG4gKiAgICAgfDp8ICB8ICAgICAgIFxcOlxcICBcXCAgIFxcOlxcX19cXCAgICAgICAgIHw6Oi8gIC8gICAgIFxcOlxcIFxcL19fLyAgICAgXFw6XFwgIFxcICAgICAgICAgICAvOi8gIC8gICAgICAgIC86LyAgLyAgICAgIHw6fFxcL19fLyAgICAgXFwvX18vXG4gKiAgICAgfDp8ICB8ICAgICAgICBcXDpcXF9fXFwgICBcXC9fXy8gICAgICAgICAvOi8gIC8gICAgICAgXFw6XFxfX1xcICAgICAgICBcXDpcXF9fXFwgICAgICAgICAvOi8gIC8gICAgICAgIC86LyAgLyAgICAgICB8OnwgIHxcbiAqICAgICAgXFx8X198ICAgICAgICAgXFwvX18vICAgICAgICAgICAgICAgICBcXC9fXy8gICAgICAgICBcXC9fXy8gICAgICAgICBcXC9fXy8gICAgICAgICBcXC9fXy8gICAgICAgICBcXC9fXy8gICAgICAgICBcXHxfX3xcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgY2hhcnRzID0gbmV3IE1hcCgpO1xudmFyIGNoYXJ0QmFzZUlkID0gMTtcbi8qKlxuICogQ2hhcnQgdmVyc2lvblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnMTAuMC4wLWFscGhhNSc7XG59XG4vKipcbiAqIEluaXQgY2hhcnQgaW5zdGFuY2VcbiAqIEBwYXJhbSBkc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtDaGFydH1cbiAqL1xuZnVuY3Rpb24gaW5pdChkcywgb3B0aW9ucykge1xuICAgIGxvZ1RhZygpO1xuICAgIHZhciBkb20gPSBudWxsO1xuICAgIGlmIChpc1N0cmluZyhkcykpIHtcbiAgICAgICAgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9tID0gZHM7XG4gICAgfVxuICAgIGlmIChkb20gPT09IG51bGwpIHtcbiAgICAgICAgbG9nRXJyb3IoJycsICcnLCAnVGhlIGNoYXJ0IGNhbm5vdCBiZSBpbml0aWFsaXplZCBjb3JyZWN0bHkuIFBsZWFzZSBjaGVjayB0aGUgcGFyYW1ldGVycy4gVGhlIGNoYXJ0IGNvbnRhaW5lciBjYW5ub3QgYmUgbnVsbCBhbmQgY2hpbGQgZWxlbWVudHMgbmVlZCB0byBiZSBhZGRlZCEhIScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoYXJ0ID0gY2hhcnRzLmdldChkb20uaWQpO1xuICAgIGlmIChpc1ZhbGlkKGNoYXJ0KSkge1xuICAgICAgICBsb2dXYXJuKCcnLCAnJywgJ1RoZSBjaGFydCBoYXMgYmVlbiBpbml0aWFsaXplZCBvbiB0aGUgZG9t77yB77yB77yBJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG4gICAgdmFyIGlkID0gXCJrX2xpbmVfY2hhcnRfXCIuY29uY2F0KGNoYXJ0QmFzZUlkKyspO1xuICAgIGNoYXJ0ID0gbmV3IENoYXJ0SW1wKGRvbSwgb3B0aW9ucyk7XG4gICAgY2hhcnQuaWQgPSBpZDtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdrLWxpbmUtY2hhcnQtaWQnLCBpZCk7XG4gICAgY2hhcnRzLnNldChpZCwgY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn1cbi8qKlxuICogRGVzdHJveSBjaGFydCBpbnN0YW5jZVxuICogQHBhcmFtIGRjc1xuICovXG5mdW5jdGlvbiBkaXNwb3NlKGRjcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIGlkID0gbnVsbDtcbiAgICBpZiAoZGNzIGluc3RhbmNlb2YgQ2hhcnRJbXApIHtcbiAgICAgICAgaWQgPSBkY3MuaWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZG9tID0gbnVsbDtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGRjcykpIHtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRjcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb20gPSBkY3M7XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSAoX2EgPSBkb20gPT09IG51bGwgfHwgZG9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb20uZ2V0QXR0cmlidXRlKCdrLWxpbmUtY2hhcnQtaWQnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICAgIChfYiA9IGNoYXJ0cy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xuICAgICAgICBjaGFydHMuZGVsZXRlKGlkKTtcbiAgICB9XG59XG52YXIgdXRpbHMgPSB7XG4gICAgY2xvbmU6IGNsb25lLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWUsXG4gICAgZm9ybWF0UHJlY2lzaW9uOiBmb3JtYXRQcmVjaXNpb24sXG4gICAgZm9ybWF0QmlnTnVtYmVyOiBmb3JtYXRCaWdOdW1iZXIsXG4gICAgZm9ybWF0RGF0ZTogZm9ybWF0VGltZXN0YW1wVG9TdHJpbmcsXG4gICAgZm9ybWF0VGhvdXNhbmRzOiBmb3JtYXRUaG91c2FuZHMsXG4gICAgZm9ybWF0Rm9sZERlY2ltYWw6IGZvcm1hdEZvbGREZWNpbWFsLFxuICAgIGNhbGNUZXh0V2lkdGg6IGNhbGNUZXh0V2lkdGgsXG4gICAgZ2V0TGluZWFyU2xvcGVJbnRlcmNlcHQ6IGdldExpbmVhclNsb3BlSW50ZXJjZXB0LFxuICAgIGdldExpbmVhcllGcm9tU2xvcGVJbnRlcmNlcHQ6IGdldExpbmVhcllGcm9tU2xvcGVJbnRlcmNlcHQsXG4gICAgZ2V0TGluZWFyWUZyb21Db29yZGluYXRlczogZ2V0TGluZWFyWUZyb21Db29yZGluYXRlcyxcbiAgICBjaGVja0Nvb3JkaW5hdGVPbkFyYzogY2hlY2tDb29yZGluYXRlT25BcmMsXG4gICAgY2hlY2tDb29yZGluYXRlT25DaXJjbGU6IGNoZWNrQ29vcmRpbmF0ZU9uQ2lyY2xlLFxuICAgIGNoZWNrQ29vcmRpbmF0ZU9uTGluZTogY2hlY2tDb29yZGluYXRlT25MaW5lLFxuICAgIGNoZWNrQ29vcmRpbmF0ZU9uUG9seWdvbjogY2hlY2tDb29yZGluYXRlT25Qb2x5Z29uLFxuICAgIGNoZWNrQ29vcmRpbmF0ZU9uUmVjdDogY2hlY2tDb29yZGluYXRlT25SZWN0LFxuICAgIGNoZWNrQ29vcmRpbmF0ZU9uVGV4dDogY2hlY2tDb29yZGluYXRlT25UZXh0XG59O1xuXG5leHBvcnQgeyBBY3Rpb25UeXBlLCBDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uLCBDYW5kbGVUeXBlLCBEb21Qb3NpdGlvbiwgRm9ybWF0RGF0ZVR5cGUsIEluZGljYXRvclNlcmllcywgTGluZVR5cGUsIE92ZXJsYXlNb2RlLCBQb2x5Z29uVHlwZSwgVG9vbHRpcEZlYXR1cmVQb3NpdGlvbiwgVG9vbHRpcEZlYXR1cmVUeXBlLCBUb29sdGlwU2hvd1J1bGUsIFRvb2x0aXBTaG93VHlwZSwgZGlzcG9zZSwgZ2V0RmlndXJlQ2xhc3MsIGdldE92ZXJsYXlDbGFzcywgZ2V0U3VwcG9ydGVkRmlndXJlcywgZ2V0U3VwcG9ydGVkSW5kaWNhdG9ycywgZ2V0U3VwcG9ydGVkTG9jYWxlcywgZ2V0U3VwcG9ydGVkT3ZlcmxheXMsIGluaXQsIHJlZ2lzdGVyRmlndXJlLCByZWdpc3RlckluZGljYXRvciwgcmVnaXN0ZXJMb2NhbGUsIHJlZ2lzdGVyT3ZlcmxheSwgcmVnaXN0ZXJTdHlsZXMsIHJlZ2lzdGVyWEF4aXMsIHJlZ2lzdGVyWUF4aXMsIHV0aWxzLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/klinecharts/dist/index.esm.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Cakpxi%5CDocuments%5Ccursor%5Cren1%5Csrc%5Ccomponents%5CBollingerBandsChart.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);