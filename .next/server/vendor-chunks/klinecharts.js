"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/klinecharts";
exports.ids = ["vendor-chunks/klinecharts"];
exports.modules = {

/***/ "(ssr)/./node_modules/klinecharts/dist/index.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/klinecharts/dist/index.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionType: () => (/* binding */ ActionType),\n/* harmony export */   CandleTooltipRectPosition: () => (/* binding */ CandleTooltipRectPosition),\n/* harmony export */   CandleType: () => (/* binding */ CandleType),\n/* harmony export */   DomPosition: () => (/* binding */ DomPosition),\n/* harmony export */   FormatDateType: () => (/* binding */ FormatDateType),\n/* harmony export */   IndicatorSeries: () => (/* binding */ IndicatorSeries),\n/* harmony export */   LineType: () => (/* binding */ LineType),\n/* harmony export */   OverlayMode: () => (/* binding */ OverlayMode),\n/* harmony export */   PolygonType: () => (/* binding */ PolygonType),\n/* harmony export */   TooltipFeaturePosition: () => (/* binding */ TooltipFeaturePosition),\n/* harmony export */   TooltipFeatureType: () => (/* binding */ TooltipFeatureType),\n/* harmony export */   TooltipShowRule: () => (/* binding */ TooltipShowRule),\n/* harmony export */   TooltipShowType: () => (/* binding */ TooltipShowType),\n/* harmony export */   dispose: () => (/* binding */ dispose),\n/* harmony export */   getFigureClass: () => (/* binding */ getFigureClass),\n/* harmony export */   getOverlayClass: () => (/* binding */ getOverlayClass),\n/* harmony export */   getSupportedFigures: () => (/* binding */ getSupportedFigures),\n/* harmony export */   getSupportedIndicators: () => (/* binding */ getSupportedIndicators),\n/* harmony export */   getSupportedLocales: () => (/* binding */ getSupportedLocales),\n/* harmony export */   getSupportedOverlays: () => (/* binding */ getSupportedOverlays),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   registerFigure: () => (/* binding */ registerFigure),\n/* harmony export */   registerIndicator: () => (/* binding */ registerIndicator),\n/* harmony export */   registerLocale: () => (/* binding */ registerLocale),\n/* harmony export */   registerOverlay: () => (/* binding */ registerOverlay),\n/* harmony export */   registerStyles: () => (/* binding */ registerStyles),\n/* harmony export */   registerXAxis: () => (/* binding */ registerXAxis),\n/* harmony export */   registerYAxis: () => (/* binding */ registerYAxis),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n     * @license\n     * KLineChart v10.0.0-alpha5\n     * Copyright (c) 2019 lihu.\n     * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n     */ /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore\nfunction merge(target, source) {\n    if (!isObject(target) && !isObject(source)) {\n        return;\n    }\n    for(var key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n            var targetProp = target[key];\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n            var sourceProp = source[key];\n            if (isObject(sourceProp) && isObject(targetProp)) {\n                merge(targetProp, sourceProp);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                if (isValid(source[key])) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access -- ignore\n                    target[key] = clone(source[key]);\n                }\n            }\n        }\n    }\n}\nfunction clone(target) {\n    if (!isObject(target)) {\n        return target;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignore\n    var copy = null;\n    if (isArray(target)) {\n        copy = [];\n    } else {\n        copy = {};\n    }\n    for(var key in target){\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n            var v = target[key];\n            if (isObject(v)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                copy[key] = clone(v);\n            } else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- ignore\n                copy[key] = v;\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- ignore\n    return copy;\n}\nfunction isArray(value) {\n    return Object.prototype.toString.call(value) === \"[object Array]\";\n}\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters -- ignore\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && isValid(value);\n}\nfunction isNumber(value) {\n    return typeof value === \"number\" && Number.isFinite(value);\n}\nfunction isValid(value) {\n    return value !== null && value !== undefined;\n}\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function isTransparent(color) {\n    return color === \"transparent\" || color === \"none\" || /^[rR][gG][Bb][Aa]\\(([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){3}[\\s]*0[\\s]*\\)$/.test(color) || /^[hH][Ss][Ll][Aa]\\(([\\s]*(360｜3[0-5][0-9]|[012]?[0-9][0-9]?)[\\s]*,)([\\s]*((100|[0-9][0-9]?)%|0)[\\s]*,){2}([\\s]*0[\\s]*)\\)$/.test(color);\n}\nfunction hexToRgb(hex, alpha) {\n    var h = hex.replace(/^#/, \"\");\n    var i = parseInt(h, 16);\n    var r = i >> 16 & 255;\n    var g = i >> 8 & 255;\n    var b = i & 255;\n    return \"rgba(\".concat(r, \", \").concat(g, \", \").concat(b, \", \").concat(alpha !== null && alpha !== void 0 ? alpha : 1, \")\");\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * line type\n */ var LineType;\n(function(LineType) {\n    LineType[\"Dashed\"] = \"dashed\";\n    LineType[\"Solid\"] = \"solid\";\n})(LineType || (LineType = {}));\nvar PathType;\n(function(PathType) {\n    PathType[\"Stroke\"] = \"stroke\";\n    PathType[\"Fill\"] = \"fill\";\n})(PathType || (PathType = {}));\nvar PolygonType;\n(function(PolygonType) {\n    PolygonType[\"Stroke\"] = \"stroke\";\n    PolygonType[\"Fill\"] = \"fill\";\n    PolygonType[\"StrokeFill\"] = \"stroke_fill\";\n})(PolygonType || (PolygonType = {}));\nvar TooltipShowRule;\n(function(TooltipShowRule) {\n    TooltipShowRule[\"Always\"] = \"always\";\n    TooltipShowRule[\"FollowCross\"] = \"follow_cross\";\n    TooltipShowRule[\"None\"] = \"none\";\n})(TooltipShowRule || (TooltipShowRule = {}));\nvar TooltipShowType;\n(function(TooltipShowType) {\n    TooltipShowType[\"Standard\"] = \"standard\";\n    TooltipShowType[\"Rect\"] = \"rect\";\n})(TooltipShowType || (TooltipShowType = {}));\nvar TooltipFeatureType;\n(function(TooltipFeatureType) {\n    TooltipFeatureType[\"Path\"] = \"path\";\n    TooltipFeatureType[\"IconFont\"] = \"icon_font\";\n})(TooltipFeatureType || (TooltipFeatureType = {}));\nvar TooltipFeaturePosition;\n(function(TooltipFeaturePosition) {\n    TooltipFeaturePosition[\"Left\"] = \"left\";\n    TooltipFeaturePosition[\"Middle\"] = \"middle\";\n    TooltipFeaturePosition[\"Right\"] = \"right\";\n})(TooltipFeaturePosition || (TooltipFeaturePosition = {}));\nvar CandleTooltipRectPosition;\n(function(CandleTooltipRectPosition) {\n    CandleTooltipRectPosition[\"Fixed\"] = \"fixed\";\n    CandleTooltipRectPosition[\"Pointer\"] = \"pointer\";\n})(CandleTooltipRectPosition || (CandleTooltipRectPosition = {}));\nvar CandleType;\n(function(CandleType) {\n    CandleType[\"CandleSolid\"] = \"candle_solid\";\n    CandleType[\"CandleStroke\"] = \"candle_stroke\";\n    CandleType[\"CandleUpStroke\"] = \"candle_up_stroke\";\n    CandleType[\"CandleDownStroke\"] = \"candle_down_stroke\";\n    CandleType[\"Ohlc\"] = \"ohlc\";\n    CandleType[\"Area\"] = \"area\";\n})(CandleType || (CandleType = {}));\nvar CandleColorCompareRule;\n(function(CandleColorCompareRule) {\n    CandleColorCompareRule[\"CurrentOpen\"] = \"current_open\";\n    CandleColorCompareRule[\"PreviousClose\"] = \"previous_close\";\n})(CandleColorCompareRule || (CandleColorCompareRule = {}));\nvar Color = {\n    RED: \"#F92855\",\n    GREEN: \"#2DC08E\",\n    WHITE: \"#FFFFFF\",\n    GREY: \"#76808F\",\n    BLUE: \"#1677FF\"\n};\nfunction getDefaultGridStyle() {\n    return {\n        show: true,\n        horizontal: {\n            show: true,\n            size: 1,\n            color: \"#EDEDED\",\n            style: LineType.Dashed,\n            dashedValue: [\n                2,\n                2\n            ]\n        },\n        vertical: {\n            show: true,\n            size: 1,\n            color: \"#EDEDED\",\n            style: LineType.Dashed,\n            dashedValue: [\n                2,\n                2\n            ]\n        }\n    };\n}\n/**\n * Get default candle style\n * @type {{area: {backgroundColor: [{offset: number, color: string}, {offset: number, color: string}], lineColor: string, lineSize: number, value: string}, bar: {noChangeColor: string, upColor: string, downColor: string}, tooltip: {rect: {offsetTop: number, fillColor: string, borderColor: string, paddingBottom: number, borderRadius: number, paddingRight: number, borderSize: number, offsetLeft: number, paddingTop: number, paddingLeft: number, offsetRight: number}, showRule: string, values: null, showType: string, text: {marginRight: number, size: number, color: string, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}, labels: string[]}, type: string, priceMark: {high: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, last: {noChangeColor: string, upColor: string, line: {dashValue: number[], size: number, show: boolean, style: string}, show: boolean, text: {paddingBottom: number, size: number, color: string, paddingRight: number, show: boolean, weight: string, paddingTop: number, family: string, paddingLeft: number}, downColor: string}, low: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, show: boolean}}}\n */ function getDefaultCandleStyle() {\n    var highLow = {\n        show: true,\n        color: Color.GREY,\n        textOffset: 5,\n        textSize: 10,\n        textFamily: \"Helvetica Neue\",\n        textWeight: \"normal\"\n    };\n    return {\n        type: CandleType.CandleSolid,\n        bar: {\n            compareRule: CandleColorCompareRule.CurrentOpen,\n            upColor: Color.GREEN,\n            downColor: Color.RED,\n            noChangeColor: Color.GREY,\n            upBorderColor: Color.GREEN,\n            downBorderColor: Color.RED,\n            noChangeBorderColor: Color.GREY,\n            upWickColor: Color.GREEN,\n            downWickColor: Color.RED,\n            noChangeWickColor: Color.GREY\n        },\n        area: {\n            lineSize: 2,\n            lineColor: Color.BLUE,\n            smooth: false,\n            value: \"close\",\n            backgroundColor: [\n                {\n                    offset: 0,\n                    color: hexToRgb(Color.BLUE, 0.01)\n                },\n                {\n                    offset: 1,\n                    color: hexToRgb(Color.BLUE, 0.2)\n                }\n            ],\n            point: {\n                show: true,\n                color: Color.BLUE,\n                radius: 4,\n                rippleColor: hexToRgb(Color.BLUE, 0.3),\n                rippleRadius: 8,\n                animation: true,\n                animationDuration: 1000\n            }\n        },\n        priceMark: {\n            show: true,\n            high: __assign({}, highLow),\n            low: __assign({}, highLow),\n            last: {\n                show: true,\n                compareRule: CandleColorCompareRule.CurrentOpen,\n                upColor: Color.GREEN,\n                downColor: Color.RED,\n                noChangeColor: Color.GREY,\n                line: {\n                    show: true,\n                    style: LineType.Dashed,\n                    dashedValue: [\n                        4,\n                        4\n                    ],\n                    size: 1\n                },\n                text: {\n                    show: true,\n                    style: PolygonType.Fill,\n                    size: 12,\n                    paddingLeft: 4,\n                    paddingTop: 4,\n                    paddingRight: 4,\n                    paddingBottom: 4,\n                    borderColor: \"transparent\",\n                    borderStyle: LineType.Solid,\n                    borderSize: 0,\n                    borderDashedValue: [\n                        2,\n                        2\n                    ],\n                    color: Color.WHITE,\n                    family: \"Helvetica Neue\",\n                    weight: \"normal\",\n                    borderRadius: 2\n                }\n            }\n        },\n        tooltip: {\n            offsetLeft: 4,\n            offsetTop: 6,\n            offsetRight: 4,\n            offsetBottom: 6,\n            showRule: TooltipShowRule.Always,\n            showType: TooltipShowType.Standard,\n            custom: [\n                {\n                    title: \"time\",\n                    value: \"{time}\"\n                },\n                {\n                    title: \"open\",\n                    value: \"{open}\"\n                },\n                {\n                    title: \"high\",\n                    value: \"{high}\"\n                },\n                {\n                    title: \"low\",\n                    value: \"{low}\"\n                },\n                {\n                    title: \"close\",\n                    value: \"{close}\"\n                },\n                {\n                    title: \"volume\",\n                    value: \"{volume}\"\n                }\n            ],\n            defaultValue: \"n/a\",\n            rect: {\n                position: CandleTooltipRectPosition.Fixed,\n                paddingLeft: 4,\n                paddingRight: 4,\n                paddingTop: 4,\n                paddingBottom: 4,\n                offsetLeft: 4,\n                offsetTop: 4,\n                offsetRight: 4,\n                offsetBottom: 4,\n                borderRadius: 4,\n                borderSize: 1,\n                borderColor: \"#F2F3F5\",\n                color: \"#FEFEFE\"\n            },\n            text: {\n                size: 12,\n                family: \"Helvetica Neue\",\n                weight: \"normal\",\n                color: Color.GREY,\n                marginLeft: 8,\n                marginTop: 4,\n                marginRight: 8,\n                marginBottom: 4\n            },\n            features: []\n        }\n    };\n}\n/**\n * Get default indicator style\n */ function getDefaultIndicatorStyle() {\n    var alphaGreen = hexToRgb(Color.GREEN, 0.7);\n    var alphaRed = hexToRgb(Color.RED, 0.7);\n    return {\n        ohlc: {\n            compareRule: CandleColorCompareRule.CurrentOpen,\n            upColor: alphaGreen,\n            downColor: alphaRed,\n            noChangeColor: Color.GREY\n        },\n        bars: [\n            {\n                style: PolygonType.Fill,\n                borderStyle: LineType.Solid,\n                borderSize: 1,\n                borderDashedValue: [\n                    2,\n                    2\n                ],\n                upColor: alphaGreen,\n                downColor: alphaRed,\n                noChangeColor: Color.GREY\n            }\n        ],\n        lines: [\n            \"#FF9600\",\n            \"#935EBD\",\n            Color.BLUE,\n            \"#E11D74\",\n            \"#01C5C4\"\n        ].map(function(color) {\n            return {\n                style: LineType.Solid,\n                smooth: false,\n                size: 1,\n                dashedValue: [\n                    2,\n                    2\n                ],\n                color: color\n            };\n        }),\n        circles: [\n            {\n                style: PolygonType.Fill,\n                borderStyle: LineType.Solid,\n                borderSize: 1,\n                borderDashedValue: [\n                    2,\n                    2\n                ],\n                upColor: alphaGreen,\n                downColor: alphaRed,\n                noChangeColor: Color.GREY\n            }\n        ],\n        lastValueMark: {\n            show: false,\n            text: {\n                show: false,\n                style: PolygonType.Fill,\n                color: Color.WHITE,\n                size: 12,\n                family: \"Helvetica Neue\",\n                weight: \"normal\",\n                borderStyle: LineType.Solid,\n                borderColor: \"transparent\",\n                borderSize: 0,\n                borderDashedValue: [\n                    2,\n                    2\n                ],\n                paddingLeft: 4,\n                paddingTop: 4,\n                paddingRight: 4,\n                paddingBottom: 4,\n                borderRadius: 2\n            }\n        },\n        tooltip: {\n            offsetLeft: 4,\n            offsetTop: 6,\n            offsetRight: 4,\n            offsetBottom: 6,\n            showRule: TooltipShowRule.Always,\n            showType: TooltipShowType.Standard,\n            showName: true,\n            showParams: true,\n            defaultValue: \"n/a\",\n            text: {\n                size: 12,\n                family: \"Helvetica Neue\",\n                weight: \"normal\",\n                color: Color.GREY,\n                marginLeft: 8,\n                marginTop: 4,\n                marginRight: 8,\n                marginBottom: 4\n            },\n            features: []\n        }\n    };\n}\nfunction getDefaultAxisStyle() {\n    return {\n        show: true,\n        size: \"auto\",\n        axisLine: {\n            show: true,\n            color: \"#DDDDDD\",\n            size: 1\n        },\n        tickText: {\n            show: true,\n            color: Color.GREY,\n            size: 12,\n            family: \"Helvetica Neue\",\n            weight: \"normal\",\n            marginStart: 4,\n            marginEnd: 6\n        },\n        tickLine: {\n            show: true,\n            size: 1,\n            length: 3,\n            color: \"#DDDDDD\"\n        }\n    };\n}\nfunction getDefaultCrosshairStyle() {\n    function item() {\n        return {\n            show: true,\n            line: {\n                show: true,\n                style: LineType.Dashed,\n                dashedValue: [\n                    4,\n                    2\n                ],\n                size: 1,\n                color: Color.GREY\n            },\n            text: {\n                show: true,\n                style: PolygonType.Fill,\n                color: Color.WHITE,\n                size: 12,\n                family: \"Helvetica Neue\",\n                weight: \"normal\",\n                borderStyle: LineType.Solid,\n                borderDashedValue: [\n                    2,\n                    2\n                ],\n                borderSize: 1,\n                borderColor: Color.GREY,\n                borderRadius: 2,\n                paddingLeft: 4,\n                paddingRight: 4,\n                paddingTop: 4,\n                paddingBottom: 4,\n                backgroundColor: Color.GREY\n            }\n        };\n    }\n    return {\n        show: true,\n        horizontal: item(),\n        vertical: item()\n    };\n}\nfunction getDefaultOverlayStyle() {\n    var pointBorderColor = hexToRgb(Color.BLUE, 0.35);\n    var alphaBg = hexToRgb(Color.BLUE, 0.25);\n    function text() {\n        return {\n            style: PolygonType.Fill,\n            color: Color.WHITE,\n            size: 12,\n            family: \"Helvetica Neue\",\n            weight: \"normal\",\n            borderStyle: LineType.Solid,\n            borderDashedValue: [\n                2,\n                2\n            ],\n            borderSize: 1,\n            borderRadius: 2,\n            borderColor: Color.BLUE,\n            paddingLeft: 4,\n            paddingRight: 4,\n            paddingTop: 4,\n            paddingBottom: 4,\n            backgroundColor: Color.BLUE\n        };\n    }\n    return {\n        point: {\n            color: Color.BLUE,\n            borderColor: pointBorderColor,\n            borderSize: 1,\n            radius: 5,\n            activeColor: Color.BLUE,\n            activeBorderColor: pointBorderColor,\n            activeBorderSize: 3,\n            activeRadius: 5\n        },\n        line: {\n            style: LineType.Solid,\n            smooth: false,\n            color: Color.BLUE,\n            size: 1,\n            dashedValue: [\n                2,\n                2\n            ]\n        },\n        rect: {\n            style: PolygonType.Fill,\n            color: alphaBg,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderRadius: 0,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [\n                2,\n                2\n            ]\n        },\n        polygon: {\n            style: PolygonType.Fill,\n            color: Color.BLUE,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [\n                2,\n                2\n            ]\n        },\n        circle: {\n            style: PolygonType.Fill,\n            color: alphaBg,\n            borderColor: Color.BLUE,\n            borderSize: 1,\n            borderStyle: LineType.Solid,\n            borderDashedValue: [\n                2,\n                2\n            ]\n        },\n        arc: {\n            style: LineType.Solid,\n            color: Color.BLUE,\n            size: 1,\n            dashedValue: [\n                2,\n                2\n            ]\n        },\n        text: text()\n    };\n}\nfunction getDefaultSeparatorStyle() {\n    return {\n        size: 1,\n        color: \"#DDDDDD\",\n        fill: true,\n        activeBackgroundColor: hexToRgb(Color.BLUE, 0.08)\n    };\n}\nfunction getDefaultStyles() {\n    return {\n        grid: getDefaultGridStyle(),\n        candle: getDefaultCandleStyle(),\n        indicator: getDefaultIndicatorStyle(),\n        xAxis: getDefaultAxisStyle(),\n        yAxis: getDefaultAxisStyle(),\n        separator: getDefaultSeparatorStyle(),\n        crosshair: getDefaultCrosshairStyle(),\n        overlay: getDefaultOverlayStyle()\n    };\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DEV = \"development\" === \"development\";\nfunction log(templateText, tagStyle, messageStyle, api, invalidParam, append) {\n    if (DEV) {\n        var apiStr = api !== \"\" ? \"Call api `\".concat(api, \"`\").concat(invalidParam !== \"\" || append !== \"\" ? \", \" : \".\") : \"\";\n        var invalidParamStr = invalidParam !== \"\" ? \"invalid parameter `\".concat(invalidParam, \"`\").concat(append !== \"\" ? \", \" : \".\") : \"\";\n        var appendStr = append !== \"\" ? append : \"\";\n        console.log(templateText, tagStyle, messageStyle, apiStr, invalidParamStr, appendStr);\n    }\n}\nfunction logWarn(api, invalidParam, append) {\n    log(\"%c\\uD83D\\uDE11 klinecharts warning%c %s%s%s\", \"padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#FF9600\", \"color:#FF9600\", api, invalidParam, append !== null && append !== void 0 ? append : \"\");\n}\nfunction logError(api, invalidParam, append) {\n    log(\"%c\\uD83D\\uDE1F klinecharts error%c %s%s%s\", \"padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#F92855;\", \"color:#F92855;\", api, invalidParam, append);\n}\nfunction logTag() {\n    log(\"%c❤️ Welcome to klinecharts. Version is 10.0.0-alpha5\", \"border-radius:4px;border:dashed 1px #1677FF;line-height:70px;padding:0 20px;margin:16px 0;font-size:14px;color:#1677FF;\", \"\", \"\", \"\", \"\");\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp(\"[^.[\\\\]]+\" + \"|\" + \"\\\\[(?:\" + \"([^\\\"'][^[]*)\" + \"|\" + \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" + \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\nfunction formatValue(data, key, defaultValue) {\n    if (isValid(data)) {\n        var path_1 = [];\n        key.replace(rePropName, function(subString) {\n            var args = [];\n            for(var _i = 1; _i < arguments.length; _i++){\n                args[_i - 1] = arguments[_i];\n            }\n            var k = subString;\n            if (isValid(args[1])) {\n                k = args[2].replace(reEscapeChar, \"$1\");\n            } else if (isValid(args[0])) {\n                k = args[0].trim();\n            }\n            path_1.push(k);\n            return \"\";\n        });\n        var value = data;\n        var index = 0;\n        var length_1 = path_1.length;\n        while(isValid(value) && index < length_1){\n            value = value === null || value === void 0 ? void 0 : value[path_1[index++]];\n        }\n        return isValid(value) ? value : defaultValue !== null && defaultValue !== void 0 ? defaultValue : \"--\";\n    }\n    return defaultValue !== null && defaultValue !== void 0 ? defaultValue : \"--\";\n}\nfunction formatTimestampToDateTime(dateTimeFormat, timestamp) {\n    var date = {};\n    dateTimeFormat.formatToParts(new Date(timestamp)).forEach(function(_a) {\n        var type = _a.type, value = _a.value;\n        switch(type){\n            case \"year\":\n                {\n                    date.YYYY = value;\n                    break;\n                }\n            case \"month\":\n                {\n                    date.MM = value;\n                    break;\n                }\n            case \"day\":\n                {\n                    date.DD = value;\n                    break;\n                }\n            case \"hour\":\n                {\n                    date.HH = value === \"24\" ? \"00\" : value;\n                    break;\n                }\n            case \"minute\":\n                {\n                    date.mm = value;\n                    break;\n                }\n            case \"second\":\n                {\n                    date.ss = value;\n                    break;\n                }\n        }\n    });\n    return date;\n}\nfunction formatTimestampToString(dateTimeFormat, timestamp, format) {\n    var date = formatTimestampToDateTime(dateTimeFormat, timestamp);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- ignore\n    return format.replace(/YYYY|MM|DD|HH|mm|ss/g, function(key) {\n        return date[key];\n    });\n}\nfunction formatPrecision(value, precision) {\n    var v = +value;\n    if (isNumber(v)) {\n        return v.toFixed(precision !== null && precision !== void 0 ? precision : 2);\n    }\n    return \"\".concat(value);\n}\nfunction formatBigNumber(value) {\n    var v = +value;\n    if (isNumber(v)) {\n        if (v > 1000000000) {\n            return \"\".concat(+(v / 1000000000).toFixed(3), \"B\");\n        }\n        if (v > 1000000) {\n            return \"\".concat(+(v / 1000000).toFixed(3), \"M\");\n        }\n        if (v > 1000) {\n            return \"\".concat(+(v / 1000).toFixed(3), \"K\");\n        }\n    }\n    return \"\".concat(value);\n}\nfunction formatThousands(value, sign) {\n    var vl = \"\".concat(value);\n    if (sign.length === 0) {\n        return vl;\n    }\n    if (vl.includes(\".\")) {\n        var arr = vl.split(\".\");\n        return \"\".concat(arr[0].replace(/(\\d)(?=(\\d{3})+$)/g, function($1) {\n            return \"\".concat($1).concat(sign);\n        }), \".\").concat(arr[1]);\n    }\n    return vl.replace(/(\\d)(?=(\\d{3})+$)/g, function($1) {\n        return \"\".concat($1).concat(sign);\n    });\n}\nfunction formatFoldDecimal(value, threshold) {\n    var vl = \"\".concat(value);\n    var reg = new RegExp(\"\\\\.0{\" + threshold + \",}[1-9][0-9]*$\");\n    if (reg.test(vl)) {\n        var result = vl.split(\".\");\n        var lastIndex = result.length - 1;\n        var v = result[lastIndex];\n        var match = /0*/.exec(v);\n        if (isValid(match)) {\n            var count = match[0].length;\n            result[lastIndex] = v.replace(/0*/, \"0{\".concat(count, \"}\"));\n            return result.join(\".\");\n        }\n    }\n    return vl;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var measureCtx = null;\n/**\n * Get pixel ratio\n * @param canvas\n * @returns {number}\n */ function getPixelRatio(canvas) {\n    var _a, _b;\n    return (_b = (_a = canvas.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;\n}\nfunction createFont(size, weight, family) {\n    return \"\".concat(weight !== null && weight !== void 0 ? weight : \"normal\", \" \").concat(size !== null && size !== void 0 ? size : 12, \"px \").concat(family !== null && family !== void 0 ? family : \"Helvetica Neue\");\n}\n/**\n * Measure the width of text\n * @param text\n * @returns {number}\n */ function calcTextWidth(text, size, weight, family) {\n    if (!isValid(measureCtx)) {\n        var canvas = document.createElement(\"canvas\");\n        var pixelRatio = getPixelRatio(canvas);\n        measureCtx = canvas.getContext(\"2d\");\n        measureCtx.scale(pixelRatio, pixelRatio);\n    }\n    measureCtx.font = createFont(size, weight, family);\n    return Math.round(measureCtx.measureText(text).width);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var ActionType;\n(function(ActionType) {\n    ActionType[\"OnZoom\"] = \"onZoom\";\n    ActionType[\"OnScroll\"] = \"onScroll\";\n    ActionType[\"OnVisibleRangeChange\"] = \"onVisibleRangeChange\";\n    ActionType[\"OnCandleTooltipFeatureClick\"] = \"onCandleTooltipFeatureClick\";\n    ActionType[\"OnCrosshairChange\"] = \"onCrosshairChange\";\n    ActionType[\"OnCandleBarClick\"] = \"onCandleBarClick\";\n    ActionType[\"OnPaneDrag\"] = \"onPaneDrag\";\n})(ActionType || (ActionType = {}));\nvar Action = /** @class */ function() {\n    function Action() {\n        this._callbacks = [];\n    }\n    Action.prototype.subscribe = function(callback) {\n        var index = this._callbacks.indexOf(callback);\n        if (index < 0) {\n            this._callbacks.push(callback);\n        }\n    };\n    Action.prototype.unsubscribe = function(callback) {\n        if (isFunction(callback)) {\n            var index = this._callbacks.indexOf(callback);\n            if (index > -1) {\n                this._callbacks.splice(index, 1);\n            }\n        } else {\n            this._callbacks = [];\n        }\n    };\n    Action.prototype.execute = function(data) {\n        this._callbacks.forEach(function(callback) {\n            callback(data);\n        });\n    };\n    Action.prototype.isEmpty = function() {\n        return this._callbacks.length === 0;\n    };\n    return Action;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorSeries;\n(function(IndicatorSeries) {\n    IndicatorSeries[\"Normal\"] = \"normal\";\n    IndicatorSeries[\"Price\"] = \"price\";\n    IndicatorSeries[\"Volume\"] = \"volume\";\n})(IndicatorSeries || (IndicatorSeries = {}));\nvar IndicatorEventTarget;\n(function(IndicatorEventTarget) {\n    IndicatorEventTarget[\"Feature\"] = \"feature\";\n})(IndicatorEventTarget || (IndicatorEventTarget = {}));\nvar IndicatorDataState;\n(function(IndicatorDataState) {\n    IndicatorDataState[\"Loading\"] = \"loading\";\n    IndicatorDataState[\"Error\"] = \"error\";\n    IndicatorDataState[\"Ready\"] = \"ready\";\n})(IndicatorDataState || (IndicatorDataState = {}));\nfunction eachFigures(indicator, dataIndex, defaultStyles, eachFigureCallback) {\n    var result = indicator.result;\n    var figures = indicator.figures;\n    var styles = indicator.styles;\n    var circleStyles = formatValue(styles, \"circles\", defaultStyles.circles);\n    var circleStyleCount = circleStyles.length;\n    var barStyles = formatValue(styles, \"bars\", defaultStyles.bars);\n    var barStyleCount = barStyles.length;\n    var lineStyles = formatValue(styles, \"lines\", defaultStyles.lines);\n    var lineStyleCount = lineStyles.length;\n    var circleCount = 0;\n    var barCount = 0;\n    var lineCount = 0;\n    // eslint-disable-next-line @typescript-eslint/init-declarations  -- ignore\n    var defaultFigureStyles;\n    var figureIndex = 0;\n    figures.forEach(function(figure) {\n        var _a;\n        switch(figure.type){\n            case \"circle\":\n                {\n                    figureIndex = circleCount;\n                    var styles_1 = circleStyles[circleCount % circleStyleCount];\n                    defaultFigureStyles = __assign(__assign({}, styles_1), {\n                        color: styles_1.noChangeColor\n                    });\n                    circleCount++;\n                    break;\n                }\n            case \"bar\":\n                {\n                    figureIndex = barCount;\n                    var styles_2 = barStyles[barCount % barStyleCount];\n                    defaultFigureStyles = __assign(__assign({}, styles_2), {\n                        color: styles_2.noChangeColor\n                    });\n                    barCount++;\n                    break;\n                }\n            case \"line\":\n                {\n                    figureIndex = lineCount;\n                    defaultFigureStyles = lineStyles[lineCount % lineStyleCount];\n                    lineCount++;\n                    break;\n                }\n        }\n        if (isValid(figure.type)) {\n            var ss = (_a = figure.styles) === null || _a === void 0 ? void 0 : _a.call(figure, {\n                data: {\n                    prev: result[dataIndex - 1],\n                    current: result[dataIndex],\n                    next: result[dataIndex + 1]\n                },\n                indicator: indicator,\n                defaultStyles: defaultStyles\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n            eachFigureCallback(figure, __assign(__assign({}, defaultFigureStyles), ss), figureIndex);\n        }\n    });\n}\nvar IndicatorImp = /** @class */ function() {\n    function IndicatorImp(indicator) {\n        this.precision = 4;\n        this.calcParams = [];\n        this.shouldOhlc = false;\n        this.shouldFormatBigNumber = false;\n        this.visible = true;\n        this.zLevel = 0;\n        this.series = IndicatorSeries.Normal;\n        this.figures = [];\n        this.minValue = null;\n        this.maxValue = null;\n        this.styles = null;\n        this.shouldUpdate = function(prev, current) {\n            var calc = JSON.stringify(prev.calcParams) !== JSON.stringify(current.calcParams) || prev.figures !== current.figures || prev.calc !== current.calc;\n            var draw = calc || prev.shortName !== current.shortName || prev.series !== current.series || prev.minValue !== current.minValue || prev.maxValue !== current.maxValue || prev.precision !== current.precision || prev.shouldOhlc !== current.shouldOhlc || prev.shouldFormatBigNumber !== current.shouldFormatBigNumber || prev.visible !== current.visible || prev.zLevel !== current.zLevel || prev.extendData !== current.extendData || prev.regenerateFigures !== current.regenerateFigures || prev.createTooltipDataSource !== current.createTooltipDataSource || prev.draw !== current.draw;\n            return {\n                calc: calc,\n                draw: draw\n            };\n        };\n        this.calc = function() {\n            return [];\n        };\n        this.regenerateFigures = null;\n        this.createTooltipDataSource = null;\n        this.draw = null;\n        this.onClick = null;\n        this.onDataStateChange = null;\n        this.result = [];\n        this._lockSeriesPrecision = false;\n        this.override(indicator);\n        this._lockSeriesPrecision = false;\n    }\n    IndicatorImp.prototype.override = function(indicator) {\n        var _a, _b;\n        var _c = this, result = _c.result, currentOthers = __rest(_c, [\n            \"result\"\n        ]);\n        this._prevIndicator = __assign(__assign({}, clone(currentOthers)), {\n            result: result\n        });\n        var id = indicator.id, name = indicator.name, shortName = indicator.shortName, precision = indicator.precision, styles = indicator.styles, figures = indicator.figures, calcParams = indicator.calcParams, others = __rest(indicator, [\n            \"id\",\n            \"name\",\n            \"shortName\",\n            \"precision\",\n            \"styles\",\n            \"figures\",\n            \"calcParams\"\n        ]);\n        if (!isString(this.id) && isString(id)) {\n            this.id = id;\n        }\n        if (!isString(this.name)) {\n            this.name = name !== null && name !== void 0 ? name : \"\";\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition  -- ignore\n        this.shortName = (_a = shortName !== null && shortName !== void 0 ? shortName : this.shortName) !== null && _a !== void 0 ? _a : this.name;\n        if (isNumber(precision)) {\n            this.precision = precision;\n            this._lockSeriesPrecision = true;\n        }\n        if (isValid(styles)) {\n            (_b = this.styles) !== null && _b !== void 0 ? _b : this.styles = {};\n            merge(this.styles, styles);\n        }\n        merge(this, others);\n        if (isValid(calcParams)) {\n            this.calcParams = calcParams;\n            if (isFunction(this.regenerateFigures)) {\n                this.figures = this.regenerateFigures(this.calcParams);\n            }\n        }\n        this.figures = figures !== null && figures !== void 0 ? figures : this.figures;\n    };\n    IndicatorImp.prototype.setSeriesPrecision = function(precision) {\n        if (!this._lockSeriesPrecision) {\n            this.precision = precision;\n        }\n    };\n    IndicatorImp.prototype.shouldUpdateImp = function() {\n        var sort = this._prevIndicator.zLevel !== this.zLevel;\n        var result = this.shouldUpdate(this._prevIndicator, this);\n        if (isBoolean(result)) {\n            return {\n                calc: result,\n                draw: result,\n                sort: sort\n            };\n        }\n        return __assign(__assign({}, result), {\n            sort: sort\n        });\n    };\n    IndicatorImp.prototype.calcImp = function(dataList) {\n        return __awaiter(this, void 0, void 0, function() {\n            var result;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        _a.trys.push([\n                            0,\n                            2,\n                            ,\n                            3\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            this.calc(dataList, this)\n                        ];\n                    case 1:\n                        result = _a.sent();\n                        this.result = result;\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            false\n                        ];\n                    case 3:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    IndicatorImp.extend = function(template) {\n        var Custom = /** @class */ function(_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super.call(this, template) || this;\n            }\n            return Custom;\n        }(IndicatorImp);\n        return Custom;\n    };\n    return IndicatorImp;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var OverlayMode;\n(function(OverlayMode) {\n    OverlayMode[\"Normal\"] = \"normal\";\n    OverlayMode[\"WeakMagnet\"] = \"weak_magnet\";\n    OverlayMode[\"StrongMagnet\"] = \"strong_magnet\";\n})(OverlayMode || (OverlayMode = {}));\nfunction checkOverlayFigureEvent(targetEventType, figure) {\n    var _a;\n    var ignoreEvent = (_a = figure === null || figure === void 0 ? void 0 : figure.ignoreEvent) !== null && _a !== void 0 ? _a : false;\n    if (isBoolean(ignoreEvent)) {\n        return !ignoreEvent;\n    }\n    return !ignoreEvent.includes(targetEventType);\n}\nvar OVERLAY_DRAW_STEP_START = 1;\nvar OVERLAY_DRAW_STEP_FINISHED = -1;\nvar OVERLAY_ID_PREFIX = \"overlay_\";\nvar OVERLAY_FIGURE_KEY_PREFIX = \"overlay_figure_\";\nvar OverlayImp = /** @class */ function() {\n    function OverlayImp(overlay) {\n        this.groupId = \"\";\n        this.totalStep = 1;\n        this.currentStep = OVERLAY_DRAW_STEP_START;\n        this.lock = false;\n        this.visible = true;\n        this.zLevel = 0;\n        this.needDefaultPointFigure = false;\n        this.needDefaultXAxisFigure = false;\n        this.needDefaultYAxisFigure = false;\n        this.mode = OverlayMode.Normal;\n        this.modeSensitivity = 8;\n        this.points = [];\n        this.styles = null;\n        this.createPointFigures = null;\n        this.createXAxisFigures = null;\n        this.createYAxisFigures = null;\n        this.performEventPressedMove = null;\n        this.performEventMoveForDrawing = null;\n        this.onDrawStart = null;\n        this.onDrawing = null;\n        this.onDrawEnd = null;\n        this.onClick = null;\n        this.onDoubleClick = null;\n        this.onRightClick = null;\n        this.onPressedMoveStart = null;\n        this.onPressedMoving = null;\n        this.onPressedMoveEnd = null;\n        this.onMouseEnter = null;\n        this.onMouseLeave = null;\n        this.onRemoved = null;\n        this.onSelected = null;\n        this.onDeselected = null;\n        this._prevZLevel = 0;\n        this._prevPressedPoint = null;\n        this._prevPressedPoints = [];\n        this.override(overlay);\n    }\n    OverlayImp.prototype.override = function(overlay) {\n        var _a, _b;\n        this._prevOverlay = clone(this);\n        var id = overlay.id, name = overlay.name;\n        overlay.currentStep;\n        var points = overlay.points, styles = overlay.styles, others = __rest(overlay, [\n            \"id\",\n            \"name\",\n            \"currentStep\",\n            \"points\",\n            \"styles\"\n        ]);\n        merge(this, others);\n        if (!isString(this.name)) {\n            this.name = name !== null && name !== void 0 ? name : \"\";\n        }\n        if (!isString(this.id) && isString(id)) {\n            this.id = id;\n        }\n        if (isValid(styles)) {\n            (_a = this.styles) !== null && _a !== void 0 ? _a : this.styles = {};\n            merge(this.styles, styles);\n        }\n        if (isArray(points) && points.length > 0) {\n            var repeatTotalStep = 0;\n            this.points = __spreadArray([], __read(points), false);\n            if (points.length >= this.totalStep - 1) {\n                this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n                repeatTotalStep = this.totalStep - 1;\n            } else {\n                this.currentStep = points.length + 1;\n                repeatTotalStep = points.length;\n            }\n            // Prevent wrong drawing due to wrong points\n            if (isFunction(this.performEventMoveForDrawing)) {\n                for(var i = 0; i < repeatTotalStep; i++){\n                    this.performEventMoveForDrawing({\n                        currentStep: i + 2,\n                        mode: this.mode,\n                        points: this.points,\n                        performPointIndex: i,\n                        performPoint: this.points[i]\n                    });\n                }\n            }\n            if (this.currentStep === OVERLAY_DRAW_STEP_FINISHED) {\n                (_b = this.performEventPressedMove) === null || _b === void 0 ? void 0 : _b.call(this, {\n                    currentStep: this.currentStep,\n                    mode: this.mode,\n                    points: this.points,\n                    performPointIndex: this.points.length - 1,\n                    performPoint: this.points[this.points.length - 1]\n                });\n            }\n        }\n    };\n    OverlayImp.prototype.getPrevZLevel = function() {\n        return this._prevZLevel;\n    };\n    OverlayImp.prototype.setPrevZLevel = function(zLevel) {\n        this._prevZLevel = zLevel;\n    };\n    OverlayImp.prototype.shouldUpdate = function() {\n        var sort = this._prevOverlay.zLevel !== this.zLevel;\n        var draw = sort || JSON.stringify(this._prevOverlay) !== JSON.stringify(this.points) || this._prevOverlay.visible !== this.visible || this._prevOverlay.extendData !== this.extendData || this._prevOverlay.styles !== this.styles;\n        return {\n            sort: sort,\n            draw: draw\n        };\n    };\n    OverlayImp.prototype.nextStep = function() {\n        if (this.currentStep === this.totalStep - 1) {\n            this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n        } else {\n            this.currentStep++;\n        }\n    };\n    OverlayImp.prototype.forceComplete = function() {\n        this.currentStep = OVERLAY_DRAW_STEP_FINISHED;\n    };\n    OverlayImp.prototype.isDrawing = function() {\n        return this.currentStep !== OVERLAY_DRAW_STEP_FINISHED;\n    };\n    OverlayImp.prototype.isStart = function() {\n        return this.currentStep === OVERLAY_DRAW_STEP_START;\n    };\n    OverlayImp.prototype.eventMoveForDrawing = function(point) {\n        var _a;\n        var pointIndex = this.currentStep - 1;\n        var newPoint = {};\n        if (isNumber(point.timestamp)) {\n            newPoint.timestamp = point.timestamp;\n        }\n        if (isNumber(point.dataIndex)) {\n            newPoint.dataIndex = point.dataIndex;\n        }\n        if (isNumber(point.value)) {\n            newPoint.value = point.value;\n        }\n        this.points[pointIndex] = newPoint;\n        (_a = this.performEventMoveForDrawing) === null || _a === void 0 ? void 0 : _a.call(this, {\n            currentStep: this.currentStep,\n            mode: this.mode,\n            points: this.points,\n            performPointIndex: pointIndex,\n            performPoint: newPoint\n        });\n    };\n    OverlayImp.prototype.eventPressedPointMove = function(point, pointIndex) {\n        var _a;\n        this.points[pointIndex].timestamp = point.timestamp;\n        if (isNumber(point.value)) {\n            this.points[pointIndex].value = point.value;\n        }\n        (_a = this.performEventPressedMove) === null || _a === void 0 ? void 0 : _a.call(this, {\n            currentStep: this.currentStep,\n            points: this.points,\n            mode: this.mode,\n            performPointIndex: pointIndex,\n            performPoint: this.points[pointIndex]\n        });\n    };\n    OverlayImp.prototype.startPressedMove = function(point) {\n        this._prevPressedPoint = __assign({}, point);\n        this._prevPressedPoints = clone(this.points);\n    };\n    OverlayImp.prototype.eventPressedOtherMove = function(point, chartStore) {\n        if (this._prevPressedPoint !== null) {\n            var difDataIndex_1 = null;\n            if (isNumber(point.dataIndex) && isNumber(this._prevPressedPoint.dataIndex)) {\n                difDataIndex_1 = point.dataIndex - this._prevPressedPoint.dataIndex;\n            }\n            var difValue_1 = null;\n            if (isNumber(point.value) && isNumber(this._prevPressedPoint.value)) {\n                difValue_1 = point.value - this._prevPressedPoint.value;\n            }\n            this.points = this._prevPressedPoints.map(function(p) {\n                var _a;\n                if (isNumber(p.timestamp)) {\n                    p.dataIndex = chartStore.timestampToDataIndex(p.timestamp);\n                }\n                var newPoint = __assign({}, p);\n                if (isNumber(difDataIndex_1) && isNumber(p.dataIndex)) {\n                    newPoint.dataIndex = p.dataIndex + difDataIndex_1;\n                    newPoint.timestamp = (_a = chartStore.dataIndexToTimestamp(newPoint.dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (isNumber(difValue_1) && isNumber(p.value)) {\n                    newPoint.value = p.value + difValue_1;\n                }\n                return newPoint;\n            });\n        }\n    };\n    OverlayImp.extend = function(template) {\n        var Custom = /** @class */ function(_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super.call(this, template) || this;\n            }\n            return Custom;\n        }(OverlayImp);\n        return Custom;\n    };\n    return OverlayImp;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var FormatDateType;\n(function(FormatDateType) {\n    FormatDateType[FormatDateType[\"Tooltip\"] = 0] = \"Tooltip\";\n    FormatDateType[FormatDateType[\"Crosshair\"] = 1] = \"Crosshair\";\n    FormatDateType[FormatDateType[\"XAxis\"] = 2] = \"XAxis\";\n})(FormatDateType || (FormatDateType = {}));\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function createDefaultBounding(bounding) {\n    var defaultBounding = {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    if (isValid(bounding)) {\n        merge(defaultBounding, bounding);\n    }\n    return defaultBounding;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DEFAULT_REQUEST_ID = -1;\nfunction requestAnimationFrame(fn) {\n    if (isFunction(window.requestAnimationFrame)) {\n        return window.requestAnimationFrame(fn);\n    }\n    return window.setTimeout(fn, 20);\n}\nfunction cancelAnimationFrame(id) {\n    if (isFunction(window.cancelAnimationFrame)) {\n        window.cancelAnimationFrame(id);\n    } else {\n        window.clearTimeout(id);\n    }\n}\nfunction requestIdleCallback(fn) {\n    if (isFunction(window.requestIdleCallback)) {\n        return window.requestIdleCallback(fn);\n    }\n    var startTime = performance.now();\n    return window.setTimeout(function() {\n        fn({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (performance.now() - startTime));\n            }\n        });\n    }, 1);\n}\nfunction cancelIdleCallback(id) {\n    if (isFunction(window.cancelIdleCallback)) {\n        window.cancelIdleCallback(id);\n    } else {\n        window.clearTimeout(id);\n    }\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var Animation = /** @class */ function() {\n    function Animation(options) {\n        this._options = {\n            duration: 500,\n            iterationCount: 1\n        };\n        this._currentIterationCount = 0;\n        this._running = false;\n        this._time = 0;\n        merge(this._options, options);\n    }\n    Animation.prototype._loop = function() {\n        var _this = this;\n        this._running = true;\n        var step = function() {\n            var _a;\n            if (_this._running) {\n                var diffTime = new Date().getTime() - _this._time;\n                if (diffTime < _this._options.duration) {\n                    (_a = _this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(_this, diffTime);\n                    requestAnimationFrame(step);\n                } else {\n                    _this.stop();\n                    _this._currentIterationCount++;\n                    if (_this._currentIterationCount < _this._options.iterationCount) {\n                        _this.start();\n                    }\n                }\n            }\n        };\n        requestAnimationFrame(step);\n    };\n    Animation.prototype.doFrame = function(callback) {\n        this._doFrameCallback = callback;\n        return this;\n    };\n    Animation.prototype.setDuration = function(duration) {\n        this._options.duration = duration;\n        return this;\n    };\n    Animation.prototype.setIterationCount = function(iterationCount) {\n        this._options.iterationCount = iterationCount;\n        return this;\n    };\n    Animation.prototype.start = function() {\n        if (!this._running) {\n            this._time = new Date().getTime();\n            this._loop();\n        }\n    };\n    Animation.prototype.stop = function() {\n        var _a;\n        if (this._running) {\n            (_a = this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(this, this._options.duration);\n        }\n        this._running = false;\n    };\n    return Animation;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var baseId = 1;\nvar prevIdTimestamp = new Date().getTime();\nfunction createId(prefix) {\n    var timestamp = new Date().getTime();\n    if (timestamp === prevIdTimestamp) {\n        ++baseId;\n    } else {\n        baseId = 1;\n    }\n    prevIdTimestamp = timestamp;\n    return \"\".concat(prefix !== null && prefix !== void 0 ? prefix : \"\").concat(timestamp, \"_\").concat(baseId);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Create dom\n * @param tagName\n * @param styles\n * @return {*}\n */ function createDom(tagName, styles) {\n    var _a;\n    var dom = document.createElement(tagName);\n    var s = styles !== null && styles !== void 0 ? styles : {};\n    // eslint-disable-next-line guard-for-in -- ignore\n    for(var key in s){\n        dom.style[key] = (_a = s[key]) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return dom;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Binary search for the nearest result\n * @param dataList\n * @param valueKey\n * @param targetValue\n * @return {number}\n */ function binarySearchNearest(dataList, valueKey, targetValue) {\n    var left = 0;\n    var right = 0;\n    for(right = dataList.length - 1; left !== right;){\n        var midIndex = Math.floor((right + left) / 2);\n        var mid = right - left;\n        var midValue = dataList[midIndex][valueKey];\n        if (targetValue === dataList[left][valueKey]) {\n            return left;\n        }\n        if (targetValue === dataList[right][valueKey]) {\n            return right;\n        }\n        if (targetValue === midValue) {\n            return midIndex;\n        }\n        if (targetValue > midValue) {\n            left = midIndex;\n        } else {\n            right = midIndex;\n        }\n        if (mid <= 2) {\n            break;\n        }\n    }\n    return left;\n}\n/**\n * 优化数字\n * @param value\n * @return {number|number}\n */ function nice(value) {\n    var exponent = Math.floor(log10(value));\n    var exp10 = index10(exponent);\n    var f = value / exp10; // 1 <= f < 10\n    var nf = 0;\n    if (f < 1.5) {\n        nf = 1;\n    } else if (f < 2.5) {\n        nf = 2;\n    } else if (f < 3.5) {\n        nf = 3;\n    } else if (f < 4.5) {\n        nf = 4;\n    } else if (f < 5.5) {\n        nf = 5;\n    } else if (f < 6.5) {\n        nf = 6;\n    } else {\n        nf = 8;\n    }\n    value = nf * exp10;\n    return +value.toFixed(Math.abs(exponent));\n}\n/**\n * Round\n * @param value\n * @param precision\n * @return {number}\n */ function round(value, precision) {\n    precision = Math.max(0, precision !== null && precision !== void 0 ? precision : 0);\n    var pow = Math.pow(10, precision);\n    return Math.round(value * pow) / pow;\n}\n/**\n * Get precision\n * @param value\n * @return {number|number}\n */ function getPrecision(value) {\n    var str = value.toString();\n    var eIndex = str.indexOf(\"e\");\n    if (eIndex > 0) {\n        var precision = +str.slice(eIndex + 1);\n        return precision < 0 ? -precision : 0;\n    }\n    var dotIndex = str.indexOf(\".\");\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n}\nfunction getMaxMin(dataList, maxKey, minKey) {\n    var _a, _b;\n    var maxMin = [\n        Number.MIN_SAFE_INTEGER,\n        Number.MAX_SAFE_INTEGER\n    ];\n    var dataLength = dataList.length;\n    var index = 0;\n    while(index < dataLength){\n        var data = dataList[index];\n        maxMin[0] = Math.max((_a = data[maxKey]) !== null && _a !== void 0 ? _a : Number.MIN_SAFE_INTEGER, maxMin[0]);\n        maxMin[1] = Math.min((_b = data[minKey]) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER, maxMin[1]);\n        ++index;\n    }\n    return maxMin;\n}\n/**\n * log10\n * @param value\n * @return {number}\n */ function log10(value) {\n    if (value === 0) {\n        return 0;\n    }\n    return Math.log10(value);\n}\n/**\n * index 10\n * @param value\n * @return {number}\n */ function index10(value) {\n    return Math.pow(10, value);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var LoadDataType;\n(function(LoadDataType) {\n    LoadDataType[\"Init\"] = \"init\";\n    LoadDataType[\"Forward\"] = \"forward\";\n    LoadDataType[\"Backward\"] = \"backward\";\n    LoadDataType[\"Update\"] = \"update\";\n})(LoadDataType || (LoadDataType = {}));\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getDefaultVisibleRange() {\n    return {\n        from: 0,\n        to: 0,\n        realFrom: 0,\n        realTo: 0\n    };\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function generateTaskId() {\n    var params = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        params[_i] = arguments[_i];\n    }\n    return params.join(\"_\");\n}\nvar TaskScheduler = /** @class */ function() {\n    function TaskScheduler(tasks) {\n        this._requestIdleCallbackId = DEFAULT_REQUEST_ID;\n        this._tasks = tasks !== null && tasks !== void 0 ? tasks : [];\n        this._operateTasks();\n    }\n    TaskScheduler.prototype._operateTasks = function(fn) {\n        var _this = this;\n        if (this._requestIdleCallbackId !== DEFAULT_REQUEST_ID) {\n            cancelIdleCallback(this._requestIdleCallbackId);\n            this._requestIdleCallbackId = DEFAULT_REQUEST_ID;\n        }\n        fn === null || fn === void 0 ? void 0 : fn();\n        this._requestIdleCallbackId = requestIdleCallback(function(deadline) {\n            _this._runTasks(deadline);\n        });\n    };\n    TaskScheduler.prototype._runTasks = function(deadline) {\n        var _this = this;\n        while(deadline.timeRemaining() > 0 && this._tasks.length > 0){\n            var task = this._tasks.shift();\n            task === null || task === void 0 ? void 0 : task.handler();\n        }\n        if (this._tasks.length > 0) {\n            this._requestIdleCallbackId = requestIdleCallback(function(deadline) {\n                _this._runTasks(deadline);\n            });\n        }\n    };\n    TaskScheduler.prototype.addTask = function(task) {\n        var _this = this;\n        this._operateTasks(function() {\n            var index = _this._tasks.findIndex(function(t) {\n                return t.id === task.id;\n            });\n            if (index > -1) {\n                _this._tasks[index] = task;\n            } else {\n                _this._tasks.push(task);\n            }\n        });\n        return this;\n    };\n    TaskScheduler.prototype.removeTask = function(id) {\n        var _this = this;\n        this._operateTasks(function() {\n            var index = _this._tasks.findIndex(function(t) {\n                return t.id === id;\n            });\n            if (index > -1) {\n                _this._tasks.splice(index, 1);\n            }\n        });\n        return this;\n    };\n    return TaskScheduler;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var TimeWeightConstants = {\n    Year: 365 * 24 * 3600,\n    Month: 30 * 24 * 3600,\n    Day: 24 * 3600,\n    Hour: 3600,\n    Minute: 60,\n    Second: 1\n};\nfunction classifyTimeWeightTicks(map, dataList, dateTimeFormat, baseDataIndex, minTimeSpan, startTimestamp) {\n    var _a;\n    if (baseDataIndex === void 0) {\n        baseDataIndex = 0;\n    }\n    var prevDateTime = null;\n    var prevTimestamp = startTimestamp !== null && startTimestamp !== void 0 ? startTimestamp : null;\n    for(var i = 0; i < dataList.length; i++){\n        var timestamp = dataList[i].timestamp;\n        var weight = TimeWeightConstants.Minute;\n        var dateTime = formatTimestampToDateTime(dateTimeFormat, timestamp);\n        if (isValid(prevDateTime)) {\n            if (dateTime.YYYY !== prevDateTime.YYYY) {\n                weight = TimeWeightConstants.Year;\n            } else if (dateTime.MM !== prevDateTime.MM) {\n                weight = TimeWeightConstants.Month;\n            } else if (dateTime.DD !== prevDateTime.DD) {\n                weight = TimeWeightConstants.Day;\n            } else if (dateTime.HH !== prevDateTime.HH) {\n                weight = TimeWeightConstants.Hour;\n            } else if (dateTime.mm !== prevDateTime.mm) {\n                weight = TimeWeightConstants.Minute;\n            } else {\n                weight = TimeWeightConstants.Second;\n            }\n        }\n        if (isNumber(prevTimestamp) && isNumber(minTimeSpan === null || minTimeSpan === void 0 ? void 0 : minTimeSpan.compare)) {\n            minTimeSpan.compare = Math.min(minTimeSpan.compare, timestamp - prevTimestamp);\n        }\n        var currentTimeWeightList = (_a = map.get(weight)) !== null && _a !== void 0 ? _a : [];\n        currentTimeWeightList.push({\n            dataIndex: i + baseDataIndex,\n            weight: weight,\n            timestamp: timestamp\n        });\n        map.set(weight, currentTimeWeightList);\n        prevDateTime = dateTime;\n        prevTimestamp = timestamp;\n    }\n}\nfunction calcBetweenTimeWeightTickBarCount(barSpace, textStyles) {\n    var space = Math.max(calcTextWidth(\"0000-00-00 00:00:00\", textStyles.size, textStyles.weight, textStyles.family), 146);\n    return Math.ceil(space / barSpace);\n}\nfunction createTimeWeightTickList(map, barSpace, textStyles) {\n    var barCount = calcBetweenTimeWeightTickBarCount(barSpace, textStyles);\n    var optTimeWeightTickList = [];\n    Array.from(map.keys()).sort(function(w1, w2) {\n        return w2 - w1;\n    }).forEach(function(weight) {\n        var currentTimeWeightTickList = map.get(weight);\n        var prevOptTimeWeightTickList = optTimeWeightTickList;\n        optTimeWeightTickList = [];\n        var prevOptTimeWeightTickListLength = prevOptTimeWeightTickList.length;\n        var prevOptTimeWeightTickListPointer = 0;\n        var currentTimeWeightTickListLength = currentTimeWeightTickList.length;\n        var rightIndex = Infinity;\n        var leftIndex = -Infinity;\n        for(var i = 0; i < currentTimeWeightTickListLength; i++){\n            var timeWeightTick = currentTimeWeightTickList[i];\n            var currentIndex = timeWeightTick.dataIndex;\n            while(prevOptTimeWeightTickListPointer < prevOptTimeWeightTickListLength){\n                var lastTimeWeightTick = prevOptTimeWeightTickList[prevOptTimeWeightTickListPointer];\n                var lastIndex = lastTimeWeightTick.dataIndex;\n                if (lastIndex < currentIndex) {\n                    prevOptTimeWeightTickListPointer++;\n                    optTimeWeightTickList.push(lastTimeWeightTick);\n                    leftIndex = lastIndex;\n                    rightIndex = Infinity;\n                } else {\n                    rightIndex = lastIndex;\n                    break;\n                }\n            }\n            if (rightIndex - currentIndex >= barCount && currentIndex - leftIndex >= barCount) {\n                optTimeWeightTickList.push(timeWeightTick);\n                leftIndex = currentIndex;\n            }\n        }\n        for(; prevOptTimeWeightTickListPointer < prevOptTimeWeightTickListLength; prevOptTimeWeightTickListPointer++){\n            optTimeWeightTickList.push(prevOptTimeWeightTickList[prevOptTimeWeightTickListPointer]);\n        }\n    });\n    return optTimeWeightTickList;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * average price\n */ var averagePrice = {\n    name: \"AVP\",\n    shortName: \"AVP\",\n    series: IndicatorSeries.Price,\n    precision: 2,\n    figures: [\n        {\n            key: \"avp\",\n            title: \"AVP: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList) {\n        var totalTurnover = 0;\n        var totalVolume = 0;\n        return dataList.map(function(kLineData) {\n            var _a, _b;\n            var avp = {};\n            var turnover = (_a = kLineData.turnover) !== null && _a !== void 0 ? _a : 0;\n            var volume = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;\n            totalTurnover += turnover;\n            totalVolume += volume;\n            if (totalVolume !== 0) {\n                avp.avp = totalTurnover / totalVolume;\n            }\n            return avp;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var awesomeOscillator = {\n    name: \"AO\",\n    shortName: \"AO\",\n    calcParams: [\n        5,\n        34\n    ],\n    figures: [\n        {\n            key: \"ao\",\n            title: \"AO: \",\n            type: \"bar\",\n            baseValue: 0,\n            styles: function(_a) {\n                var _b, _c;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var prev = data.prev, current = data.current;\n                var prevAo = (_b = prev === null || prev === void 0 ? void 0 : prev.ao) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var currentAo = (_c = current === null || current === void 0 ? void 0 : current.ao) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;\n                var color = \"\";\n                if (currentAo > prevAo) {\n                    color = formatValue(indicator.styles, \"bars[0].upColor\", defaultStyles.bars[0].upColor);\n                } else {\n                    color = formatValue(indicator.styles, \"bars[0].downColor\", defaultStyles.bars[0].downColor);\n                }\n                var style = currentAo > prevAo ? PolygonType.Stroke : PolygonType.Fill;\n                return {\n                    color: color,\n                    style: style,\n                    borderColor: color\n                };\n            }\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max(params[0], params[1]);\n        var shortSum = 0;\n        var longSum = 0;\n        var short = 0;\n        var long = 0;\n        return dataList.map(function(kLineData, i) {\n            var ao = {};\n            var middle = (kLineData.low + kLineData.high) / 2;\n            shortSum += middle;\n            longSum += middle;\n            if (i >= params[0] - 1) {\n                short = shortSum / params[0];\n                var agoKLineData = dataList[i - (params[0] - 1)];\n                shortSum -= (agoKLineData.low + agoKLineData.high) / 2;\n            }\n            if (i >= params[1] - 1) {\n                long = longSum / params[1];\n                var agoKLineData = dataList[i - (params[1] - 1)];\n                longSum -= (agoKLineData.low + agoKLineData.high) / 2;\n            }\n            if (i >= maxPeriod - 1) {\n                ao.ao = short - long;\n            }\n            return ao;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * BIAS\n * 乖离率=[(当日收盘价-N日平均价)/N日平均价]*100%\n */ var bias = {\n    name: \"BIAS\",\n    shortName: \"BIAS\",\n    calcParams: [\n        6,\n        12,\n        24\n    ],\n    figures: [\n        {\n            key: \"bias1\",\n            title: \"BIAS6: \",\n            type: \"line\"\n        },\n        {\n            key: \"bias2\",\n            title: \"BIAS12: \",\n            type: \"line\"\n        },\n        {\n            key: \"bias3\",\n            title: \"BIAS24: \",\n            type: \"line\"\n        }\n    ],\n    regenerateFigures: function(params) {\n        return params.map(function(p, i) {\n            return {\n                key: \"bias\".concat(i + 1),\n                title: \"BIAS\".concat(p, \": \"),\n                type: \"line\"\n            };\n        });\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSums = [];\n        return dataList.map(function(kLineData, i) {\n            var bias = {};\n            var close = kLineData.close;\n            params.forEach(function(p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    var mean = closeSums[index] / params[index];\n                    bias[figures[index].key] = (close - mean) / mean * 100;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            return bias;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * 计算布林指标中的标准差\n * @param dataList\n * @param ma\n * @return {number}\n */ function getBollMd(dataList, ma) {\n    var dataSize = dataList.length;\n    var sum = 0;\n    dataList.forEach(function(data) {\n        var closeMa = data.close - ma;\n        sum += closeMa * closeMa;\n    });\n    sum = Math.abs(sum);\n    return Math.sqrt(sum / dataSize);\n}\n/**\n * BOLL\n */ var bollingerBands = {\n    name: \"BOLL\",\n    shortName: \"BOLL\",\n    series: IndicatorSeries.Price,\n    calcParams: [\n        20,\n        2\n    ],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        {\n            key: \"up\",\n            title: \"UP: \",\n            type: \"line\"\n        },\n        {\n            key: \"mid\",\n            title: \"MID: \",\n            type: \"line\"\n        },\n        {\n            key: \"dn\",\n            title: \"DN: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var p = params[0] - 1;\n        var closeSum = 0;\n        return dataList.map(function(kLineData, i) {\n            var close = kLineData.close;\n            var boll = {};\n            closeSum += close;\n            if (i >= p) {\n                boll.mid = closeSum / params[0];\n                var md = getBollMd(dataList.slice(i - p, i + 1), boll.mid);\n                boll.up = boll.mid + params[1] * md;\n                boll.dn = boll.mid - params[1] * md;\n                closeSum -= dataList[i - p].close;\n            }\n            return boll;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * BRAR\n * 默认参数是26。\n * 公式N日BR=N日内（H－CY）之和除以N日内（CY－L）之和*100，\n * 其中，H为当日最高价，L为当日最低价，CY为前一交易日的收盘价，N为设定的时间参数。\n * N日AR=(N日内（H－O）之和除以N日内（O－L）之和)*100，\n * 其中，H为当日最高价，L为当日最低价，O为当日开盘价，N为设定的时间参数\n *\n */ var brar = {\n    name: \"BRAR\",\n    shortName: \"BRAR\",\n    calcParams: [\n        26\n    ],\n    figures: [\n        {\n            key: \"br\",\n            title: \"BR: \",\n            type: \"line\"\n        },\n        {\n            key: \"ar\",\n            title: \"AR: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var hcy = 0;\n        var cyl = 0;\n        var ho = 0;\n        var ol = 0;\n        return dataList.map(function(kLineData, i) {\n            var _a, _b;\n            var brar = {};\n            var high = kLineData.high;\n            var low = kLineData.low;\n            var open = kLineData.open;\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            ho += high - open;\n            ol += open - low;\n            hcy += high - prevClose;\n            cyl += prevClose - low;\n            if (i >= params[0] - 1) {\n                if (ol !== 0) {\n                    brar.ar = ho / ol * 100;\n                } else {\n                    brar.ar = 0;\n                }\n                if (cyl !== 0) {\n                    brar.br = hcy / cyl * 100;\n                } else {\n                    brar.br = 0;\n                }\n                var agoKLineData = dataList[i - (params[0] - 1)];\n                var agoHigh = agoKLineData.high;\n                var agoLow = agoKLineData.low;\n                var agoOpen = agoKLineData.open;\n                var agoPreClose = ((_b = dataList[i - params[0]]) !== null && _b !== void 0 ? _b : dataList[i - (params[0] - 1)]).close;\n                hcy -= agoHigh - agoPreClose;\n                cyl -= agoPreClose - agoLow;\n                ho -= agoHigh - agoOpen;\n                ol -= agoOpen - agoLow;\n            }\n            return brar;\n        });\n    }\n};\n/**\n * 多空指标\n * 公式: BBI = (MA(CLOSE, M) + MA(CLOSE, N) + MA(CLOSE, O) + MA(CLOSE, P)) / 4\n *\n */ var bullAndBearIndex = {\n    name: \"BBI\",\n    shortName: \"BBI\",\n    series: IndicatorSeries.Price,\n    precision: 2,\n    calcParams: [\n        3,\n        6,\n        12,\n        24\n    ],\n    shouldOhlc: true,\n    figures: [\n        {\n            key: \"bbi\",\n            title: \"BBI: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max.apply(Math, __spreadArray([], __read(params), false));\n        var closeSums = [];\n        var mas = [];\n        return dataList.map(function(kLineData, i) {\n            var bbi = {};\n            var close = kLineData.close;\n            params.forEach(function(p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    mas[index] = closeSums[index] / p;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            if (i >= maxPeriod - 1) {\n                var maSum_1 = 0;\n                mas.forEach(function(ma) {\n                    maSum_1 += ma;\n                });\n                bbi.bbi = maSum_1 / 4;\n            }\n            return bbi;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * CCI\n * CCI（N日）=（TP－MA）÷MD÷0.015\n * 其中，TP=（最高价+最低价+收盘价）÷3\n * MA=近N日TP价的累计之和÷N\n * MD=近N日TP - 当前MA绝对值的累计之和÷N\n *\n */ var commodityChannelIndex = {\n    name: \"CCI\",\n    shortName: \"CCI\",\n    calcParams: [\n        20\n    ],\n    figures: [\n        {\n            key: \"cci\",\n            title: \"CCI: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var p = params[0] - 1;\n        var tpSum = 0;\n        var tpList = [];\n        return dataList.map(function(kLineData, i) {\n            var cci = {};\n            var tp = (kLineData.high + kLineData.low + kLineData.close) / 3;\n            tpSum += tp;\n            tpList.push(tp);\n            if (i >= p) {\n                var maTp_1 = tpSum / params[0];\n                var sliceTpList = tpList.slice(i - p, i + 1);\n                var sum_1 = 0;\n                sliceTpList.forEach(function(tp) {\n                    sum_1 += Math.abs(tp - maTp_1);\n                });\n                var md = sum_1 / params[0];\n                cci.cci = md !== 0 ? (tp - maTp_1) / md / 0.015 : 0;\n                var agoTp = (dataList[i - p].high + dataList[i - p].low + dataList[i - p].close) / 3;\n                tpSum -= agoTp;\n            }\n            return cci;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http:*www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * MID:=REF(HIGH+LOW,1)/2;\n * CR:SUM(MAX(0,HIGH-MID),N)/SUM(MAX(0,MID-LOW),N)*100;\n * MA1:REF(MA(CR,M1),M1/2.5+1);\n * MA2:REF(MA(CR,M2),M2/2.5+1);\n * MA3:REF(MA(CR,M3),M3/2.5+1);\n * MA4:REF(MA(CR,M4),M4/2.5+1);\n * MID赋值:(昨日最高价+昨日最低价)/2\n * 输出带状能量线:0和最高价-MID的较大值的N日累和/0和MID-最低价的较大值的N日累和*100\n * 输出MA1:M1(5)/2.5+1日前的CR的M1(5)日简单移动平均\n * 输出MA2:M2(10)/2.5+1日前的CR的M2(10)日简单移动平均\n * 输出MA3:M3(20)/2.5+1日前的CR的M3(20)日简单移动平均\n * 输出MA4:M4/2.5+1日前的CR的M4日简单移动平均\n *\n */ var currentRatio = {\n    name: \"CR\",\n    shortName: \"CR\",\n    calcParams: [\n        26,\n        10,\n        20,\n        40,\n        60\n    ],\n    figures: [\n        {\n            key: \"cr\",\n            title: \"CR: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma1\",\n            title: \"MA1: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma2\",\n            title: \"MA2: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma3\",\n            title: \"MA3: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma4\",\n            title: \"MA4: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var ma1ForwardPeriod = Math.ceil(params[1] / 2.5 + 1);\n        var ma2ForwardPeriod = Math.ceil(params[2] / 2.5 + 1);\n        var ma3ForwardPeriod = Math.ceil(params[3] / 2.5 + 1);\n        var ma4ForwardPeriod = Math.ceil(params[4] / 2.5 + 1);\n        var ma1Sum = 0;\n        var ma1List = [];\n        var ma2Sum = 0;\n        var ma2List = [];\n        var ma3Sum = 0;\n        var ma3List = [];\n        var ma4Sum = 0;\n        var ma4List = [];\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b, _c, _d, _e;\n            var cr = {};\n            var prevData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            var prevMid = (prevData.high + prevData.close + prevData.low + prevData.open) / 4;\n            var highSubPreMid = Math.max(0, kLineData.high - prevMid);\n            var preMidSubLow = Math.max(0, prevMid - kLineData.low);\n            if (i >= params[0] - 1) {\n                if (preMidSubLow !== 0) {\n                    cr.cr = highSubPreMid / preMidSubLow * 100;\n                } else {\n                    cr.cr = 0;\n                }\n                ma1Sum += cr.cr;\n                ma2Sum += cr.cr;\n                ma3Sum += cr.cr;\n                ma4Sum += cr.cr;\n                if (i >= params[0] + params[1] - 2) {\n                    ma1List.push(ma1Sum / params[1]);\n                    if (i >= params[0] + params[1] + ma1ForwardPeriod - 3) {\n                        cr.ma1 = ma1List[ma1List.length - 1 - ma1ForwardPeriod];\n                    }\n                    ma1Sum -= (_b = result[i - (params[1] - 1)].cr) !== null && _b !== void 0 ? _b : 0;\n                }\n                if (i >= params[0] + params[2] - 2) {\n                    ma2List.push(ma2Sum / params[2]);\n                    if (i >= params[0] + params[2] + ma2ForwardPeriod - 3) {\n                        cr.ma2 = ma2List[ma2List.length - 1 - ma2ForwardPeriod];\n                    }\n                    ma2Sum -= (_c = result[i - (params[2] - 1)].cr) !== null && _c !== void 0 ? _c : 0;\n                }\n                if (i >= params[0] + params[3] - 2) {\n                    ma3List.push(ma3Sum / params[3]);\n                    if (i >= params[0] + params[3] + ma3ForwardPeriod - 3) {\n                        cr.ma3 = ma3List[ma3List.length - 1 - ma3ForwardPeriod];\n                    }\n                    ma3Sum -= (_d = result[i - (params[3] - 1)].cr) !== null && _d !== void 0 ? _d : 0;\n                }\n                if (i >= params[0] + params[4] - 2) {\n                    ma4List.push(ma4Sum / params[4]);\n                    if (i >= params[0] + params[4] + ma4ForwardPeriod - 3) {\n                        cr.ma4 = ma4List[ma4List.length - 1 - ma4ForwardPeriod];\n                    }\n                    ma4Sum -= (_e = result[i - (params[4] - 1)].cr) !== null && _e !== void 0 ? _e : 0;\n                }\n            }\n            result.push(cr);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * DMA\n * 公式：DIF:MA(CLOSE,N1)-MA(CLOSE,N2);DIFMA:MA(DIF,M)\n */ var differentOfMovingAverage = {\n    name: \"DMA\",\n    shortName: \"DMA\",\n    calcParams: [\n        10,\n        50,\n        10\n    ],\n    figures: [\n        {\n            key: \"dma\",\n            title: \"DMA: \",\n            type: \"line\"\n        },\n        {\n            key: \"ama\",\n            title: \"AMA: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var maxPeriod = Math.max(params[0], params[1]);\n        var closeSum1 = 0;\n        var closeSum2 = 0;\n        var dmaSum = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a;\n            var dma = {};\n            var close = kLineData.close;\n            closeSum1 += close;\n            closeSum2 += close;\n            var ma1 = 0;\n            var ma2 = 0;\n            if (i >= params[0] - 1) {\n                ma1 = closeSum1 / params[0];\n                closeSum1 -= dataList[i - (params[0] - 1)].close;\n            }\n            if (i >= params[1] - 1) {\n                ma2 = closeSum2 / params[1];\n                closeSum2 -= dataList[i - (params[1] - 1)].close;\n            }\n            if (i >= maxPeriod - 1) {\n                var dif = ma1 - ma2;\n                dma.dma = dif;\n                dmaSum += dif;\n                if (i >= maxPeriod + params[2] - 2) {\n                    dma.ama = dmaSum / params[2];\n                    dmaSum -= (_a = result[i - (params[2] - 1)].dma) !== null && _a !== void 0 ? _a : 0;\n                }\n            }\n            result.push(dma);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * DMI\n *\n * MTR:=EXPMEMA(MAX(MAX(HIGH-LOW,ABS(HIGH-REF(CLOSE,1))),ABS(REF(CLOSE,1)-LOW)),N)\n * HD :=HIGH-REF(HIGH,1);\n * LD :=REF(LOW,1)-LOW;\n * DMP:=EXPMEMA(IF(HD>0&&HD>LD,HD,0),N);\n * DMM:=EXPMEMA(IF(LD>0&&LD>HD,LD,0),N);\n *\n * PDI: DMP*100/MTR;\n * MDI: DMM*100/MTR;\n * ADX: EXPMEMA(ABS(MDI-PDI)/(MDI+PDI)*100,MM);\n * ADXR:EXPMEMA(ADX,MM);\n * 公式含义：\n * MTR赋值:最高价-最低价和最高价-昨收的绝对值的较大值和昨收-最低价的绝对值的较大值的N日指数平滑移动平均\n * HD赋值:最高价-昨日最高价\n * LD赋值:昨日最低价-最低价\n * DMP赋值:如果HD>0并且HD>LD,返回HD,否则返回0的N日指数平滑移动平均\n * DMM赋值:如果LD>0并且LD>HD,返回LD,否则返回0的N日指数平滑移动平均\n * 输出PDI:DMP*100/MTR\n * 输出MDI:DMM*100/MTR\n * 输出ADX:MDI-PDI的绝对值/(MDI+PDI)*100的MM日指数平滑移动平均\n * 输出ADXR:ADX的MM日指数平滑移动平均\n *\n */ var directionalMovementIndex = {\n    name: \"DMI\",\n    shortName: \"DMI\",\n    calcParams: [\n        14,\n        6\n    ],\n    figures: [\n        {\n            key: \"pdi\",\n            title: \"PDI: \",\n            type: \"line\"\n        },\n        {\n            key: \"mdi\",\n            title: \"MDI: \",\n            type: \"line\"\n        },\n        {\n            key: \"adx\",\n            title: \"ADX: \",\n            type: \"line\"\n        },\n        {\n            key: \"adxr\",\n            title: \"ADXR: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var trSum = 0;\n        var hSum = 0;\n        var lSum = 0;\n        var mtr = 0;\n        var dmp = 0;\n        var dmm = 0;\n        var dxSum = 0;\n        var adx = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b;\n            var dmi = {};\n            var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            var preClose = prevKLineData.close;\n            var high = kLineData.high;\n            var low = kLineData.low;\n            var hl = high - low;\n            var hcy = Math.abs(high - preClose);\n            var lcy = Math.abs(preClose - low);\n            var hhy = high - prevKLineData.high;\n            var lyl = prevKLineData.low - low;\n            var tr = Math.max(Math.max(hl, hcy), lcy);\n            var h = hhy > 0 && hhy > lyl ? hhy : 0;\n            var l = lyl > 0 && lyl > hhy ? lyl : 0;\n            trSum += tr;\n            hSum += h;\n            lSum += l;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    mtr = mtr - mtr / params[0] + tr;\n                    dmp = dmp - dmp / params[0] + h;\n                    dmm = dmm - dmm / params[0] + l;\n                } else {\n                    mtr = trSum;\n                    dmp = hSum;\n                    dmm = lSum;\n                }\n                var pdi = 0;\n                var mdi = 0;\n                if (mtr !== 0) {\n                    pdi = dmp * 100 / mtr;\n                    mdi = dmm * 100 / mtr;\n                }\n                dmi.pdi = pdi;\n                dmi.mdi = mdi;\n                var dx = 0;\n                if (mdi + pdi !== 0) {\n                    dx = Math.abs(mdi - pdi) / (mdi + pdi) * 100;\n                }\n                dxSum += dx;\n                if (i >= params[0] * 2 - 2) {\n                    if (i > params[0] * 2 - 2) {\n                        adx = (adx * (params[0] - 1) + dx) / params[0];\n                    } else {\n                        adx = dxSum / params[0];\n                    }\n                    dmi.adx = adx;\n                    if (i >= params[0] * 2 + params[1] - 3) {\n                        dmi.adxr = (((_b = result[i - (params[1] - 1)].adx) !== null && _b !== void 0 ? _b : 0) + adx) / 2;\n                    }\n                }\n            }\n            result.push(dmi);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n *\n * EMV 简易波动指标\n * 公式：\n * A=（今日最高+今日最低）/2\n * B=（前日最高+前日最低）/2\n * C=今日最高-今日最低\n * EM=（A-B）*C/今日成交额\n * EMV=N日内EM的累和\n * MAEMV=EMV的M日的简单移动平均\n *\n */ var easeOfMovementValue = {\n    name: \"EMV\",\n    shortName: \"EMV\",\n    calcParams: [\n        14,\n        9\n    ],\n    figures: [\n        {\n            key: \"emv\",\n            title: \"EMV: \",\n            type: \"line\"\n        },\n        {\n            key: \"maEmv\",\n            title: \"MAEMV: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var emvValueSum = 0;\n        var emvValueList = [];\n        return dataList.map(function(kLineData, i) {\n            var _a;\n            var emv = {};\n            if (i > 0) {\n                var prevKLineData = dataList[i - 1];\n                var high = kLineData.high;\n                var low = kLineData.low;\n                var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;\n                var distanceMoved = (high + low) / 2 - (prevKLineData.high + prevKLineData.low) / 2;\n                if (volume === 0 || high - low === 0) {\n                    emv.emv = 0;\n                } else {\n                    var ratio = volume / 100000000 / (high - low);\n                    emv.emv = distanceMoved / ratio;\n                }\n                emvValueSum += emv.emv;\n                emvValueList.push(emv.emv);\n                if (i >= params[0]) {\n                    emv.maEmv = emvValueSum / params[0];\n                    emvValueSum -= emvValueList[i - params[0]];\n                }\n            }\n            return emv;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * EMA 指数移动平均\n */ var exponentialMovingAverage = {\n    name: \"EMA\",\n    shortName: \"EMA\",\n    series: IndicatorSeries.Price,\n    calcParams: [\n        6,\n        12,\n        20\n    ],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        {\n            key: \"ema1\",\n            title: \"EMA6: \",\n            type: \"line\"\n        },\n        {\n            key: \"ema2\",\n            title: \"EMA12: \",\n            type: \"line\"\n        },\n        {\n            key: \"ema3\",\n            title: \"EMA20: \",\n            type: \"line\"\n        }\n    ],\n    regenerateFigures: function(params) {\n        return params.map(function(p, i) {\n            return {\n                key: \"ema\".concat(i + 1),\n                title: \"EMA\".concat(p, \": \"),\n                type: \"line\"\n            };\n        });\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSum = 0;\n        var emaValues = [];\n        return dataList.map(function(kLineData, i) {\n            var ema = {};\n            var close = kLineData.close;\n            closeSum += close;\n            params.forEach(function(p, index) {\n                if (i >= p - 1) {\n                    if (i > p - 1) {\n                        emaValues[index] = (2 * close + (p - 1) * emaValues[index]) / (p + 1);\n                    } else {\n                        emaValues[index] = closeSum / p;\n                    }\n                    ema[figures[index].key] = emaValues[index];\n                }\n            });\n            return ema;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * mtm\n * 公式 MTM（N日）=C－CN\n */ var momentum = {\n    name: \"MTM\",\n    shortName: \"MTM\",\n    calcParams: [\n        12,\n        6\n    ],\n    figures: [\n        {\n            key: \"mtm\",\n            title: \"MTM: \",\n            type: \"line\"\n        },\n        {\n            key: \"maMtm\",\n            title: \"MAMTM: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var mtmSum = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a;\n            var mtm = {};\n            if (i >= params[0]) {\n                var close_1 = kLineData.close;\n                var agoClose = dataList[i - params[0]].close;\n                mtm.mtm = close_1 - agoClose;\n                mtmSum += mtm.mtm;\n                if (i >= params[0] + params[1] - 1) {\n                    mtm.maMtm = mtmSum / params[1];\n                    mtmSum -= (_a = result[i - (params[1] - 1)].mtm) !== null && _a !== void 0 ? _a : 0;\n                }\n            }\n            result.push(mtm);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * MA 移动平均\n */ var movingAverage = {\n    name: \"MA\",\n    shortName: \"MA\",\n    series: IndicatorSeries.Price,\n    calcParams: [\n        5,\n        10,\n        30,\n        60\n    ],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        {\n            key: \"ma1\",\n            title: \"MA5: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma2\",\n            title: \"MA10: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma3\",\n            title: \"MA30: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma4\",\n            title: \"MA60: \",\n            type: \"line\"\n        }\n    ],\n    regenerateFigures: function(params) {\n        return params.map(function(p, i) {\n            return {\n                key: \"ma\".concat(i + 1),\n                title: \"MA\".concat(p, \": \"),\n                type: \"line\"\n            };\n        });\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var closeSums = [];\n        return dataList.map(function(kLineData, i) {\n            var ma = {};\n            var close = kLineData.close;\n            params.forEach(function(p, index) {\n                var _a;\n                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;\n                if (i >= p - 1) {\n                    ma[figures[index].key] = closeSums[index] / p;\n                    closeSums[index] -= dataList[i - (p - 1)].close;\n                }\n            });\n            return ma;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * MACD：参数快线移动平均、慢线移动平均、移动平均，\n * 默认参数值12、26、9。\n * 公式：⒈首先分别计算出收盘价12日指数平滑移动平均线与26日指数平滑移动平均线，分别记为EMA(12）与EMA(26）。\n * ⒉求这两条指数平滑移动平均线的差，即：DIFF = EMA(SHORT) － EMA(LONG)。\n * ⒊再计算DIFF的M日的平均的指数平滑移动平均线，记为DEA。\n * ⒋最后用DIFF减DEA，得MACD。MACD通常绘制成围绕零轴线波动的柱形图。MACD柱状大于0涨颜色，小于0跌颜色。\n */ var movingAverageConvergenceDivergence = {\n    name: \"MACD\",\n    shortName: \"MACD\",\n    calcParams: [\n        12,\n        26,\n        9\n    ],\n    figures: [\n        {\n            key: \"dif\",\n            title: \"DIF: \",\n            type: \"line\"\n        },\n        {\n            key: \"dea\",\n            title: \"DEA: \",\n            type: \"line\"\n        },\n        {\n            key: \"macd\",\n            title: \"MACD: \",\n            type: \"bar\",\n            baseValue: 0,\n            styles: function(_a) {\n                var _b, _c;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var prev = data.prev, current = data.current;\n                var prevMacd = (_b = prev === null || prev === void 0 ? void 0 : prev.macd) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var currentMacd = (_c = current === null || current === void 0 ? void 0 : current.macd) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;\n                var color = \"\";\n                if (currentMacd > 0) {\n                    color = formatValue(indicator.styles, \"bars[0].upColor\", defaultStyles.bars[0].upColor);\n                } else if (currentMacd < 0) {\n                    color = formatValue(indicator.styles, \"bars[0].downColor\", defaultStyles.bars[0].downColor);\n                } else {\n                    color = formatValue(indicator.styles, \"bars[0].noChangeColor\", defaultStyles.bars[0].noChangeColor);\n                }\n                var style = prevMacd < currentMacd ? PolygonType.Stroke : PolygonType.Fill;\n                return {\n                    style: style,\n                    color: color,\n                    borderColor: color\n                };\n            }\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var emaShort = 0;\n        var emaLong = 0;\n        var dif = 0;\n        var difSum = 0;\n        var dea = 0;\n        var maxPeriod = Math.max(params[0], params[1]);\n        return dataList.map(function(kLineData, i) {\n            var macd = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    emaShort = (2 * close + (params[0] - 1) * emaShort) / (params[0] + 1);\n                } else {\n                    emaShort = closeSum / params[0];\n                }\n            }\n            if (i >= params[1] - 1) {\n                if (i > params[1] - 1) {\n                    emaLong = (2 * close + (params[1] - 1) * emaLong) / (params[1] + 1);\n                } else {\n                    emaLong = closeSum / params[1];\n                }\n            }\n            if (i >= maxPeriod - 1) {\n                dif = emaShort - emaLong;\n                macd.dif = dif;\n                difSum += dif;\n                if (i >= maxPeriod + params[2] - 2) {\n                    if (i > maxPeriod + params[2] - 2) {\n                        dea = (dif * 2 + dea * (params[2] - 1)) / (params[2] + 1);\n                    } else {\n                        dea = difSum / params[2];\n                    }\n                    macd.macd = (dif - dea) * 2;\n                    macd.dea = dea;\n                }\n            }\n            return macd;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * OBV\n * OBV = REF(OBV) + sign * V\n */ var onBalanceVolume = {\n    name: \"OBV\",\n    shortName: \"OBV\",\n    calcParams: [\n        30\n    ],\n    figures: [\n        {\n            key: \"obv\",\n            title: \"OBV: \",\n            type: \"line\"\n        },\n        {\n            key: \"maObv\",\n            title: \"MAOBV: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var obvSum = 0;\n        var oldObv = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b, _c, _d;\n            var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;\n            if (kLineData.close < prevKLineData.close) {\n                oldObv -= (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;\n            } else if (kLineData.close > prevKLineData.close) {\n                oldObv += (_c = kLineData.volume) !== null && _c !== void 0 ? _c : 0;\n            }\n            var obv = {\n                obv: oldObv\n            };\n            obvSum += oldObv;\n            if (i >= params[0] - 1) {\n                obv.maObv = obvSum / params[0];\n                obvSum -= (_d = result[i - (params[0] - 1)].obv) !== null && _d !== void 0 ? _d : 0;\n            }\n            result.push(obv);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * 价量趋势指标\n * 公式:\n * X = (CLOSE - REF(CLOSE, 1)) / REF(CLOSE, 1) * VOLUME\n * PVT = SUM(X)\n *\n */ var priceAndVolumeTrend = {\n    name: \"PVT\",\n    shortName: \"PVT\",\n    figures: [\n        {\n            key: \"pvt\",\n            title: \"PVT: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList) {\n        var sum = 0;\n        return dataList.map(function(kLineData, i) {\n            var _a, _b;\n            var pvt = {};\n            var close = kLineData.close;\n            var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 1;\n            var prevClose = ((_b = dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData).close;\n            var x = 0;\n            var total = prevClose * volume;\n            if (total !== 0) {\n                x = (close - prevClose) / total;\n            }\n            sum += x;\n            pvt.pvt = sum;\n            return pvt;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * PSY\n * 公式：PSY=N日内的上涨天数/N×100%。\n */ var psychologicalLine = {\n    name: \"PSY\",\n    shortName: \"PSY\",\n    calcParams: [\n        12,\n        6\n    ],\n    figures: [\n        {\n            key: \"psy\",\n            title: \"PSY: \",\n            type: \"line\"\n        },\n        {\n            key: \"maPsy\",\n            title: \"MAPSY: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var upCount = 0;\n        var psySum = 0;\n        var upList = [];\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b;\n            var psy = {};\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var upFlag = kLineData.close - prevClose > 0 ? 1 : 0;\n            upList.push(upFlag);\n            upCount += upFlag;\n            if (i >= params[0] - 1) {\n                psy.psy = upCount / params[0] * 100;\n                psySum += psy.psy;\n                if (i >= params[0] + params[1] - 2) {\n                    psy.maPsy = psySum / params[1];\n                    psySum -= (_b = result[i - (params[1] - 1)].psy) !== null && _b !== void 0 ? _b : 0;\n                }\n                upCount -= upList[i - (params[0] - 1)];\n            }\n            result.push(psy);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * 变动率指标\n * 公式：ROC = (CLOSE - REF(CLOSE, N)) / REF(CLOSE, N)\n */ var rateOfChange = {\n    name: \"ROC\",\n    shortName: \"ROC\",\n    calcParams: [\n        12,\n        6\n    ],\n    figures: [\n        {\n            key: \"roc\",\n            title: \"ROC: \",\n            type: \"line\"\n        },\n        {\n            key: \"maRoc\",\n            title: \"MAROC: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var result = [];\n        var rocSum = 0;\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b;\n            var roc = {};\n            if (i >= params[0] - 1) {\n                var close_1 = kLineData.close;\n                var agoClose = ((_a = dataList[i - params[0]]) !== null && _a !== void 0 ? _a : dataList[i - (params[0] - 1)]).close;\n                if (agoClose !== 0) {\n                    roc.roc = (close_1 - agoClose) / agoClose * 100;\n                } else {\n                    roc.roc = 0;\n                }\n                rocSum += roc.roc;\n                if (i >= params[0] - 1 + params[1] - 1) {\n                    roc.maRoc = rocSum / params[1];\n                    rocSum -= (_b = result[i - (params[1] - 1)].roc) !== null && _b !== void 0 ? _b : 0;\n                }\n            }\n            result.push(roc);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * RSI\n * RSI = SUM(MAX(CLOSE - REF(CLOSE,1),0),N) / SUM(ABS(CLOSE - REF(CLOSE,1)),N) × 100\n */ var relativeStrengthIndex = {\n    name: \"RSI\",\n    shortName: \"RSI\",\n    calcParams: [\n        6,\n        12,\n        24\n    ],\n    figures: [\n        {\n            key: \"rsi1\",\n            title: \"RSI1: \",\n            type: \"line\"\n        },\n        {\n            key: \"rsi2\",\n            title: \"RSI2: \",\n            type: \"line\"\n        },\n        {\n            key: \"rsi3\",\n            title: \"RSI3: \",\n            type: \"line\"\n        }\n    ],\n    regenerateFigures: function(params) {\n        return params.map(function(_, index) {\n            var num = index + 1;\n            return {\n                key: \"rsi\".concat(num),\n                title: \"RSI\".concat(num, \": \"),\n                type: \"line\"\n            };\n        });\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var sumCloseAs = [];\n        var sumCloseBs = [];\n        return dataList.map(function(kLineData, i) {\n            var _a;\n            var rsi = {};\n            var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var tmp = kLineData.close - prevClose;\n            params.forEach(function(p, index) {\n                var _a, _b, _c;\n                if (tmp > 0) {\n                    sumCloseAs[index] = ((_a = sumCloseAs[index]) !== null && _a !== void 0 ? _a : 0) + tmp;\n                } else {\n                    sumCloseBs[index] = ((_b = sumCloseBs[index]) !== null && _b !== void 0 ? _b : 0) + Math.abs(tmp);\n                }\n                if (i >= p - 1) {\n                    if (sumCloseBs[index] !== 0) {\n                        rsi[figures[index].key] = 100 - 100.0 / (1 + sumCloseAs[index] / sumCloseBs[index]);\n                    } else {\n                        rsi[figures[index].key] = 0;\n                    }\n                    var agoData = dataList[i - (p - 1)];\n                    var agoPreData = (_c = dataList[i - p]) !== null && _c !== void 0 ? _c : agoData;\n                    var agoTmp = agoData.close - agoPreData.close;\n                    if (agoTmp > 0) {\n                        sumCloseAs[index] -= agoTmp;\n                    } else {\n                        sumCloseBs[index] -= Math.abs(agoTmp);\n                    }\n                }\n            });\n            return rsi;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * sma\n */ var simpleMovingAverage = {\n    name: \"SMA\",\n    shortName: \"SMA\",\n    series: IndicatorSeries.Price,\n    calcParams: [\n        12,\n        2\n    ],\n    precision: 2,\n    figures: [\n        {\n            key: \"sma\",\n            title: \"SMA: \",\n            type: \"line\"\n        }\n    ],\n    shouldOhlc: true,\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var smaValue = 0;\n        return dataList.map(function(kLineData, i) {\n            var sma = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    smaValue = (close * params[1] + smaValue * (params[0] - params[1] + 1)) / (params[0] + 1);\n                } else {\n                    smaValue = closeSum / params[0];\n                }\n                sma.sma = smaValue;\n            }\n            return sma;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * KDJ\n *\n * 当日K值=2/3×前一日K值+1/3×当日RSV\n * 当日D值=2/3×前一日D值+1/3×当日K值\n * 若无前一日K 值与D值，则可分别用50来代替。\n * J值=3*当日K值-2*当日D值\n */ var stoch = {\n    name: \"KDJ\",\n    shortName: \"KDJ\",\n    calcParams: [\n        9,\n        3,\n        3\n    ],\n    figures: [\n        {\n            key: \"k\",\n            title: \"K: \",\n            type: \"line\"\n        },\n        {\n            key: \"d\",\n            title: \"D: \",\n            type: \"line\"\n        },\n        {\n            key: \"j\",\n            title: \"J: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b, _c, _d;\n            var kdj = {};\n            var close = kLineData.close;\n            if (i >= params[0] - 1) {\n                var lhn = getMaxMin(dataList.slice(i - (params[0] - 1), i + 1), \"high\", \"low\");\n                var hn = lhn[0];\n                var ln = lhn[1];\n                var hnSubLn = hn - ln;\n                var rsv = (close - ln) / (hnSubLn === 0 ? 1 : hnSubLn) * 100;\n                kdj.k = ((params[1] - 1) * ((_b = (_a = result[i - 1]) === null || _a === void 0 ? void 0 : _a.k) !== null && _b !== void 0 ? _b : 50) + rsv) / params[1];\n                kdj.d = ((params[2] - 1) * ((_d = (_c = result[i - 1]) === null || _c === void 0 ? void 0 : _c.d) !== null && _d !== void 0 ? _d : 50) + kdj.k) / params[2];\n                kdj.j = 3.0 * kdj.k - 2.0 * kdj.d;\n            }\n            result.push(kdj);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var stopAndReverse = {\n    name: \"SAR\",\n    shortName: \"SAR\",\n    series: IndicatorSeries.Price,\n    calcParams: [\n        2,\n        2,\n        20\n    ],\n    precision: 2,\n    shouldOhlc: true,\n    figures: [\n        {\n            key: \"sar\",\n            title: \"SAR: \",\n            type: \"circle\",\n            styles: function(_a) {\n                var _b, _c, _d;\n                var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n                var current = data.current;\n                var sar = (_b = current === null || current === void 0 ? void 0 : current.sar) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n                var halfHL = (((_c = current === null || current === void 0 ? void 0 : current.high) !== null && _c !== void 0 ? _c : 0) + ((_d = current === null || current === void 0 ? void 0 : current.low) !== null && _d !== void 0 ? _d : 0)) / 2;\n                var color = sar < halfHL ? formatValue(indicator.styles, \"circles[0].upColor\", defaultStyles.circles[0].upColor) : formatValue(indicator.styles, \"circles[0].downColor\", defaultStyles.circles[0].downColor);\n                return {\n                    color: color\n                };\n            }\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var startAf = params[0] / 100;\n        var step = params[1] / 100;\n        var maxAf = params[2] / 100;\n        // 加速因子\n        var af = startAf;\n        // 极值\n        var ep = -100;\n        // 判断是上涨还是下跌  false：下跌\n        var isIncreasing = false;\n        var sar = 0;\n        return dataList.map(function(kLineData, i) {\n            // 上一个周期的sar\n            var preSar = sar;\n            var high = kLineData.high;\n            var low = kLineData.low;\n            if (isIncreasing) {\n                // 上涨\n                if (ep === -100 || ep < high) {\n                    // 重新初始化值\n                    ep = high;\n                    af = Math.min(af + step, maxAf);\n                }\n                sar = preSar + af * (ep - preSar);\n                var lowMin = Math.min(dataList[Math.max(1, i) - 1].low, low);\n                if (sar > kLineData.low) {\n                    sar = ep;\n                    // 重新初始化值\n                    af = startAf;\n                    ep = -100;\n                    isIncreasing = !isIncreasing;\n                } else if (sar > lowMin) {\n                    sar = lowMin;\n                }\n            } else {\n                if (ep === -100 || ep > low) {\n                    // 重新初始化值\n                    ep = low;\n                    af = Math.min(af + step, maxAf);\n                }\n                sar = preSar + af * (ep - preSar);\n                var highMax = Math.max(dataList[Math.max(1, i) - 1].high, high);\n                if (sar < kLineData.high) {\n                    sar = ep;\n                    // 重新初始化值\n                    af = 0;\n                    ep = -100;\n                    isIncreasing = !isIncreasing;\n                } else if (sar < highMax) {\n                    sar = highMax;\n                }\n            }\n            return {\n                high: high,\n                low: low,\n                sar: sar\n            };\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http:*www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * trix\n *\n * TR=收盘价的N日指数移动平均的N日指数移动平均的N日指数移动平均；\n * TRIX=(TR-昨日TR)/昨日TR*100；\n * MATRIX=TRIX的M日简单移动平均；\n * 默认参数N设为12，默认参数M设为9；\n * 默认参数12、9\n * 公式：MTR:=EMA(EMA(EMA(CLOSE,N),N),N)\n * TRIX:(MTR-REF(MTR,1))/REF(MTR,1)*100;\n * TRMA:MA(TRIX,M)\n *\n */ var tripleExponentiallySmoothedAverage = {\n    name: \"TRIX\",\n    shortName: \"TRIX\",\n    calcParams: [\n        12,\n        9\n    ],\n    figures: [\n        {\n            key: \"trix\",\n            title: \"TRIX: \",\n            type: \"line\"\n        },\n        {\n            key: \"maTrix\",\n            title: \"MATRIX: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var closeSum = 0;\n        var ema1 = 0;\n        var ema2 = 0;\n        var oldTr = 0;\n        var ema1Sum = 0;\n        var ema2Sum = 0;\n        var trixSum = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a;\n            var trix = {};\n            var close = kLineData.close;\n            closeSum += close;\n            if (i >= params[0] - 1) {\n                if (i > params[0] - 1) {\n                    ema1 = (2 * close + (params[0] - 1) * ema1) / (params[0] + 1);\n                } else {\n                    ema1 = closeSum / params[0];\n                }\n                ema1Sum += ema1;\n                if (i >= params[0] * 2 - 2) {\n                    if (i > params[0] * 2 - 2) {\n                        ema2 = (2 * ema1 + (params[0] - 1) * ema2) / (params[0] + 1);\n                    } else {\n                        ema2 = ema1Sum / params[0];\n                    }\n                    ema2Sum += ema2;\n                    if (i >= params[0] * 3 - 3) {\n                        var tr = 0;\n                        var trixValue = 0;\n                        if (i > params[0] * 3 - 3) {\n                            tr = (2 * ema2 + (params[0] - 1) * oldTr) / (params[0] + 1);\n                            trixValue = (tr - oldTr) / oldTr * 100;\n                        } else {\n                            tr = ema2Sum / params[0];\n                        }\n                        oldTr = tr;\n                        trix.trix = trixValue;\n                        trixSum += trixValue;\n                        if (i >= params[0] * 3 + params[1] - 4) {\n                            trix.maTrix = trixSum / params[1];\n                            trixSum -= (_a = result[i - (params[1] - 1)].trix) !== null && _a !== void 0 ? _a : 0;\n                        }\n                    }\n                }\n            }\n            result.push(trix);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getVolumeFigure() {\n    return {\n        key: \"volume\",\n        title: \"VOLUME: \",\n        type: \"bar\",\n        baseValue: 0,\n        styles: function(_a) {\n            var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;\n            var current = data.current;\n            var color = formatValue(indicator.styles, \"bars[0].noChangeColor\", defaultStyles.bars[0].noChangeColor);\n            if (isValid(current)) {\n                if (current.close > current.open) {\n                    color = formatValue(indicator.styles, \"bars[0].upColor\", defaultStyles.bars[0].upColor);\n                } else if (current.close < current.open) {\n                    color = formatValue(indicator.styles, \"bars[0].downColor\", defaultStyles.bars[0].downColor);\n                }\n            }\n            return {\n                color: color\n            };\n        }\n    };\n}\nvar volume = {\n    name: \"VOL\",\n    shortName: \"VOL\",\n    series: IndicatorSeries.Volume,\n    calcParams: [\n        5,\n        10,\n        20\n    ],\n    shouldFormatBigNumber: true,\n    precision: 0,\n    minValue: 0,\n    figures: [\n        {\n            key: \"ma1\",\n            title: \"MA5: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma2\",\n            title: \"MA10: \",\n            type: \"line\"\n        },\n        {\n            key: \"ma3\",\n            title: \"MA20: \",\n            type: \"line\"\n        },\n        getVolumeFigure()\n    ],\n    regenerateFigures: function(params) {\n        var figures = params.map(function(p, i) {\n            return {\n                key: \"ma\".concat(i + 1),\n                title: \"MA\".concat(p, \": \"),\n                type: \"line\"\n            };\n        });\n        figures.push(getVolumeFigure());\n        return figures;\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        var volSums = [];\n        return dataList.map(function(kLineData, i) {\n            var _a;\n            var volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;\n            var vol = {\n                volume: volume,\n                open: kLineData.open,\n                close: kLineData.close\n            };\n            params.forEach(function(p, index) {\n                var _a, _b;\n                volSums[index] = ((_a = volSums[index]) !== null && _a !== void 0 ? _a : 0) + volume;\n                if (i >= p - 1) {\n                    vol[figures[index].key] = volSums[index] / p;\n                    volSums[index] -= (_b = dataList[i - (p - 1)].volume) !== null && _b !== void 0 ? _b : 0;\n                }\n            });\n            return vol;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * VR\n * VR=（UVS+1/2PVS）/（DVS+1/2PVS）\n * 24天以来凡是股价上涨那一天的成交量都称为AV，将24天内的AV总和相加后称为UVS\n * 24天以来凡是股价下跌那一天的成交量都称为BV，将24天内的BV总和相加后称为DVS\n * 24天以来凡是股价不涨不跌，则那一天的成交量都称为CV，将24天内的CV总和相加后称为PVS\n *\n */ var volumeRatio = {\n    name: \"VR\",\n    shortName: \"VR\",\n    calcParams: [\n        26,\n        6\n    ],\n    figures: [\n        {\n            key: \"vr\",\n            title: \"VR: \",\n            type: \"line\"\n        },\n        {\n            key: \"maVr\",\n            title: \"MAVR: \",\n            type: \"line\"\n        }\n    ],\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams;\n        var uvs = 0;\n        var dvs = 0;\n        var pvs = 0;\n        var vrSum = 0;\n        var result = [];\n        dataList.forEach(function(kLineData, i) {\n            var _a, _b, _c, _d, _e;\n            var vr = {};\n            var close = kLineData.close;\n            var preClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;\n            var volume = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;\n            if (close > preClose) {\n                uvs += volume;\n            } else if (close < preClose) {\n                dvs += volume;\n            } else {\n                pvs += volume;\n            }\n            if (i >= params[0] - 1) {\n                var halfPvs = pvs / 2;\n                if (dvs + halfPvs === 0) {\n                    vr.vr = 0;\n                } else {\n                    vr.vr = (uvs + halfPvs) / (dvs + halfPvs) * 100;\n                }\n                vrSum += vr.vr;\n                if (i >= params[0] + params[1] - 2) {\n                    vr.maVr = vrSum / params[1];\n                    vrSum -= (_c = result[i - (params[1] - 1)].vr) !== null && _c !== void 0 ? _c : 0;\n                }\n                var agoData = dataList[i - (params[0] - 1)];\n                var agoPreData = (_d = dataList[i - params[0]]) !== null && _d !== void 0 ? _d : agoData;\n                var agoClose = agoData.close;\n                var agoVolume = (_e = agoData.volume) !== null && _e !== void 0 ? _e : 0;\n                if (agoClose > agoPreData.close) {\n                    uvs -= agoVolume;\n                } else if (agoClose < agoPreData.close) {\n                    dvs -= agoVolume;\n                } else {\n                    pvs -= agoVolume;\n                }\n            }\n            result.push(vr);\n        });\n        return result;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * WR\n * 公式 WR(N) = 100 * [ C - HIGH(N) ] / [ HIGH(N)-LOW(N) ]\n */ var williamsR = {\n    name: \"WR\",\n    shortName: \"WR\",\n    calcParams: [\n        6,\n        10,\n        14\n    ],\n    figures: [\n        {\n            key: \"wr1\",\n            title: \"WR1: \",\n            type: \"line\"\n        },\n        {\n            key: \"wr2\",\n            title: \"WR2: \",\n            type: \"line\"\n        },\n        {\n            key: \"wr3\",\n            title: \"WR3: \",\n            type: \"line\"\n        }\n    ],\n    regenerateFigures: function(params) {\n        return params.map(function(_, i) {\n            return {\n                key: \"wr\".concat(i + 1),\n                title: \"WR\".concat(i + 1, \": \"),\n                type: \"line\"\n            };\n        });\n    },\n    calc: function(dataList, indicator) {\n        var params = indicator.calcParams, figures = indicator.figures;\n        return dataList.map(function(kLineData, i) {\n            var wr = {};\n            var close = kLineData.close;\n            params.forEach(function(param, index) {\n                var p = param - 1;\n                if (i >= p) {\n                    var hln = getMaxMin(dataList.slice(i - p, i + 1), \"high\", \"low\");\n                    var hn = hln[0];\n                    var ln = hln[1];\n                    var hnSubLn = hn - ln;\n                    wr[figures[index].key] = hnSubLn === 0 ? 0 : (close - hn) / hnSubLn * 100;\n                }\n            });\n            return wr;\n        });\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var indicators = {};\nvar extensions$2 = [\n    averagePrice,\n    awesomeOscillator,\n    bias,\n    bollingerBands,\n    brar,\n    bullAndBearIndex,\n    commodityChannelIndex,\n    currentRatio,\n    differentOfMovingAverage,\n    directionalMovementIndex,\n    easeOfMovementValue,\n    exponentialMovingAverage,\n    momentum,\n    movingAverage,\n    movingAverageConvergenceDivergence,\n    onBalanceVolume,\n    priceAndVolumeTrend,\n    psychologicalLine,\n    rateOfChange,\n    relativeStrengthIndex,\n    simpleMovingAverage,\n    stoch,\n    stopAndReverse,\n    tripleExponentiallySmoothedAverage,\n    volume,\n    volumeRatio,\n    williamsR\n];\nextensions$2.forEach(function(indicator) {\n    indicators[indicator.name] = IndicatorImp.extend(indicator);\n});\nfunction registerIndicator(indicator) {\n    indicators[indicator.name] = IndicatorImp.extend(indicator);\n}\nfunction getIndicatorClass(name) {\n    var _a;\n    return (_a = indicators[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getSupportedIndicators() {\n    return Object.keys(indicators);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var fibonacciLine = {\n    name: \"fibonacciLine\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var _b;\n        var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;\n        var points = overlay.points;\n        if (coordinates.length > 0) {\n            var precision_1 = 0;\n            if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {\n                precision_1 = chart.getPrecision().price;\n            } else {\n                var indicators = chart.getIndicators({\n                    paneId: overlay.paneId\n                });\n                indicators.forEach(function(indicator) {\n                    precision_1 = Math.max(precision_1, indicator.precision);\n                });\n            }\n            var lines_1 = [];\n            var texts_1 = [];\n            var startX_1 = 0;\n            var endX_1 = bounding.width;\n            if (coordinates.length > 1 && isNumber(points[0].value) && isNumber(points[1].value)) {\n                var percents = [\n                    1,\n                    0.786,\n                    0.618,\n                    0.5,\n                    0.382,\n                    0.236,\n                    0\n                ];\n                var yDif_1 = coordinates[0].y - coordinates[1].y;\n                var valueDif_1 = points[0].value - points[1].value;\n                percents.forEach(function(percent) {\n                    var _a;\n                    var y = coordinates[1].y + yDif_1 * percent;\n                    var value = chart.getDecimalFold().format(chart.getThousandsSeparator().format((((_a = points[1].value) !== null && _a !== void 0 ? _a : 0) + valueDif_1 * percent).toFixed(precision_1)));\n                    lines_1.push({\n                        coordinates: [\n                            {\n                                x: startX_1,\n                                y: y\n                            },\n                            {\n                                x: endX_1,\n                                y: y\n                            }\n                        ]\n                    });\n                    texts_1.push({\n                        x: startX_1,\n                        y: y,\n                        text: \"\".concat(value, \" (\").concat((percent * 100).toFixed(1), \"%)\"),\n                        baseline: \"bottom\"\n                    });\n                });\n            }\n            return [\n                {\n                    type: \"line\",\n                    attrs: lines_1\n                },\n                {\n                    type: \"text\",\n                    isCheckEvent: false,\n                    attrs: texts_1\n                }\n            ];\n        }\n        return [];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var horizontalRayLine = {\n    name: \"horizontalRayLine\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        var coordinate = {\n            x: 0,\n            y: coordinates[0].y\n        };\n        if (isValid(coordinates[1]) && coordinates[0].x < coordinates[1].x) {\n            coordinate.x = bounding.width;\n        }\n        return [\n            {\n                type: \"line\",\n                attrs: {\n                    coordinates: [\n                        coordinates[0],\n                        coordinate\n                    ]\n                }\n            }\n        ];\n    },\n    performEventPressedMove: function(_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].value = performPoint.value;\n        points[1].value = performPoint.value;\n    },\n    performEventMoveForDrawing: function(_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].value = performPoint.value;\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var horizontalSegment = {\n    name: \"horizontalSegment\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates;\n        var lines = [];\n        if (coordinates.length === 2) {\n            lines.push({\n                coordinates: coordinates\n            });\n        }\n        return [\n            {\n                type: \"line\",\n                attrs: lines\n            }\n        ];\n    },\n    performEventPressedMove: function(_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].value = performPoint.value;\n        points[1].value = performPoint.value;\n    },\n    performEventMoveForDrawing: function(_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].value = performPoint.value;\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var horizontalStraightLine = {\n    name: \"horizontalStraightLine\",\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: \"line\",\n                attrs: {\n                    coordinates: [\n                        {\n                            x: 0,\n                            y: coordinates[0].y\n                        },\n                        {\n                            x: bounding.width,\n                            y: coordinates[0].y\n                        }\n                    ]\n                }\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var Eventful = /** @class */ function() {\n    function Eventful() {\n        this._children = [];\n        this._callbacks = new Map();\n    }\n    Eventful.prototype.registerEvent = function(name, callback) {\n        this._callbacks.set(name, callback);\n        return this;\n    };\n    Eventful.prototype.onEvent = function(name, event, other) {\n        var callback = this._callbacks.get(name);\n        if (isValid(callback) && this.checkEventOn(event)) {\n            return callback(event, other);\n        }\n        return false;\n    };\n    Eventful.prototype.checkEventOn = function(event) {\n        var e_1, _a;\n        try {\n            for(var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()){\n                var ful = _c.value;\n                if (ful.checkEventOn(event)) {\n                    return true;\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        return false;\n    };\n    Eventful.prototype.dispatchEvent = function(name, event, other) {\n        var start = this._children.length - 1;\n        if (start > -1) {\n            for(var i = start; i > -1; i--){\n                if (this._children[i].dispatchEvent(name, event, other)) {\n                    return true;\n                }\n            }\n        }\n        return this.onEvent(name, event, other);\n    };\n    Eventful.prototype.addChild = function(eventful) {\n        this._children.push(eventful);\n        return this;\n    };\n    Eventful.prototype.clear = function() {\n        this._children = [];\n    };\n    return Eventful;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DEVIATION = 2;\nvar FigureImp = /** @class */ function(_super) {\n    __extends(FigureImp, _super);\n    function FigureImp(figure) {\n        var _this = _super.call(this) || this;\n        _this.attrs = figure.attrs;\n        _this.styles = figure.styles;\n        return _this;\n    }\n    FigureImp.prototype.checkEventOn = function(event) {\n        return this.checkEventOnImp(event, this.attrs, this.styles);\n    };\n    FigureImp.prototype.setAttrs = function(attrs) {\n        this.attrs = attrs;\n        return this;\n    };\n    FigureImp.prototype.setStyles = function(styles) {\n        this.styles = styles;\n        return this;\n    };\n    FigureImp.prototype.draw = function(ctx) {\n        this.drawImp(ctx, this.attrs, this.styles);\n    };\n    FigureImp.extend = function(figure) {\n        var Custom = /** @class */ function(_super) {\n            __extends(Custom, _super);\n            function Custom() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            Custom.prototype.checkEventOnImp = function(coordinate, attrs, styles) {\n                return figure.checkEventOn(coordinate, attrs, styles);\n            };\n            Custom.prototype.drawImp = function(ctx, attrs, styles) {\n                figure.draw(ctx, attrs, styles);\n            };\n            return Custom;\n        }(FigureImp);\n        return Custom;\n    };\n    return FigureImp;\n}(Eventful);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function checkCoordinateOnLine(coordinate, attrs) {\n    var e_1, _a;\n    var lines = [];\n    lines = lines.concat(attrs);\n    try {\n        for(var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()){\n            var line_1 = lines_1_1.value;\n            var coordinates = line_1.coordinates;\n            if (coordinates.length > 1) {\n                for(var i = 1; i < coordinates.length; i++){\n                    var prevCoordinate = coordinates[i - 1];\n                    var currentCoordinate = coordinates[i];\n                    if (prevCoordinate.x === currentCoordinate.x) {\n                        if (Math.abs(prevCoordinate.y - coordinate.y) + Math.abs(currentCoordinate.y - coordinate.y) - Math.abs(prevCoordinate.y - currentCoordinate.y) < DEVIATION + DEVIATION && Math.abs(coordinate.x - prevCoordinate.x) < DEVIATION) {\n                            return true;\n                        }\n                    } else {\n                        var kb = getLinearSlopeIntercept(prevCoordinate, currentCoordinate);\n                        var y = getLinearYFromSlopeIntercept(kb, coordinate);\n                        var yDif = Math.abs(y - coordinate.y);\n                        if (Math.abs(prevCoordinate.x - coordinate.x) + Math.abs(currentCoordinate.x - coordinate.x) - Math.abs(prevCoordinate.x - currentCoordinate.x) < DEVIATION + DEVIATION && yDif * yDif / (kb[0] * kb[0] + 1) < DEVIATION * DEVIATION) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction getLinearYFromSlopeIntercept(kb, coordinate) {\n    if (kb !== null) {\n        return coordinate.x * kb[0] + kb[1];\n    }\n    return coordinate.y;\n}\n/**\n * 获取点在两点决定的一次函数上的y值\n * @param coordinate1\n * @param coordinate2\n * @param targetCoordinate\n */ function getLinearYFromCoordinates(coordinate1, coordinate2, targetCoordinate) {\n    var kb = getLinearSlopeIntercept(coordinate1, coordinate2);\n    return getLinearYFromSlopeIntercept(kb, targetCoordinate);\n}\nfunction getLinearSlopeIntercept(coordinate1, coordinate2) {\n    var difX = coordinate1.x - coordinate2.x;\n    if (difX !== 0) {\n        var k = (coordinate1.y - coordinate2.y) / difX;\n        var b = coordinate1.y - k * coordinate1.x;\n        return [\n            k,\n            b\n        ];\n    }\n    return null;\n}\nfunction lineTo(ctx, coordinates, smooth) {\n    var length = coordinates.length;\n    var smoothParam = isNumber(smooth) ? smooth > 0 && smooth < 1 ? smooth : 0 : smooth ? 0.5 : 0;\n    if (smoothParam > 0 && length > 2) {\n        var cpx0 = coordinates[0].x;\n        var cpy0 = coordinates[0].y;\n        for(var i = 1; i < length - 1; i++){\n            var prevCoordinate = coordinates[i - 1];\n            var coordinate = coordinates[i];\n            var nextCoordinate = coordinates[i + 1];\n            var dx01 = coordinate.x - prevCoordinate.x;\n            var dy01 = coordinate.y - prevCoordinate.y;\n            var dx12 = nextCoordinate.x - coordinate.x;\n            var dy12 = nextCoordinate.y - coordinate.y;\n            var dx02 = nextCoordinate.x - prevCoordinate.x;\n            var dy02 = nextCoordinate.y - prevCoordinate.y;\n            var prevSegmentLength = Math.sqrt(dx01 * dx01 + dy01 * dy01);\n            var nextSegmentLength = Math.sqrt(dx12 * dx12 + dy12 * dy12);\n            var segmentLengthRatio = nextSegmentLength / (nextSegmentLength + prevSegmentLength);\n            var nextCpx = coordinate.x + dx02 * smoothParam * segmentLengthRatio;\n            var nextCpy = coordinate.y + dy02 * smoothParam * segmentLengthRatio;\n            nextCpx = Math.min(nextCpx, Math.max(nextCoordinate.x, coordinate.x));\n            nextCpy = Math.min(nextCpy, Math.max(nextCoordinate.y, coordinate.y));\n            nextCpx = Math.max(nextCpx, Math.min(nextCoordinate.x, coordinate.x));\n            nextCpy = Math.max(nextCpy, Math.min(nextCoordinate.y, coordinate.y));\n            dx02 = nextCpx - coordinate.x;\n            dy02 = nextCpy - coordinate.y;\n            var cpx1 = coordinate.x - dx02 * prevSegmentLength / nextSegmentLength;\n            var cpy1 = coordinate.y - dy02 * prevSegmentLength / nextSegmentLength;\n            cpx1 = Math.min(cpx1, Math.max(prevCoordinate.x, coordinate.x));\n            cpy1 = Math.min(cpy1, Math.max(prevCoordinate.y, coordinate.y));\n            cpx1 = Math.max(cpx1, Math.min(prevCoordinate.x, coordinate.x));\n            cpy1 = Math.max(cpy1, Math.min(prevCoordinate.y, coordinate.y));\n            dx02 = coordinate.x - cpx1;\n            dy02 = coordinate.y - cpy1;\n            nextCpx = coordinate.x + dx02 * nextSegmentLength / prevSegmentLength;\n            nextCpy = coordinate.y + dy02 * nextSegmentLength / prevSegmentLength;\n            ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, coordinate.x, coordinate.y);\n            cpx0 = nextCpx;\n            cpy0 = nextCpy;\n        }\n        var lastCoordinate = coordinates[length - 1];\n        ctx.bezierCurveTo(cpx0, cpy0, lastCoordinate.x, lastCoordinate.y, lastCoordinate.x, lastCoordinate.y);\n    } else {\n        for(var i = 1; i < length; i++){\n            ctx.lineTo(coordinates[i].x, coordinates[i].y);\n        }\n    }\n}\nfunction drawLine(ctx, attrs, styles) {\n    var lines = [];\n    lines = lines.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? LineType.Solid : _a, _b = styles.smooth, smooth = _b === void 0 ? false : _b, _c = styles.size, size = _c === void 0 ? 1 : _c, _d = styles.color, color = _d === void 0 ? \"currentColor\" : _d, _e = styles.dashedValue, dashedValue = _e === void 0 ? [\n        2,\n        2\n    ] : _e;\n    ctx.lineWidth = size;\n    ctx.strokeStyle = color;\n    if (style === LineType.Dashed) {\n        ctx.setLineDash(dashedValue);\n    } else {\n        ctx.setLineDash([]);\n    }\n    var correction = size % 2 === 1 ? 0.5 : 0;\n    lines.forEach(function(_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length > 1) {\n            if (coordinates.length === 2 && (coordinates[0].x === coordinates[1].x || coordinates[0].y === coordinates[1].y)) {\n                ctx.beginPath();\n                if (coordinates[0].x === coordinates[1].x) {\n                    ctx.moveTo(coordinates[0].x + correction, coordinates[0].y);\n                    ctx.lineTo(coordinates[1].x + correction, coordinates[1].y);\n                } else {\n                    ctx.moveTo(coordinates[0].x, coordinates[0].y + correction);\n                    ctx.lineTo(coordinates[1].x, coordinates[1].y + correction);\n                }\n                ctx.stroke();\n                ctx.closePath();\n            } else {\n                ctx.save();\n                if (size % 2 === 1) {\n                    ctx.translate(0.5, 0.5);\n                }\n                ctx.beginPath();\n                ctx.moveTo(coordinates[0].x, coordinates[0].y);\n                lineTo(ctx, coordinates, smooth);\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n    });\n}\nvar line = {\n    name: \"line\",\n    checkEventOn: checkCoordinateOnLine,\n    draw: function(ctx, attrs, styles) {\n        drawLine(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * 获取平行线\n * @param coordinates\n * @param bounding\n * @param extendParallelLineCount\n * @returns {Array}\n */ function getParallelLines(coordinates, bounding, extendParallelLineCount) {\n    var count = extendParallelLineCount !== null && extendParallelLineCount !== void 0 ? extendParallelLineCount : 0;\n    var lines = [];\n    if (coordinates.length > 1) {\n        if (coordinates[0].x === coordinates[1].x) {\n            var startY = 0;\n            var endY = bounding.height;\n            lines.push({\n                coordinates: [\n                    {\n                        x: coordinates[0].x,\n                        y: startY\n                    },\n                    {\n                        x: coordinates[0].x,\n                        y: endY\n                    }\n                ]\n            });\n            if (coordinates.length > 2) {\n                lines.push({\n                    coordinates: [\n                        {\n                            x: coordinates[2].x,\n                            y: startY\n                        },\n                        {\n                            x: coordinates[2].x,\n                            y: endY\n                        }\n                    ]\n                });\n                var distance = coordinates[0].x - coordinates[2].x;\n                for(var i = 0; i < count; i++){\n                    var d = distance * (i + 1);\n                    lines.push({\n                        coordinates: [\n                            {\n                                x: coordinates[0].x + d,\n                                y: startY\n                            },\n                            {\n                                x: coordinates[0].x + d,\n                                y: endY\n                            }\n                        ]\n                    });\n                }\n            }\n        } else {\n            var startX = 0;\n            var endX = bounding.width;\n            var kb = getLinearSlopeIntercept(coordinates[0], coordinates[1]);\n            var k = kb[0];\n            var b = kb[1];\n            lines.push({\n                coordinates: [\n                    {\n                        x: startX,\n                        y: startX * k + b\n                    },\n                    {\n                        x: endX,\n                        y: endX * k + b\n                    }\n                ]\n            });\n            if (coordinates.length > 2) {\n                var b1 = coordinates[2].y - k * coordinates[2].x;\n                lines.push({\n                    coordinates: [\n                        {\n                            x: startX,\n                            y: startX * k + b1\n                        },\n                        {\n                            x: endX,\n                            y: endX * k + b1\n                        }\n                    ]\n                });\n                var distance = b - b1;\n                for(var i = 0; i < count; i++){\n                    var b2 = b + distance * (i + 1);\n                    lines.push({\n                        coordinates: [\n                            {\n                                x: startX,\n                                y: startX * k + b2\n                            },\n                            {\n                                x: endX,\n                                y: endX * k + b2\n                            }\n                        ]\n                    });\n                }\n            }\n        }\n    }\n    return lines;\n}\nvar parallelStraightLine = {\n    name: \"parallelStraightLine\",\n    totalStep: 4,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: \"line\",\n                attrs: getParallelLines(coordinates, bounding)\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var priceChannelLine = {\n    name: \"priceChannelLine\",\n    totalStep: 4,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: \"line\",\n                attrs: getParallelLines(coordinates, bounding, 1)\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var priceLine = {\n    name: \"priceLine\",\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var _b;\n        var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;\n        var precision = 0;\n        if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {\n            precision = chart.getPrecision().price;\n        } else {\n            var indicators = chart.getIndicators({\n                paneId: overlay.paneId\n            });\n            indicators.forEach(function(indicator) {\n                precision = Math.max(precision, indicator.precision);\n            });\n        }\n        var _c = overlay.points[0].value, value = _c === void 0 ? 0 : _c;\n        return [\n            {\n                type: \"line\",\n                attrs: {\n                    coordinates: [\n                        coordinates[0],\n                        {\n                            x: bounding.width,\n                            y: coordinates[0].y\n                        }\n                    ]\n                }\n            },\n            {\n                type: \"text\",\n                ignoreEvent: true,\n                attrs: {\n                    x: coordinates[0].x,\n                    y: coordinates[0].y,\n                    text: chart.getDecimalFold().format(chart.getThousandsSeparator().format(value.toFixed(precision))),\n                    baseline: \"bottom\"\n                }\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getRayLine(coordinates, bounding) {\n    if (coordinates.length > 1) {\n        var coordinate = {\n            x: 0,\n            y: 0\n        };\n        if (coordinates[0].x === coordinates[1].x && coordinates[0].y !== coordinates[1].y) {\n            if (coordinates[0].y < coordinates[1].y) {\n                coordinate = {\n                    x: coordinates[0].x,\n                    y: bounding.height\n                };\n            } else {\n                coordinate = {\n                    x: coordinates[0].x,\n                    y: 0\n                };\n            }\n        } else if (coordinates[0].x > coordinates[1].x) {\n            coordinate = {\n                x: 0,\n                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], {\n                    x: 0,\n                    y: coordinates[0].y\n                })\n            };\n        } else {\n            coordinate = {\n                x: bounding.width,\n                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], {\n                    x: bounding.width,\n                    y: coordinates[0].y\n                })\n            };\n        }\n        return {\n            coordinates: [\n                coordinates[0],\n                coordinate\n            ]\n        };\n    }\n    return [];\n}\nvar rayLine = {\n    name: \"rayLine\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: \"line\",\n                attrs: getRayLine(coordinates, bounding)\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var segment = {\n    name: \"segment\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length === 2) {\n            return [\n                {\n                    type: \"line\",\n                    attrs: {\n                        coordinates: coordinates\n                    }\n                }\n            ];\n        }\n        return [];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var straightLine = {\n    name: \"straightLine\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        if (coordinates.length === 2) {\n            if (coordinates[0].x === coordinates[1].x) {\n                return [\n                    {\n                        type: \"line\",\n                        attrs: {\n                            coordinates: [\n                                {\n                                    x: coordinates[0].x,\n                                    y: 0\n                                },\n                                {\n                                    x: coordinates[0].x,\n                                    y: bounding.height\n                                }\n                            ]\n                        }\n                    }\n                ];\n            }\n            return [\n                {\n                    type: \"line\",\n                    attrs: {\n                        coordinates: [\n                            {\n                                x: 0,\n                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], {\n                                    x: 0,\n                                    y: coordinates[0].y\n                                })\n                            },\n                            {\n                                x: bounding.width,\n                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], {\n                                    x: bounding.width,\n                                    y: coordinates[0].y\n                                })\n                            }\n                        ]\n                    }\n                }\n            ];\n        }\n        return [];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var verticalRayLine = {\n    name: \"verticalRayLine\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        if (coordinates.length === 2) {\n            var coordinate = {\n                x: coordinates[0].x,\n                y: 0\n            };\n            if (coordinates[0].y < coordinates[1].y) {\n                coordinate.y = bounding.height;\n            }\n            return [\n                {\n                    type: \"line\",\n                    attrs: {\n                        coordinates: [\n                            coordinates[0],\n                            coordinate\n                        ]\n                    }\n                }\n            ];\n        }\n        return [];\n    },\n    performEventPressedMove: function(_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].timestamp = performPoint.timestamp;\n        points[0].dataIndex = performPoint.dataIndex;\n        points[1].timestamp = performPoint.timestamp;\n        points[1].dataIndex = performPoint.dataIndex;\n    },\n    performEventMoveForDrawing: function(_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].timestamp = performPoint.timestamp;\n            points[0].dataIndex = performPoint.dataIndex;\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var verticalSegment = {\n    name: \"verticalSegment\",\n    totalStep: 3,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates;\n        if (coordinates.length === 2) {\n            return [\n                {\n                    type: \"line\",\n                    attrs: {\n                        coordinates: coordinates\n                    }\n                }\n            ];\n        }\n        return [];\n    },\n    performEventPressedMove: function(_a) {\n        var points = _a.points, performPoint = _a.performPoint;\n        points[0].timestamp = performPoint.timestamp;\n        points[0].dataIndex = performPoint.dataIndex;\n        points[1].timestamp = performPoint.timestamp;\n        points[1].dataIndex = performPoint.dataIndex;\n    },\n    performEventMoveForDrawing: function(_a) {\n        var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;\n        if (currentStep === 2) {\n            points[0].timestamp = performPoint.timestamp;\n            points[0].dataIndex = performPoint.dataIndex;\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var verticalStraightLine = {\n    name: \"verticalStraightLine\",\n    totalStep: 2,\n    needDefaultPointFigure: true,\n    needDefaultXAxisFigure: true,\n    needDefaultYAxisFigure: true,\n    createPointFigures: function(_a) {\n        var coordinates = _a.coordinates, bounding = _a.bounding;\n        return [\n            {\n                type: \"line\",\n                attrs: {\n                    coordinates: [\n                        {\n                            x: coordinates[0].x,\n                            y: 0\n                        },\n                        {\n                            x: coordinates[0].x,\n                            y: bounding.height\n                        }\n                    ]\n                }\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var simpleAnnotation = {\n    name: \"simpleAnnotation\",\n    totalStep: 2,\n    styles: {\n        line: {\n            style: LineType.Dashed\n        }\n    },\n    createPointFigures: function(_a) {\n        var _b;\n        var overlay = _a.overlay, coordinates = _a.coordinates;\n        var text = \"\";\n        if (isValid(overlay.extendData)) {\n            if (!isFunction(overlay.extendData)) {\n                text = (_b = overlay.extendData) !== null && _b !== void 0 ? _b : \"\";\n            } else {\n                text = overlay.extendData(overlay);\n            }\n        }\n        var startX = coordinates[0].x;\n        var startY = coordinates[0].y - 6;\n        var lineEndY = startY - 50;\n        var arrowEndY = lineEndY - 5;\n        return [\n            {\n                type: \"line\",\n                attrs: {\n                    coordinates: [\n                        {\n                            x: startX,\n                            y: startY\n                        },\n                        {\n                            x: startX,\n                            y: lineEndY\n                        }\n                    ]\n                },\n                ignoreEvent: true\n            },\n            {\n                type: \"polygon\",\n                attrs: {\n                    coordinates: [\n                        {\n                            x: startX,\n                            y: lineEndY\n                        },\n                        {\n                            x: startX - 4,\n                            y: arrowEndY\n                        },\n                        {\n                            x: startX + 4,\n                            y: arrowEndY\n                        }\n                    ]\n                },\n                ignoreEvent: true\n            },\n            {\n                type: \"text\",\n                attrs: {\n                    x: startX,\n                    y: arrowEndY,\n                    text: text,\n                    align: \"center\",\n                    baseline: \"bottom\"\n                },\n                ignoreEvent: true\n            }\n        ];\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var simpleTag = {\n    name: \"simpleTag\",\n    totalStep: 2,\n    styles: {\n        line: {\n            style: LineType.Dashed\n        }\n    },\n    createPointFigures: function(_a) {\n        var bounding = _a.bounding, coordinates = _a.coordinates;\n        return {\n            type: \"line\",\n            attrs: {\n                coordinates: [\n                    {\n                        x: 0,\n                        y: coordinates[0].y\n                    },\n                    {\n                        x: bounding.width,\n                        y: coordinates[0].y\n                    }\n                ]\n            },\n            ignoreEvent: true\n        };\n    },\n    createYAxisFigures: function(_a) {\n        var _b, _c;\n        var chart = _a.chart, overlay = _a.overlay, coordinates = _a.coordinates, bounding = _a.bounding, yAxis = _a.yAxis;\n        var isFromZero = (_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isFromZero()) !== null && _b !== void 0 ? _b : false;\n        var textAlign = \"left\";\n        var x = 0;\n        if (isFromZero) {\n            textAlign = \"left\";\n            x = 0;\n        } else {\n            textAlign = \"right\";\n            x = bounding.width;\n        }\n        var text = \"\";\n        if (isValid(overlay.extendData)) {\n            if (!isFunction(overlay.extendData)) {\n                text = (_c = overlay.extendData) !== null && _c !== void 0 ? _c : \"\";\n            } else {\n                text = overlay.extendData(overlay);\n            }\n        }\n        if (!isValid(text) && isNumber(overlay.points[0].value)) {\n            text = formatPrecision(overlay.points[0].value, chart.getPrecision().price);\n        }\n        return {\n            type: \"text\",\n            attrs: {\n                x: x,\n                y: coordinates[0].y,\n                text: text,\n                align: textAlign,\n                baseline: \"middle\"\n            }\n        };\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var overlays = {};\nvar extensions$1 = [\n    fibonacciLine,\n    horizontalRayLine,\n    horizontalSegment,\n    horizontalStraightLine,\n    parallelStraightLine,\n    priceChannelLine,\n    priceLine,\n    rayLine,\n    segment,\n    straightLine,\n    verticalRayLine,\n    verticalSegment,\n    verticalStraightLine,\n    simpleAnnotation,\n    simpleTag\n];\nextensions$1.forEach(function(template) {\n    overlays[template.name] = OverlayImp.extend(template);\n});\nfunction registerOverlay(template) {\n    overlays[template.name] = OverlayImp.extend(template);\n}\nfunction getOverlayInnerClass(name) {\n    var _a;\n    return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getOverlayClass(name) {\n    var _a;\n    return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getSupportedOverlays() {\n    return Object.keys(overlays);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var light = {\n    grid: {\n        horizontal: {\n            color: \"#EDEDED\"\n        },\n        vertical: {\n            color: \"#EDEDED\"\n        }\n    },\n    candle: {\n        priceMark: {\n            high: {\n                color: \"#76808F\"\n            },\n            low: {\n                color: \"#76808F\"\n            }\n        },\n        tooltip: {\n            rect: {\n                color: \"#FEFEFE\",\n                borderColor: \"#F2F3F5\"\n            },\n            text: {\n                color: \"#76808F\"\n            }\n        }\n    },\n    indicator: {\n        tooltip: {\n            text: {\n                color: \"#76808F\"\n            }\n        }\n    },\n    xAxis: {\n        axisLine: {\n            color: \"#DDDDDD\"\n        },\n        tickText: {\n            color: \"#76808F\"\n        },\n        tickLine: {\n            color: \"#DDDDDD\"\n        }\n    },\n    yAxis: {\n        axisLine: {\n            color: \"#DDDDDD\"\n        },\n        tickText: {\n            color: \"#76808F\"\n        },\n        tickLine: {\n            color: \"#DDDDDD\"\n        }\n    },\n    separator: {\n        color: \"#DDDDDD\"\n    },\n    crosshair: {\n        horizontal: {\n            line: {\n                color: \"#76808F\"\n            },\n            text: {\n                borderColor: \"#686D76\",\n                backgroundColor: \"#686D76\"\n            }\n        },\n        vertical: {\n            line: {\n                color: \"#76808F\"\n            },\n            text: {\n                borderColor: \"#686D76\",\n                backgroundColor: \"#686D76\"\n            }\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var dark = {\n    grid: {\n        horizontal: {\n            color: \"#292929\"\n        },\n        vertical: {\n            color: \"#292929\"\n        }\n    },\n    candle: {\n        priceMark: {\n            high: {\n                color: \"#929AA5\"\n            },\n            low: {\n                color: \"#929AA5\"\n            }\n        },\n        tooltip: {\n            rect: {\n                color: \"rgba(10, 10, 10, .6)\",\n                borderColor: \"rgba(10, 10, 10, .6)\"\n            },\n            text: {\n                color: \"#929AA5\"\n            }\n        }\n    },\n    indicator: {\n        tooltip: {\n            text: {\n                color: \"#929AA5\"\n            }\n        }\n    },\n    xAxis: {\n        axisLine: {\n            color: \"#333333\"\n        },\n        tickText: {\n            color: \"#929AA5\"\n        },\n        tickLine: {\n            color: \"#333333\"\n        }\n    },\n    yAxis: {\n        axisLine: {\n            color: \"#333333\"\n        },\n        tickText: {\n            color: \"#929AA5\"\n        },\n        tickLine: {\n            color: \"#333333\"\n        }\n    },\n    separator: {\n        color: \"#333333\"\n    },\n    crosshair: {\n        horizontal: {\n            line: {\n                color: \"#929AA5\"\n            },\n            text: {\n                borderColor: \"#373a40\",\n                backgroundColor: \"#373a40\"\n            }\n        },\n        vertical: {\n            line: {\n                color: \"#929AA5\"\n            },\n            text: {\n                borderColor: \"#373a40\",\n                backgroundColor: \"#373a40\"\n            }\n        }\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var styles = {\n    light: light,\n    dark: dark\n};\nfunction registerStyles(name, ss) {\n    styles[name] = ss;\n}\nfunction getStyles(name) {\n    var _a;\n    return (_a = styles[name]) !== null && _a !== void 0 ? _a : null;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var PANE_MIN_HEIGHT = 30;\nvar PANE_DEFAULT_HEIGHT = 100;\nvar PaneIdConstants = {\n    CANDLE: \"candle_pane\",\n    INDICATOR: \"indicator_pane_\",\n    X_AXIS: \"x_axis_pane\"\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var BarSpaceLimitConstants = {\n    MIN: 1,\n    MAX: 50\n};\nvar DEFAULT_BAR_SPACE = 10;\nvar DEFAULT_OFFSET_RIGHT_DISTANCE = 80;\nvar BAR_GAP_RATIO = 0.2;\nvar SCALE_MULTIPLIER = 10;\nvar DEFAULT_MIN_TIME_SPAN = 15 * 60 * 1000;\nvar StoreImp = /** @class */ function() {\n    function StoreImp(chart, options) {\n        var _this = this;\n        /**\n         * Styles\n         */ this._styles = getDefaultStyles();\n        /**\n         * Custom api\n         */ this._customApi = {\n            formatDate: function(timestamp, format) {\n                return formatTimestampToString(_this._dateTimeFormat, timestamp, format);\n            },\n            formatBigNumber: formatBigNumber\n        };\n        /**\n         * Locale\n         */ this._locale = \"en-US\";\n        /**\n         * Thousands separator\n         */ this._thousandsSeparator = {\n            sign: \",\",\n            format: function(value) {\n                return formatThousands(value, _this._thousandsSeparator.sign);\n            }\n        };\n        /**\n         * Decimal fold\n         */ this._decimalFold = {\n            threshold: 3,\n            format: function(value) {\n                return formatFoldDecimal(value, _this._decimalFold.threshold);\n            }\n        };\n        /**\n         * Price and volume precision\n         */ this._precision = {\n            price: 2,\n            volume: 0\n        };\n        /**\n         * Data source\n         */ this._dataList = [];\n        /**\n         * Load more data callback\n         */ this._loadMoreDataCallback = null;\n        /**\n         * Is loading data flag\n         */ this._loading = true;\n        /**\n        * Whether there are forward and backward more flag\n         */ this._loadDataMore = {\n            forward: false,\n            backward: false\n        };\n        /**\n         * Scale enabled flag\n         */ this._zoomEnabled = true;\n        /**\n         * Scroll enabled flag\n         */ this._scrollEnabled = true;\n        /**\n         * Total space of drawing area\n         */ this._totalBarSpace = 0;\n        /**\n         * Space occupied by a single piece of data\n         */ this._barSpace = DEFAULT_BAR_SPACE;\n        /**\n         * Distance from the last data to the right of the drawing area\n         */ this._offsetRightDistance = DEFAULT_OFFSET_RIGHT_DISTANCE;\n        /**\n         * The number of bar to the right of the drawing area from the last data when scrolling starts\n         */ this._startLastBarRightSideDiffBarCount = 0;\n        /**\n         * Scroll limit role\n         */ this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */ ;\n        /**\n         * Scroll to the leftmost and rightmost visible bar\n         */ this._minVisibleBarCount = {\n            left: 2,\n            right: 2\n        };\n        /**\n         * Scroll to the leftmost and rightmost distance\n         */ this._maxOffsetDistance = {\n            left: 50,\n            right: 50\n        };\n        /**\n         * Start and end points of visible area data index\n         */ this._visibleRange = getDefaultVisibleRange();\n        this._timeWeightTickMap = new Map();\n        this._timeWeightTickList = [];\n        this._minTimeSpan = {\n            compare: Number.MAX_SAFE_INTEGER,\n            calc: DEFAULT_MIN_TIME_SPAN\n        };\n        /**\n         * Visible data array\n         */ this._visibleRangeDataList = [];\n        /**\n         * Visible highest lowest price data\n         */ this._visibleRangeHighLowPrice = [\n            {\n                x: 0,\n                price: Number.MIN_SAFE_INTEGER\n            },\n            {\n                x: 0,\n                price: Number.MAX_SAFE_INTEGER\n            }\n        ];\n        /**\n         * Crosshair info\n         */ this._crosshair = {};\n        /**\n         * Active tooltip icon info\n         */ this._activeTooltipFeatureInfo = null;\n        /**\n         * Actions\n         */ this._actions = new Map();\n        /**\n         * Indicator\n         */ this._indicators = new Map();\n        /**\n         * Task scheduler\n         */ this._taskScheduler = new TaskScheduler();\n        /**\n         * Overlay\n         */ this._overlays = new Map();\n        /**\n         * Overlay information in painting\n         */ this._progressOverlayInfo = null;\n        /**\n         * Overlay information by the mouse pressed\n         */ this._pressedOverlayInfo = {\n            paneId: \"\",\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n            figureIndex: -1,\n            figure: null\n        };\n        /**\n         * Overlay information by hover\n         */ this._hoverOverlayInfo = {\n            paneId: \"\",\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n            figureIndex: -1,\n            figure: null\n        };\n        /**\n         * Overlay information by the mouse click\n         */ this._clickOverlayInfo = {\n            paneId: \"\",\n            overlay: null,\n            figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n            figureIndex: -1,\n            figure: null\n        };\n        this._chart = chart;\n        this._calcOptimalBarSpace();\n        this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;\n        var _a = options !== null && options !== void 0 ? options : {}, styles = _a.styles, locale = _a.locale, timezone = _a.timezone, customApi = _a.customApi, thousandsSeparator = _a.thousandsSeparator, decimalFold = _a.decimalFold;\n        if (isValid(styles)) {\n            this.setStyles(styles);\n        }\n        if (isString(locale)) {\n            this.setLocale(locale);\n        }\n        this.setTimezone(timezone !== null && timezone !== void 0 ? timezone : \"\");\n        if (isValid(customApi)) {\n            this.setCustomApi(customApi);\n        }\n        if (isValid(thousandsSeparator)) {\n            this.setThousandsSeparator(thousandsSeparator);\n        }\n        if (isValid(decimalFold)) {\n            this.setDecimalFold(decimalFold);\n        }\n    }\n    StoreImp.prototype.setStyles = function(value) {\n        var _a, _b;\n        var styles = null;\n        if (isString(value)) {\n            styles = getStyles(value);\n        } else {\n            styles = value;\n        }\n        merge(this._styles, styles);\n        // `candle.tooltip.custom` should override\n        if (isArray((_b = (_a = styles === null || styles === void 0 ? void 0 : styles.candle) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.custom)) {\n            this._styles.candle.tooltip.custom = styles.candle.tooltip.custom;\n        }\n    };\n    StoreImp.prototype.getStyles = function() {\n        return this._styles;\n    };\n    StoreImp.prototype.setCustomApi = function(api) {\n        merge(this._customApi, api);\n    };\n    StoreImp.prototype.getCustomApi = function() {\n        return this._customApi;\n    };\n    StoreImp.prototype.setLocale = function(locale) {\n        this._locale = locale;\n    };\n    StoreImp.prototype.getLocale = function() {\n        return this._locale;\n    };\n    StoreImp.prototype.setTimezone = function(timezone) {\n        if (!isValid(this._dateTimeFormat) || this.getTimezone() !== timezone) {\n            var options = {\n                hour12: false,\n                year: \"numeric\",\n                month: \"2-digit\",\n                day: \"2-digit\",\n                hour: \"2-digit\",\n                minute: \"2-digit\",\n                second: \"2-digit\"\n            };\n            if (timezone.length > 0) {\n                options.timeZone = timezone;\n            }\n            var dateTimeFormat = null;\n            try {\n                dateTimeFormat = new Intl.DateTimeFormat(\"en\", options);\n            } catch (e) {\n                logWarn(\"\", \"\", \"Timezone is error!!!\");\n            }\n            if (dateTimeFormat !== null) {\n                this._classifyTimeWeightTicks(this._dataList);\n                this._dateTimeFormat = dateTimeFormat;\n            }\n        }\n    };\n    StoreImp.prototype.getTimezone = function() {\n        return this._dateTimeFormat.resolvedOptions().timeZone;\n    };\n    StoreImp.prototype.getDateTimeFormat = function() {\n        return this._dateTimeFormat;\n    };\n    StoreImp.prototype.setThousandsSeparator = function(thousandsSeparator) {\n        merge(this._thousandsSeparator, thousandsSeparator);\n    };\n    StoreImp.prototype.getThousandsSeparator = function() {\n        return this._thousandsSeparator;\n    };\n    StoreImp.prototype.setDecimalFold = function(decimalFold) {\n        merge(this._decimalFold, decimalFold);\n    };\n    StoreImp.prototype.getDecimalFold = function() {\n        return this._decimalFold;\n    };\n    StoreImp.prototype.getPrecision = function() {\n        return this._precision;\n    };\n    StoreImp.prototype.setPrecision = function(precision) {\n        merge(this._precision, precision);\n        this._synchronizeIndicatorSeriesPrecision();\n    };\n    StoreImp.prototype.getDataList = function() {\n        return this._dataList;\n    };\n    StoreImp.prototype.getVisibleRangeDataList = function() {\n        return this._visibleRangeDataList;\n    };\n    StoreImp.prototype.getVisibleRangeHighLowPrice = function() {\n        return this._visibleRangeHighLowPrice;\n    };\n    StoreImp.prototype.addData = function(data, type, more) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        var success = false;\n        var adjustFlag = false;\n        var dataLengthChange = 0;\n        if (isArray(data)) {\n            dataLengthChange = data.length;\n            switch(type){\n                case LoadDataType.Init:\n                    {\n                        this.clearData();\n                        this._dataList = data;\n                        this._loadDataMore.backward = (_a = more === null || more === void 0 ? void 0 : more.backward) !== null && _a !== void 0 ? _a : false;\n                        this._loadDataMore.forward = (_b = more === null || more === void 0 ? void 0 : more.forward) !== null && _b !== void 0 ? _b : false;\n                        this._classifyTimeWeightTicks(this._dataList);\n                        this.setOffsetRightDistance(this._offsetRightDistance);\n                        adjustFlag = true;\n                        break;\n                    }\n                case LoadDataType.Backward:\n                    {\n                        this._classifyTimeWeightTicks(data, true);\n                        this._dataList = this._dataList.concat(data);\n                        this._loadDataMore.backward = (_c = more === null || more === void 0 ? void 0 : more.backward) !== null && _c !== void 0 ? _c : false;\n                        adjustFlag = dataLengthChange > 0;\n                        break;\n                    }\n                case LoadDataType.Forward:\n                    {\n                        this._dataList = data.concat(this._dataList);\n                        this._classifyTimeWeightTicks(this._dataList);\n                        this._loadDataMore.forward = (_d = more === null || more === void 0 ? void 0 : more.forward) !== null && _d !== void 0 ? _d : false;\n                        adjustFlag = dataLengthChange > 0;\n                        break;\n                    }\n            }\n            this._loading = false;\n            success = true;\n        } else {\n            var dataCount = this._dataList.length;\n            // Determine where individual data should be added\n            var timestamp = data.timestamp;\n            var lastDataTimestamp = formatValue(this._dataList[dataCount - 1], \"timestamp\", 0);\n            if (timestamp > lastDataTimestamp) {\n                this._classifyTimeWeightTicks([\n                    data\n                ], true);\n                this._dataList.push(data);\n                var lastBarRightSideDiffBarCount = this.getLastBarRightSideDiffBarCount();\n                if (lastBarRightSideDiffBarCount < 0) {\n                    this.setLastBarRightSideDiffBarCount(--lastBarRightSideDiffBarCount);\n                }\n                dataLengthChange = 1;\n                success = true;\n                adjustFlag = true;\n            } else if (timestamp === lastDataTimestamp) {\n                this._dataList[dataCount - 1] = data;\n                success = true;\n                adjustFlag = true;\n            }\n        }\n        if (success) {\n            if (adjustFlag) {\n                this._adjustVisibleRange();\n                this.setCrosshair(this._crosshair, {\n                    notInvalidate: true\n                });\n                var filterIndicators = this.getIndicatorsByFilter({});\n                filterIndicators.forEach(function(indicator) {\n                    _this._addIndicatorCalcTask(indicator, type);\n                });\n                this._chart.layout({\n                    measureWidth: true,\n                    update: true,\n                    buildYAxisTick: true\n                });\n            }\n        }\n    };\n    StoreImp.prototype.setLoadMoreDataCallback = function(callback) {\n        this._loadMoreDataCallback = callback;\n    };\n    StoreImp.prototype._calcOptimalBarSpace = function() {\n        var specialBarSpace = 4;\n        var ratio = 1 - BAR_GAP_RATIO * Math.atan(Math.max(specialBarSpace, this._barSpace) - specialBarSpace) / (Math.PI * 0.5);\n        var gapBarSpace = Math.min(Math.floor(this._barSpace * ratio), Math.floor(this._barSpace));\n        if (gapBarSpace % 2 === 0 && gapBarSpace + 2 >= this._barSpace) {\n            --gapBarSpace;\n        }\n        this._gapBarSpace = Math.max(1, gapBarSpace);\n    };\n    StoreImp.prototype._classifyTimeWeightTicks = function(newDataList, isUpdate) {\n        var baseDataIndex = 0;\n        var prevTimestamp = null;\n        if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {\n            baseDataIndex = this._dataList.length;\n            prevTimestamp = this._dataList[baseDataIndex - 1].timestamp;\n        } else {\n            this._timeWeightTickMap.clear();\n            this._minTimeSpan = {\n                compare: Number.MAX_SAFE_INTEGER,\n                calc: DEFAULT_MIN_TIME_SPAN\n            };\n        }\n        classifyTimeWeightTicks(this._timeWeightTickMap, newDataList, this._dateTimeFormat, baseDataIndex, this._minTimeSpan, prevTimestamp);\n        if (this._minTimeSpan.compare !== Number.MAX_SAFE_INTEGER) {\n            this._minTimeSpan.calc = this._minTimeSpan.compare;\n        }\n        this._timeWeightTickList = createTimeWeightTickList(this._timeWeightTickMap, this._barSpace, this._styles.xAxis.tickText);\n    };\n    StoreImp.prototype.getTimeWeightTickList = function() {\n        return this._timeWeightTickList;\n    };\n    StoreImp.prototype._adjustVisibleRange = function() {\n        var _this = this;\n        var _a, _b, _c, _d;\n        var totalBarCount = this._dataList.length;\n        var visibleBarCount = this._totalBarSpace / this._barSpace;\n        var leftMinVisibleBarCount = 0;\n        var rightMinVisibleBarCount = 0;\n        if (this._scrollLimitRole === 1 /* ScrollLimitRole.Distance */ ) {\n            leftMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.right) / this._barSpace;\n            rightMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.left) / this._barSpace;\n        } else {\n            leftMinVisibleBarCount = this._minVisibleBarCount.left;\n            rightMinVisibleBarCount = this._minVisibleBarCount.right;\n        }\n        leftMinVisibleBarCount = Math.max(0, leftMinVisibleBarCount);\n        rightMinVisibleBarCount = Math.max(0, rightMinVisibleBarCount);\n        var maxRightOffsetBarCount = visibleBarCount - Math.min(leftMinVisibleBarCount, totalBarCount);\n        if (this._lastBarRightSideDiffBarCount > maxRightOffsetBarCount) {\n            this._lastBarRightSideDiffBarCount = maxRightOffsetBarCount;\n        }\n        var minRightOffsetBarCount = -totalBarCount + Math.min(rightMinVisibleBarCount, totalBarCount);\n        if (this._lastBarRightSideDiffBarCount < minRightOffsetBarCount) {\n            this._lastBarRightSideDiffBarCount = minRightOffsetBarCount;\n        }\n        var to = Math.round(this._lastBarRightSideDiffBarCount + totalBarCount + 0.5);\n        var realTo = to;\n        if (to > totalBarCount) {\n            to = totalBarCount;\n        }\n        var from = Math.round(to - visibleBarCount) - 1;\n        if (from < 0) {\n            from = 0;\n        }\n        var realFrom = this._lastBarRightSideDiffBarCount > 0 ? Math.round(totalBarCount + this._lastBarRightSideDiffBarCount - visibleBarCount) - 1 : from;\n        this._visibleRange = {\n            from: from,\n            to: to,\n            realFrom: realFrom,\n            realTo: realTo\n        };\n        this.executeAction(ActionType.OnVisibleRangeChange, this._visibleRange);\n        this._visibleRangeDataList = [];\n        this._visibleRangeHighLowPrice = [\n            {\n                x: 0,\n                price: Number.MIN_SAFE_INTEGER\n            },\n            {\n                x: 0,\n                price: Number.MAX_SAFE_INTEGER\n            }\n        ];\n        for(var i = realFrom; i < realTo; i++){\n            var kLineData = this._dataList[i];\n            var x = this.dataIndexToCoordinate(i);\n            this._visibleRangeDataList.push({\n                dataIndex: i,\n                x: x,\n                data: {\n                    prev: (_a = this._dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData,\n                    current: kLineData,\n                    next: (_b = this._dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData\n                }\n            });\n            if (isValid(kLineData)) {\n                if (this._visibleRangeHighLowPrice[0].price < kLineData.high) {\n                    this._visibleRangeHighLowPrice[0].price = kLineData.high;\n                    this._visibleRangeHighLowPrice[0].x = x;\n                }\n                if (this._visibleRangeHighLowPrice[1].price > kLineData.low) {\n                    this._visibleRangeHighLowPrice[1].price = kLineData.low;\n                    this._visibleRangeHighLowPrice[1].x = x;\n                }\n            }\n        }\n        // More processing and loading, more loading if there are callback methods and no data is being loaded\n        if (!this._loading && isValid(this._loadMoreDataCallback)) {\n            var params = null;\n            if (from === 0) {\n                if (this._loadDataMore.forward) {\n                    this._loading = true;\n                    params = {\n                        type: LoadDataType.Forward,\n                        data: (_c = this._dataList[0]) !== null && _c !== void 0 ? _c : null,\n                        callback: function(data, more) {\n                            _this.addData(data, LoadDataType.Forward, {\n                                forward: more !== null && more !== void 0 ? more : false,\n                                backward: more !== null && more !== void 0 ? more : false\n                            });\n                        }\n                    };\n                }\n            } else if (to === totalBarCount) {\n                if (this._loadDataMore.backward) {\n                    this._loading = true;\n                    params = {\n                        type: LoadDataType.Backward,\n                        data: (_d = this._dataList[totalBarCount - 1]) !== null && _d !== void 0 ? _d : null,\n                        callback: function(data, more) {\n                            _this.addData(data, LoadDataType.Backward, {\n                                forward: more !== null && more !== void 0 ? more : false,\n                                backward: more !== null && more !== void 0 ? more : false\n                            });\n                        }\n                    };\n                }\n            }\n            if (isValid(params)) {\n                this._loadMoreDataCallback(params);\n            }\n        }\n    };\n    StoreImp.prototype.getBarSpace = function() {\n        return {\n            bar: this._barSpace,\n            halfBar: this._barSpace / 2,\n            gapBar: this._gapBarSpace,\n            halfGapBar: Math.floor(this._gapBarSpace / 2)\n        };\n    };\n    StoreImp.prototype.setBarSpace = function(barSpace, adjustBeforeFunc) {\n        if (barSpace < BarSpaceLimitConstants.MIN || barSpace > BarSpaceLimitConstants.MAX || this._barSpace === barSpace) {\n            return;\n        }\n        this._barSpace = barSpace;\n        this._timeWeightTickList = createTimeWeightTickList(this._timeWeightTickMap, this._barSpace, this._styles.xAxis.tickText);\n        this._calcOptimalBarSpace();\n        adjustBeforeFunc === null || adjustBeforeFunc === void 0 ? void 0 : adjustBeforeFunc();\n        this._adjustVisibleRange();\n        this.setCrosshair(this._crosshair, {\n            notInvalidate: true\n        });\n        this._chart.layout({\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true\n        });\n    };\n    StoreImp.prototype.setTotalBarSpace = function(totalSpace) {\n        if (this._totalBarSpace !== totalSpace) {\n            this._totalBarSpace = totalSpace;\n            this._adjustVisibleRange();\n            this.setCrosshair(this._crosshair, {\n                notInvalidate: true\n            });\n        }\n    };\n    StoreImp.prototype.setOffsetRightDistance = function(distance, isUpdate) {\n        this._offsetRightDistance = this._scrollLimitRole === 1 /* ScrollLimitRole.Distance */  ? Math.min(this._maxOffsetDistance.right, distance) : distance;\n        this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;\n        if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {\n            this._adjustVisibleRange();\n            this.setCrosshair(this._crosshair, {\n                notInvalidate: true\n            });\n            this._chart.layout({\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true\n            });\n        }\n        return this;\n    };\n    StoreImp.prototype.getInitialOffsetRightDistance = function() {\n        return this._offsetRightDistance;\n    };\n    StoreImp.prototype.getOffsetRightDistance = function() {\n        return Math.max(0, this._lastBarRightSideDiffBarCount * this._barSpace);\n    };\n    StoreImp.prototype.getLastBarRightSideDiffBarCount = function() {\n        return this._lastBarRightSideDiffBarCount;\n    };\n    StoreImp.prototype.setLastBarRightSideDiffBarCount = function(barCount) {\n        this._lastBarRightSideDiffBarCount = barCount;\n    };\n    StoreImp.prototype.setMaxOffsetLeftDistance = function(distance) {\n        this._scrollLimitRole = 1 /* ScrollLimitRole.Distance */ ;\n        this._maxOffsetDistance.left = distance;\n    };\n    StoreImp.prototype.setMaxOffsetRightDistance = function(distance) {\n        this._scrollLimitRole = 1 /* ScrollLimitRole.Distance */ ;\n        this._maxOffsetDistance.right = distance;\n    };\n    StoreImp.prototype.setLeftMinVisibleBarCount = function(barCount) {\n        this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */ ;\n        this._minVisibleBarCount.left = barCount;\n    };\n    StoreImp.prototype.setRightMinVisibleBarCount = function(barCount) {\n        this._scrollLimitRole = 0 /* ScrollLimitRole.BarCount */ ;\n        this._minVisibleBarCount.right = barCount;\n    };\n    StoreImp.prototype.getVisibleRange = function() {\n        return this._visibleRange;\n    };\n    StoreImp.prototype.startScroll = function() {\n        this._startLastBarRightSideDiffBarCount = this._lastBarRightSideDiffBarCount;\n    };\n    StoreImp.prototype.scroll = function(distance) {\n        if (!this._scrollEnabled) {\n            return;\n        }\n        var distanceBarCount = distance / this._barSpace;\n        var prevLastBarRightSideDistance = this._lastBarRightSideDiffBarCount * this._barSpace;\n        this._lastBarRightSideDiffBarCount = this._startLastBarRightSideDiffBarCount - distanceBarCount;\n        this._adjustVisibleRange();\n        this.setCrosshair(this._crosshair, {\n            notInvalidate: true\n        });\n        this._chart.layout({\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true\n        });\n        var realDistance = Math.round(prevLastBarRightSideDistance - this._lastBarRightSideDiffBarCount * this._barSpace);\n        if (realDistance !== 0) {\n            this.executeAction(ActionType.OnScroll, {\n                distance: realDistance\n            });\n        }\n    };\n    StoreImp.prototype.getDataByDataIndex = function(dataIndex) {\n        var _a;\n        return (_a = this._dataList[dataIndex]) !== null && _a !== void 0 ? _a : null;\n    };\n    StoreImp.prototype.coordinateToFloatIndex = function(x) {\n        var dataCount = this._dataList.length;\n        var deltaFromRight = (this._totalBarSpace - x) / this._barSpace;\n        var index = dataCount + this._lastBarRightSideDiffBarCount - deltaFromRight;\n        return Math.round(index * 1000000) / 1000000;\n    };\n    StoreImp.prototype.dataIndexToTimestamp = function(dataIndex) {\n        var length = this._dataList.length;\n        if (length === 0) {\n            return null;\n        }\n        var data = this.getDataByDataIndex(dataIndex);\n        if (isValid(data)) {\n            return data.timestamp;\n        }\n        var lastIndex = length - 1;\n        if (dataIndex > lastIndex) {\n            return this._dataList[lastIndex].timestamp + this._minTimeSpan.calc * (dataIndex - lastIndex);\n        }\n        if (dataIndex < 0) {\n            return this._dataList[0].timestamp - this._minTimeSpan.calc * Math.abs(dataIndex);\n        }\n        return null;\n    };\n    StoreImp.prototype.timestampToDataIndex = function(timestamp) {\n        var length = this._dataList.length;\n        if (length === 0) {\n            return 0;\n        }\n        var lastIndex = length - 1;\n        var lastTimestamp = this._dataList[lastIndex].timestamp;\n        if (timestamp > lastTimestamp) {\n            return lastIndex + Math.floor((timestamp - lastTimestamp) / this._minTimeSpan.calc);\n        }\n        var firstTimestamp = this._dataList[0].timestamp;\n        if (timestamp < firstTimestamp) {\n            return Math.floor((timestamp - firstTimestamp) / this._minTimeSpan.calc);\n        }\n        return binarySearchNearest(this._dataList, \"timestamp\", timestamp);\n    };\n    StoreImp.prototype.dataIndexToCoordinate = function(dataIndex) {\n        var dataCount = this._dataList.length;\n        var deltaFromRight = dataCount + this._lastBarRightSideDiffBarCount - dataIndex;\n        return Math.floor(this._totalBarSpace - (deltaFromRight - 0.5) * this._barSpace + 0.5);\n    };\n    StoreImp.prototype.coordinateToDataIndex = function(x) {\n        return Math.ceil(this.coordinateToFloatIndex(x)) - 1;\n    };\n    StoreImp.prototype.zoom = function(scale, coordinate) {\n        var _this = this;\n        var _a;\n        if (!this._zoomEnabled) {\n            return;\n        }\n        var zoomCoordinate = coordinate !== null && coordinate !== void 0 ? coordinate : null;\n        if (!isNumber(zoomCoordinate === null || zoomCoordinate === void 0 ? void 0 : zoomCoordinate.x)) {\n            zoomCoordinate = {\n                x: (_a = this._crosshair.x) !== null && _a !== void 0 ? _a : this._totalBarSpace / 2\n            };\n        }\n        var x = zoomCoordinate.x;\n        var floatIndex = this.coordinateToFloatIndex(x);\n        var prevBarSpace = this._barSpace;\n        var barSpace = this._barSpace + scale * (this._barSpace / SCALE_MULTIPLIER);\n        this.setBarSpace(barSpace, function() {\n            _this._lastBarRightSideDiffBarCount += floatIndex - _this.coordinateToFloatIndex(x);\n        });\n        var realScale = this._barSpace / prevBarSpace;\n        if (realScale !== 1) {\n            this.executeAction(ActionType.OnZoom, {\n                scale: realScale\n            });\n        }\n    };\n    StoreImp.prototype.setZoomEnabled = function(enabled) {\n        this._zoomEnabled = enabled;\n    };\n    StoreImp.prototype.isZoomEnabled = function() {\n        return this._zoomEnabled;\n    };\n    StoreImp.prototype.setScrollEnabled = function(enabled) {\n        this._scrollEnabled = enabled;\n    };\n    StoreImp.prototype.isScrollEnabled = function() {\n        return this._scrollEnabled;\n    };\n    StoreImp.prototype.setCrosshair = function(crosshair, options) {\n        var _a;\n        var _b = options !== null && options !== void 0 ? options : {}, notInvalidate = _b.notInvalidate, notExecuteAction = _b.notExecuteAction, forceInvalidate = _b.forceInvalidate;\n        var cr = crosshair !== null && crosshair !== void 0 ? crosshair : {};\n        var realDataIndex = 0;\n        var dataIndex = 0;\n        if (isNumber(cr.x)) {\n            realDataIndex = this.coordinateToDataIndex(cr.x);\n            if (realDataIndex < 0) {\n                dataIndex = 0;\n            } else if (realDataIndex > this._dataList.length - 1) {\n                dataIndex = this._dataList.length - 1;\n            } else {\n                dataIndex = realDataIndex;\n            }\n        } else {\n            realDataIndex = this._dataList.length - 1;\n            dataIndex = realDataIndex;\n        }\n        var kLineData = this._dataList[dataIndex];\n        var realX = this.dataIndexToCoordinate(realDataIndex);\n        var prevCrosshair = {\n            x: this._crosshair.x,\n            y: this._crosshair.y,\n            paneId: this._crosshair.paneId\n        };\n        this._crosshair = __assign(__assign({}, cr), {\n            realX: realX,\n            kLineData: kLineData,\n            realDataIndex: realDataIndex,\n            dataIndex: dataIndex,\n            timestamp: (_a = this.dataIndexToTimestamp(realDataIndex)) !== null && _a !== void 0 ? _a : undefined\n        });\n        if (prevCrosshair.x !== cr.x || prevCrosshair.y !== cr.y || prevCrosshair.paneId !== cr.paneId || (forceInvalidate !== null && forceInvalidate !== void 0 ? forceInvalidate : false)) {\n            if (isValid(kLineData) && !(notExecuteAction !== null && notExecuteAction !== void 0 ? notExecuteAction : false)) {\n                this._chart.crosshairChange(this._crosshair);\n            }\n            if (!(notInvalidate !== null && notInvalidate !== void 0 ? notInvalidate : false)) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n            }\n        }\n    };\n    /**\n     * 获取crosshair信息\n     * @returns\n     */ StoreImp.prototype.getCrosshair = function() {\n        return this._crosshair;\n    };\n    StoreImp.prototype.setActiveTooltipFeatureInfo = function(info) {\n        this._activeTooltipFeatureInfo = info !== null && info !== void 0 ? info : null;\n    };\n    StoreImp.prototype.getActiveTooltipFeatureInfo = function() {\n        return this._activeTooltipFeatureInfo;\n    };\n    StoreImp.prototype.executeAction = function(type, data) {\n        var _a;\n        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.execute(data);\n    };\n    StoreImp.prototype.subscribeAction = function(type, callback) {\n        var _a;\n        if (!this._actions.has(type)) {\n            this._actions.set(type, new Action());\n        }\n        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.subscribe(callback);\n    };\n    StoreImp.prototype.unsubscribeAction = function(type, callback) {\n        var action = this._actions.get(type);\n        if (isValid(action)) {\n            action.unsubscribe(callback);\n            if (action.isEmpty()) {\n                this._actions.delete(type);\n            }\n        }\n    };\n    StoreImp.prototype.hasAction = function(type) {\n        var action = this._actions.get(type);\n        return isValid(action) && !action.isEmpty();\n    };\n    StoreImp.prototype._sortIndicators = function(paneId) {\n        var _a;\n        if (isString(paneId)) {\n            (_a = this._indicators.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function(i1, i2) {\n                return i1.zLevel - i2.zLevel;\n            });\n        } else {\n            this._indicators.forEach(function(paneIndicators) {\n                paneIndicators.sort(function(i1, i2) {\n                    return i1.zLevel - i2.zLevel;\n                });\n            });\n        }\n    };\n    StoreImp.prototype._addIndicatorCalcTask = function(indicator, loadDataType) {\n        var _this = this;\n        this._taskScheduler.addTask({\n            id: generateTaskId(indicator.id),\n            handler: function() {\n                var _a;\n                (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                    state: IndicatorDataState.Loading,\n                    type: loadDataType,\n                    indicator: indicator\n                });\n                indicator.calcImp(_this._dataList).then(function(result) {\n                    var _a;\n                    if (result) {\n                        _this._chart.layout({\n                            measureWidth: true,\n                            update: true,\n                            buildYAxisTick: true\n                        });\n                        (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                            state: IndicatorDataState.Ready,\n                            type: loadDataType,\n                            indicator: indicator\n                        });\n                    }\n                }).catch(function() {\n                    var _a;\n                    (_a = indicator.onDataStateChange) === null || _a === void 0 ? void 0 : _a.call(indicator, {\n                        state: IndicatorDataState.Error,\n                        type: loadDataType,\n                        indicator: indicator\n                    });\n                });\n            }\n        });\n    };\n    StoreImp.prototype.addIndicator = function(create, paneId, isStack) {\n        var name = create.name;\n        var filterIndicators = this.getIndicatorsByFilter(create);\n        if (filterIndicators.length > 0) {\n            return false;\n        }\n        var paneIndicators = this.getIndicatorsByPaneId(paneId);\n        var IndicatorClazz = getIndicatorClass(name);\n        var indicator = new IndicatorClazz();\n        this._synchronizeIndicatorSeriesPrecision(indicator);\n        indicator.paneId = paneId;\n        indicator.override(create);\n        if (!isStack) {\n            this.removeIndicator({\n                paneId: paneId\n            });\n            paneIndicators = [];\n        }\n        paneIndicators.push(indicator);\n        this._indicators.set(paneId, paneIndicators);\n        this._sortIndicators(paneId);\n        this._addIndicatorCalcTask(indicator, LoadDataType.Init);\n        return true;\n    };\n    StoreImp.prototype.getIndicatorsByPaneId = function(paneId) {\n        var _a;\n        return (_a = this._indicators.get(paneId)) !== null && _a !== void 0 ? _a : [];\n    };\n    StoreImp.prototype.getIndicatorsByFilter = function(filter) {\n        var paneId = filter.paneId, name = filter.name, id = filter.id;\n        var match = function(indicator) {\n            if (isValid(id)) {\n                return indicator.id === id;\n            }\n            return !isValid(name) || indicator.name === name;\n        };\n        var indicators = [];\n        if (isValid(paneId)) {\n            indicators = indicators.concat(this.getIndicatorsByPaneId(paneId).filter(match));\n        } else {\n            this._indicators.forEach(function(paneIndicators) {\n                indicators = indicators.concat(paneIndicators.filter(match));\n            });\n        }\n        return indicators;\n    };\n    StoreImp.prototype.removeIndicator = function(filter) {\n        var _this = this;\n        var removed = false;\n        var filterIndicators = this.getIndicatorsByFilter(filter);\n        filterIndicators.forEach(function(indicator) {\n            var paneIndicators = _this.getIndicatorsByPaneId(indicator.paneId);\n            var index = paneIndicators.findIndex(function(ins) {\n                return ins.id === indicator.id;\n            });\n            if (index > -1) {\n                _this._taskScheduler.removeTask(generateTaskId(indicator.id));\n                paneIndicators.splice(index, 1);\n                removed = true;\n            }\n            if (paneIndicators.length === 0) {\n                _this._indicators.delete(indicator.paneId);\n            }\n        });\n        return removed;\n    };\n    StoreImp.prototype.hasIndicators = function(paneId) {\n        return this._indicators.has(paneId);\n    };\n    StoreImp.prototype._synchronizeIndicatorSeriesPrecision = function(indicator) {\n        var _a = this._precision, pricePrecision = _a.price, volumePrecision = _a.volume;\n        var synchronize = function(indicator) {\n            switch(indicator.series){\n                case IndicatorSeries.Price:\n                    {\n                        indicator.setSeriesPrecision(pricePrecision);\n                        break;\n                    }\n                case IndicatorSeries.Volume:\n                    {\n                        indicator.setSeriesPrecision(volumePrecision);\n                        break;\n                    }\n            }\n        };\n        if (isValid(indicator)) {\n            synchronize(indicator);\n        } else {\n            this._indicators.forEach(function(paneIndicators) {\n                paneIndicators.forEach(function(indicator) {\n                    synchronize(indicator);\n                });\n            });\n        }\n    };\n    StoreImp.prototype.overrideIndicator = function(override) {\n        var _this = this;\n        var updateFlag = false;\n        var sortFlag = false;\n        var filterIndicators = this.getIndicatorsByFilter(override);\n        filterIndicators.forEach(function(indicator) {\n            indicator.override(override);\n            var _a = indicator.shouldUpdateImp(), calc = _a.calc, draw = _a.draw, sort = _a.sort;\n            if (sort) {\n                sortFlag = true;\n            }\n            if (calc) {\n                _this._addIndicatorCalcTask(indicator, LoadDataType.Update);\n            } else {\n                if (draw) {\n                    updateFlag = true;\n                }\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (sortFlag) {\n            this._sortIndicators();\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (updateFlag) {\n            this._chart.layout({\n                update: true\n            });\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.getOverlaysByFilter = function(filter) {\n        var _a;\n        var id = filter.id, groupId = filter.groupId, paneId = filter.paneId, name = filter.name;\n        var match = function(overlay) {\n            if (isValid(id)) {\n                return overlay.id === id;\n            } else {\n                if (isValid(groupId)) {\n                    return overlay.groupId === groupId && (!isValid(name) || overlay.name === name);\n                }\n            }\n            return !isValid(name) || overlay.name === name;\n        };\n        var overlays = [];\n        if (isValid(paneId)) {\n            overlays = overlays.concat(this.getOverlaysByPaneId(paneId).filter(match));\n        } else {\n            this._overlays.forEach(function(paneOverlays) {\n                overlays = overlays.concat(paneOverlays.filter(match));\n            });\n        }\n        var progressOverlay = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay;\n        if (isValid(progressOverlay) && match(progressOverlay)) {\n            overlays.push(progressOverlay);\n        }\n        return overlays;\n    };\n    StoreImp.prototype.getOverlaysByPaneId = function(paneId) {\n        var _a;\n        if (!isString(paneId)) {\n            var overlays_1 = [];\n            this._overlays.forEach(function(paneOverlays) {\n                overlays_1 = overlays_1.concat(paneOverlays);\n            });\n            return overlays_1;\n        }\n        return (_a = this._overlays.get(paneId)) !== null && _a !== void 0 ? _a : [];\n    };\n    StoreImp.prototype._sortOverlays = function(paneId) {\n        var _a;\n        if (isString(paneId)) {\n            (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function(o1, o2) {\n                return o1.zLevel - o2.zLevel;\n            });\n        } else {\n            this._overlays.forEach(function(paneOverlays) {\n                paneOverlays.sort(function(o1, o2) {\n                    return o1.zLevel - o2.zLevel;\n                });\n            });\n        }\n    };\n    StoreImp.prototype.addOverlays = function(os, appointPaneFlags) {\n        var _this = this;\n        var updatePaneIds = [];\n        var ids = os.map(function(create, index) {\n            var e_1, _a;\n            var _b, _c, _d, _e, _f, _g;\n            if (isValid(create.id)) {\n                var findOverlay = null;\n                try {\n                    for(var _h = __values(_this._overlays), _j = _h.next(); !_j.done; _j = _h.next()){\n                        var _k = __read(_j.value, 2), overlays = _k[1];\n                        var overlay = overlays.find(function(o) {\n                            return o.id === create.id;\n                        });\n                        if (isValid(overlay)) {\n                            findOverlay = overlay;\n                            break;\n                        }\n                    }\n                } catch (e_1_1) {\n                    e_1 = {\n                        error: e_1_1\n                    };\n                } finally{\n                    try {\n                        if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n                    } finally{\n                        if (e_1) throw e_1.error;\n                    }\n                }\n                if (isValid(findOverlay)) {\n                    return create.id;\n                }\n            }\n            var OverlayClazz = getOverlayInnerClass(create.name);\n            if (isValid(OverlayClazz)) {\n                var id = (_b = create.id) !== null && _b !== void 0 ? _b : createId(OVERLAY_ID_PREFIX);\n                var overlay = new OverlayClazz();\n                var paneId = (_c = create.paneId) !== null && _c !== void 0 ? _c : PaneIdConstants.CANDLE;\n                create.id = id;\n                (_d = create.groupId) !== null && _d !== void 0 ? _d : create.groupId = id;\n                var zLevel = _this.getOverlaysByPaneId(paneId).length;\n                (_e = create.zLevel) !== null && _e !== void 0 ? _e : create.zLevel = zLevel;\n                overlay.override(create);\n                if (!updatePaneIds.includes(paneId)) {\n                    updatePaneIds.push(paneId);\n                }\n                if (overlay.isDrawing()) {\n                    _this._progressOverlayInfo = {\n                        paneId: paneId,\n                        overlay: overlay,\n                        appointPaneFlag: appointPaneFlags[index]\n                    };\n                } else {\n                    if (!_this._overlays.has(paneId)) {\n                        _this._overlays.set(paneId, []);\n                    }\n                    (_f = _this._overlays.get(paneId)) === null || _f === void 0 ? void 0 : _f.push(overlay);\n                }\n                if (overlay.isStart()) {\n                    (_g = overlay.onDrawStart) === null || _g === void 0 ? void 0 : _g.call(overlay, {\n                        overlay: overlay,\n                        chart: _this._chart\n                    });\n                }\n                return id;\n            }\n            return null;\n        });\n        if (updatePaneIds.length > 0) {\n            this._sortOverlays();\n            updatePaneIds.forEach(function(paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */ , paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ , PaneIdConstants.X_AXIS);\n        }\n        return ids;\n    };\n    StoreImp.prototype.getProgressOverlayInfo = function() {\n        return this._progressOverlayInfo;\n    };\n    StoreImp.prototype.progressOverlayComplete = function() {\n        var _a;\n        if (this._progressOverlayInfo !== null) {\n            var _b = this._progressOverlayInfo, overlay = _b.overlay, paneId = _b.paneId;\n            if (!overlay.isDrawing()) {\n                if (!this._overlays.has(paneId)) {\n                    this._overlays.set(paneId, []);\n                }\n                (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.push(overlay);\n                this._sortOverlays(paneId);\n                this._progressOverlayInfo = null;\n            }\n        }\n    };\n    StoreImp.prototype.updateProgressOverlayInfo = function(paneId, appointPaneFlag) {\n        if (this._progressOverlayInfo !== null) {\n            if (isBoolean(appointPaneFlag) && appointPaneFlag) {\n                this._progressOverlayInfo.appointPaneFlag = appointPaneFlag;\n            }\n            this._progressOverlayInfo.paneId = paneId;\n            this._progressOverlayInfo.overlay.override({\n                paneId: paneId\n            });\n        }\n    };\n    StoreImp.prototype.overrideOverlay = function(override) {\n        var _this = this;\n        var sortFlag = false;\n        var updatePaneIds = [];\n        var filterOverlays = this.getOverlaysByFilter(override);\n        filterOverlays.forEach(function(overlay) {\n            overlay.override(override);\n            var _a = overlay.shouldUpdate(), sort = _a.sort, draw = _a.draw;\n            if (sort) {\n                sortFlag = true;\n            }\n            if (sort || draw) {\n                if (!updatePaneIds.includes(overlay.paneId)) {\n                    updatePaneIds.push(overlay.paneId);\n                }\n            }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (sortFlag) {\n            this._sortOverlays();\n        }\n        if (updatePaneIds.length > 0) {\n            updatePaneIds.forEach(function(paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */ , paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ , PaneIdConstants.X_AXIS);\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.removeOverlay = function(filter) {\n        var _this = this;\n        var updatePaneIds = [];\n        var filterOverlays = this.getOverlaysByFilter(filter);\n        filterOverlays.forEach(function(overlay) {\n            var _a;\n            var paneId = overlay.paneId;\n            var paneOverlays = _this.getOverlaysByPaneId(overlay.paneId);\n            (_a = overlay.onRemoved) === null || _a === void 0 ? void 0 : _a.call(overlay, {\n                overlay: overlay,\n                chart: _this._chart\n            });\n            if (!updatePaneIds.includes(paneId)) {\n                updatePaneIds.push(paneId);\n            }\n            if (overlay.isDrawing()) {\n                _this._progressOverlayInfo = null;\n            } else {\n                var index = paneOverlays.findIndex(function(o) {\n                    return o.id === overlay.id;\n                });\n                if (index > -1) {\n                    paneOverlays.splice(index, 1);\n                }\n            }\n            if (paneOverlays.length === 0) {\n                _this._overlays.delete(paneId);\n            }\n        });\n        if (updatePaneIds.length > 0) {\n            updatePaneIds.forEach(function(paneId) {\n                _this._chart.updatePane(1 /* UpdateLevel.Overlay */ , paneId);\n            });\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ , PaneIdConstants.X_AXIS);\n            return true;\n        }\n        return false;\n    };\n    StoreImp.prototype.setPressedOverlayInfo = function(info) {\n        this._pressedOverlayInfo = info;\n    };\n    StoreImp.prototype.getPressedOverlayInfo = function() {\n        return this._pressedOverlayInfo;\n    };\n    StoreImp.prototype.setHoverOverlayInfo = function(info, event) {\n        var _a;\n        var _b = this._hoverOverlayInfo, overlay = _b.overlay, figureType = _b.figureType, figureIndex = _b.figureIndex, figure = _b.figure;\n        var infoOverlay = info.overlay;\n        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {\n            this._hoverOverlayInfo = info;\n            if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {\n                var ignoreUpdateFlag = false;\n                var sortFlag = false;\n                if (overlay !== null) {\n                    overlay.override({\n                        zLevel: overlay.getPrevZLevel()\n                    });\n                    sortFlag = true;\n                    if (isFunction(overlay.onMouseLeave) && checkOverlayFigureEvent(\"onMouseLeave\", figure)) {\n                        overlay.onMouseLeave(__assign({\n                            chart: this._chart,\n                            overlay: overlay,\n                            figure: figure !== null && figure !== void 0 ? figure : undefined\n                        }, event));\n                        ignoreUpdateFlag = true;\n                    }\n                }\n                if (infoOverlay !== null) {\n                    infoOverlay.setPrevZLevel(infoOverlay.zLevel);\n                    infoOverlay.override({\n                        zLevel: Number.MAX_SAFE_INTEGER\n                    });\n                    sortFlag = true;\n                    if (isFunction(infoOverlay.onMouseEnter) && checkOverlayFigureEvent(\"onMouseEnter\", info.figure)) {\n                        infoOverlay.onMouseEnter(__assign({\n                            chart: this._chart,\n                            overlay: infoOverlay,\n                            figure: (_a = info.figure) !== null && _a !== void 0 ? _a : undefined\n                        }, event));\n                        ignoreUpdateFlag = true;\n                    }\n                }\n                if (sortFlag) {\n                    this._sortOverlays();\n                }\n                if (!ignoreUpdateFlag) {\n                    this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n                }\n            }\n        }\n    };\n    StoreImp.prototype.getHoverOverlayInfo = function() {\n        return this._hoverOverlayInfo;\n    };\n    StoreImp.prototype.setClickOverlayInfo = function(info, event) {\n        var _a, _b, _c, _d, _e, _f;\n        var _g = this._clickOverlayInfo, paneId = _g.paneId, overlay = _g.overlay, figureType = _g.figureType, figure = _g.figure, figureIndex = _g.figureIndex;\n        var infoOverlay = info.overlay;\n        if (!((_a = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.isDrawing()) !== null && _a !== void 0 ? _a : false) && checkOverlayFigureEvent(\"onClick\", info.figure)) {\n            (_b = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.onClick) === null || _b === void 0 ? void 0 : _b.call(infoOverlay, __assign({\n                chart: this._chart,\n                overlay: infoOverlay,\n                figure: (_c = info.figure) !== null && _c !== void 0 ? _c : undefined\n            }, event));\n        }\n        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {\n            this._clickOverlayInfo = info;\n            if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {\n                if (checkOverlayFigureEvent(\"onDeselected\", figure)) {\n                    (_d = overlay === null || overlay === void 0 ? void 0 : overlay.onDeselected) === null || _d === void 0 ? void 0 : _d.call(overlay, __assign({\n                        chart: this._chart,\n                        overlay: overlay,\n                        figure: figure !== null && figure !== void 0 ? figure : undefined\n                    }, event));\n                }\n                if (checkOverlayFigureEvent(\"onSelected\", info.figure)) {\n                    (_e = infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.onSelected) === null || _e === void 0 ? void 0 : _e.call(infoOverlay, __assign({\n                        chart: this._chart,\n                        overlay: infoOverlay,\n                        figure: (_f = info.figure) !== null && _f !== void 0 ? _f : undefined\n                    }, event));\n                }\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ , info.paneId);\n                if (paneId !== info.paneId) {\n                    this._chart.updatePane(1 /* UpdateLevel.Overlay */ , paneId);\n                }\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ , PaneIdConstants.X_AXIS);\n            }\n        }\n    };\n    StoreImp.prototype.getClickOverlayInfo = function() {\n        return this._clickOverlayInfo;\n    };\n    StoreImp.prototype.isOverlayEmpty = function() {\n        return this._overlays.size === 0 && this._progressOverlayInfo === null;\n    };\n    StoreImp.prototype.isOverlayDrawing = function() {\n        var _a, _b;\n        return (_b = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay.isDrawing()) !== null && _b !== void 0 ? _b : false;\n    };\n    StoreImp.prototype.clearData = function() {\n        this._loadDataMore.backward = false;\n        this._loadDataMore.forward = false;\n        this._loading = true;\n        this._dataList = [];\n        this._visibleRangeDataList = [];\n        this._visibleRangeHighLowPrice = [\n            {\n                x: 0,\n                price: Number.MIN_SAFE_INTEGER\n            },\n            {\n                x: 0,\n                price: Number.MAX_SAFE_INTEGER\n            }\n        ];\n        this._visibleRange = getDefaultVisibleRange();\n        this._timeWeightTickMap.clear();\n        this._timeWeightTickList = [];\n        this._crosshair = {};\n        this._activeTooltipFeatureInfo = null;\n    };\n    StoreImp.prototype.getChart = function() {\n        return this._chart;\n    };\n    return StoreImp;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var WidgetNameConstants = {\n    MAIN: \"main\",\n    X_AXIS: \"xAxis\",\n    Y_AXIS: \"yAxis\",\n    SEPARATOR: \"separator\"\n};\nvar REAL_SEPARATOR_HEIGHT = 7;\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function isSupportedDevicePixelContentBox() {\n    return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    return [\n                        4 /*yield*/ ,\n                        new Promise(function(resolve) {\n                            var ro = new ResizeObserver(function(entries) {\n                                resolve(entries.every(function(entry) {\n                                    return \"devicePixelContentBoxSize\" in entry;\n                                }));\n                                ro.disconnect();\n                            });\n                            ro.observe(document.body, {\n                                box: \"device-pixel-content-box\"\n                            });\n                        }).catch(function() {\n                            return false;\n                        })\n                    ];\n                case 1:\n                    // eslint-disable-next-line promise/avoid-new -- ignore\n                    return [\n                        2 /*return*/ ,\n                        _a.sent()\n                    ];\n            }\n        });\n    });\n}\nvar Canvas = /** @class */ function() {\n    function Canvas(style, listener) {\n        var _this = this;\n        this._supportedDevicePixelContentBox = false;\n        this._width = 0;\n        this._height = 0;\n        this._pixelWidth = 0;\n        this._pixelHeight = 0;\n        this._nextPixelWidth = 0;\n        this._nextPixelHeight = 0;\n        this._requestAnimationId = DEFAULT_REQUEST_ID;\n        this._mediaQueryListener = function() {\n            var pixelRatio = getPixelRatio(_this._element);\n            _this._nextPixelWidth = Math.round(_this._element.clientWidth * pixelRatio);\n            _this._nextPixelHeight = Math.round(_this._element.clientHeight * pixelRatio);\n            _this._resetPixelRatio();\n        };\n        this._listener = listener;\n        this._element = createDom(\"canvas\", style);\n        this._ctx = this._element.getContext(\"2d\");\n        isSupportedDevicePixelContentBox().then(function(result) {\n            _this._supportedDevicePixelContentBox = result;\n            if (result) {\n                _this._resizeObserver = new ResizeObserver(function(entries) {\n                    var entry = entries.find(function(entry) {\n                        return entry.target === _this._element;\n                    });\n                    var size = entry === null || entry === void 0 ? void 0 : entry.devicePixelContentBoxSize[0];\n                    if (isValid(size)) {\n                        _this._nextPixelWidth = size.inlineSize;\n                        _this._nextPixelHeight = size.blockSize;\n                        if (_this._pixelWidth !== _this._nextPixelWidth || _this._pixelHeight !== _this._nextPixelHeight) {\n                            _this._resetPixelRatio();\n                        }\n                    }\n                });\n                _this._resizeObserver.observe(_this._element, {\n                    box: \"device-pixel-content-box\"\n                });\n            } else {\n                _this._mediaQueryList = window.matchMedia(\"(resolution: \".concat(getPixelRatio(_this._element), \"dppx)\"));\n                // eslint-disable-next-line @typescript-eslint/no-deprecated -- ignore\n                _this._mediaQueryList.addListener(_this._mediaQueryListener);\n            }\n        }).catch(function(_) {\n            return false;\n        });\n    }\n    Canvas.prototype._resetPixelRatio = function() {\n        var _this = this;\n        this._executeListener(function() {\n            var width = _this._element.clientWidth;\n            var height = _this._element.clientHeight;\n            _this._width = width;\n            _this._height = height;\n            _this._pixelWidth = _this._nextPixelWidth;\n            _this._pixelHeight = _this._nextPixelHeight;\n            _this._element.width = _this._nextPixelWidth;\n            _this._element.height = _this._nextPixelHeight;\n            var horizontalPixelRatio = _this._nextPixelWidth / width;\n            var verticalPixelRatio = _this._nextPixelHeight / height;\n            _this._ctx.scale(horizontalPixelRatio, verticalPixelRatio);\n        });\n    };\n    Canvas.prototype._executeListener = function(fn) {\n        var _this = this;\n        if (this._requestAnimationId === DEFAULT_REQUEST_ID) {\n            this._requestAnimationId = requestAnimationFrame(function() {\n                _this._ctx.clearRect(0, 0, _this._width, _this._height);\n                fn === null || fn === void 0 ? void 0 : fn();\n                _this._listener();\n                _this._requestAnimationId = DEFAULT_REQUEST_ID;\n            });\n        }\n    };\n    Canvas.prototype.update = function(w, h) {\n        if (this._width !== w || this._height !== h) {\n            this._element.style.width = \"\".concat(w, \"px\");\n            this._element.style.height = \"\".concat(h, \"px\");\n            if (!this._supportedDevicePixelContentBox) {\n                var pixelRatio = getPixelRatio(this._element);\n                this._nextPixelWidth = Math.round(w * pixelRatio);\n                this._nextPixelHeight = Math.round(h * pixelRatio);\n                this._resetPixelRatio();\n            }\n        } else {\n            this._executeListener();\n        }\n    };\n    Canvas.prototype.getElement = function() {\n        return this._element;\n    };\n    Canvas.prototype.getContext = function() {\n        return this._ctx;\n    };\n    Canvas.prototype.destroy = function() {\n        if (isValid(this._resizeObserver)) {\n            this._resizeObserver.unobserve(this._element);\n        }\n        if (isValid(this._mediaQueryList)) {\n            // eslint-disable-next-line @typescript-eslint/no-deprecated -- ignore\n            this._mediaQueryList.removeListener(this._mediaQueryListener);\n        }\n    };\n    return Canvas;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var Widget = /** @class */ function(_super) {\n    __extends(Widget, _super);\n    function Widget(rootContainer, pane) {\n        var _this = _super.call(this) || this;\n        _this._bounding = createDefaultBounding();\n        _this._pane = pane;\n        _this._rootContainer = rootContainer;\n        _this._container = _this.createContainer();\n        rootContainer.appendChild(_this._container);\n        return _this;\n    }\n    Widget.prototype.setBounding = function(bounding) {\n        merge(this._bounding, bounding);\n        return this;\n    };\n    Widget.prototype.getContainer = function() {\n        return this._container;\n    };\n    Widget.prototype.getBounding = function() {\n        return this._bounding;\n    };\n    Widget.prototype.getPane = function() {\n        return this._pane;\n    };\n    Widget.prototype.update = function(level) {\n        this.updateImp(this._container, this._bounding, level !== null && level !== void 0 ? level : 3 /* UpdateLevel.Drawer */ );\n    };\n    Widget.prototype.destroy = function() {\n        this._rootContainer.removeChild(this._container);\n    };\n    return Widget;\n}(Eventful);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DrawWidget = /** @class */ function(_super) {\n    __extends(DrawWidget, _super);\n    function DrawWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._mainCanvas = new Canvas({\n            position: \"absolute\",\n            top: \"0\",\n            left: \"0\",\n            zIndex: \"2\",\n            boxSizing: \"border-box\"\n        }, function() {\n            _this.updateMain(_this._mainCanvas.getContext());\n        });\n        _this._overlayCanvas = new Canvas({\n            position: \"absolute\",\n            top: \"0\",\n            left: \"0\",\n            zIndex: \"2\",\n            boxSizing: \"border-box\"\n        }, function() {\n            _this.updateOverlay(_this._overlayCanvas.getContext());\n        });\n        var container = _this.getContainer();\n        container.appendChild(_this._mainCanvas.getElement());\n        container.appendChild(_this._overlayCanvas.getElement());\n        return _this;\n    }\n    DrawWidget.prototype.createContainer = function() {\n        return createDom(\"div\", {\n            margin: \"0\",\n            padding: \"0\",\n            position: \"absolute\",\n            top: \"0\",\n            overflow: \"hidden\",\n            boxSizing: \"border-box\",\n            zIndex: \"1\"\n        });\n    };\n    DrawWidget.prototype.updateImp = function(container, bounding, level) {\n        var width = bounding.width, height = bounding.height, left = bounding.left;\n        container.style.left = \"\".concat(left, \"px\");\n        var l = level;\n        var w = container.clientWidth;\n        var h = container.clientHeight;\n        if (width !== w || height !== h) {\n            container.style.width = \"\".concat(width, \"px\");\n            container.style.height = \"\".concat(height, \"px\");\n            l = 3 /* UpdateLevel.Drawer */ ;\n        }\n        switch(l){\n            case 0 /* UpdateLevel.Main */ :\n                {\n                    this._mainCanvas.update(width, height);\n                    break;\n                }\n            case 1 /* UpdateLevel.Overlay */ :\n                {\n                    this._overlayCanvas.update(width, height);\n                    break;\n                }\n            case 3 /* UpdateLevel.Drawer */ :\n            case 4 /* UpdateLevel.All */ :\n                {\n                    this._mainCanvas.update(width, height);\n                    this._overlayCanvas.update(width, height);\n                    break;\n                }\n        }\n    };\n    DrawWidget.prototype.destroy = function() {\n        this._mainCanvas.destroy();\n        this._overlayCanvas.destroy();\n    };\n    DrawWidget.prototype.getImage = function(includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var canvas = createDom(\"canvas\", {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: \"border-box\"\n        });\n        var ctx = canvas.getContext(\"2d\");\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.drawImage(this._mainCanvas.getElement(), 0, 0, width, height);\n        if (includeOverlay) {\n            ctx.drawImage(this._overlayCanvas.getElement(), 0, 0, width, height);\n        }\n        return canvas;\n    };\n    return DrawWidget;\n}(Widget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function checkCoordinateOnCircle(coordinate, attrs) {\n    var e_1, _a;\n    var circles = [];\n    circles = circles.concat(attrs);\n    try {\n        for(var circles_1 = __values(circles), circles_1_1 = circles_1.next(); !circles_1_1.done; circles_1_1 = circles_1.next()){\n            var circle_1 = circles_1_1.value;\n            var x = circle_1.x, y = circle_1.y, r = circle_1.r;\n            var difX = coordinate.x - x;\n            var difY = coordinate.y - y;\n            if (!(difX * difX + difY * difY > r * r)) {\n                return true;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (circles_1_1 && !circles_1_1.done && (_a = circles_1.return)) _a.call(circles_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction drawCircle(ctx, attrs, styles) {\n    var circles = [];\n    circles = circles.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? PolygonType.Fill : _a, _b = styles.color, color = _b === void 0 ? \"currentColor\" : _b, _c = styles.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles.borderColor, borderColor = _d === void 0 ? \"currentColor\" : _d, _e = styles.borderStyle, borderStyle = _e === void 0 ? LineType.Solid : _e, _f = styles.borderDashedValue, borderDashedValue = _f === void 0 ? [\n        2,\n        2\n    ] : _f;\n    var solid = (style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) && (!isString(color) || !isTransparent(color));\n    if (solid) {\n        ctx.fillStyle = color;\n        circles.forEach(function(_a) {\n            var x = _a.x, y = _a.y, r = _a.r;\n            ctx.beginPath();\n            ctx.arc(x, y, r, 0, Math.PI * 2);\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        } else {\n            ctx.setLineDash([]);\n        }\n        circles.forEach(function(_a) {\n            var x = _a.x, y = _a.y, r = _a.r;\n            if (!solid || r > borderSize) {\n                ctx.beginPath();\n                ctx.arc(x, y, r, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.stroke();\n            }\n        });\n    }\n}\nvar circle = {\n    name: \"circle\",\n    checkEventOn: checkCoordinateOnCircle,\n    draw: function(ctx, attrs, styles) {\n        drawCircle(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function checkCoordinateOnPolygon(coordinate, attrs) {\n    var e_1, _a;\n    var polygons = [];\n    polygons = polygons.concat(attrs);\n    try {\n        for(var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()){\n            var polygon_1 = polygons_1_1.value;\n            var on = false;\n            var coordinates = polygon_1.coordinates;\n            for(var i = 0, j = coordinates.length - 1; i < coordinates.length; j = i++){\n                if (coordinates[i].y > coordinate.y !== coordinates[j].y > coordinate.y && coordinate.x < (coordinates[j].x - coordinates[i].x) * (coordinate.y - coordinates[i].y) / (coordinates[j].y - coordinates[i].y) + coordinates[i].x) {\n                    on = !on;\n                }\n            }\n            if (on) {\n                return true;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction drawPolygon(ctx, attrs, styles) {\n    var polygons = [];\n    polygons = polygons.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? PolygonType.Fill : _a, _b = styles.color, color = _b === void 0 ? \"currentColor\" : _b, _c = styles.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles.borderColor, borderColor = _d === void 0 ? \"currentColor\" : _d, _e = styles.borderStyle, borderStyle = _e === void 0 ? LineType.Solid : _e, _f = styles.borderDashedValue, borderDashedValue = _f === void 0 ? [\n        2,\n        2\n    ] : _f;\n    if ((style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) && (!isString(color) || !isTransparent(color))) {\n        ctx.fillStyle = color;\n        polygons.forEach(function(_a) {\n            var coordinates = _a.coordinates;\n            ctx.beginPath();\n            ctx.moveTo(coordinates[0].x, coordinates[0].y);\n            for(var i = 1; i < coordinates.length; i++){\n                ctx.lineTo(coordinates[i].x, coordinates[i].y);\n            }\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        } else {\n            ctx.setLineDash([]);\n        }\n        polygons.forEach(function(_a) {\n            var coordinates = _a.coordinates;\n            ctx.beginPath();\n            ctx.moveTo(coordinates[0].x, coordinates[0].y);\n            for(var i = 1; i < coordinates.length; i++){\n                ctx.lineTo(coordinates[i].x, coordinates[i].y);\n            }\n            ctx.closePath();\n            ctx.stroke();\n        });\n    }\n}\nvar polygon = {\n    name: \"polygon\",\n    checkEventOn: checkCoordinateOnPolygon,\n    draw: function(ctx, attrs, styles) {\n        drawPolygon(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function checkCoordinateOnRect(coordinate, attrs) {\n    var e_1, _a;\n    var rects = [];\n    rects = rects.concat(attrs);\n    try {\n        for(var rects_1 = __values(rects), rects_1_1 = rects_1.next(); !rects_1_1.done; rects_1_1 = rects_1.next()){\n            var rect_1 = rects_1_1.value;\n            var x = rect_1.x;\n            var width = rect_1.width;\n            if (width < DEVIATION * 2) {\n                x -= DEVIATION;\n                width = DEVIATION * 2;\n            }\n            var y = rect_1.y;\n            var height = rect_1.height;\n            if (height < DEVIATION * 2) {\n                y -= DEVIATION;\n                height = DEVIATION * 2;\n            }\n            if (coordinate.x >= x && coordinate.x <= x + width && coordinate.y >= y && coordinate.y <= y + height) {\n                return true;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (rects_1_1 && !rects_1_1.done && (_a = rects_1.return)) _a.call(rects_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction drawRect(ctx, attrs, styles) {\n    var _a;\n    var rects = [];\n    rects = rects.concat(attrs);\n    var _b = styles.style, style = _b === void 0 ? PolygonType.Fill : _b, _c = styles.color, color = _c === void 0 ? \"transparent\" : _c, _d = styles.borderSize, borderSize = _d === void 0 ? 1 : _d, _e = styles.borderColor, borderColor = _e === void 0 ? \"transparent\" : _e, _f = styles.borderStyle, borderStyle = _f === void 0 ? LineType.Solid : _f, _g = styles.borderRadius, r = _g === void 0 ? 0 : _g, _h = styles.borderDashedValue, borderDashedValue = _h === void 0 ? [\n        2,\n        2\n    ] : _h;\n    // eslint-disable-next-line @typescript-eslint/unbound-method, @typescript-eslint/no-unnecessary-condition -- ignore\n    var draw = (_a = ctx.roundRect) !== null && _a !== void 0 ? _a : ctx.rect;\n    var solid = (style === PolygonType.Fill || styles.style === PolygonType.StrokeFill) && (!isString(color) || !isTransparent(color));\n    if (solid) {\n        ctx.fillStyle = color;\n        rects.forEach(function(_a) {\n            var x = _a.x, y = _a.y, w = _a.width, h = _a.height;\n            ctx.beginPath();\n            draw.call(ctx, x, y, w, h, r);\n            ctx.closePath();\n            ctx.fill();\n        });\n    }\n    if ((style === PolygonType.Stroke || styles.style === PolygonType.StrokeFill) && borderSize > 0 && !isTransparent(borderColor)) {\n        ctx.strokeStyle = borderColor;\n        ctx.fillStyle = borderColor;\n        ctx.lineWidth = borderSize;\n        if (borderStyle === LineType.Dashed) {\n            ctx.setLineDash(borderDashedValue);\n        } else {\n            ctx.setLineDash([]);\n        }\n        var correction_1 = borderSize % 2 === 1 ? 0.5 : 0;\n        var doubleCorrection_1 = Math.round(correction_1 * 2);\n        rects.forEach(function(_a) {\n            var x = _a.x, y = _a.y, w = _a.width, h = _a.height;\n            if (w > borderSize * 2 && h > borderSize * 2) {\n                ctx.beginPath();\n                draw.call(ctx, x + correction_1, y + correction_1, w - doubleCorrection_1, h - doubleCorrection_1, r);\n                ctx.closePath();\n                ctx.stroke();\n            } else {\n                if (!solid) {\n                    ctx.fillRect(x, y, w, h);\n                }\n            }\n        });\n    }\n}\nvar rect = {\n    name: \"rect\",\n    checkEventOn: checkCoordinateOnRect,\n    draw: function(ctx, attrs, styles) {\n        drawRect(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getTextRect(attrs, styles) {\n    var _a = styles.size, size = _a === void 0 ? 12 : _a, _b = styles.paddingLeft, paddingLeft = _b === void 0 ? 0 : _b, _c = styles.paddingTop, paddingTop = _c === void 0 ? 0 : _c, _d = styles.paddingRight, paddingRight = _d === void 0 ? 0 : _d, _e = styles.paddingBottom, paddingBottom = _e === void 0 ? 0 : _e, _f = styles.weight, weight = _f === void 0 ? \"normal\" : _f, family = styles.family;\n    var x = attrs.x, y = attrs.y, text = attrs.text, _g = attrs.align, align = _g === void 0 ? \"left\" : _g, _h = attrs.baseline, baseline = _h === void 0 ? \"top\" : _h, w = attrs.width, h = attrs.height;\n    var width = w !== null && w !== void 0 ? w : paddingLeft + calcTextWidth(text, size, weight, family) + paddingRight;\n    var height = h !== null && h !== void 0 ? h : paddingTop + size + paddingBottom;\n    var startX = 0;\n    switch(align){\n        case \"left\":\n        case \"start\":\n            {\n                startX = x;\n                break;\n            }\n        case \"right\":\n        case \"end\":\n            {\n                startX = x - width;\n                break;\n            }\n        default:\n            {\n                startX = x - width / 2;\n                break;\n            }\n    }\n    var startY = 0;\n    switch(baseline){\n        case \"top\":\n        case \"hanging\":\n            {\n                startY = y;\n                break;\n            }\n        case \"bottom\":\n        case \"ideographic\":\n        case \"alphabetic\":\n            {\n                startY = y - height;\n                break;\n            }\n        default:\n            {\n                startY = y - height / 2;\n                break;\n            }\n    }\n    return {\n        x: startX,\n        y: startY,\n        width: width,\n        height: height\n    };\n}\nfunction checkCoordinateOnText(coordinate, attrs, styles) {\n    var e_1, _a;\n    var texts = [];\n    texts = texts.concat(attrs);\n    try {\n        for(var texts_1 = __values(texts), texts_1_1 = texts_1.next(); !texts_1_1.done; texts_1_1 = texts_1.next()){\n            var text_1 = texts_1_1.value;\n            var _b = getTextRect(text_1, styles), x = _b.x, y = _b.y, width = _b.width, height = _b.height;\n            if (coordinate.x >= x && coordinate.x <= x + width && coordinate.y >= y && coordinate.y <= y + height) {\n                return true;\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (texts_1_1 && !texts_1_1.done && (_a = texts_1.return)) _a.call(texts_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction drawText(ctx, attrs, styles) {\n    var texts = [];\n    texts = texts.concat(attrs);\n    var _a = styles.color, color = _a === void 0 ? \"currentColor\" : _a, _b = styles.size, size = _b === void 0 ? 12 : _b, family = styles.family, weight = styles.weight, _c = styles.paddingLeft, paddingLeft = _c === void 0 ? 0 : _c, _d = styles.paddingTop, paddingTop = _d === void 0 ? 0 : _d, _e = styles.paddingRight, paddingRight = _e === void 0 ? 0 : _e;\n    var rects = texts.map(function(text) {\n        return getTextRect(text, styles);\n    });\n    drawRect(ctx, rects, __assign(__assign({}, styles), {\n        color: styles.backgroundColor\n    }));\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"top\";\n    ctx.font = createFont(size, weight, family);\n    ctx.fillStyle = color;\n    texts.forEach(function(text, index) {\n        var rect = rects[index];\n        ctx.fillText(text.text, rect.x + paddingLeft, rect.y + paddingTop, rect.width - paddingLeft - paddingRight);\n    });\n}\nvar text = {\n    name: \"text\",\n    checkEventOn: checkCoordinateOnText,\n    draw: function(ctx, attrs, styles) {\n        drawText(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getDistance(coordinate1, coordinate2) {\n    var xDif = coordinate1.x - coordinate2.x;\n    var yDif = coordinate1.y - coordinate2.y;\n    return Math.sqrt(xDif * xDif + yDif * yDif);\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function checkCoordinateOnArc(coordinate, attrs) {\n    var e_1, _a;\n    var arcs = [];\n    arcs = arcs.concat(attrs);\n    try {\n        for(var arcs_1 = __values(arcs), arcs_1_1 = arcs_1.next(); !arcs_1_1.done; arcs_1_1 = arcs_1.next()){\n            var arc_1 = arcs_1_1.value;\n            if (Math.abs(getDistance(coordinate, arc_1) - arc_1.r) < DEVIATION) {\n                var r = arc_1.r, startAngle = arc_1.startAngle, endAngle = arc_1.endAngle;\n                var startCoordinateX = r * Math.cos(startAngle) + arc_1.x;\n                var startCoordinateY = r * Math.sin(startAngle) + arc_1.y;\n                var endCoordinateX = r * Math.cos(endAngle) + arc_1.x;\n                var endCoordinateY = r * Math.sin(endAngle) + arc_1.y;\n                if (coordinate.x <= Math.max(startCoordinateX, endCoordinateX) + DEVIATION && coordinate.x >= Math.min(startCoordinateX, endCoordinateX) - DEVIATION && coordinate.y <= Math.max(startCoordinateY, endCoordinateY) + DEVIATION && coordinate.y >= Math.min(startCoordinateY, endCoordinateY) - DEVIATION) {\n                    return true;\n                }\n            }\n        }\n    } catch (e_1_1) {\n        e_1 = {\n            error: e_1_1\n        };\n    } finally{\n        try {\n            if (arcs_1_1 && !arcs_1_1.done && (_a = arcs_1.return)) _a.call(arcs_1);\n        } finally{\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction drawArc(ctx, attrs, styles) {\n    var arcs = [];\n    arcs = arcs.concat(attrs);\n    var _a = styles.style, style = _a === void 0 ? LineType.Solid : _a, _b = styles.size, size = _b === void 0 ? 1 : _b, _c = styles.color, color = _c === void 0 ? \"currentColor\" : _c, _d = styles.dashedValue, dashedValue = _d === void 0 ? [\n        2,\n        2\n    ] : _d;\n    ctx.lineWidth = size;\n    ctx.strokeStyle = color;\n    if (style === LineType.Dashed) {\n        ctx.setLineDash(dashedValue);\n    } else {\n        ctx.setLineDash([]);\n    }\n    arcs.forEach(function(_a) {\n        var x = _a.x, y = _a.y, r = _a.r, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        ctx.beginPath();\n        ctx.arc(x, y, r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.closePath();\n    });\n}\nvar arc = {\n    name: \"arc\",\n    checkEventOn: checkCoordinateOnArc,\n    draw: function(ctx, attrs, styles) {\n        drawArc(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function drawEllipticalArc(ctx, x1, y1, args, offsetX, offsetY, isRelative) {\n    var _a = __read(args, 7), rx = _a[0], ry = _a[1], rotation = _a[2], largeArcFlag = _a[3], sweepFlag = _a[4], x2 = _a[5], y2 = _a[6];\n    var targetX = isRelative ? x1 + x2 : x2 + offsetX;\n    var targetY = isRelative ? y1 + y2 : y2 + offsetY;\n    var segments = ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, targetX, targetY);\n    segments.forEach(function(segment) {\n        ctx.bezierCurveTo(segment[0], segment[1], segment[2], segment[3], segment[4], segment[5]);\n    });\n}\nfunction ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {\n    var _a = computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2), cx = _a.cx, cy = _a.cy, startAngle = _a.startAngle, deltaAngle = _a.deltaAngle;\n    var segments = [];\n    var numSegments = Math.ceil(Math.abs(deltaAngle) / (Math.PI / 2));\n    for(var i = 0; i < numSegments; i++){\n        var start = startAngle + i * deltaAngle / numSegments;\n        var end = startAngle + (i + 1) * deltaAngle / numSegments;\n        var bezier = ellipticalArcToBezier(cx, cy, rx, ry, rotation, start, end);\n        segments.push(bezier);\n    }\n    return segments;\n}\nfunction computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {\n    var phi = rotation * Math.PI / 180;\n    var dx = (x1 - x2) / 2;\n    var dy = (y1 - y2) / 2;\n    var x1p = Math.cos(phi) * dx + Math.sin(phi) * dy;\n    var y1p = -Math.sin(phi) * dx + Math.cos(phi) * dy;\n    var lambda = Math.pow(x1p, 2) / Math.pow(rx, 2) + Math.pow(y1p, 2) / Math.pow(ry, 2);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    var sign = largeArcFlag === sweepFlag ? -1 : 1;\n    var numerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(y1p, 2) - Math.pow(ry, 2) * Math.pow(x1p, 2);\n    var denominator = Math.pow(rx, 2) * Math.pow(y1p, 2) + Math.pow(ry, 2) * Math.pow(x1p, 2);\n    var cxp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (rx * y1p / ry);\n    var cyp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (-ry * x1p / rx);\n    var cx = Math.cos(phi) * cxp - Math.sin(phi) * cyp + (x1 + x2) / 2;\n    var cy = Math.sin(phi) * cxp + Math.cos(phi) * cyp + (y1 + y2) / 2;\n    var startAngle = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);\n    var deltaAngle = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx) - startAngle;\n    if (deltaAngle < 0 && sweepFlag === 1) {\n        deltaAngle += 2 * Math.PI;\n    } else if (deltaAngle > 0 && sweepFlag === 0) {\n        deltaAngle -= 2 * Math.PI;\n    }\n    return {\n        cx: cx,\n        cy: cy,\n        startAngle: startAngle,\n        deltaAngle: deltaAngle\n    };\n}\n/**\n * Ellipse arc segment to Bezier curve\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param rotation\n * @param startAngle\n * @param endAngle\n * @returns\n */ function ellipticalArcToBezier(cx, cy, rx, ry, rotation, startAngle, endAngle) {\n    // 计算控制点\n    var alpha = Math.sin(endAngle - startAngle) * (Math.sqrt(4 + 3 * Math.pow(Math.tan((endAngle - startAngle) / 2), 2)) - 1) / 3;\n    var cosPhi = Math.cos(rotation);\n    var sinPhi = Math.sin(rotation);\n    var x1 = cx + rx * Math.cos(startAngle) * cosPhi - ry * Math.sin(startAngle) * sinPhi;\n    var y1 = cy + rx * Math.cos(startAngle) * sinPhi + ry * Math.sin(startAngle) * cosPhi;\n    var x2 = cx + rx * Math.cos(endAngle) * cosPhi - ry * Math.sin(endAngle) * sinPhi;\n    var y2 = cy + rx * Math.cos(endAngle) * sinPhi + ry * Math.sin(endAngle) * cosPhi;\n    var cp1x = x1 + alpha * (-rx * Math.sin(startAngle) * cosPhi - ry * Math.cos(startAngle) * sinPhi);\n    var cp1y = y1 + alpha * (-rx * Math.sin(startAngle) * sinPhi + ry * Math.cos(startAngle) * cosPhi);\n    var cp2x = x2 - alpha * (-rx * Math.sin(endAngle) * cosPhi - ry * Math.cos(endAngle) * sinPhi);\n    var cp2y = y2 - alpha * (-rx * Math.sin(endAngle) * sinPhi + ry * Math.cos(endAngle) * cosPhi);\n    return [\n        cp1x,\n        cp1y,\n        cp2x,\n        cp2y,\n        x2,\n        y2\n    ];\n}\nfunction drawPath(ctx, attrs, styles) {\n    var paths = [];\n    paths = paths.concat(attrs);\n    var _a = styles.lineWidth, lineWidth = _a === void 0 ? 1 : _a, _b = styles.color, color = _b === void 0 ? \"currentColor\" : _b;\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.setLineDash([]);\n    paths.forEach(function(_a) {\n        var x = _a.x, y = _a.y, path = _a.path;\n        var commands = path.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);\n        if (isValid(commands)) {\n            var offsetX_1 = x;\n            var offsetY_1 = y;\n            ctx.beginPath();\n            commands.forEach(function(command) {\n                var currentX = 0;\n                var currentY = 0;\n                var startX = 0;\n                var startY = 0;\n                var type = command[0];\n                var args = command.slice(1).trim().split(/[\\s,]+/).map(Number);\n                switch(type){\n                    case \"M\":\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        ctx.moveTo(currentX, currentY);\n                        startX = currentX;\n                        startY = currentY;\n                        break;\n                    case \"m\":\n                        currentX += args[0];\n                        currentY += args[1];\n                        ctx.moveTo(currentX, currentY);\n                        startX = currentX;\n                        startY = currentY;\n                        break;\n                    case \"L\":\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"l\":\n                        currentX += args[0];\n                        currentY += args[1];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"H\":\n                        currentX = args[0] + offsetX_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"h\":\n                        currentX += args[0];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"V\":\n                        currentY = args[0] + offsetY_1;\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"v\":\n                        currentY += args[0];\n                        ctx.lineTo(currentX, currentY);\n                        break;\n                    case \"C\":\n                        ctx.bezierCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1, args[4] + offsetX_1, args[5] + offsetY_1);\n                        currentX = args[4] + offsetX_1;\n                        currentY = args[5] + offsetY_1;\n                        break;\n                    case \"c\":\n                        ctx.bezierCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3], currentX + args[4], currentY + args[5]);\n                        currentX += args[4];\n                        currentY += args[5];\n                        break;\n                    case \"S\":\n                        ctx.bezierCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);\n                        currentX = args[2] + offsetX_1;\n                        currentY = args[3] + offsetY_1;\n                        break;\n                    case \"s\":\n                        ctx.bezierCurveTo(currentX, currentY, currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);\n                        currentX += args[2];\n                        currentY += args[3];\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);\n                        currentX = args[2] + offsetX_1;\n                        currentY = args[3] + offsetY_1;\n                        break;\n                    case \"q\":\n                        ctx.quadraticCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);\n                        currentX += args[2];\n                        currentY += args[3];\n                        break;\n                    case \"T\":\n                        ctx.quadraticCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1);\n                        currentX = args[0] + offsetX_1;\n                        currentY = args[1] + offsetY_1;\n                        break;\n                    case \"t\":\n                        ctx.quadraticCurveTo(currentX, currentY, currentX + args[0], currentY + args[1]);\n                        currentX += args[0];\n                        currentY += args[1];\n                        break;\n                    case \"A\":\n                        // arc\n                        // reference https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                        drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, false);\n                        currentX = args[5] + offsetX_1;\n                        currentY = args[6] + offsetY_1;\n                        break;\n                    case \"a\":\n                        // arc\n                        // reference https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                        drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, true);\n                        currentX += args[5];\n                        currentY += args[6];\n                        break;\n                    case \"Z\":\n                    case \"z\":\n                        ctx.closePath();\n                        currentX = startX;\n                        currentY = startY;\n                        break;\n                }\n            });\n            if (styles.style === PathType.Fill) {\n                ctx.fill();\n            } else {\n                ctx.stroke();\n            }\n        }\n    });\n}\nvar path = {\n    name: \"path\",\n    checkEventOn: checkCoordinateOnRect,\n    draw: function(ctx, attrs, styles) {\n        drawPath(ctx, attrs, styles);\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var figures = {};\nvar extensions = [\n    circle,\n    line,\n    polygon,\n    rect,\n    text,\n    arc,\n    path\n];\nextensions.forEach(function(figure) {\n    figures[figure.name] = FigureImp.extend(figure);\n});\nfunction getSupportedFigures() {\n    return Object.keys(figures);\n}\nfunction registerFigure(figure) {\n    figures[figure.name] = FigureImp.extend(figure);\n}\nfunction getInnerFigureClass(name) {\n    var _a;\n    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;\n}\nfunction getFigureClass(name) {\n    var _a;\n    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var View = /** @class */ function(_super) {\n    __extends(View, _super);\n    function View(widget) {\n        var _this = _super.call(this) || this;\n        _this._widget = widget;\n        return _this;\n    }\n    View.prototype.getWidget = function() {\n        return this._widget;\n    };\n    View.prototype.createFigure = function(create, eventHandler) {\n        var FigureClazz = getInnerFigureClass(create.name);\n        if (FigureClazz !== null) {\n            var figure = new FigureClazz(create);\n            if (isValid(eventHandler)) {\n                for(var key in eventHandler){\n                    // eslint-disable-next-line no-prototype-builtins -- ignore\n                    if (eventHandler.hasOwnProperty(key)) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n                        figure.registerEvent(key, eventHandler[key]);\n                    }\n                }\n                this.addChild(figure);\n            }\n            return figure;\n        }\n        return null;\n    };\n    View.prototype.draw = function(ctx) {\n        var extend = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            extend[_i - 1] = arguments[_i];\n        }\n        this.clear();\n        this.drawImp(ctx, extend);\n    };\n    return View;\n}(Eventful);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var GridView = /** @class */ function(_super) {\n    __extends(GridView, _super);\n    function GridView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GridView.prototype.drawImp = function(ctx) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var bounding = widget.getBounding();\n        var styles = chart.getStyles().grid;\n        var show = styles.show;\n        if (show) {\n            ctx.save();\n            ctx.globalCompositeOperation = \"destination-over\";\n            var horizontalStyles = styles.horizontal;\n            var horizontalShow = horizontalStyles.show;\n            if (horizontalShow) {\n                var yAxis = pane.getAxisComponent();\n                var attrs = yAxis.getTicks().map(function(tick) {\n                    return {\n                        coordinates: [\n                            {\n                                x: 0,\n                                y: tick.coord\n                            },\n                            {\n                                x: bounding.width,\n                                y: tick.coord\n                            }\n                        ]\n                    };\n                });\n                (_a = this.createFigure({\n                    name: \"line\",\n                    attrs: attrs,\n                    styles: horizontalStyles\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n            var verticalStyles = styles.vertical;\n            var verticalShow = verticalStyles.show;\n            if (verticalShow) {\n                var xAxis = chart.getXAxisPane().getAxisComponent();\n                var attrs = xAxis.getTicks().map(function(tick) {\n                    return {\n                        coordinates: [\n                            {\n                                x: tick.coord,\n                                y: 0\n                            },\n                            {\n                                x: tick.coord,\n                                y: bounding.height\n                            }\n                        ]\n                    };\n                });\n                (_b = this.createFigure({\n                    name: \"line\",\n                    attrs: attrs,\n                    styles: verticalStyles\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            }\n            ctx.restore();\n        }\n    };\n    return GridView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var ChildrenView = /** @class */ function(_super) {\n    __extends(ChildrenView, _super);\n    function ChildrenView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ChildrenView.prototype.eachChildren = function(childCallback) {\n        var pane = this.getWidget().getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var visibleRangeDataList = chartStore.getVisibleRangeDataList();\n        var barSpace = chartStore.getBarSpace();\n        var dataLength = visibleRangeDataList.length;\n        var index = 0;\n        while(index < dataLength){\n            childCallback(visibleRangeDataList[index], barSpace, index);\n            ++index;\n        }\n    };\n    return ChildrenView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleBarView = /** @class */ function(_super) {\n    __extends(CandleBarView, _super);\n    function CandleBarView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._boundCandleBarClickEvent = function(data) {\n            return function() {\n                _this.getWidget().getPane().getChart().getChartStore().executeAction(ActionType.OnCandleBarClick, data);\n                return false;\n            };\n        };\n        return _this;\n    }\n    CandleBarView.prototype.drawImp = function(ctx) {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var isMain = pane.getId() === PaneIdConstants.CANDLE;\n        var chartStore = pane.getChart().getChartStore();\n        var candleBarOptions = this.getCandleBarOptions();\n        if (candleBarOptions !== null) {\n            var type_1 = candleBarOptions.type, styles_1 = candleBarOptions.styles;\n            var ohlcSize_1 = 0;\n            var halfOhlcSize_1 = 0;\n            if (candleBarOptions.type === CandleType.Ohlc) {\n                var gapBar = chartStore.getBarSpace().gapBar;\n                ohlcSize_1 = Math.min(Math.max(Math.round(gapBar * 0.2), 1), 8);\n                if (ohlcSize_1 > 2 && ohlcSize_1 % 2 === 1) {\n                    ohlcSize_1--;\n                }\n                halfOhlcSize_1 = Math.floor(halfOhlcSize_1 / 2);\n            }\n            var yAxis_1 = pane.getAxisComponent();\n            this.eachChildren(function(visibleData, barSpace) {\n                var _a;\n                var x = visibleData.x, _b = visibleData.data, current = _b.current, prev = _b.prev;\n                if (isValid(current)) {\n                    var open_1 = current.open, high = current.high, low = current.low, close_1 = current.close;\n                    var comparePrice = styles_1.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : (_a = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _a !== void 0 ? _a : close_1;\n                    var colors = [];\n                    if (close_1 > comparePrice) {\n                        colors[0] = styles_1.upColor;\n                        colors[1] = styles_1.upBorderColor;\n                        colors[2] = styles_1.upWickColor;\n                    } else if (close_1 < comparePrice) {\n                        colors[0] = styles_1.downColor;\n                        colors[1] = styles_1.downBorderColor;\n                        colors[2] = styles_1.downWickColor;\n                    } else {\n                        colors[0] = styles_1.noChangeColor;\n                        colors[1] = styles_1.noChangeBorderColor;\n                        colors[2] = styles_1.noChangeWickColor;\n                    }\n                    var openY = yAxis_1.convertToPixel(open_1);\n                    var closeY = yAxis_1.convertToPixel(close_1);\n                    var priceY = [\n                        openY,\n                        closeY,\n                        yAxis_1.convertToPixel(high),\n                        yAxis_1.convertToPixel(low)\n                    ];\n                    priceY.sort(function(a, b) {\n                        return a - b;\n                    });\n                    var correction = barSpace.gapBar % 2 === 0 ? 1 : 0;\n                    var rects = [];\n                    switch(type_1){\n                        case CandleType.CandleSolid:\n                            {\n                                rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                                break;\n                            }\n                        case CandleType.CandleStroke:\n                            {\n                                rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                                break;\n                            }\n                        case CandleType.CandleUpStroke:\n                            {\n                                if (close_1 > open_1) {\n                                    rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                                } else {\n                                    rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                                }\n                                break;\n                            }\n                        case CandleType.CandleDownStroke:\n                            {\n                                if (open_1 > close_1) {\n                                    rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);\n                                } else {\n                                    rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);\n                                }\n                                break;\n                            }\n                        case CandleType.Ohlc:\n                            {\n                                rects = [\n                                    {\n                                        name: \"rect\",\n                                        attrs: [\n                                            {\n                                                x: x - halfOhlcSize_1,\n                                                y: priceY[0],\n                                                width: ohlcSize_1,\n                                                height: priceY[3] - priceY[0]\n                                            },\n                                            {\n                                                x: x - barSpace.halfGapBar,\n                                                y: openY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : openY,\n                                                width: barSpace.halfGapBar,\n                                                height: ohlcSize_1\n                                            },\n                                            {\n                                                x: x + halfOhlcSize_1,\n                                                y: closeY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : closeY,\n                                                width: barSpace.halfGapBar - halfOhlcSize_1,\n                                                height: ohlcSize_1\n                                            }\n                                        ],\n                                        styles: {\n                                            color: colors[0]\n                                        }\n                                    }\n                                ];\n                                break;\n                            }\n                    }\n                    rects.forEach(function(rect) {\n                        var _a;\n                        var handler = null;\n                        if (isMain) {\n                            handler = {\n                                mouseClickEvent: _this._boundCandleBarClickEvent(visibleData)\n                            };\n                        }\n                        (_a = _this.createFigure(rect, handler !== null && handler !== void 0 ? handler : undefined)) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                    });\n                }\n            });\n        }\n    };\n    CandleBarView.prototype.getCandleBarOptions = function() {\n        var candleStyles = this.getWidget().getPane().getChart().getStyles().candle;\n        return {\n            type: candleStyles.type,\n            styles: candleStyles.bar\n        };\n    };\n    CandleBarView.prototype._createSolidBar = function(x, priceY, barSpace, colors, correction) {\n        return [\n            {\n                name: \"rect\",\n                attrs: {\n                    x: x,\n                    y: priceY[0],\n                    width: 1,\n                    height: priceY[3] - priceY[0]\n                },\n                styles: {\n                    color: colors[2]\n                }\n            },\n            {\n                name: \"rect\",\n                attrs: {\n                    x: x - barSpace.halfGapBar,\n                    y: priceY[1],\n                    width: barSpace.gapBar + correction,\n                    height: Math.max(1, priceY[2] - priceY[1])\n                },\n                styles: {\n                    style: PolygonType.StrokeFill,\n                    color: colors[0],\n                    borderColor: colors[1]\n                }\n            }\n        ];\n    };\n    CandleBarView.prototype._createStrokeBar = function(x, priceY, barSpace, colors, correction) {\n        return [\n            {\n                name: \"rect\",\n                attrs: [\n                    {\n                        x: x,\n                        y: priceY[0],\n                        width: 1,\n                        height: priceY[1] - priceY[0]\n                    },\n                    {\n                        x: x,\n                        y: priceY[2],\n                        width: 1,\n                        height: priceY[3] - priceY[2]\n                    }\n                ],\n                styles: {\n                    color: colors[2]\n                }\n            },\n            {\n                name: \"rect\",\n                attrs: {\n                    x: x - barSpace.halfGapBar,\n                    y: priceY[1],\n                    width: barSpace.gapBar + correction,\n                    height: Math.max(1, priceY[2] - priceY[1])\n                },\n                styles: {\n                    style: PolygonType.Stroke,\n                    borderColor: colors[1]\n                }\n            }\n        ];\n    };\n    return CandleBarView;\n}(ChildrenView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorView = /** @class */ function(_super) {\n    __extends(IndicatorView, _super);\n    function IndicatorView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorView.prototype.getCandleBarOptions = function() {\n        var e_1, _a;\n        var pane = this.getWidget().getPane();\n        var yAxis = pane.getAxisComponent();\n        if (!yAxis.isInCandle()) {\n            var chartStore = pane.getChart().getChartStore();\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            try {\n                for(var indicators_1 = __values(indicators), indicators_1_1 = indicators_1.next(); !indicators_1_1.done; indicators_1_1 = indicators_1.next()){\n                    var indicator = indicators_1_1.value;\n                    if (indicator.shouldOhlc && indicator.visible) {\n                        var indicatorStyles = indicator.styles;\n                        var defaultStyles = chartStore.getStyles().indicator;\n                        var compareRule = formatValue(indicatorStyles, \"ohlc.compareRule\", defaultStyles.ohlc.compareRule);\n                        var upColor = formatValue(indicatorStyles, \"ohlc.upColor\", defaultStyles.ohlc.upColor);\n                        var downColor = formatValue(indicatorStyles, \"ohlc.downColor\", defaultStyles.ohlc.downColor);\n                        var noChangeColor = formatValue(indicatorStyles, \"ohlc.noChangeColor\", defaultStyles.ohlc.noChangeColor);\n                        return {\n                            type: CandleType.Ohlc,\n                            styles: {\n                                compareRule: compareRule,\n                                upColor: upColor,\n                                downColor: downColor,\n                                noChangeColor: noChangeColor,\n                                upBorderColor: upColor,\n                                downBorderColor: downColor,\n                                noChangeBorderColor: noChangeColor,\n                                upWickColor: upColor,\n                                downWickColor: downColor,\n                                noChangeWickColor: noChangeColor\n                            }\n                        };\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (indicators_1_1 && !indicators_1_1.done && (_a = indicators_1.return)) _a.call(indicators_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        return null;\n    };\n    IndicatorView.prototype.drawImp = function(ctx) {\n        var _this = this;\n        _super.prototype.drawImp.call(this, ctx);\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var bounding = widget.getBounding();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var yAxis = pane.getAxisComponent();\n        var chartStore = chart.getChartStore();\n        var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n        var defaultStyles = chartStore.getStyles().indicator;\n        ctx.save();\n        indicators.forEach(function(indicator) {\n            if (indicator.visible) {\n                if (indicator.zLevel < 0) {\n                    ctx.globalCompositeOperation = \"destination-over\";\n                } else {\n                    ctx.globalCompositeOperation = \"source-over\";\n                }\n                var isCover = false;\n                if (indicator.draw !== null) {\n                    ctx.save();\n                    isCover = indicator.draw({\n                        ctx: ctx,\n                        chart: chart,\n                        indicator: indicator,\n                        bounding: bounding,\n                        xAxis: xAxis,\n                        yAxis: yAxis\n                    });\n                    ctx.restore();\n                }\n                if (!isCover) {\n                    var result_1 = indicator.result;\n                    var lines_1 = [];\n                    _this.eachChildren(function(data, barSpace) {\n                        var _a, _b, _c;\n                        var halfGapBar = barSpace.halfGapBar;\n                        var dataIndex = data.dataIndex, x = data.x;\n                        var prevX = xAxis.convertToPixel(dataIndex - 1);\n                        var nextX = xAxis.convertToPixel(dataIndex + 1);\n                        var prevData = (_a = result_1[dataIndex - 1]) !== null && _a !== void 0 ? _a : null;\n                        var currentData = (_b = result_1[dataIndex]) !== null && _b !== void 0 ? _b : null;\n                        var nextData = (_c = result_1[dataIndex + 1]) !== null && _c !== void 0 ? _c : null;\n                        var prevCoordinate = {\n                            x: prevX\n                        };\n                        var currentCoordinate = {\n                            x: x\n                        };\n                        var nextCoordinate = {\n                            x: nextX\n                        };\n                        indicator.figures.forEach(function(_a) {\n                            var key = _a.key;\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var prevValue = prevData === null || prevData === void 0 ? void 0 : prevData[key];\n                            if (isNumber(prevValue)) {\n                                prevCoordinate[key] = yAxis.convertToPixel(prevValue);\n                            }\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var currentValue = currentData === null || currentData === void 0 ? void 0 : currentData[key];\n                            if (isNumber(currentValue)) {\n                                currentCoordinate[key] = yAxis.convertToPixel(currentValue);\n                            }\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                            var nextValue = nextData === null || nextData === void 0 ? void 0 : nextData[key];\n                            if (isNumber(nextValue)) {\n                                nextCoordinate[key] = yAxis.convertToPixel(nextValue);\n                            }\n                        });\n                        eachFigures(indicator, dataIndex, defaultStyles, function(figure, figureStyles, figureIndex) {\n                            var _a, _b, _c;\n                            if (isValid(currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {\n                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                var valueY = currentCoordinate[figure.key];\n                                var attrs = (_a = figure.attrs) === null || _a === void 0 ? void 0 : _a.call(figure, {\n                                    data: {\n                                        prev: prevData,\n                                        current: currentData,\n                                        next: nextData\n                                    },\n                                    coordinate: {\n                                        prev: prevCoordinate,\n                                        current: currentCoordinate,\n                                        next: nextCoordinate\n                                    },\n                                    bounding: bounding,\n                                    barSpace: barSpace,\n                                    xAxis: xAxis,\n                                    yAxis: yAxis\n                                });\n                                if (!isValid(attrs)) {\n                                    switch(figure.type){\n                                        case \"circle\":\n                                            {\n                                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                attrs = {\n                                                    x: x,\n                                                    y: valueY,\n                                                    r: Math.max(1, halfGapBar)\n                                                };\n                                                break;\n                                            }\n                                        case \"rect\":\n                                        case \"bar\":\n                                            {\n                                                var baseValue = (_b = figure.baseValue) !== null && _b !== void 0 ? _b : yAxis.getRange().from;\n                                                var baseValueY = yAxis.convertToPixel(baseValue);\n                                                var height = Math.abs(baseValueY - valueY);\n                                                if (baseValue !== (currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {\n                                                    height = Math.max(1, height);\n                                                }\n                                                var y = 0;\n                                                if (valueY > baseValueY) {\n                                                    y = baseValueY;\n                                                } else {\n                                                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                    y = valueY;\n                                                }\n                                                attrs = {\n                                                    x: x - halfGapBar,\n                                                    y: y,\n                                                    width: Math.max(1, halfGapBar * 2),\n                                                    height: height\n                                                };\n                                                break;\n                                            }\n                                        case \"line\":\n                                            {\n                                                if (!isValid(lines_1[figureIndex])) {\n                                                    lines_1[figureIndex] = [];\n                                                }\n                                                if (isNumber(currentCoordinate[figure.key]) && isNumber(nextCoordinate[figure.key])) {\n                                                    lines_1[figureIndex].push({\n                                                        coordinates: [\n                                                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                            {\n                                                                x: currentCoordinate.x,\n                                                                y: currentCoordinate[figure.key]\n                                                            },\n                                                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                                                            {\n                                                                x: nextCoordinate.x,\n                                                                y: nextCoordinate[figure.key]\n                                                            }\n                                                        ],\n                                                        styles: figureStyles\n                                                    });\n                                                }\n                                                break;\n                                            }\n                                    }\n                                }\n                                var type = figure.type;\n                                if (isValid(attrs) && type !== \"line\") {\n                                    (_c = _this.createFigure({\n                                        name: type === \"bar\" ? \"rect\" : type,\n                                        attrs: attrs,\n                                        styles: figureStyles\n                                    })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n                                }\n                            }\n                        });\n                    });\n                    // merge line and render\n                    lines_1.forEach(function(items) {\n                        var _a, _b, _c, _d;\n                        if (items.length > 1) {\n                            var mergeLines = [\n                                {\n                                    coordinates: [\n                                        items[0].coordinates[0],\n                                        items[0].coordinates[1]\n                                    ],\n                                    styles: items[0].styles\n                                }\n                            ];\n                            for(var i = 1; i < items.length; i++){\n                                var lastMergeLine = mergeLines[mergeLines.length - 1];\n                                var current = items[i];\n                                var lastMergeLineLastCoordinate = lastMergeLine.coordinates[lastMergeLine.coordinates.length - 1];\n                                if (lastMergeLineLastCoordinate.x === current.coordinates[0].x && lastMergeLineLastCoordinate.y === current.coordinates[0].y && lastMergeLine.styles.style === current.styles.style && lastMergeLine.styles.color === current.styles.color && lastMergeLine.styles.size === current.styles.size && lastMergeLine.styles.smooth === current.styles.smooth && ((_a = lastMergeLine.styles.dashedValue) === null || _a === void 0 ? void 0 : _a[0]) === ((_b = current.styles.dashedValue) === null || _b === void 0 ? void 0 : _b[0]) && ((_c = lastMergeLine.styles.dashedValue) === null || _c === void 0 ? void 0 : _c[1]) === ((_d = current.styles.dashedValue) === null || _d === void 0 ? void 0 : _d[1])) {\n                                    lastMergeLine.coordinates.push(current.coordinates[1]);\n                                } else {\n                                    mergeLines.push({\n                                        coordinates: [\n                                            current.coordinates[0],\n                                            current.coordinates[1]\n                                        ],\n                                        styles: current.styles\n                                    });\n                                }\n                            }\n                            mergeLines.forEach(function(_a) {\n                                var _b;\n                                var coordinates = _a.coordinates, styles = _a.styles;\n                                (_b = _this.createFigure({\n                                    name: \"line\",\n                                    attrs: {\n                                        coordinates: coordinates\n                                    },\n                                    styles: styles\n                                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                            });\n                        }\n                    });\n                }\n            }\n        });\n        ctx.restore();\n    };\n    return IndicatorView;\n}(CandleBarView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CrosshairLineView = /** @class */ function(_super) {\n    __extends(CrosshairLineView, _super);\n    function CrosshairLineView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairLineView.prototype.drawImp = function(ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        var styles = chartStore.getStyles().crosshair;\n        if (isString(crosshair.paneId) && styles.show) {\n            if (crosshair.paneId === pane.getId()) {\n                var y = crosshair.y;\n                this._drawLine(ctx, [\n                    {\n                        x: 0,\n                        y: y\n                    },\n                    {\n                        x: bounding.width,\n                        y: y\n                    }\n                ], styles.horizontal);\n            }\n            var x = crosshair.realX;\n            this._drawLine(ctx, [\n                {\n                    x: x,\n                    y: 0\n                },\n                {\n                    x: x,\n                    y: bounding.height\n                }\n            ], styles.vertical);\n        }\n    };\n    CrosshairLineView.prototype._drawLine = function(ctx, coordinates, styles) {\n        var _a;\n        if (styles.show) {\n            var lineStyles = styles.line;\n            if (lineStyles.show) {\n                (_a = this.createFigure({\n                    name: \"line\",\n                    attrs: {\n                        coordinates: coordinates\n                    },\n                    styles: lineStyles\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n        }\n    };\n    return CrosshairLineView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorTooltipView = /** @class */ function(_super) {\n    __extends(IndicatorTooltipView, _super);\n    function IndicatorTooltipView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._boundFeatureClickEvent = function(currentFeatureInfo) {\n            return function() {\n                var _a;\n                var pane = _this.getWidget().getPane();\n                var indicator = currentFeatureInfo.indicator, others = __rest(currentFeatureInfo, [\n                    \"indicator\"\n                ]);\n                if (isValid(indicator)) {\n                    (_a = indicator.onClick) === null || _a === void 0 ? void 0 : _a.call(indicator, __assign({\n                        target: IndicatorEventTarget.Feature,\n                        chart: pane.getChart(),\n                        indicator: indicator\n                    }, others));\n                } else {\n                    pane.getChart().getChartStore().executeAction(ActionType.OnCandleTooltipFeatureClick, currentFeatureInfo);\n                }\n                return true;\n            };\n        };\n        _this._boundFeatureMouseMoveEvent = function(currentFeatureInfo) {\n            return function() {\n                _this.getWidget().getPane().getChart().getChartStore().setActiveTooltipFeatureInfo(currentFeatureInfo);\n                return true;\n            };\n        };\n        return _this;\n    }\n    IndicatorTooltipView.prototype.drawImp = function(ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        if (isValid(crosshair.kLineData)) {\n            var bounding = widget.getBounding();\n            var _a = chartStore.getStyles().indicator.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;\n            this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, bounding.width - offsetRight);\n        }\n    };\n    IndicatorTooltipView.prototype.drawIndicatorTooltip = function(ctx, left, top, maxWidth) {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var styles = chartStore.getStyles().indicator;\n        var tooltipStyles = styles.tooltip;\n        if (this.isDrawTooltip(chartStore.getCrosshair(), tooltipStyles)) {\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var tooltipTextStyles_1 = tooltipStyles.text;\n            indicators.forEach(function(indicator) {\n                var prevRowHeight = 0;\n                var coordinate = {\n                    x: left,\n                    y: top\n                };\n                var _a = _this.getIndicatorTooltipData(indicator), name = _a.name, calcParamsText = _a.calcParamsText, legends = _a.legends, features = _a.features;\n                var nameValid = name.length > 0;\n                var legendValid = legends.length > 0;\n                if (nameValid || legendValid) {\n                    var _b = __read(_this.classifyTooltipFeatures(features), 3), leftFeatures = _b[0], middleFeatures = _b[1], rightFeatures = _b[2];\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, leftFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    if (nameValid) {\n                        var text = name;\n                        if (calcParamsText.length > 0) {\n                            text = \"\".concat(text).concat(calcParamsText);\n                        }\n                        prevRowHeight = _this.drawStandardTooltipLegends(ctx, [\n                            {\n                                title: {\n                                    text: \"\",\n                                    color: tooltipTextStyles_1.color\n                                },\n                                value: {\n                                    text: text,\n                                    color: tooltipTextStyles_1.color\n                                }\n                            }\n                        ], coordinate, left, prevRowHeight, maxWidth, tooltipTextStyles_1);\n                    }\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, middleFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    if (legendValid) {\n                        prevRowHeight = _this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipStyles.text);\n                    }\n                    // draw right icons\n                    prevRowHeight = _this.drawStandardTooltipFeatures(ctx, rightFeatures, coordinate, indicator, left, prevRowHeight, maxWidth);\n                    top = coordinate.y + prevRowHeight;\n                }\n            });\n        }\n        return top;\n    };\n    IndicatorTooltipView.prototype.drawStandardTooltipFeatures = function(ctx, features, coordinate, indicator, left, prevRowHeight, maxWidth) {\n        var _this = this;\n        if (features.length > 0) {\n            var width_1 = 0;\n            var height_1 = 0;\n            features.forEach(function(feature) {\n                var _a = feature.marginLeft, marginLeft = _a === void 0 ? 0 : _a, _b = feature.marginTop, marginTop = _b === void 0 ? 0 : _b, _c = feature.marginRight, marginRight = _c === void 0 ? 0 : _c, _d = feature.marginBottom, marginBottom = _d === void 0 ? 0 : _d, _e = feature.paddingLeft, paddingLeft = _e === void 0 ? 0 : _e, _f = feature.paddingTop, paddingTop = _f === void 0 ? 0 : _f, _g = feature.paddingRight, paddingRight = _g === void 0 ? 0 : _g, _h = feature.paddingBottom, paddingBottom = _h === void 0 ? 0 : _h, _j = feature.size, size = _j === void 0 ? 0 : _j, type = feature.type, iconFont = feature.iconFont;\n                var contentWidth = 0;\n                if (type === TooltipFeatureType.IconFont) {\n                    ctx.font = createFont(size, \"normal\", iconFont.family);\n                    contentWidth = ctx.measureText(iconFont.content).width;\n                } else {\n                    contentWidth = size;\n                }\n                width_1 += marginLeft + paddingLeft + contentWidth + paddingRight + marginRight;\n                height_1 = Math.max(height_1, marginTop + paddingTop + size + paddingBottom + marginBottom);\n            });\n            if (coordinate.x + width_1 > maxWidth) {\n                coordinate.x = left;\n                coordinate.y += prevRowHeight;\n                prevRowHeight = height_1;\n            } else {\n                prevRowHeight = Math.max(prevRowHeight, height_1);\n            }\n            var pane = this.getWidget().getPane();\n            var paneId_1 = pane.getId();\n            var activeFeatureInfo_1 = pane.getChart().getChartStore().getActiveTooltipFeatureInfo();\n            features.forEach(function(feature) {\n                var _a, _b, _c, _d;\n                var _e = feature.marginLeft, marginLeft = _e === void 0 ? 0 : _e, _f = feature.marginTop, marginTop = _f === void 0 ? 0 : _f, _g = feature.marginRight, marginRight = _g === void 0 ? 0 : _g, _h = feature.paddingLeft, paddingLeft = _h === void 0 ? 0 : _h, _j = feature.paddingTop, paddingTop = _j === void 0 ? 0 : _j, _k = feature.paddingRight, paddingRight = _k === void 0 ? 0 : _k, _l = feature.paddingBottom, paddingBottom = _l === void 0 ? 0 : _l, backgroundColor = feature.backgroundColor, activeBackgroundColor = feature.activeBackgroundColor, borderRadius = feature.borderRadius, _m = feature.size, size = _m === void 0 ? 0 : _m, color = feature.color, activeColor = feature.activeColor, type = feature.type, iconFont = feature.iconFont, path = feature.path;\n                var active = (activeFeatureInfo_1 === null || activeFeatureInfo_1 === void 0 ? void 0 : activeFeatureInfo_1.paneId) === paneId_1 && ((_a = activeFeatureInfo_1.indicator) === null || _a === void 0 ? void 0 : _a.id) === (indicator === null || indicator === void 0 ? void 0 : indicator.id) && activeFeatureInfo_1.feature.id === feature.id;\n                var contentWidth = 0;\n                var eventHandler = {\n                    mouseClickEvent: _this._boundFeatureClickEvent({\n                        paneId: paneId_1,\n                        indicator: indicator,\n                        feature: feature\n                    }),\n                    mouseMoveEvent: _this._boundFeatureMouseMoveEvent({\n                        paneId: paneId_1,\n                        indicator: indicator,\n                        feature: feature\n                    })\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n                var finalColor = active ? activeColor !== null && activeColor !== void 0 ? activeColor : color : color;\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n                var finalBackgroundColor = active ? activeBackgroundColor !== null && activeBackgroundColor !== void 0 ? activeBackgroundColor : backgroundColor : backgroundColor;\n                if (type === TooltipFeatureType.IconFont) {\n                    (_b = _this.createFigure({\n                        name: \"text\",\n                        attrs: {\n                            text: iconFont.content,\n                            x: coordinate.x + marginLeft,\n                            y: coordinate.y + marginTop\n                        },\n                        styles: {\n                            paddingLeft: paddingLeft,\n                            paddingTop: paddingTop,\n                            paddingRight: paddingRight,\n                            paddingBottom: paddingBottom,\n                            borderRadius: borderRadius,\n                            size: size,\n                            family: iconFont.family,\n                            color: finalColor,\n                            backgroundColor: finalBackgroundColor\n                        }\n                    }, eventHandler)) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                    contentWidth = ctx.measureText(iconFont.content).width;\n                } else {\n                    (_c = _this.createFigure({\n                        name: \"rect\",\n                        attrs: {\n                            x: coordinate.x + marginLeft,\n                            y: coordinate.y + marginTop,\n                            width: size,\n                            height: size\n                        },\n                        styles: {\n                            paddingLeft: paddingLeft,\n                            paddingTop: paddingTop,\n                            paddingRight: paddingRight,\n                            paddingBottom: paddingBottom,\n                            color: finalBackgroundColor\n                        }\n                    }, eventHandler)) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n                    (_d = _this.createFigure({\n                        name: \"path\",\n                        attrs: {\n                            path: path.path,\n                            x: coordinate.x + marginLeft + paddingLeft,\n                            y: coordinate.y + marginTop + paddingTop,\n                            width: size,\n                            height: size\n                        },\n                        styles: {\n                            style: path.style,\n                            lineWidth: path.lineWidth,\n                            color: finalColor\n                        }\n                    })) === null || _d === void 0 ? void 0 : _d.draw(ctx);\n                    contentWidth = size;\n                }\n                coordinate.x += marginLeft + paddingLeft + contentWidth + paddingRight + marginRight;\n            });\n        }\n        return prevRowHeight;\n    };\n    IndicatorTooltipView.prototype.drawStandardTooltipLegends = function(ctx, legends, coordinate, left, prevRowHeight, maxWidth, styles) {\n        var _this = this;\n        if (legends.length > 0) {\n            var marginLeft_1 = styles.marginLeft, marginTop_1 = styles.marginTop, marginRight_1 = styles.marginRight, marginBottom_1 = styles.marginBottom, size_1 = styles.size, family_1 = styles.family, weight_1 = styles.weight;\n            ctx.font = createFont(size_1, weight_1, family_1);\n            legends.forEach(function(data) {\n                var _a, _b;\n                var title = data.title;\n                var value = data.value;\n                var titleTextWidth = ctx.measureText(title.text).width;\n                var valueTextWidth = ctx.measureText(value.text).width;\n                var totalTextWidth = titleTextWidth + valueTextWidth;\n                var h = marginTop_1 + size_1 + marginBottom_1;\n                if (coordinate.x + marginLeft_1 + totalTextWidth + marginRight_1 > maxWidth) {\n                    coordinate.x = left;\n                    coordinate.y += prevRowHeight;\n                    prevRowHeight = h;\n                } else {\n                    prevRowHeight = Math.max(prevRowHeight, h);\n                }\n                if (title.text.length > 0) {\n                    (_a = _this.createFigure({\n                        name: \"text\",\n                        attrs: {\n                            x: coordinate.x + marginLeft_1,\n                            y: coordinate.y + marginTop_1,\n                            text: title.text\n                        },\n                        styles: {\n                            color: title.color,\n                            size: size_1,\n                            family: family_1,\n                            weight: weight_1\n                        }\n                    })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                }\n                (_b = _this.createFigure({\n                    name: \"text\",\n                    attrs: {\n                        x: coordinate.x + marginLeft_1 + titleTextWidth,\n                        y: coordinate.y + marginTop_1,\n                        text: value.text\n                    },\n                    styles: {\n                        color: value.color,\n                        size: size_1,\n                        family: family_1,\n                        weight: weight_1\n                    }\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                coordinate.x += marginLeft_1 + totalTextWidth + marginRight_1;\n            });\n        }\n        return prevRowHeight;\n    };\n    IndicatorTooltipView.prototype.isDrawTooltip = function(crosshair, styles) {\n        var showRule = styles.showRule;\n        return showRule === TooltipShowRule.Always || showRule === TooltipShowRule.FollowCross && isString(crosshair.paneId);\n    };\n    IndicatorTooltipView.prototype.getIndicatorTooltipData = function(indicator) {\n        var _a, _b;\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().indicator;\n        var tooltipStyles = styles.tooltip;\n        var name = tooltipStyles.showName ? indicator.shortName : \"\";\n        var calcParamsText = \"\";\n        if (tooltipStyles.showParams) {\n            var calcParams = indicator.calcParams;\n            if (calcParams.length > 0) {\n                calcParamsText = \"(\".concat(calcParams.join(\",\"), \")\");\n            }\n        }\n        var tooltipData = {\n            name: name,\n            calcParamsText: calcParamsText,\n            legends: [],\n            features: tooltipStyles.features\n        };\n        var dataIndex = chartStore.getCrosshair().dataIndex;\n        var result = indicator.result;\n        var customApi = chartStore.getCustomApi();\n        var decimalFold = chartStore.getDecimalFold();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var legends = [];\n        if (indicator.visible) {\n            var data_1 = (_b = (_a = result[dataIndex]) !== null && _a !== void 0 ? _a : result[dataIndex - 1]) !== null && _b !== void 0 ? _b : {};\n            eachFigures(indicator, dataIndex, styles, function(figure, figureStyles) {\n                if (isString(figure.title)) {\n                    var color = figureStyles.color;\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment  -- ignore\n                    var value = data_1[figure.key];\n                    if (isNumber(value)) {\n                        value = formatPrecision(value, indicator.precision);\n                        if (indicator.shouldFormatBigNumber) {\n                            value = customApi.formatBigNumber(value);\n                        }\n                        value = decimalFold.format(thousandsSeparator.format(value));\n                    }\n                    legends.push({\n                        title: {\n                            text: figure.title,\n                            color: color\n                        },\n                        value: {\n                            text: value !== null && value !== void 0 ? value : tooltipStyles.defaultValue,\n                            color: color\n                        }\n                    });\n                }\n            });\n            tooltipData.legends = legends;\n        }\n        if (isFunction(indicator.createTooltipDataSource)) {\n            var widget = this.getWidget();\n            var pane = widget.getPane();\n            var chart = pane.getChart();\n            var _c = indicator.createTooltipDataSource({\n                chart: chart,\n                indicator: indicator,\n                crosshair: chartStore.getCrosshair(),\n                bounding: widget.getBounding(),\n                xAxis: pane.getChart().getXAxisPane().getAxisComponent(),\n                yAxis: pane.getAxisComponent()\n            }), customName = _c.name, customCalcParamsText = _c.calcParamsText, customLegends = _c.legends, customFeatures = _c.features;\n            if (isString(customName) && tooltipStyles.showName) {\n                tooltipData.name = customName;\n            }\n            if (isString(customCalcParamsText) && tooltipStyles.showParams) {\n                tooltipData.calcParamsText = customCalcParamsText;\n            }\n            if (isValid(customFeatures)) {\n                tooltipData.features = customFeatures;\n            }\n            if (isValid(customLegends) && indicator.visible) {\n                var optimizedLegends_1 = [];\n                var color_1 = styles.tooltip.text.color;\n                customLegends.forEach(function(data) {\n                    var title = {\n                        text: \"\",\n                        color: color_1\n                    };\n                    if (isObject(data.title)) {\n                        title = data.title;\n                    } else {\n                        title.text = data.title;\n                    }\n                    var value = {\n                        text: \"\",\n                        color: color_1\n                    };\n                    if (isObject(data.value)) {\n                        value = data.value;\n                    } else {\n                        value.text = data.value;\n                    }\n                    if (isNumber(Number(value.text))) {\n                        value.text = decimalFold.format(thousandsSeparator.format(value.text));\n                    }\n                    optimizedLegends_1.push({\n                        title: title,\n                        value: value\n                    });\n                });\n                tooltipData.legends = optimizedLegends_1;\n            }\n        }\n        return tooltipData;\n    };\n    IndicatorTooltipView.prototype.classifyTooltipFeatures = function(features) {\n        var leftFeatures = [];\n        var middleFeatures = [];\n        var rightFeatures = [];\n        features.forEach(function(feature) {\n            switch(feature.position){\n                case TooltipFeaturePosition.Left:\n                    {\n                        leftFeatures.push(feature);\n                        break;\n                    }\n                case TooltipFeaturePosition.Middle:\n                    {\n                        middleFeatures.push(feature);\n                        break;\n                    }\n                case TooltipFeaturePosition.Right:\n                    {\n                        rightFeatures.push(feature);\n                        break;\n                    }\n            }\n        });\n        return [\n            leftFeatures,\n            middleFeatures,\n            rightFeatures\n        ];\n    };\n    return IndicatorTooltipView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var OverlayView = /** @class */ function(_super) {\n    __extends(OverlayView, _super);\n    function OverlayView(widget) {\n        var _this = _super.call(this, widget) || this;\n        _this._initEvent();\n        return _this;\n    }\n    OverlayView.prototype._initEvent = function() {\n        var _this = this;\n        var pane = this.getWidget().getPane();\n        var paneId = pane.getId();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        this.registerEvent(\"mouseMoveEvent\", function(event) {\n            var _a;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isStart()) {\n                    chartStore.updateProgressOverlayInfo(paneId);\n                    progressOverlayPaneId = paneId;\n                }\n                var index = overlay.points.length - 1;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));\n                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                        chart: chart,\n                        overlay: overlay\n                    }, event));\n                }\n                return _this._figureMouseMoveEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */ , index, {\n                    key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                    type: \"circle\",\n                    attrs: {}\n                })(event);\n            }\n            chartStore.setHoverOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n                figureIndex: -1,\n                figure: null\n            }, event);\n            return false;\n        }).registerEvent(\"mouseClickEvent\", function(event) {\n            var _a, _b;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isStart()) {\n                    chartStore.updateProgressOverlayInfo(paneId, true);\n                    progressOverlayPaneId = paneId;\n                }\n                var index = overlay.points.length - 1;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));\n                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                        chart: chart,\n                        overlay: overlay\n                    }, event));\n                    overlay.nextStep();\n                    if (!overlay.isDrawing()) {\n                        chartStore.progressOverlayComplete();\n                        (_b = overlay.onDrawEnd) === null || _b === void 0 ? void 0 : _b.call(overlay, __assign({\n                            chart: chart,\n                            overlay: overlay\n                        }, event));\n                    }\n                }\n                return _this._figureMouseClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */ , index, {\n                    key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                    type: \"circle\",\n                    attrs: {}\n                })(event);\n            }\n            chartStore.setClickOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n                figureIndex: -1,\n                figure: null\n            }, event);\n            return false;\n        }).registerEvent(\"mouseDoubleClickEvent\", function(event) {\n            var _a;\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                var progressOverlayPaneId = progressOverlayInfo.paneId;\n                if (overlay.isDrawing() && progressOverlayPaneId === paneId) {\n                    overlay.forceComplete();\n                    if (!overlay.isDrawing()) {\n                        chartStore.progressOverlayComplete();\n                        (_a = overlay.onDrawEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                            chart: chart,\n                            overlay: overlay\n                        }, event));\n                    }\n                }\n                var index = overlay.points.length - 1;\n                return _this._figureMouseClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */ , index, {\n                    key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                    type: \"circle\",\n                    attrs: {}\n                })(event);\n            }\n            return false;\n        }).registerEvent(\"mouseRightClickEvent\", function(event) {\n            var progressOverlayInfo = chartStore.getProgressOverlayInfo();\n            if (progressOverlayInfo !== null) {\n                var overlay = progressOverlayInfo.overlay;\n                if (overlay.isDrawing()) {\n                    var index = overlay.points.length - 1;\n                    return _this._figureMouseRightClickEvent(overlay, 1 /* EventOverlayInfoFigureType.Point */ , index, {\n                        key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                        type: \"circle\",\n                        attrs: {}\n                    })(event);\n                }\n            }\n            return false;\n        }).registerEvent(\"mouseUpEvent\", function(event) {\n            var _a;\n            var _b = chartStore.getPressedOverlayInfo(), overlay = _b.overlay, figure = _b.figure;\n            if (overlay !== null) {\n                if (checkOverlayFigureEvent(\"onPressedMoveEnd\", figure)) {\n                    (_a = overlay.onPressedMoveEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                        chart: chart,\n                        overlay: overlay,\n                        figure: figure !== null && figure !== void 0 ? figure : undefined\n                    }, event));\n                }\n            }\n            chartStore.setPressedOverlayInfo({\n                paneId: paneId,\n                overlay: null,\n                figureType: 0 /* EventOverlayInfoFigureType.None */ ,\n                figureIndex: -1,\n                figure: null\n            });\n            return false;\n        }).registerEvent(\"pressedMouseMoveEvent\", function(event) {\n            var _a, _b;\n            var _c = chartStore.getPressedOverlayInfo(), overlay = _c.overlay, figureType = _c.figureType, figureIndex = _c.figureIndex, figure = _c.figure;\n            if (overlay !== null) {\n                if (checkOverlayFigureEvent(\"onPressedMoving\", figure)) {\n                    if (!overlay.lock) {\n                        if (!((_b = (_a = overlay.onPressedMoving) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                            chart: chart,\n                            overlay: overlay,\n                            figure: figure !== null && figure !== void 0 ? figure : undefined\n                        }, event))) !== null && _b !== void 0 ? _b : false)) {\n                            var point = _this._coordinateToPoint(overlay, event);\n                            if (figureType === 1 /* EventOverlayInfoFigureType.Point */ ) {\n                                overlay.eventPressedPointMove(point, figureIndex);\n                            } else {\n                                overlay.eventPressedOtherMove(point, _this.getWidget().getPane().getChart().getChartStore());\n                            }\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        });\n    };\n    OverlayView.prototype._createFigureEvents = function(overlay, figureType, figureIndex, figure) {\n        if (overlay.isDrawing()) {\n            return null;\n        }\n        return {\n            mouseMoveEvent: this._figureMouseMoveEvent(overlay, figureType, figureIndex, figure),\n            mouseDownEvent: this._figureMouseDownEvent(overlay, figureType, figureIndex, figure),\n            mouseClickEvent: this._figureMouseClickEvent(overlay, figureType, figureIndex, figure),\n            mouseRightClickEvent: this._figureMouseRightClickEvent(overlay, figureType, figureIndex, figure),\n            mouseDoubleClickEvent: this._figureMouseDoubleClickEvent(overlay, figureType, figureIndex, figure)\n        };\n    };\n    OverlayView.prototype._figureMouseMoveEvent = function(overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function(event) {\n            var pane = _this.getWidget().getPane();\n            pane.getChart().getChartStore().setHoverOverlayInfo({\n                paneId: pane.getId(),\n                overlay: overlay,\n                figureType: figureType,\n                figure: figure,\n                figureIndex: figureIndex\n            }, event);\n            return checkOverlayFigureEvent(\"onMouseEnter\", figure) && !overlay.isDrawing();\n        };\n    };\n    OverlayView.prototype._figureMouseDownEvent = function(overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function(event) {\n            var _a;\n            var pane = _this.getWidget().getPane();\n            var paneId = pane.getId();\n            overlay.startPressedMove(_this._coordinateToPoint(overlay, event));\n            if (checkOverlayFigureEvent(\"onPressedMoveStart\", figure)) {\n                (_a = overlay.onPressedMoveStart) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                    chart: pane.getChart(),\n                    overlay: overlay,\n                    figure: figure\n                }, event));\n                pane.getChart().getChartStore().setPressedOverlayInfo({\n                    paneId: paneId,\n                    overlay: overlay,\n                    figureType: figureType,\n                    figureIndex: figureIndex,\n                    figure: figure\n                });\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._figureMouseClickEvent = function(overlay, figureType, figureIndex, figure) {\n        var _this = this;\n        return function(event) {\n            var pane = _this.getWidget().getPane();\n            var paneId = pane.getId();\n            pane.getChart().getChartStore().setClickOverlayInfo({\n                paneId: paneId,\n                overlay: overlay,\n                figureType: figureType,\n                figureIndex: figureIndex,\n                figure: figure\n            }, event);\n            return checkOverlayFigureEvent(\"onClick\", figure) && !overlay.isDrawing();\n        };\n    };\n    OverlayView.prototype._figureMouseDoubleClickEvent = function(overlay, _figureType, _figureIndex, figure) {\n        var _this = this;\n        return function(event) {\n            var _a;\n            if (checkOverlayFigureEvent(\"onDoubleClick\", figure)) {\n                (_a = overlay.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({}, event), {\n                    chart: _this.getWidget().getPane().getChart(),\n                    figure: figure,\n                    overlay: overlay\n                }));\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._figureMouseRightClickEvent = function(overlay, _figureType, _figureIndex, figure) {\n        var _this = this;\n        return function(event) {\n            var _a, _b;\n            if (checkOverlayFigureEvent(\"onRightClick\", figure)) {\n                if (!((_b = (_a = overlay.onRightClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({\n                    chart: _this.getWidget().getPane().getChart(),\n                    overlay: overlay,\n                    figure: figure\n                }, event))) !== null && _b !== void 0 ? _b : false)) {\n                    _this.getWidget().getPane().getChart().getChartStore().removeOverlay(overlay);\n                }\n                return !overlay.isDrawing();\n            }\n            return false;\n        };\n    };\n    OverlayView.prototype._coordinateToPoint = function(o, coordinate) {\n        var _a;\n        var point = {};\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var paneId = pane.getId();\n        var chartStore = chart.getChartStore();\n        if (this.coordinateToPointTimestampDataIndexFlag()) {\n            var xAxis = chart.getXAxisPane().getAxisComponent();\n            var dataIndex = xAxis.convertFromPixel(coordinate.x);\n            var timestamp = (_a = chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n            point.timestamp = timestamp;\n            point.dataIndex = dataIndex;\n        }\n        if (this.coordinateToPointValueFlag()) {\n            var yAxis = pane.getAxisComponent();\n            var value = yAxis.convertFromPixel(coordinate.y);\n            if (o.mode !== OverlayMode.Normal && paneId === PaneIdConstants.CANDLE && isNumber(point.dataIndex)) {\n                var kLineData = chartStore.getDataByDataIndex(point.dataIndex);\n                if (kLineData !== null) {\n                    var modeSensitivity = o.modeSensitivity;\n                    if (value > kLineData.high) {\n                        if (o.mode === OverlayMode.WeakMagnet) {\n                            var highY = yAxis.convertToPixel(kLineData.high);\n                            var buffValue = yAxis.convertFromPixel(highY - modeSensitivity);\n                            if (value < buffValue) {\n                                value = kLineData.high;\n                            }\n                        } else {\n                            value = kLineData.high;\n                        }\n                    } else if (value < kLineData.low) {\n                        if (o.mode === OverlayMode.WeakMagnet) {\n                            var lowY = yAxis.convertToPixel(kLineData.low);\n                            var buffValue = yAxis.convertFromPixel(lowY - modeSensitivity);\n                            if (value > buffValue) {\n                                value = kLineData.low;\n                            }\n                        } else {\n                            value = kLineData.low;\n                        }\n                    } else {\n                        var max = Math.max(kLineData.open, kLineData.close);\n                        var min = Math.min(kLineData.open, kLineData.close);\n                        if (value > max) {\n                            if (value - max < kLineData.high - value) {\n                                value = max;\n                            } else {\n                                value = kLineData.high;\n                            }\n                        } else if (value < min) {\n                            if (value - kLineData.low < min - value) {\n                                value = kLineData.low;\n                            } else {\n                                value = min;\n                            }\n                        } else if (max - value < value - min) {\n                            value = max;\n                        } else {\n                            value = min;\n                        }\n                    }\n                }\n            }\n            point.value = value;\n        }\n        return point;\n    };\n    OverlayView.prototype.coordinateToPointValueFlag = function() {\n        return true;\n    };\n    OverlayView.prototype.coordinateToPointTimestampDataIndexFlag = function() {\n        return true;\n    };\n    OverlayView.prototype.dispatchEvent = function(name, event, other) {\n        if (this.getWidget().getPane().getChart().getChartStore().isOverlayDrawing()) {\n            return this.onEvent(name, event, other);\n        }\n        return _super.prototype.dispatchEvent.call(this, name, event, other);\n    };\n    OverlayView.prototype.checkEventOn = function() {\n        return true;\n    };\n    OverlayView.prototype.drawImp = function(ctx) {\n        var _this = this;\n        var overlays = this.getCompleteOverlays();\n        overlays.forEach(function(overlay) {\n            if (overlay.visible) {\n                _this._drawOverlay(ctx, overlay);\n            }\n        });\n        var progressOverlay = this.getProgressOverlay();\n        if (isValid(progressOverlay) && progressOverlay.visible) {\n            this._drawOverlay(ctx, progressOverlay);\n        }\n    };\n    OverlayView.prototype._drawOverlay = function(ctx, overlay) {\n        var points = overlay.points;\n        var pane = this.getWidget().getPane();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var coordinates = points.map(function(point) {\n            var _a;\n            var dataIndex = null;\n            if (isNumber(point.timestamp)) {\n                dataIndex = chartStore.timestampToDataIndex(point.timestamp);\n            }\n            var coordinate = {\n                x: 0,\n                y: 0\n            };\n            if (isNumber(dataIndex)) {\n                coordinate.x = xAxis.convertToPixel(dataIndex);\n            }\n            if (isNumber(point.value)) {\n                coordinate.y = (_a = yAxis === null || yAxis === void 0 ? void 0 : yAxis.convertToPixel(point.value)) !== null && _a !== void 0 ? _a : 0;\n            }\n            return coordinate;\n        });\n        if (coordinates.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            var figures = [].concat(this.getFigures(overlay, coordinates));\n            this.drawFigures(ctx, overlay, figures);\n        }\n        this.drawDefaultFigures(ctx, overlay, coordinates);\n    };\n    OverlayView.prototype.drawFigures = function(ctx, overlay, figures) {\n        var _this = this;\n        var defaultStyles = this.getWidget().getPane().getChart().getStyles().overlay;\n        figures.forEach(function(figure, figureIndex) {\n            var type = figure.type, styles = figure.styles, attrs = figure.attrs;\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            var attrsArray = [].concat(attrs);\n            attrsArray.forEach(function(ats) {\n                var _a, _b;\n                var events = _this._createFigureEvents(overlay, 2 /* EventOverlayInfoFigureType.Other */ , figureIndex, figure);\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                var ss = __assign(__assign(__assign({}, defaultStyles[type]), (_a = overlay.styles) === null || _a === void 0 ? void 0 : _a[type]), styles);\n                (_b = _this.createFigure({\n                    name: type,\n                    attrs: ats,\n                    styles: ss\n                }, events !== null && events !== void 0 ? events : undefined)) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            });\n        });\n    };\n    OverlayView.prototype.getCompleteOverlays = function() {\n        var pane = this.getWidget().getPane();\n        return pane.getChart().getChartStore().getOverlaysByPaneId(pane.getId());\n    };\n    OverlayView.prototype.getProgressOverlay = function() {\n        var pane = this.getWidget().getPane();\n        var info = pane.getChart().getChartStore().getProgressOverlayInfo();\n        if (isValid(info) && info.paneId === pane.getId()) {\n            return info.overlay;\n        }\n        return null;\n    };\n    OverlayView.prototype.getFigures = function(o, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = o.createPointFigures) === null || _a === void 0 ? void 0 : _a.call(o, {\n            chart: chart,\n            overlay: o,\n            coordinates: coordinates,\n            bounding: bounding,\n            xAxis: xAxis,\n            yAxis: yAxis\n        })) !== null && _b !== void 0 ? _b : [];\n    };\n    OverlayView.prototype.drawDefaultFigures = function(ctx, overlay, coordinates) {\n        var _this = this;\n        var _a, _b;\n        if (overlay.needDefaultPointFigure) {\n            var chartStore = this.getWidget().getPane().getChart().getChartStore();\n            var hoverOverlayInfo_1 = chartStore.getHoverOverlayInfo();\n            var clickOverlayInfo = chartStore.getClickOverlayInfo();\n            if (((_a = hoverOverlayInfo_1.overlay) === null || _a === void 0 ? void 0 : _a.id) === overlay.id && hoverOverlayInfo_1.figureType !== 0 /* EventOverlayInfoFigureType.None */  || ((_b = clickOverlayInfo.overlay) === null || _b === void 0 ? void 0 : _b.id) === overlay.id && clickOverlayInfo.figureType !== 0 /* EventOverlayInfoFigureType.None */ ) {\n                var defaultStyles = chartStore.getStyles().overlay;\n                var styles = overlay.styles;\n                var pointStyles_1 = __assign(__assign({}, defaultStyles.point), styles === null || styles === void 0 ? void 0 : styles.point);\n                coordinates.forEach(function(_a, index) {\n                    var _b, _c, _d, _e, _f;\n                    var x = _a.x, y = _a.y;\n                    var radius = pointStyles_1.radius;\n                    var color = pointStyles_1.color;\n                    var borderColor = pointStyles_1.borderColor;\n                    var borderSize = pointStyles_1.borderSize;\n                    if (((_b = hoverOverlayInfo_1.overlay) === null || _b === void 0 ? void 0 : _b.id) === overlay.id && hoverOverlayInfo_1.figureType === 1 /* EventOverlayInfoFigureType.Point */  && ((_c = hoverOverlayInfo_1.figure) === null || _c === void 0 ? void 0 : _c.key) === \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index)) {\n                        radius = pointStyles_1.activeRadius;\n                        color = pointStyles_1.activeColor;\n                        borderColor = pointStyles_1.activeBorderColor;\n                        borderSize = pointStyles_1.activeBorderSize;\n                    }\n                    (_e = _this.createFigure({\n                        name: \"circle\",\n                        attrs: {\n                            x: x,\n                            y: y,\n                            r: radius + borderSize\n                        },\n                        styles: {\n                            color: borderColor\n                        }\n                    }, (_d = _this._createFigureEvents(overlay, 1 /* EventOverlayInfoFigureType.Point */ , index, {\n                        key: \"\".concat(OVERLAY_FIGURE_KEY_PREFIX, \"point_\").concat(index),\n                        type: \"circle\",\n                        attrs: {\n                            x: x,\n                            y: y,\n                            r: radius + borderSize\n                        },\n                        styles: {\n                            color: borderColor\n                        }\n                    })) !== null && _d !== void 0 ? _d : undefined)) === null || _e === void 0 ? void 0 : _e.draw(ctx);\n                    (_f = _this.createFigure({\n                        name: \"circle\",\n                        attrs: {\n                            x: x,\n                            y: y,\n                            r: radius\n                        },\n                        styles: {\n                            color: color\n                        }\n                    })) === null || _f === void 0 ? void 0 : _f.draw(ctx);\n                });\n            }\n        }\n    };\n    return OverlayView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorWidget = /** @class */ function(_super) {\n    __extends(IndicatorWidget, _super);\n    function IndicatorWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._gridView = new GridView(_this);\n        _this._indicatorView = new IndicatorView(_this);\n        _this._crosshairLineView = new CrosshairLineView(_this);\n        _this._tooltipView = _this.createTooltipView();\n        _this._overlayView = new OverlayView(_this);\n        _this.addChild(_this._tooltipView);\n        _this.addChild(_this._overlayView);\n        _this.getContainer().style.cursor = \"crosshair\";\n        return _this;\n    }\n    IndicatorWidget.prototype.getName = function() {\n        return WidgetNameConstants.MAIN;\n    };\n    IndicatorWidget.prototype.updateMain = function(ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */ ) {\n            this.updateMainContent(ctx);\n            this._indicatorView.draw(ctx);\n            this._gridView.draw(ctx);\n        }\n    };\n    IndicatorWidget.prototype.createTooltipView = function() {\n        return new IndicatorTooltipView(this);\n    };\n    IndicatorWidget.prototype.updateMainContent = function(_ctx) {\n    // to do it\n    };\n    IndicatorWidget.prototype.updateOverlay = function(ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */ ) {\n            this._overlayView.draw(ctx);\n            this._crosshairLineView.draw(ctx);\n        }\n        this._tooltipView.draw(ctx);\n    };\n    return IndicatorWidget;\n}(DrawWidget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleAreaView = /** @class */ function(_super) {\n    __extends(CandleAreaView, _super);\n    function CandleAreaView() {\n        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n        _this._ripplePoint = _this.createFigure({\n            name: \"circle\",\n            attrs: {\n                x: 0,\n                y: 0,\n                r: 0\n            },\n            styles: {\n                style: \"fill\"\n            }\n        });\n        _this._animationFrameTime = 0;\n        _this._animation = new Animation({\n            iterationCount: Infinity\n        }).doFrame(function(time) {\n            _this._animationFrameTime = time;\n            var pane = _this.getWidget().getPane();\n            pane.getChart().updatePane(0 /* UpdateLevel.Main */ , pane.getId());\n        });\n        return _this;\n    }\n    CandleAreaView.prototype.drawImp = function(ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var dataList = chart.getDataList();\n        var lastDataIndex = dataList.length - 1;\n        var bounding = widget.getBounding();\n        var yAxis = pane.getAxisComponent();\n        var styles = chart.getStyles().candle.area;\n        var coordinates = [];\n        var minY = Number.MAX_SAFE_INTEGER;\n        var areaStartX = Number.MIN_SAFE_INTEGER;\n        var ripplePointCoordinate = null;\n        this.eachChildren(function(data) {\n            var x = data.x;\n            var kLineData = data.data.current;\n            var value = kLineData === null || kLineData === void 0 ? void 0 : kLineData[styles.value];\n            if (isNumber(value)) {\n                var y = yAxis.convertToPixel(value);\n                if (areaStartX === Number.MIN_SAFE_INTEGER) {\n                    areaStartX = x;\n                }\n                coordinates.push({\n                    x: x,\n                    y: y\n                });\n                minY = Math.min(minY, y);\n                if (data.dataIndex === lastDataIndex) {\n                    ripplePointCoordinate = {\n                        x: x,\n                        y: y\n                    };\n                }\n            }\n        });\n        if (coordinates.length > 0) {\n            (_a = this.createFigure({\n                name: \"line\",\n                attrs: {\n                    coordinates: coordinates\n                },\n                styles: {\n                    color: styles.lineColor,\n                    size: styles.lineSize,\n                    smooth: styles.smooth\n                }\n            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            // render area\n            var backgroundColor = styles.backgroundColor;\n            var color = \"\";\n            if (isArray(backgroundColor)) {\n                var gradient_1 = ctx.createLinearGradient(0, bounding.height, 0, minY);\n                try {\n                    backgroundColor.forEach(function(_a) {\n                        var offset = _a.offset, color = _a.color;\n                        gradient_1.addColorStop(offset, color);\n                    });\n                } catch (e) {}\n                color = gradient_1;\n            } else {\n                color = backgroundColor;\n            }\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            ctx.moveTo(areaStartX, bounding.height);\n            ctx.lineTo(coordinates[0].x, coordinates[0].y);\n            lineTo(ctx, coordinates, styles.smooth);\n            ctx.lineTo(coordinates[coordinates.length - 1].x, bounding.height);\n            ctx.closePath();\n            ctx.fill();\n        }\n        var pointStyles = styles.point;\n        if (pointStyles.show && isValid(ripplePointCoordinate)) {\n            (_b = this.createFigure({\n                name: \"circle\",\n                attrs: {\n                    x: ripplePointCoordinate.x,\n                    y: ripplePointCoordinate.y,\n                    r: pointStyles.radius\n                },\n                styles: {\n                    style: \"fill\",\n                    color: pointStyles.color\n                }\n            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n            var rippleRadius = pointStyles.rippleRadius;\n            if (pointStyles.animation) {\n                rippleRadius = pointStyles.radius + this._animationFrameTime / pointStyles.animationDuration * (pointStyles.rippleRadius - pointStyles.radius);\n                this._animation.setDuration(pointStyles.animationDuration).start();\n            }\n            (_c = this._ripplePoint) === null || _c === void 0 ? void 0 : _c.setAttrs({\n                x: ripplePointCoordinate.x,\n                y: ripplePointCoordinate.y,\n                r: rippleRadius\n            }).setStyles({\n                style: \"fill\",\n                color: pointStyles.rippleColor\n            }).draw(ctx);\n        } else {\n            this.stopAnimation();\n        }\n    };\n    CandleAreaView.prototype.stopAnimation = function() {\n        this._animation.stop();\n    };\n    return CandleAreaView;\n}(ChildrenView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleHighLowPriceView = /** @class */ function(_super) {\n    __extends(CandleHighLowPriceView, _super);\n    function CandleHighLowPriceView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleHighLowPriceView.prototype.drawImp = function(ctx) {\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var highPriceMarkStyles = priceMarkStyles.high;\n        var lowPriceMarkStyles = priceMarkStyles.low;\n        if (priceMarkStyles.show && (highPriceMarkStyles.show || lowPriceMarkStyles.show)) {\n            var highestLowestPrice = chartStore.getVisibleRangeHighLowPrice();\n            var precision = chartStore.getPrecision();\n            var yAxis = pane.getAxisComponent();\n            var _a = highestLowestPrice[0], high = _a.price, highX = _a.x;\n            var _b = highestLowestPrice[1], low = _b.price, lowX = _b.x;\n            var highY = yAxis.convertToPixel(high);\n            var lowY = yAxis.convertToPixel(low);\n            var decimalFold = chartStore.getDecimalFold();\n            var thousandsSeparator = chartStore.getThousandsSeparator();\n            if (highPriceMarkStyles.show && high !== Number.MIN_SAFE_INTEGER) {\n                this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(high, precision.price))), {\n                    x: highX,\n                    y: highY\n                }, highY < lowY ? [\n                    -2,\n                    -5\n                ] : [\n                    2,\n                    5\n                ], highPriceMarkStyles);\n            }\n            if (lowPriceMarkStyles.show && low !== Number.MAX_SAFE_INTEGER) {\n                this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(low, precision.price))), {\n                    x: lowX,\n                    y: lowY\n                }, highY < lowY ? [\n                    2,\n                    5\n                ] : [\n                    -2,\n                    -5\n                ], lowPriceMarkStyles);\n            }\n        }\n    };\n    CandleHighLowPriceView.prototype._drawMark = function(ctx, text, coordinate, offsets, styles) {\n        var _a, _b, _c;\n        var startX = coordinate.x;\n        var startY = coordinate.y + offsets[0];\n        (_a = this.createFigure({\n            name: \"line\",\n            attrs: {\n                coordinates: [\n                    {\n                        x: startX - 2,\n                        y: startY + offsets[0]\n                    },\n                    {\n                        x: startX,\n                        y: startY\n                    },\n                    {\n                        x: startX + 2,\n                        y: startY + offsets[0]\n                    }\n                ]\n            },\n            styles: {\n                color: styles.color\n            }\n        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n        var lineEndX = 0;\n        var textStartX = 0;\n        var textAlign = \"left\";\n        var width = this.getWidget().getBounding().width;\n        if (startX > width / 2) {\n            lineEndX = startX - 5;\n            textStartX = lineEndX - styles.textOffset;\n            textAlign = \"right\";\n        } else {\n            lineEndX = startX + 5;\n            textAlign = \"left\";\n            textStartX = lineEndX + styles.textOffset;\n        }\n        var y = startY + offsets[1];\n        (_b = this.createFigure({\n            name: \"line\",\n            attrs: {\n                coordinates: [\n                    {\n                        x: startX,\n                        y: startY\n                    },\n                    {\n                        x: startX,\n                        y: y\n                    },\n                    {\n                        x: lineEndX,\n                        y: y\n                    }\n                ]\n            },\n            styles: {\n                color: styles.color\n            }\n        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n        (_c = this.createFigure({\n            name: \"text\",\n            attrs: {\n                x: textStartX,\n                y: y,\n                text: text,\n                align: textAlign,\n                baseline: \"middle\"\n            },\n            styles: {\n                color: styles.color,\n                size: styles.textSize,\n                family: styles.textFamily,\n                weight: styles.textWeight\n            }\n        })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n    };\n    return CandleHighLowPriceView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleLastPriceView = /** @class */ function(_super) {\n    __extends(CandleLastPriceView, _super);\n    function CandleLastPriceView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleLastPriceView.prototype.drawImp = function(ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var lastPriceMarkStyles = priceMarkStyles.last;\n        var lastPriceMarkLineStyles = lastPriceMarkStyles.line;\n        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkLineStyles.show) {\n            var yAxis = pane.getAxisComponent();\n            var dataList = chartStore.getDataList();\n            var data = dataList[dataList.length - 1];\n            if (isValid(data)) {\n                var close_1 = data.close, open_1 = data.open;\n                var comparePrice = lastPriceMarkStyles.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : (_b = (_a = dataList[dataList.length - 2]) === null || _a === void 0 ? void 0 : _a.close) !== null && _b !== void 0 ? _b : close_1;\n                var priceY = yAxis.convertToNicePixel(close_1);\n                var color = \"\";\n                if (close_1 > comparePrice) {\n                    color = lastPriceMarkStyles.upColor;\n                } else if (close_1 < comparePrice) {\n                    color = lastPriceMarkStyles.downColor;\n                } else {\n                    color = lastPriceMarkStyles.noChangeColor;\n                }\n                (_c = this.createFigure({\n                    name: \"line\",\n                    attrs: {\n                        coordinates: [\n                            {\n                                x: 0,\n                                y: priceY\n                            },\n                            {\n                                x: bounding.width,\n                                y: priceY\n                            }\n                        ]\n                    },\n                    styles: {\n                        style: lastPriceMarkLineStyles.style,\n                        color: color,\n                        size: lastPriceMarkLineStyles.size,\n                        dashedValue: lastPriceMarkLineStyles.dashedValue\n                    }\n                })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n            }\n        }\n    };\n    return CandleLastPriceView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var AxisPosition;\n(function(AxisPosition) {\n    AxisPosition[\"Left\"] = \"left\";\n    AxisPosition[\"Right\"] = \"right\";\n})(AxisPosition || (AxisPosition = {}));\nfunction getDefaultAxisRange() {\n    return {\n        from: 0,\n        to: 0,\n        range: 0,\n        realFrom: 0,\n        realTo: 0,\n        realRange: 0,\n        displayFrom: 0,\n        displayTo: 0,\n        displayRange: 0\n    };\n}\nvar AxisImp = /** @class */ function() {\n    function AxisImp(parent) {\n        this.scrollZoomEnabled = true;\n        this._range = getDefaultAxisRange();\n        this._prevRange = getDefaultAxisRange();\n        this._ticks = [];\n        this._autoCalcTickFlag = true;\n        this._parent = parent;\n    }\n    AxisImp.prototype.getParent = function() {\n        return this._parent;\n    };\n    AxisImp.prototype.buildTicks = function(force) {\n        if (this._autoCalcTickFlag) {\n            this._range = this.createRangeImp();\n        }\n        if (this._prevRange.from !== this._range.from || this._prevRange.to !== this._range.to || force) {\n            this._prevRange = this._range;\n            this._ticks = this.createTicksImp();\n            return true;\n        }\n        return false;\n    };\n    AxisImp.prototype.getTicks = function() {\n        return this._ticks;\n    };\n    AxisImp.prototype.setRange = function(range) {\n        this._autoCalcTickFlag = false;\n        this._range = range;\n    };\n    AxisImp.prototype.getRange = function() {\n        return this._range;\n    };\n    AxisImp.prototype.setAutoCalcTickFlag = function(flag) {\n        this._autoCalcTickFlag = flag;\n    };\n    AxisImp.prototype.getAutoCalcTickFlag = function() {\n        return this._autoCalcTickFlag;\n    };\n    return AxisImp;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var zhCN = {\n    time: \"时间：\",\n    open: \"开：\",\n    high: \"高：\",\n    low: \"低：\",\n    close: \"收：\",\n    volume: \"成交量：\",\n    turnover: \"成交额：\",\n    change: \"涨幅：\"\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var enUS = {\n    time: \"Time: \",\n    open: \"Open: \",\n    high: \"High: \",\n    low: \"Low: \",\n    close: \"Close: \",\n    volume: \"Volume: \",\n    turnover: \"Turnover: \",\n    change: \"Change: \"\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var locales = {\n    \"zh-CN\": zhCN,\n    \"en-US\": enUS\n};\nfunction registerLocale(locale, ls) {\n    locales[locale] = __assign(__assign({}, locales[locale]), ls);\n}\nfunction getSupportedLocales() {\n    return Object.keys(locales);\n}\nfunction i18n(key, locale) {\n    var _a;\n    return (_a = locales[locale][key]) !== null && _a !== void 0 ? _a : key;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleTooltipView = /** @class */ function(_super) {\n    __extends(CandleTooltipView, _super);\n    function CandleTooltipView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleTooltipView.prototype.drawImp = function(ctx) {\n        var widget = this.getWidget();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        if (isValid(crosshair.kLineData)) {\n            var bounding = widget.getBounding();\n            var styles = chartStore.getStyles();\n            var candleStyles = styles.candle;\n            var indicatorStyles = styles.indicator;\n            if (candleStyles.tooltip.showType === TooltipShowType.Rect && indicatorStyles.tooltip.showType === TooltipShowType.Rect) {\n                var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);\n                var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);\n                this._drawRectTooltip(ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, candleStyles.tooltip.offsetTop);\n            } else if (candleStyles.tooltip.showType === TooltipShowType.Standard && indicatorStyles.tooltip.showType === TooltipShowType.Standard) {\n                var _a = candleStyles.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_1 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                this.drawIndicatorTooltip(ctx, offsetLeft, top_1, maxWidth);\n            } else if (candleStyles.tooltip.showType === TooltipShowType.Rect && indicatorStyles.tooltip.showType === TooltipShowType.Standard) {\n                var _b = candleStyles.tooltip, offsetLeft = _b.offsetLeft, offsetTop = _b.offsetTop, offsetRight = _b.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_2 = this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);\n                this._drawRectTooltip(ctx, isDrawCandleTooltip, false, top_2);\n            } else {\n                var _c = candleStyles.tooltip, offsetLeft = _c.offsetLeft, offsetTop = _c.offsetTop, offsetRight = _c.offsetRight;\n                var maxWidth = bounding.width - offsetRight;\n                var top_3 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);\n                var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);\n                this._drawRectTooltip(ctx, false, isDrawIndicatorTooltip, top_3);\n            }\n        }\n    };\n    CandleTooltipView.prototype._drawCandleStandardTooltip = function(ctx, left, top, maxWidth) {\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().candle;\n        var tooltipStyles = styles.tooltip;\n        var tooltipTextStyles = tooltipStyles.text;\n        var prevRowHeight = 0;\n        var coordinate = {\n            x: left,\n            y: top\n        };\n        var crosshair = chartStore.getCrosshair();\n        if (this.isDrawTooltip(crosshair, tooltipStyles)) {\n            var legends = this._getCandleTooltipLegends();\n            var _a = __read(this.classifyTooltipFeatures(tooltipStyles.features), 3), leftFeatures = _a[0], middleFeatures = _a[1], rightFeatures = _a[2];\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, leftFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, middleFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n            if (legends.length > 0) {\n                prevRowHeight = this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipTextStyles);\n            }\n            prevRowHeight = this.drawStandardTooltipFeatures(ctx, rightFeatures, coordinate, null, left, prevRowHeight, maxWidth);\n        }\n        return coordinate.y + prevRowHeight;\n    };\n    CandleTooltipView.prototype._drawRectTooltip = function(ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, top) {\n        var _this = this;\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var styles = chartStore.getStyles();\n        var candleStyles = styles.candle;\n        var indicatorStyles = styles.indicator;\n        var candleTooltipStyles = candleStyles.tooltip;\n        var indicatorTooltipStyles = indicatorStyles.tooltip;\n        if (isDrawCandleTooltip || isDrawIndicatorTooltip) {\n            var candleLegends = this._getCandleTooltipLegends();\n            var offsetLeft = candleTooltipStyles.offsetLeft, offsetTop = candleTooltipStyles.offsetTop, offsetRight = candleTooltipStyles.offsetRight, offsetBottom = candleTooltipStyles.offsetBottom;\n            var _c = candleTooltipStyles.text, baseTextMarginLeft_1 = _c.marginLeft, baseTextMarginRight_1 = _c.marginRight, baseTextMarginTop_1 = _c.marginTop, baseTextMarginBottom_1 = _c.marginBottom, baseTextSize_1 = _c.size, baseTextWeight_1 = _c.weight, baseTextFamily_1 = _c.family;\n            var _d = candleTooltipStyles.rect, rectPosition = _d.position, rectPaddingLeft = _d.paddingLeft, rectPaddingRight_1 = _d.paddingRight, rectPaddingTop = _d.paddingTop, rectPaddingBottom = _d.paddingBottom, rectOffsetLeft = _d.offsetLeft, rectOffsetRight = _d.offsetRight, rectOffsetTop = _d.offsetTop, rectOffsetBottom = _d.offsetBottom, rectBorderSize_1 = _d.borderSize, rectBorderRadius = _d.borderRadius, rectBorderColor = _d.borderColor, rectBackgroundColor = _d.color;\n            var maxTextWidth_1 = 0;\n            var rectWidth_1 = 0;\n            var rectHeight_1 = 0;\n            if (isDrawCandleTooltip) {\n                ctx.font = createFont(baseTextSize_1, baseTextWeight_1, baseTextFamily_1);\n                candleLegends.forEach(function(data) {\n                    var title = data.title;\n                    var value = data.value;\n                    var text = \"\".concat(title.text).concat(value.text);\n                    var labelWidth = ctx.measureText(text).width + baseTextMarginLeft_1 + baseTextMarginRight_1;\n                    maxTextWidth_1 = Math.max(maxTextWidth_1, labelWidth);\n                });\n                rectHeight_1 += (baseTextMarginBottom_1 + baseTextMarginTop_1 + baseTextSize_1) * candleLegends.length;\n            }\n            var _e = indicatorTooltipStyles.text, indicatorTextMarginLeft_1 = _e.marginLeft, indicatorTextMarginRight_1 = _e.marginRight, indicatorTextMarginTop_1 = _e.marginTop, indicatorTextMarginBottom_1 = _e.marginBottom, indicatorTextSize_1 = _e.size, indicatorTextWeight_1 = _e.weight, indicatorTextFamily_1 = _e.family;\n            var indicatorLegendsArray_1 = [];\n            if (isDrawIndicatorTooltip) {\n                var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n                ctx.font = createFont(indicatorTextSize_1, indicatorTextWeight_1, indicatorTextFamily_1);\n                indicators.forEach(function(indicator) {\n                    var tooltipDataLegends = _this.getIndicatorTooltipData(indicator).legends;\n                    indicatorLegendsArray_1.push(tooltipDataLegends);\n                    tooltipDataLegends.forEach(function(data) {\n                        var title = data.title;\n                        var value = data.value;\n                        var text = \"\".concat(title.text).concat(value.text);\n                        var textWidth = ctx.measureText(text).width + indicatorTextMarginLeft_1 + indicatorTextMarginRight_1;\n                        maxTextWidth_1 = Math.max(maxTextWidth_1, textWidth);\n                        rectHeight_1 += indicatorTextMarginTop_1 + indicatorTextMarginBottom_1 + indicatorTextSize_1;\n                    });\n                });\n            }\n            rectWidth_1 += maxTextWidth_1;\n            if (rectWidth_1 !== 0 && rectHeight_1 !== 0) {\n                var crosshair = chartStore.getCrosshair();\n                var bounding = widget.getBounding();\n                var yAxisBounding = pane.getYAxisWidget().getBounding();\n                rectWidth_1 += rectBorderSize_1 * 2 + rectPaddingLeft + rectPaddingRight_1;\n                rectHeight_1 += rectBorderSize_1 * 2 + rectPaddingTop + rectPaddingBottom;\n                var centerX = bounding.width / 2;\n                var isPointer = rectPosition === CandleTooltipRectPosition.Pointer && crosshair.paneId === PaneIdConstants.CANDLE;\n                var isLeft = ((_a = crosshair.realX) !== null && _a !== void 0 ? _a : 0) > centerX;\n                var rectX_1 = 0;\n                if (isPointer) {\n                    var realX = crosshair.realX;\n                    if (isLeft) {\n                        rectX_1 = realX - rectOffsetRight - rectWidth_1;\n                    } else {\n                        rectX_1 = realX + rectOffsetLeft;\n                    }\n                } else {\n                    var yAxis = this.getWidget().getPane().getAxisComponent();\n                    if (isLeft) {\n                        rectX_1 = rectOffsetLeft + offsetLeft;\n                        if (yAxis.inside && yAxis.position === AxisPosition.Left) {\n                            rectX_1 += yAxisBounding.width;\n                        }\n                    } else {\n                        rectX_1 = bounding.width - rectOffsetRight - rectWidth_1 - offsetRight;\n                        if (yAxis.inside && yAxis.position === AxisPosition.Right) {\n                            rectX_1 -= yAxisBounding.width;\n                        }\n                    }\n                }\n                var rectY = top + rectOffsetTop;\n                if (isPointer) {\n                    var y = crosshair.y;\n                    rectY = y - rectHeight_1 / 2;\n                    if (rectY + rectHeight_1 > bounding.height - rectOffsetBottom - offsetBottom) {\n                        rectY = bounding.height - rectOffsetBottom - rectHeight_1 - offsetBottom;\n                    }\n                    if (rectY < top + rectOffsetTop) {\n                        rectY = top + rectOffsetTop + offsetTop;\n                    }\n                }\n                (_b = this.createFigure({\n                    name: \"rect\",\n                    attrs: {\n                        x: rectX_1,\n                        y: rectY,\n                        width: rectWidth_1,\n                        height: rectHeight_1\n                    },\n                    styles: {\n                        style: PolygonType.StrokeFill,\n                        color: rectBackgroundColor,\n                        borderColor: rectBorderColor,\n                        borderSize: rectBorderSize_1,\n                        borderRadius: rectBorderRadius\n                    }\n                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                var candleTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + baseTextMarginLeft_1;\n                var textY_1 = rectY + rectBorderSize_1 + rectPaddingTop;\n                if (isDrawCandleTooltip) {\n                    // render candle texts\n                    candleLegends.forEach(function(data) {\n                        var _a, _b;\n                        textY_1 += baseTextMarginTop_1;\n                        var title = data.title;\n                        (_a = _this.createFigure({\n                            name: \"text\",\n                            attrs: {\n                                x: candleTextX_1,\n                                y: textY_1,\n                                text: title.text\n                            },\n                            styles: {\n                                color: title.color,\n                                size: baseTextSize_1,\n                                family: baseTextFamily_1,\n                                weight: baseTextWeight_1\n                            }\n                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                        var value = data.value;\n                        (_b = _this.createFigure({\n                            name: \"text\",\n                            attrs: {\n                                x: rectX_1 + rectWidth_1 - rectBorderSize_1 - baseTextMarginRight_1 - rectPaddingRight_1,\n                                y: textY_1,\n                                text: value.text,\n                                align: \"right\"\n                            },\n                            styles: {\n                                color: value.color,\n                                size: baseTextSize_1,\n                                family: baseTextFamily_1,\n                                weight: baseTextWeight_1\n                            }\n                        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                        textY_1 += baseTextSize_1 + baseTextMarginBottom_1;\n                    });\n                }\n                if (isDrawIndicatorTooltip) {\n                    // render indicator texts\n                    var indicatorTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + indicatorTextMarginLeft_1;\n                    indicatorLegendsArray_1.forEach(function(legends) {\n                        legends.forEach(function(data) {\n                            var _a, _b;\n                            textY_1 += indicatorTextMarginTop_1;\n                            var title = data.title;\n                            var value = data.value;\n                            (_a = _this.createFigure({\n                                name: \"text\",\n                                attrs: {\n                                    x: indicatorTextX_1,\n                                    y: textY_1,\n                                    text: title.text\n                                },\n                                styles: {\n                                    color: title.color,\n                                    size: indicatorTextSize_1,\n                                    family: indicatorTextFamily_1,\n                                    weight: indicatorTextWeight_1\n                                }\n                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                            (_b = _this.createFigure({\n                                name: \"text\",\n                                attrs: {\n                                    x: rectX_1 + rectWidth_1 - rectBorderSize_1 - indicatorTextMarginRight_1 - rectPaddingRight_1,\n                                    y: textY_1,\n                                    text: value.text,\n                                    align: \"right\"\n                                },\n                                styles: {\n                                    color: value.color,\n                                    size: indicatorTextSize_1,\n                                    family: indicatorTextFamily_1,\n                                    weight: indicatorTextWeight_1\n                                }\n                            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                            textY_1 += indicatorTextSize_1 + indicatorTextMarginBottom_1;\n                        });\n                    });\n                }\n            }\n        }\n    };\n    CandleTooltipView.prototype._getCandleTooltipLegends = function() {\n        var _a, _b, _c, _d, _e, _f;\n        var chartStore = this.getWidget().getPane().getChart().getChartStore();\n        var styles = chartStore.getStyles().candle;\n        var dataList = chartStore.getDataList();\n        var customApi = chartStore.getCustomApi();\n        var decimalFold = chartStore.getDecimalFold();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var locale = chartStore.getLocale();\n        var _g = chartStore.getPrecision(), pricePrecision = _g.price, volumePrecision = _g.volume;\n        var dataIndex = (_a = chartStore.getCrosshair().dataIndex) !== null && _a !== void 0 ? _a : 0;\n        var tooltipStyles = styles.tooltip;\n        var textColor = tooltipStyles.text.color;\n        var prev = (_b = dataList[dataIndex - 1]) !== null && _b !== void 0 ? _b : null;\n        var current = dataList[dataIndex];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        var prevClose = (_c = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _c !== void 0 ? _c : current.close;\n        var changeValue = current.close - prevClose;\n        var mapping = {\n            \"{time}\": customApi.formatDate(current.timestamp, \"YYYY-MM-DD HH:mm\", FormatDateType.Tooltip),\n            \"{open}\": decimalFold.format(thousandsSeparator.format(formatPrecision(current.open, pricePrecision))),\n            \"{high}\": decimalFold.format(thousandsSeparator.format(formatPrecision(current.high, pricePrecision))),\n            \"{low}\": decimalFold.format(thousandsSeparator.format(formatPrecision(current.low, pricePrecision))),\n            \"{close}\": decimalFold.format(thousandsSeparator.format(formatPrecision(current.close, pricePrecision))),\n            \"{volume}\": decimalFold.format(thousandsSeparator.format(customApi.formatBigNumber(formatPrecision((_d = current.volume) !== null && _d !== void 0 ? _d : tooltipStyles.defaultValue, volumePrecision)))),\n            \"{turnover}\": decimalFold.format(thousandsSeparator.format(formatPrecision((_e = current.turnover) !== null && _e !== void 0 ? _e : tooltipStyles.defaultValue, pricePrecision))),\n            \"{change}\": prevClose === 0 ? tooltipStyles.defaultValue : \"\".concat(thousandsSeparator.format(formatPrecision(changeValue / prevClose * 100)), \"%\")\n        };\n        var legends = isFunction(tooltipStyles.custom) ? tooltipStyles.custom({\n            prev: prev,\n            current: current,\n            next: (_f = dataList[dataIndex + 1]) !== null && _f !== void 0 ? _f : null\n        }, styles) : tooltipStyles.custom;\n        return legends.map(function(_a) {\n            var _b;\n            var title = _a.title, value = _a.value;\n            var t = {\n                text: \"\",\n                color: textColor\n            };\n            if (isObject(title)) {\n                t = __assign({}, title);\n            } else {\n                t.text = title;\n            }\n            t.text = i18n(t.text, locale);\n            var v = {\n                text: tooltipStyles.defaultValue,\n                color: textColor\n            };\n            if (isObject(value)) {\n                v = __assign({}, value);\n            } else {\n                v.text = value;\n            }\n            var match = /{(\\S*)}/.exec(v.text);\n            if (match !== null && match.length > 1) {\n                var key = \"{\".concat(match[1], \"}\");\n                v.text = v.text.replace(key, (_b = mapping[key]) !== null && _b !== void 0 ? _b : tooltipStyles.defaultValue);\n                if (key === \"{change}\") {\n                    v.color = changeValue === 0 ? styles.priceMark.last.noChangeColor : changeValue > 0 ? styles.priceMark.last.upColor : styles.priceMark.last.downColor;\n                }\n            }\n            return {\n                title: t,\n                value: v\n            };\n        });\n    };\n    return CandleTooltipView;\n}(IndicatorTooltipView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleWidget = /** @class */ function(_super) {\n    __extends(CandleWidget, _super);\n    function CandleWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._candleBarView = new CandleBarView(_this);\n        _this._candleAreaView = new CandleAreaView(_this);\n        _this._candleHighLowPriceView = new CandleHighLowPriceView(_this);\n        _this._candleLastPriceLineView = new CandleLastPriceView(_this);\n        _this.addChild(_this._candleBarView);\n        return _this;\n    }\n    CandleWidget.prototype.updateMainContent = function(ctx) {\n        var candleStyles = this.getPane().getChart().getStyles().candle;\n        if (candleStyles.type !== CandleType.Area) {\n            this._candleBarView.draw(ctx);\n            this._candleHighLowPriceView.draw(ctx);\n            this._candleAreaView.stopAnimation();\n        } else {\n            this._candleAreaView.draw(ctx);\n        }\n        this._candleLastPriceLineView.draw(ctx);\n    };\n    CandleWidget.prototype.createTooltipView = function() {\n        return new CandleTooltipView(this);\n    };\n    return CandleWidget;\n}(IndicatorWidget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var AxisView = /** @class */ function(_super) {\n    __extends(AxisView, _super);\n    function AxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AxisView.prototype.drawImp = function(ctx, extend) {\n        var _this = this;\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var axis = pane.getAxisComponent();\n        var styles = this.getAxisStyles(pane.getChart().getStyles());\n        if (styles.show) {\n            if (styles.axisLine.show) {\n                (_a = this.createFigure({\n                    name: \"line\",\n                    attrs: this.createAxisLine(bounding, styles),\n                    styles: styles.axisLine\n                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n            }\n            if (!extend[0]) {\n                var ticks = axis.getTicks();\n                if (styles.tickLine.show) {\n                    var lines = this.createTickLines(ticks, bounding, styles);\n                    lines.forEach(function(line) {\n                        var _a;\n                        (_a = _this.createFigure({\n                            name: \"line\",\n                            attrs: line,\n                            styles: styles.tickLine\n                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                    });\n                }\n                if (styles.tickText.show) {\n                    var texts = this.createTickTexts(ticks, bounding, styles);\n                    (_b = this.createFigure({\n                        name: \"text\",\n                        attrs: texts,\n                        styles: styles.tickText\n                    })) === null || _b === void 0 ? void 0 : _b.draw(ctx);\n                }\n            }\n        }\n    };\n    return AxisView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var YAxisView = /** @class */ function(_super) {\n    __extends(YAxisView, _super);\n    function YAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    YAxisView.prototype.getAxisStyles = function(styles) {\n        return styles.yAxis;\n    };\n    YAxisView.prototype.createAxisLine = function(bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var size = styles.axisLine.size;\n        var x = 0;\n        if (yAxis.isFromZero()) {\n            x = 0;\n        } else {\n            x = bounding.width - size;\n        }\n        return {\n            coordinates: [\n                {\n                    x: x,\n                    y: 0\n                },\n                {\n                    x: x,\n                    y: bounding.height\n                }\n            ]\n        };\n    };\n    YAxisView.prototype.createTickLines = function(ticks, bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var axisLineStyles = styles.axisLine;\n        var tickLineStyles = styles.tickLine;\n        var startX = 0;\n        var endX = 0;\n        if (yAxis.isFromZero()) {\n            startX = 0;\n            if (axisLineStyles.show) {\n                startX += axisLineStyles.size;\n            }\n            endX = startX + tickLineStyles.length;\n        } else {\n            startX = bounding.width;\n            if (axisLineStyles.show) {\n                startX -= axisLineStyles.size;\n            }\n            endX = startX - tickLineStyles.length;\n        }\n        return ticks.map(function(tick) {\n            return {\n                coordinates: [\n                    {\n                        x: startX,\n                        y: tick.coord\n                    },\n                    {\n                        x: endX,\n                        y: tick.coord\n                    }\n                ]\n            };\n        });\n    };\n    YAxisView.prototype.createTickTexts = function(ticks, bounding, styles) {\n        var yAxis = this.getWidget().getPane().getAxisComponent();\n        var axisLineStyles = styles.axisLine;\n        var tickLineStyles = styles.tickLine;\n        var tickTextStyles = styles.tickText;\n        var x = 0;\n        if (yAxis.isFromZero()) {\n            x = tickTextStyles.marginStart;\n            if (axisLineStyles.show) {\n                x += axisLineStyles.size;\n            }\n            if (tickLineStyles.show) {\n                x += tickLineStyles.length;\n            }\n        } else {\n            x = bounding.width - tickTextStyles.marginEnd;\n            if (axisLineStyles.show) {\n                x -= axisLineStyles.size;\n            }\n            if (tickLineStyles.show) {\n                x -= tickLineStyles.length;\n            }\n        }\n        var textAlign = this.getWidget().getPane().getAxisComponent().isFromZero() ? \"left\" : \"right\";\n        return ticks.map(function(tick) {\n            return {\n                x: x,\n                y: tick.coord,\n                text: tick.text,\n                align: textAlign,\n                baseline: \"middle\"\n            };\n        });\n    };\n    return YAxisView;\n}(AxisView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandleLastPriceLabelView = /** @class */ function(_super) {\n    __extends(CandleLastPriceLabelView, _super);\n    function CandleLastPriceLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandleLastPriceLabelView.prototype.drawImp = function(ctx) {\n        var _a, _b, _c;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var priceMarkStyles = chartStore.getStyles().candle.priceMark;\n        var lastPriceMarkStyles = priceMarkStyles.last;\n        var lastPriceMarkTextStyles = lastPriceMarkStyles.text;\n        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkTextStyles.show) {\n            var precision = chartStore.getPrecision();\n            var yAxis = pane.getAxisComponent();\n            var dataList = chartStore.getDataList();\n            var data = dataList[dataList.length - 1];\n            if (isValid(data)) {\n                var close_1 = data.close, open_1 = data.open;\n                var comparePrice = lastPriceMarkStyles.compareRule === CandleColorCompareRule.CurrentOpen ? open_1 : (_b = (_a = dataList[dataList.length - 2]) === null || _a === void 0 ? void 0 : _a.close) !== null && _b !== void 0 ? _b : close_1;\n                var priceY = yAxis.convertToNicePixel(close_1);\n                var backgroundColor = \"\";\n                if (close_1 > comparePrice) {\n                    backgroundColor = lastPriceMarkStyles.upColor;\n                } else if (close_1 < comparePrice) {\n                    backgroundColor = lastPriceMarkStyles.downColor;\n                } else {\n                    backgroundColor = lastPriceMarkStyles.noChangeColor;\n                }\n                var yAxisRange = yAxis.getRange();\n                var text = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(close_1, {\n                    range: yAxisRange\n                }), {\n                    range: yAxisRange\n                }), precision.price);\n                text = chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text));\n                var x = 0;\n                var textAlgin = \"left\";\n                if (yAxis.isFromZero()) {\n                    x = 0;\n                    textAlgin = \"left\";\n                } else {\n                    x = bounding.width;\n                    textAlgin = \"right\";\n                }\n                (_c = this.createFigure({\n                    name: \"text\",\n                    attrs: {\n                        x: x,\n                        y: priceY,\n                        text: text,\n                        align: textAlgin,\n                        baseline: \"middle\"\n                    },\n                    styles: __assign(__assign({}, lastPriceMarkTextStyles), {\n                        backgroundColor: backgroundColor\n                    })\n                })) === null || _c === void 0 ? void 0 : _c.draw(ctx);\n            }\n        }\n    };\n    return CandleLastPriceLabelView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorLastValueView = /** @class */ function(_super) {\n    __extends(IndicatorLastValueView, _super);\n    function IndicatorLastValueView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorLastValueView.prototype.drawImp = function(ctx) {\n        var _this = this;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = pane.getChart().getChartStore();\n        var defaultStyles = chartStore.getStyles().indicator;\n        var lastValueMarkStyles = defaultStyles.lastValueMark;\n        var lastValueMarkTextStyles = lastValueMarkStyles.text;\n        if (lastValueMarkStyles.show) {\n            var yAxis_1 = pane.getAxisComponent();\n            var yAxisRange_1 = yAxis_1.getRange();\n            var dataList = chartStore.getDataList();\n            var dataIndex_1 = dataList.length - 1;\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var customApi_1 = chartStore.getCustomApi();\n            var decimalFold_1 = chartStore.getDecimalFold();\n            var thousandsSeparator_1 = chartStore.getThousandsSeparator();\n            indicators.forEach(function(indicator) {\n                var _a, _b;\n                var result = indicator.result;\n                var data = (_b = (_a = result[dataIndex_1]) !== null && _a !== void 0 ? _a : result[dataIndex_1 - 1]) !== null && _b !== void 0 ? _b : {};\n                if (isValid(data) && indicator.visible) {\n                    var precision_1 = indicator.precision;\n                    eachFigures(indicator, dataIndex_1, defaultStyles, function(figure, figureStyles) {\n                        var _a;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                        var value = data[figure.key];\n                        if (isNumber(value)) {\n                            var y = yAxis_1.convertToNicePixel(value);\n                            var text = yAxis_1.displayValueToText(yAxis_1.realValueToDisplayValue(yAxis_1.valueToRealValue(value, {\n                                range: yAxisRange_1\n                            }), {\n                                range: yAxisRange_1\n                            }), precision_1);\n                            if (indicator.shouldFormatBigNumber) {\n                                text = customApi_1.formatBigNumber(text);\n                            }\n                            text = decimalFold_1.format(thousandsSeparator_1.format(text));\n                            var x = 0;\n                            var textAlign = \"left\";\n                            if (yAxis_1.isFromZero()) {\n                                x = 0;\n                                textAlign = \"left\";\n                            } else {\n                                x = bounding.width;\n                                textAlign = \"right\";\n                            }\n                            (_a = _this.createFigure({\n                                name: \"text\",\n                                attrs: {\n                                    x: x,\n                                    y: y,\n                                    text: text,\n                                    align: textAlign,\n                                    baseline: \"middle\"\n                                },\n                                styles: __assign(__assign({}, lastValueMarkTextStyles), {\n                                    backgroundColor: figureStyles.color\n                                })\n                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                        }\n                    });\n                }\n            });\n        }\n    };\n    return IndicatorLastValueView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var OverlayYAxisView = /** @class */ function(_super) {\n    __extends(OverlayYAxisView, _super);\n    function OverlayYAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OverlayYAxisView.prototype.coordinateToPointTimestampDataIndexFlag = function() {\n        return false;\n    };\n    OverlayYAxisView.prototype.drawDefaultFigures = function(ctx, overlay, coordinates) {\n        this.drawFigures(ctx, overlay, this.getDefaultFigures(overlay, coordinates));\n    };\n    OverlayYAxisView.prototype.getDefaultFigures = function(overlay, coordinates) {\n        var _a;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var clickOverlayInfo = chartStore.getClickOverlayInfo();\n        var figures = [];\n        if (overlay.needDefaultYAxisFigure && overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id) && clickOverlayInfo.paneId === pane.getId()) {\n            var yAxis = pane.getAxisComponent();\n            var bounding = widget.getBounding();\n            var topY_1 = Number.MAX_SAFE_INTEGER;\n            var bottomY_1 = Number.MIN_SAFE_INTEGER;\n            var isFromZero = yAxis.isFromZero();\n            var textAlign_1 = \"left\";\n            var x_1 = 0;\n            if (isFromZero) {\n                textAlign_1 = \"left\";\n                x_1 = 0;\n            } else {\n                textAlign_1 = \"right\";\n                x_1 = bounding.width;\n            }\n            var decimalFold_1 = chartStore.getDecimalFold();\n            var thousandsSeparator_1 = chartStore.getThousandsSeparator();\n            coordinates.forEach(function(coordinate, index) {\n                var point = overlay.points[index];\n                if (isNumber(point.value)) {\n                    topY_1 = Math.min(topY_1, coordinate.y);\n                    bottomY_1 = Math.max(bottomY_1, coordinate.y);\n                    var text = decimalFold_1.format(thousandsSeparator_1.format(formatPrecision(point.value, chartStore.getPrecision().price)));\n                    figures.push({\n                        type: \"text\",\n                        attrs: {\n                            x: x_1,\n                            y: coordinate.y,\n                            text: text,\n                            align: textAlign_1,\n                            baseline: \"middle\"\n                        },\n                        ignoreEvent: true\n                    });\n                }\n            });\n            if (coordinates.length > 1) {\n                figures.unshift({\n                    type: \"rect\",\n                    attrs: {\n                        x: 0,\n                        y: topY_1,\n                        width: bounding.width,\n                        height: bottomY_1 - topY_1\n                    },\n                    ignoreEvent: true\n                });\n            }\n        }\n        return figures;\n    };\n    OverlayYAxisView.prototype.getFigures = function(overlay, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = overlay.createYAxisFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, {\n            chart: chart,\n            overlay: overlay,\n            coordinates: coordinates,\n            bounding: bounding,\n            xAxis: xAxis,\n            yAxis: yAxis\n        })) !== null && _b !== void 0 ? _b : [];\n    };\n    return OverlayYAxisView;\n}(OverlayView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CrosshairHorizontalLabelView = /** @class */ function(_super) {\n    __extends(CrosshairHorizontalLabelView, _super);\n    function CrosshairHorizontalLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairHorizontalLabelView.prototype.drawImp = function(ctx) {\n        var _a;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var bounding = widget.getBounding();\n        var chartStore = widget.getPane().getChart().getChartStore();\n        var crosshair = chartStore.getCrosshair();\n        var styles = chartStore.getStyles().crosshair;\n        if (isString(crosshair.paneId) && this.compare(crosshair, pane.getId())) {\n            if (styles.show) {\n                var directionStyles = this.getDirectionStyles(styles);\n                var textStyles = directionStyles.text;\n                if (directionStyles.show && textStyles.show) {\n                    var axis = pane.getAxisComponent();\n                    var text = this.getText(crosshair, chartStore, axis);\n                    ctx.font = createFont(textStyles.size, textStyles.weight, textStyles.family);\n                    (_a = this.createFigure({\n                        name: \"text\",\n                        attrs: this.getTextAttrs(text, ctx.measureText(text).width, crosshair, bounding, axis, textStyles),\n                        styles: textStyles\n                    })) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n                }\n            }\n        }\n    };\n    CrosshairHorizontalLabelView.prototype.compare = function(crosshair, paneId) {\n        return crosshair.paneId === paneId;\n    };\n    CrosshairHorizontalLabelView.prototype.getDirectionStyles = function(styles) {\n        return styles.horizontal;\n    };\n    CrosshairHorizontalLabelView.prototype.getText = function(crosshair, chartStore, axis) {\n        var yAxis = axis;\n        var value = axis.convertFromPixel(crosshair.y);\n        var precision = 0;\n        var shouldFormatBigNumber = false;\n        if (yAxis.isInCandle()) {\n            precision = chartStore.getPrecision().price;\n        } else {\n            var indicators = chartStore.getIndicatorsByPaneId(crosshair.paneId);\n            indicators.forEach(function(indicator) {\n                precision = Math.max(indicator.precision, precision);\n                shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);\n            });\n        }\n        var yAxisRange = yAxis.getRange();\n        var text = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(value, {\n            range: yAxisRange\n        }), {\n            range: yAxisRange\n        }), precision);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n        if (shouldFormatBigNumber) {\n            text = chartStore.getCustomApi().formatBigNumber(text);\n        }\n        return chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text));\n    };\n    CrosshairHorizontalLabelView.prototype.getTextAttrs = function(text, _textWidth, crosshair, bounding, axis, _styles) {\n        var yAxis = axis;\n        var x = 0;\n        var textAlign = \"left\";\n        if (yAxis.isFromZero()) {\n            x = 0;\n            textAlign = \"left\";\n        } else {\n            x = bounding.width;\n            textAlign = \"right\";\n        }\n        return {\n            x: x,\n            y: crosshair.y,\n            text: text,\n            align: textAlign,\n            baseline: \"middle\"\n        };\n    };\n    return CrosshairHorizontalLabelView;\n}(View);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var YAxisWidget = /** @class */ function(_super) {\n    __extends(YAxisWidget, _super);\n    function YAxisWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._yAxisView = new YAxisView(_this);\n        _this._candleLastPriceLabelView = new CandleLastPriceLabelView(_this);\n        _this._indicatorLastValueView = new IndicatorLastValueView(_this);\n        _this._overlayYAxisView = new OverlayYAxisView(_this);\n        _this._crosshairHorizontalLabelView = new CrosshairHorizontalLabelView(_this);\n        _this.getContainer().style.cursor = \"ns-resize\";\n        _this.addChild(_this._overlayYAxisView);\n        return _this;\n    }\n    YAxisWidget.prototype.getName = function() {\n        return WidgetNameConstants.Y_AXIS;\n    };\n    YAxisWidget.prototype.updateMain = function(ctx) {\n        var minimize = this.getPane().getOptions().state === \"minimize\" /* PaneState.Minimize */ ;\n        this._yAxisView.draw(ctx, minimize);\n        if (!minimize) {\n            if (this.getPane().getAxisComponent().isInCandle()) {\n                this._candleLastPriceLabelView.draw(ctx);\n            }\n            this._indicatorLastValueView.draw(ctx);\n        }\n    };\n    YAxisWidget.prototype.updateOverlay = function(ctx) {\n        if (this.getPane().getOptions().state !== \"minimize\" /* PaneState.Minimize */ ) {\n            this._overlayYAxisView.draw(ctx);\n            this._crosshairHorizontalLabelView.draw(ctx);\n        }\n    };\n    return YAxisWidget;\n}(DrawWidget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var TICK_COUNT = 8;\nvar YAxisImp = /** @class */ function(_super) {\n    __extends(YAxisImp, _super);\n    function YAxisImp(parent, yAxis) {\n        var _this = _super.call(this, parent) || this;\n        _this.reverse = false;\n        _this.inside = false;\n        _this.position = AxisPosition.Right;\n        _this.gap = {\n            top: 0.2,\n            bottom: 0.1\n        };\n        _this.createRange = function(params) {\n            return params.defaultRange;\n        };\n        _this.minSpan = function(precision) {\n            return index10(-precision);\n        };\n        _this.valueToRealValue = function(value) {\n            return value;\n        };\n        _this.realValueToDisplayValue = function(value) {\n            return value;\n        };\n        _this.displayValueToRealValue = function(value) {\n            return value;\n        };\n        _this.realValueToValue = function(value) {\n            return value;\n        };\n        _this.displayValueToText = function(value, precision) {\n            return formatPrecision(value, precision);\n        };\n        _this.override(yAxis);\n        return _this;\n    }\n    YAxisImp.prototype.override = function(yAxis) {\n        var name = yAxis.name, gap = yAxis.gap, others = __rest(yAxis, [\n            \"name\",\n            \"gap\"\n        ]);\n        if (!isString(this.name)) {\n            this.name = name;\n        }\n        merge(this.gap, gap);\n        merge(this, others);\n    };\n    YAxisImp.prototype.createRangeImp = function() {\n        var parent = this.getParent();\n        var chart = parent.getChart();\n        var chartStore = chart.getChartStore();\n        var paneId = parent.getId();\n        var min = Number.MAX_SAFE_INTEGER;\n        var max = Number.MIN_SAFE_INTEGER;\n        var shouldOhlc = false;\n        var specifyMin = Number.MAX_SAFE_INTEGER;\n        var specifyMax = Number.MIN_SAFE_INTEGER;\n        var indicatorPrecision = Number.MAX_SAFE_INTEGER;\n        var indicators = chartStore.getIndicatorsByPaneId(paneId);\n        indicators.forEach(function(indicator) {\n            shouldOhlc || (shouldOhlc = indicator.shouldOhlc);\n            indicatorPrecision = Math.min(indicatorPrecision, indicator.precision);\n            if (isNumber(indicator.minValue)) {\n                specifyMin = Math.min(specifyMin, indicator.minValue);\n            }\n            if (isNumber(indicator.maxValue)) {\n                specifyMax = Math.max(specifyMax, indicator.maxValue);\n            }\n        });\n        var precision = 4;\n        var inCandle = this.isInCandle();\n        if (inCandle) {\n            var pricePrecision = chartStore.getPrecision().price;\n            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {\n                precision = Math.min(indicatorPrecision, pricePrecision);\n            } else {\n                precision = pricePrecision;\n            }\n        } else {\n            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {\n                precision = indicatorPrecision;\n            }\n        }\n        var visibleRangeDataList = chartStore.getVisibleRangeDataList();\n        var candleStyles = chart.getStyles().candle;\n        var isArea = candleStyles.type === CandleType.Area;\n        var areaValueKey = candleStyles.area.value;\n        var shouldCompareHighLow = inCandle && !isArea || !inCandle && shouldOhlc;\n        visibleRangeDataList.forEach(function(visibleData) {\n            var dataIndex = visibleData.dataIndex;\n            var data = visibleData.data.current;\n            if (isValid(data)) {\n                if (shouldCompareHighLow) {\n                    min = Math.min(min, data.low);\n                    max = Math.max(max, data.high);\n                }\n                if (inCandle && isArea) {\n                    var value = data[areaValueKey];\n                    if (isNumber(value)) {\n                        min = Math.min(min, value);\n                        max = Math.max(max, value);\n                    }\n                }\n            }\n            indicators.forEach(function(_a) {\n                var _b;\n                var result = _a.result, figures = _a.figures;\n                var data = (_b = result[dataIndex]) !== null && _b !== void 0 ? _b : {};\n                figures.forEach(function(figure) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore\n                    var value = data[figure.key];\n                    if (isNumber(value)) {\n                        min = Math.min(min, value);\n                        max = Math.max(max, value);\n                    }\n                });\n            });\n        });\n        if (min !== Number.MAX_SAFE_INTEGER && max !== Number.MIN_SAFE_INTEGER) {\n            min = Math.min(specifyMin, min);\n            max = Math.max(specifyMax, max);\n        } else {\n            min = 0;\n            max = 10;\n        }\n        var defaultDiff = max - min;\n        var defaultRange = {\n            from: min,\n            to: max,\n            range: defaultDiff,\n            realFrom: min,\n            realTo: max,\n            realRange: defaultDiff,\n            displayFrom: min,\n            displayTo: max,\n            displayRange: defaultDiff\n        };\n        var range = this.createRange({\n            chart: chart,\n            paneId: paneId,\n            defaultRange: defaultRange\n        });\n        var realFrom = range.realFrom;\n        var realTo = range.realTo;\n        var realRange = range.realRange;\n        var minSpan = this.minSpan(precision);\n        if (realFrom === realTo || realRange < minSpan) {\n            var minCheck = specifyMin === realFrom;\n            var maxCheck = specifyMax === realTo;\n            var halfTickCount = TICK_COUNT / 2;\n            realFrom = minCheck ? realFrom : maxCheck ? realFrom - TICK_COUNT * minSpan : realFrom - halfTickCount * minSpan;\n            realTo = maxCheck ? realTo : minCheck ? realTo + TICK_COUNT * minSpan : realTo + halfTickCount * minSpan;\n        }\n        var height = this.getBounding().height;\n        var _a = this.gap, top = _a.top, bottom = _a.bottom;\n        var topRate = top;\n        if (topRate >= 1) {\n            topRate = topRate / height;\n        }\n        var bottomRate = bottom;\n        if (bottomRate >= 1) {\n            bottomRate = bottomRate / height;\n        }\n        realRange = realTo - realFrom;\n        realFrom = realFrom - realRange * bottomRate;\n        realTo = realTo + realRange * topRate;\n        var from = this.realValueToValue(realFrom, {\n            range: range\n        });\n        var to = this.realValueToValue(realTo, {\n            range: range\n        });\n        var displayFrom = this.realValueToDisplayValue(realFrom, {\n            range: range\n        });\n        var displayTo = this.realValueToDisplayValue(realTo, {\n            range: range\n        });\n        return {\n            from: from,\n            to: to,\n            range: to - from,\n            realFrom: realFrom,\n            realTo: realTo,\n            realRange: realTo - realFrom,\n            displayFrom: displayFrom,\n            displayTo: displayTo,\n            displayRange: displayTo - displayFrom\n        };\n    };\n    /**\n     * 是否是蜡烛图轴\n     * @return {boolean}\n     */ YAxisImp.prototype.isInCandle = function() {\n        return this.getParent().getId() === PaneIdConstants.CANDLE;\n    };\n    /**\n     * 是否从y轴0开始\n     * @return {boolean}\n     */ YAxisImp.prototype.isFromZero = function() {\n        return this.position === AxisPosition.Left && this.inside || this.position === AxisPosition.Right && !this.inside;\n    };\n    YAxisImp.prototype.createTicksImp = function() {\n        var _this = this;\n        var _a, _b;\n        var range = this.getRange();\n        var displayFrom = range.displayFrom, displayTo = range.displayTo, displayRange = range.displayRange;\n        var ticks = [];\n        if (displayRange >= 0) {\n            var interval = nice(displayRange / TICK_COUNT);\n            var precision_1 = getPrecision(interval);\n            var first = round(Math.ceil(displayFrom / interval) * interval, precision_1);\n            var last = round(Math.floor(displayTo / interval) * interval, precision_1);\n            var n = 0;\n            var f = first;\n            if (interval !== 0) {\n                while(f <= last){\n                    var v = f.toFixed(precision_1);\n                    ticks[n] = {\n                        text: v,\n                        coord: 0,\n                        value: v\n                    };\n                    ++n;\n                    f += interval;\n                }\n            }\n        }\n        var pane = this.getParent();\n        var height = (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var chartStore = pane.getChart().getChartStore();\n        var optimalTicks = [];\n        var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n        var styles = chartStore.getStyles();\n        var precision = 0;\n        var shouldFormatBigNumber = false;\n        if (this.isInCandle()) {\n            precision = chartStore.getPrecision().price;\n        } else {\n            indicators.forEach(function(indicator) {\n                precision = Math.max(precision, indicator.precision);\n                shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);\n            });\n        }\n        var customApi = chartStore.getCustomApi();\n        var thousandsSeparator = chartStore.getThousandsSeparator();\n        var decimalFold = chartStore.getDecimalFold();\n        var textHeight = styles.xAxis.tickText.size;\n        var validY = NaN;\n        ticks.forEach(function(_a) {\n            var value = _a.value;\n            var v = _this.displayValueToText(+value, precision);\n            var y = _this.convertToPixel(_this.realValueToValue(_this.displayValueToRealValue(+value, {\n                range: range\n            }), {\n                range: range\n            }));\n            if (shouldFormatBigNumber) {\n                v = customApi.formatBigNumber(value);\n            }\n            v = decimalFold.format(thousandsSeparator.format(v));\n            var validYNumber = isNumber(validY);\n            if (y > textHeight && y < height - textHeight && (validYNumber && Math.abs(validY - y) > textHeight * 2 || !validYNumber)) {\n                optimalTicks.push({\n                    text: v,\n                    coord: y,\n                    value: value\n                });\n                validY = y;\n            }\n        });\n        if (isFunction(this.createTicks)) {\n            return this.createTicks({\n                range: this.getRange(),\n                bounding: this.getBounding(),\n                defaultTicks: optimalTicks\n            });\n        }\n        return optimalTicks;\n    };\n    YAxisImp.prototype.getAutoSize = function() {\n        var pane = this.getParent();\n        var chart = pane.getChart();\n        var chartStore = chart.getChartStore();\n        var styles = chartStore.getStyles();\n        var yAxisStyles = styles.yAxis;\n        var width = yAxisStyles.size;\n        if (width !== \"auto\") {\n            return width;\n        }\n        var yAxisWidth = 0;\n        if (yAxisStyles.show) {\n            if (yAxisStyles.axisLine.show) {\n                yAxisWidth += yAxisStyles.axisLine.size;\n            }\n            if (yAxisStyles.tickLine.show) {\n                yAxisWidth += yAxisStyles.tickLine.length;\n            }\n            if (yAxisStyles.tickText.show) {\n                var textWidth_1 = 0;\n                this.getTicks().forEach(function(tick) {\n                    textWidth_1 = Math.max(textWidth_1, calcTextWidth(tick.text, yAxisStyles.tickText.size, yAxisStyles.tickText.weight, yAxisStyles.tickText.family));\n                });\n                yAxisWidth += yAxisStyles.tickText.marginStart + yAxisStyles.tickText.marginEnd + textWidth_1;\n            }\n        }\n        var crosshairStyles = styles.crosshair;\n        var crosshairVerticalTextWidth = 0;\n        if (crosshairStyles.show && crosshairStyles.horizontal.show && crosshairStyles.horizontal.text.show) {\n            var indicators = chartStore.getIndicatorsByPaneId(pane.getId());\n            var indicatorPrecision_1 = 0;\n            var shouldFormatBigNumber_1 = false;\n            indicators.forEach(function(indicator) {\n                indicatorPrecision_1 = Math.max(indicator.precision, indicatorPrecision_1);\n                shouldFormatBigNumber_1 || (shouldFormatBigNumber_1 = indicator.shouldFormatBigNumber);\n            });\n            var precision = 2;\n            if (this.isInCandle()) {\n                var pricePrecision = chartStore.getPrecision().price;\n                var lastValueMarkStyles = styles.indicator.lastValueMark;\n                if (lastValueMarkStyles.show && lastValueMarkStyles.text.show) {\n                    precision = Math.max(indicatorPrecision_1, pricePrecision);\n                } else {\n                    precision = pricePrecision;\n                }\n            } else {\n                precision = indicatorPrecision_1;\n            }\n            var valueText = formatPrecision(this.getRange().displayTo, precision);\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (shouldFormatBigNumber_1) {\n                valueText = chartStore.getCustomApi().formatBigNumber(valueText);\n            }\n            valueText = chartStore.getDecimalFold().format(valueText);\n            crosshairVerticalTextWidth += crosshairStyles.horizontal.text.paddingLeft + crosshairStyles.horizontal.text.paddingRight + crosshairStyles.horizontal.text.borderSize * 2 + calcTextWidth(valueText, crosshairStyles.horizontal.text.size, crosshairStyles.horizontal.text.weight, crosshairStyles.horizontal.text.family);\n        }\n        return Math.max(yAxisWidth, crosshairVerticalTextWidth);\n    };\n    YAxisImp.prototype.getBounding = function() {\n        return this.getParent().getYAxisWidget().getBounding();\n    };\n    YAxisImp.prototype.convertFromPixel = function(pixel) {\n        var height = this.getBounding().height;\n        var range = this.getRange();\n        var realFrom = range.realFrom, realRange = range.realRange;\n        var rate = this.reverse ? pixel / height : 1 - pixel / height;\n        var realValue = rate * realRange + realFrom;\n        return this.realValueToValue(realValue, {\n            range: range\n        });\n    };\n    YAxisImp.prototype.convertToPixel = function(value) {\n        var _a, _b;\n        var range = this.getRange();\n        var realValue = this.valueToRealValue(value, {\n            range: range\n        });\n        var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var realFrom = range.realFrom, realRange = range.realRange;\n        var rate = (realValue - realFrom) / realRange;\n        return this.reverse ? Math.round(rate * height) : Math.round((1 - rate) * height);\n    };\n    YAxisImp.prototype.convertToNicePixel = function(value) {\n        var _a, _b;\n        var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;\n        var pixel = this.convertToPixel(value);\n        return Math.round(Math.max(height * 0.05, Math.min(pixel, height * 0.98)));\n    };\n    YAxisImp.extend = function(template) {\n        var Custom = /** @class */ function(_super) {\n            __extends(Custom, _super);\n            function Custom(parent) {\n                return _super.call(this, parent, template) || this;\n            }\n            return Custom;\n        }(YAxisImp);\n        return Custom;\n    };\n    return YAxisImp;\n}(AxisImp);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var normal$1 = {\n    name: \"normal\"\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var percentage = {\n    name: \"percentage\",\n    minSpan: function() {\n        return Math.pow(10, -2);\n    },\n    displayValueToText: function(value) {\n        return \"\".concat(formatPrecision(value, 2), \"%\");\n    },\n    valueToRealValue: function(value, _a) {\n        var range = _a.range;\n        return (value - range.from) / range.range * range.realRange + range.realFrom;\n    },\n    realValueToValue: function(value, _a) {\n        var range = _a.range;\n        return (value - range.realFrom) / range.realRange * range.range + range.from;\n    },\n    createRange: function(_a) {\n        var chart = _a.chart, defaultRange = _a.defaultRange;\n        var kLineDataList = chart.getDataList();\n        var visibleRange = chart.getVisibleRange();\n        var kLineData = kLineDataList[visibleRange.from];\n        if (isValid(kLineData)) {\n            var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;\n            var realFrom = (defaultRange.from - kLineData.close) / kLineData.close * 100;\n            var realTo = (defaultRange.to - kLineData.close) / kLineData.close * 100;\n            var realRange = realTo - realFrom;\n            return {\n                from: from,\n                to: to,\n                range: range,\n                realFrom: realFrom,\n                realTo: realTo,\n                realRange: realRange,\n                displayFrom: realFrom,\n                displayTo: realTo,\n                displayRange: realRange\n            };\n        }\n        return defaultRange;\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var logarithm = {\n    name: \"logarithm\",\n    minSpan: function(precision) {\n        return 0.05 * index10(-precision);\n    },\n    valueToRealValue: function(value) {\n        return value < 0 ? -log10(Math.abs(value)) : log10(value);\n    },\n    realValueToDisplayValue: function(value) {\n        return value < 0 ? -index10(Math.abs(value)) : index10(value);\n    },\n    displayValueToRealValue: function(value) {\n        return value < 0 ? -log10(Math.abs(value)) : log10(value);\n    },\n    realValueToValue: function(value) {\n        return value < 0 ? -index10(Math.abs(value)) : index10(value);\n    },\n    createRange: function(_a) {\n        var defaultRange = _a.defaultRange;\n        var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;\n        var realFrom = from < 0 ? -log10(Math.abs(from)) : log10(from);\n        var realTo = to < 0 ? -log10(Math.abs(to)) : log10(to);\n        return {\n            from: from,\n            to: to,\n            range: range,\n            realFrom: realFrom,\n            realTo: realTo,\n            realRange: realTo - realFrom,\n            displayFrom: from,\n            displayTo: to,\n            displayRange: range\n        };\n    }\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var yAxises = {\n    normal: YAxisImp.extend(normal$1),\n    percentage: YAxisImp.extend(percentage),\n    logarithm: YAxisImp.extend(logarithm)\n};\nfunction registerYAxis(axis) {\n    yAxises[axis.name] = YAxisImp.extend(axis);\n}\nfunction getYAxisClass(name) {\n    var _a;\n    return (_a = yAxises[name]) !== null && _a !== void 0 ? _a : yAxises.normal;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var Pane = /** @class */ function() {\n    function Pane(chart, id) {\n        this._bounding = createDefaultBounding();\n        this._originalBounding = createDefaultBounding();\n        this._visible = true;\n        this._chart = chart;\n        this._id = id;\n        this._container = createDom(\"div\", {\n            width: \"100%\",\n            margin: \"0\",\n            padding: \"0\",\n            position: \"relative\",\n            overflow: \"hidden\",\n            boxSizing: \"border-box\"\n        });\n    }\n    Pane.prototype.getContainer = function() {\n        return this._container;\n    };\n    Pane.prototype.setVisible = function(visible) {\n        if (this._visible !== visible) {\n            this._container.style.display = visible ? \"block\" : \"none\";\n            this._visible = visible;\n        }\n    };\n    Pane.prototype.getVisible = function() {\n        return this._visible;\n    };\n    Pane.prototype.getId = function() {\n        return this._id;\n    };\n    Pane.prototype.getChart = function() {\n        return this._chart;\n    };\n    Pane.prototype.getBounding = function() {\n        return this._bounding;\n    };\n    Pane.prototype.setOriginalBounding = function(bounding) {\n        merge(this._originalBounding, bounding);\n    };\n    Pane.prototype.getOriginalBounding = function() {\n        return this._originalBounding;\n    };\n    Pane.prototype.update = function(level) {\n        if (this._bounding.height !== this._container.clientHeight) {\n            this._container.style.height = \"\".concat(this._bounding.height, \"px\");\n        }\n        this.updateImp(level !== null && level !== void 0 ? level : 3 /* UpdateLevel.Drawer */ , this._container, this._bounding);\n    };\n    return Pane;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DrawPane = /** @class */ function(_super) {\n    __extends(DrawPane, _super);\n    function DrawPane(chart, id, options) {\n        var _this = _super.call(this, chart, id) || this;\n        _this._yAxisWidget = null;\n        _this._options = {\n            id: \"\",\n            minHeight: PANE_MIN_HEIGHT,\n            dragEnabled: true,\n            order: 0,\n            height: PANE_DEFAULT_HEIGHT,\n            state: \"normal\" /* PaneState.Normal */ ,\n            axis: {\n                name: \"normal\",\n                scrollZoomEnabled: true\n            }\n        };\n        var container = _this.getContainer();\n        _this._mainWidget = _this.createMainWidget(container);\n        _this._yAxisWidget = _this.createYAxisWidget(container);\n        _this.setOptions(options);\n        return _this;\n    }\n    DrawPane.prototype.setOptions = function(options) {\n        var _a, _b, _c, _d, _e;\n        var paneId = this.getId();\n        if (paneId === PaneIdConstants.CANDLE || paneId === PaneIdConstants.X_AXIS) {\n            var axisName = (_a = options.axis) === null || _a === void 0 ? void 0 : _a.name;\n            if (!isValid(this._axis) || isValid(axisName) && this._options.axis.name !== axisName) {\n                this._axis = this.createAxisComponent(axisName !== null && axisName !== void 0 ? axisName : \"normal\");\n            }\n        } else {\n            if (!isValid(this._axis)) {\n                this._axis = this.createAxisComponent(\"normal\");\n            }\n        }\n        if (this._axis instanceof YAxisImp) {\n            this._axis.setAutoCalcTickFlag(true);\n        }\n        merge(this._options, options);\n        this._axis.override(__assign(__assign({}, this._options.axis), {\n            name: (_c = (_b = options.axis) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : \"normal\"\n        }));\n        var container = null;\n        var cursor = \"default\";\n        if (this.getId() === PaneIdConstants.X_AXIS) {\n            container = this.getMainWidget().getContainer();\n            cursor = \"ew-resize\";\n        } else {\n            container = this.getYAxisWidget().getContainer();\n            cursor = \"ns-resize\";\n        }\n        if ((_e = (_d = options.axis) === null || _d === void 0 ? void 0 : _d.scrollZoomEnabled) !== null && _e !== void 0 ? _e : true) {\n            container.style.cursor = cursor;\n        } else {\n            container.style.cursor = \"default\";\n        }\n        return this;\n    };\n    DrawPane.prototype.getOptions = function() {\n        return this._options;\n    };\n    DrawPane.prototype.getAxisComponent = function() {\n        return this._axis;\n    };\n    DrawPane.prototype.setBounding = function(rootBounding, mainBounding, leftYAxisBounding, rightYAxisBounding) {\n        var _a, _b, _c, _d;\n        merge(this.getBounding(), rootBounding);\n        var contentBounding = {};\n        if (isValid(rootBounding.height)) {\n            contentBounding.height = rootBounding.height;\n        }\n        if (isValid(rootBounding.top)) {\n            contentBounding.top = rootBounding.top;\n        }\n        this._mainWidget.setBounding(contentBounding);\n        var mainBoundingValid = isValid(mainBounding);\n        if (mainBoundingValid) {\n            this._mainWidget.setBounding(mainBounding);\n        }\n        if (isValid(this._yAxisWidget)) {\n            this._yAxisWidget.setBounding(contentBounding);\n            var yAxis = this._axis;\n            if (yAxis.position === AxisPosition.Left) {\n                if (isValid(leftYAxisBounding)) {\n                    this._yAxisWidget.setBounding(__assign(__assign({}, leftYAxisBounding), {\n                        left: 0\n                    }));\n                }\n            } else {\n                if (isValid(rightYAxisBounding)) {\n                    this._yAxisWidget.setBounding(rightYAxisBounding);\n                    if (mainBoundingValid) {\n                        this._yAxisWidget.setBounding({\n                            left: ((_a = mainBounding.left) !== null && _a !== void 0 ? _a : 0) + ((_b = mainBounding.width) !== null && _b !== void 0 ? _b : 0) + ((_c = mainBounding.right) !== null && _c !== void 0 ? _c : 0) - ((_d = rightYAxisBounding.width) !== null && _d !== void 0 ? _d : 0)\n                        });\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    DrawPane.prototype.getMainWidget = function() {\n        return this._mainWidget;\n    };\n    DrawPane.prototype.getYAxisWidget = function() {\n        return this._yAxisWidget;\n    };\n    DrawPane.prototype.updateImp = function(level) {\n        var _a;\n        this._mainWidget.update(level);\n        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.update(level);\n    };\n    DrawPane.prototype.destroy = function() {\n        var _a;\n        this._mainWidget.destroy();\n        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.destroy();\n    };\n    DrawPane.prototype.getImage = function(includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var canvas = createDom(\"canvas\", {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: \"border-box\"\n        });\n        var ctx = canvas.getContext(\"2d\");\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        var mainBounding = this._mainWidget.getBounding();\n        ctx.drawImage(this._mainWidget.getImage(includeOverlay), mainBounding.left, 0, mainBounding.width, mainBounding.height);\n        if (this._yAxisWidget !== null) {\n            var yAxisBounding = this._yAxisWidget.getBounding();\n            ctx.drawImage(this._yAxisWidget.getImage(includeOverlay), yAxisBounding.left, 0, yAxisBounding.width, yAxisBounding.height);\n        }\n        return canvas;\n    };\n    DrawPane.prototype.createYAxisWidget = function(_container) {\n        return null;\n    };\n    return DrawPane;\n}(Pane);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var IndicatorPane = /** @class */ function(_super) {\n    __extends(IndicatorPane, _super);\n    function IndicatorPane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IndicatorPane.prototype.createAxisComponent = function(name) {\n        var YAxisClass = getYAxisClass(name !== null && name !== void 0 ? name : \"default\");\n        return new YAxisClass(this);\n    };\n    IndicatorPane.prototype.createMainWidget = function(container) {\n        return new IndicatorWidget(container, this);\n    };\n    IndicatorPane.prototype.createYAxisWidget = function(container) {\n        return new YAxisWidget(container, this);\n    };\n    return IndicatorPane;\n}(DrawPane);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CandlePane = /** @class */ function(_super) {\n    __extends(CandlePane, _super);\n    function CandlePane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CandlePane.prototype.createMainWidget = function(container) {\n        return new CandleWidget(container, this);\n    };\n    return CandlePane;\n}(IndicatorPane);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var XAxisView = /** @class */ function(_super) {\n    __extends(XAxisView, _super);\n    function XAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    XAxisView.prototype.getAxisStyles = function(styles) {\n        return styles.xAxis;\n    };\n    XAxisView.prototype.createAxisLine = function(bounding) {\n        return {\n            coordinates: [\n                {\n                    x: 0,\n                    y: 0\n                },\n                {\n                    x: bounding.width,\n                    y: 0\n                }\n            ]\n        };\n    };\n    XAxisView.prototype.createTickLines = function(ticks, _bounding, styles) {\n        var tickLineStyles = styles.tickLine;\n        var axisLineSize = styles.axisLine.size;\n        return ticks.map(function(tick) {\n            return {\n                coordinates: [\n                    {\n                        x: tick.coord,\n                        y: 0\n                    },\n                    {\n                        x: tick.coord,\n                        y: axisLineSize + tickLineStyles.length\n                    }\n                ]\n            };\n        });\n    };\n    XAxisView.prototype.createTickTexts = function(ticks, _bounding, styles) {\n        var tickTickStyles = styles.tickText;\n        var axisLineSize = styles.axisLine.size;\n        var tickLineLength = styles.tickLine.length;\n        return ticks.map(function(tick) {\n            return {\n                x: tick.coord,\n                y: axisLineSize + tickLineLength + tickTickStyles.marginStart,\n                text: tick.text,\n                align: \"center\",\n                baseline: \"top\"\n            };\n        });\n    };\n    return XAxisView;\n}(AxisView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var OverlayXAxisView = /** @class */ function(_super) {\n    __extends(OverlayXAxisView, _super);\n    function OverlayXAxisView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OverlayXAxisView.prototype.coordinateToPointTimestampDataIndexFlag = function() {\n        return true;\n    };\n    OverlayXAxisView.prototype.coordinateToPointValueFlag = function() {\n        return false;\n    };\n    OverlayXAxisView.prototype.getCompleteOverlays = function() {\n        return this.getWidget().getPane().getChart().getChartStore().getOverlaysByPaneId();\n    };\n    OverlayXAxisView.prototype.getProgressOverlay = function() {\n        var _a, _b;\n        return (_b = (_a = this.getWidget().getPane().getChart().getChartStore().getProgressOverlayInfo()) === null || _a === void 0 ? void 0 : _a.overlay) !== null && _b !== void 0 ? _b : null;\n    };\n    OverlayXAxisView.prototype.getDefaultFigures = function(overlay, coordinates) {\n        var _a;\n        var figures = [];\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chartStore = pane.getChart().getChartStore();\n        var clickOverlayInfo = chartStore.getClickOverlayInfo();\n        if (overlay.needDefaultXAxisFigure && overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id)) {\n            var leftX_1 = Number.MAX_SAFE_INTEGER;\n            var rightX_1 = Number.MIN_SAFE_INTEGER;\n            coordinates.forEach(function(coordinate, index) {\n                leftX_1 = Math.min(leftX_1, coordinate.x);\n                rightX_1 = Math.max(rightX_1, coordinate.x);\n                var point = overlay.points[index];\n                if (isNumber(point.timestamp)) {\n                    var text = chartStore.getCustomApi().formatDate(point.timestamp, \"YYYY-MM-DD HH:mm\", FormatDateType.Crosshair);\n                    figures.push({\n                        type: \"text\",\n                        attrs: {\n                            x: coordinate.x,\n                            y: 0,\n                            text: text,\n                            align: \"center\"\n                        },\n                        ignoreEvent: true\n                    });\n                }\n            });\n            if (coordinates.length > 1) {\n                figures.unshift({\n                    type: \"rect\",\n                    attrs: {\n                        x: leftX_1,\n                        y: 0,\n                        width: rightX_1 - leftX_1,\n                        height: widget.getBounding().height\n                    },\n                    ignoreEvent: true\n                });\n            }\n        }\n        return figures;\n    };\n    OverlayXAxisView.prototype.getFigures = function(o, coordinates) {\n        var _a, _b;\n        var widget = this.getWidget();\n        var pane = widget.getPane();\n        var chart = pane.getChart();\n        var yAxis = pane.getAxisComponent();\n        var xAxis = chart.getXAxisPane().getAxisComponent();\n        var bounding = widget.getBounding();\n        return (_b = (_a = o.createXAxisFigures) === null || _a === void 0 ? void 0 : _a.call(o, {\n            chart: chart,\n            overlay: o,\n            coordinates: coordinates,\n            bounding: bounding,\n            xAxis: xAxis,\n            yAxis: yAxis\n        })) !== null && _b !== void 0 ? _b : [];\n    };\n    return OverlayXAxisView;\n}(OverlayYAxisView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var CrosshairVerticalLabelView = /** @class */ function(_super) {\n    __extends(CrosshairVerticalLabelView, _super);\n    function CrosshairVerticalLabelView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CrosshairVerticalLabelView.prototype.compare = function(crosshair) {\n        return isValid(crosshair.timestamp);\n    };\n    CrosshairVerticalLabelView.prototype.getDirectionStyles = function(styles) {\n        return styles.vertical;\n    };\n    CrosshairVerticalLabelView.prototype.getText = function(crosshair, chartStore) {\n        var timestamp = crosshair.timestamp;\n        return chartStore.getCustomApi().formatDate(timestamp, \"YYYY-MM-DD HH:mm\", FormatDateType.Crosshair);\n    };\n    CrosshairVerticalLabelView.prototype.getTextAttrs = function(text, textWidth, crosshair, bounding, _axis, styles) {\n        var x = crosshair.realX;\n        var optimalX = 0;\n        var align = \"center\";\n        if (x - textWidth / 2 - styles.paddingLeft < 0) {\n            optimalX = 0;\n            align = \"left\";\n        } else if (x + textWidth / 2 + styles.paddingRight > bounding.width) {\n            optimalX = bounding.width;\n            align = \"right\";\n        } else {\n            optimalX = x;\n        }\n        return {\n            x: optimalX,\n            y: 0,\n            text: text,\n            align: align,\n            baseline: \"top\"\n        };\n    };\n    return CrosshairVerticalLabelView;\n}(CrosshairHorizontalLabelView);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var XAxisWidget = /** @class */ function(_super) {\n    __extends(XAxisWidget, _super);\n    function XAxisWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._xAxisView = new XAxisView(_this);\n        _this._overlayXAxisView = new OverlayXAxisView(_this);\n        _this._crosshairVerticalLabelView = new CrosshairVerticalLabelView(_this);\n        _this.getContainer().style.cursor = \"ew-resize\";\n        _this.addChild(_this._overlayXAxisView);\n        return _this;\n    }\n    XAxisWidget.prototype.getName = function() {\n        return WidgetNameConstants.X_AXIS;\n    };\n    XAxisWidget.prototype.updateMain = function(ctx) {\n        this._xAxisView.draw(ctx);\n    };\n    XAxisWidget.prototype.updateOverlay = function(ctx) {\n        this._overlayXAxisView.draw(ctx);\n        this._crosshairVerticalLabelView.draw(ctx);\n    };\n    return XAxisWidget;\n}(DrawWidget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var XAxisImp = /** @class */ function(_super) {\n    __extends(XAxisImp, _super);\n    function XAxisImp(parent, xAxis) {\n        var _this = _super.call(this, parent) || this;\n        _this.override(xAxis);\n        return _this;\n    }\n    XAxisImp.prototype.override = function(xAxis) {\n        var name = xAxis.name, scrollZoomEnabled = xAxis.scrollZoomEnabled, createTicks = xAxis.createTicks;\n        if (!isString(this.name)) {\n            this.name = name;\n        }\n        this.scrollZoomEnabled = scrollZoomEnabled !== null && scrollZoomEnabled !== void 0 ? scrollZoomEnabled : this.scrollZoomEnabled;\n        this.createTicks = createTicks !== null && createTicks !== void 0 ? createTicks : this.createTicks;\n    };\n    XAxisImp.prototype.createRangeImp = function() {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var visibleDataRange = chartStore.getVisibleRange();\n        var realFrom = visibleDataRange.realFrom, realTo = visibleDataRange.realTo;\n        var af = realFrom;\n        var at = realTo;\n        var diff = realTo - realFrom + 1;\n        var range = {\n            from: af,\n            to: at,\n            range: diff,\n            realFrom: af,\n            realTo: at,\n            realRange: diff,\n            displayFrom: af,\n            displayTo: at,\n            displayRange: diff\n        };\n        return range;\n    };\n    XAxisImp.prototype.createTicksImp = function() {\n        var _this = this;\n        var _a = this.getRange(), realFrom = _a.realFrom, realTo = _a.realTo;\n        var chartStore = this.getParent().getChart().getChartStore();\n        var formatDate = chartStore.getCustomApi().formatDate;\n        var timeWeightTickList = chartStore.getTimeWeightTickList();\n        var ticks = [];\n        var fitTicks = function(list, start) {\n            var e_1, _a;\n            try {\n                for(var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()){\n                    var timeWeightTick = list_1_1.value;\n                    if (timeWeightTick.dataIndex >= start && timeWeightTick.dataIndex < realTo) {\n                        var timestamp = timeWeightTick.timestamp, weight = timeWeightTick.weight, dataIndex = timeWeightTick.dataIndex;\n                        var text = \"\";\n                        switch(weight){\n                            case TimeWeightConstants.Year:\n                                {\n                                    text = formatDate(timestamp, \"YYYY\", FormatDateType.XAxis);\n                                    break;\n                                }\n                            case TimeWeightConstants.Month:\n                                {\n                                    text = formatDate(timestamp, \"YYYY-MM\", FormatDateType.XAxis);\n                                    break;\n                                }\n                            case TimeWeightConstants.Day:\n                                {\n                                    text = formatDate(timestamp, \"MM-DD\", FormatDateType.XAxis);\n                                    break;\n                                }\n                            case TimeWeightConstants.Hour:\n                            case TimeWeightConstants.Minute:\n                                {\n                                    text = formatDate(timestamp, \"HH:mm\", FormatDateType.XAxis);\n                                    break;\n                                }\n                            case TimeWeightConstants.Second:\n                                {\n                                    text = formatDate(timestamp, \"HH:mm:ss\", FormatDateType.XAxis);\n                                    break;\n                                }\n                            default:\n                                {\n                                    text = formatDate(timestamp, \"YYYY-MM-DD HH:mm\", FormatDateType.XAxis);\n                                    break;\n                                }\n                        }\n                        ticks.push({\n                            coord: _this.convertToPixel(dataIndex),\n                            value: timestamp,\n                            text: text\n                        });\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        };\n        fitTicks(timeWeightTickList, realFrom);\n        // Future time tick\n        if (timeWeightTickList.length > 0) {\n            var barSpace = chartStore.getBarSpace().bar;\n            var textStyles = chartStore.getStyles().xAxis.tickText;\n            var barCount = calcBetweenTimeWeightTickBarCount(barSpace, textStyles);\n            var startDataIndex = timeWeightTickList[timeWeightTickList.length - 1].dataIndex + barCount - 1;\n            var dataList = [];\n            for(var i = startDataIndex; i < realTo; i++){\n                var timestamp = chartStore.dataIndexToTimestamp(i);\n                if (isNumber(timestamp)) {\n                    dataList.push({\n                        timestamp: timestamp\n                    });\n                }\n            }\n            if (dataList.length > 0) {\n                var map = new Map();\n                classifyTimeWeightTicks(map, dataList, chartStore.getDateTimeFormat(), startDataIndex);\n                fitTicks(createTimeWeightTickList(map, barSpace, textStyles), startDataIndex);\n            }\n        }\n        if (isFunction(this.createTicks)) {\n            return this.createTicks({\n                range: this.getRange(),\n                bounding: this.getBounding(),\n                defaultTicks: ticks\n            });\n        }\n        return ticks;\n    };\n    XAxisImp.prototype.getAutoSize = function() {\n        var styles = this.getParent().getChart().getStyles();\n        var xAxisStyles = styles.xAxis;\n        var height = xAxisStyles.size;\n        if (height !== \"auto\") {\n            return height;\n        }\n        var crosshairStyles = styles.crosshair;\n        var xAxisHeight = 0;\n        if (xAxisStyles.show) {\n            if (xAxisStyles.axisLine.show) {\n                xAxisHeight += xAxisStyles.axisLine.size;\n            }\n            if (xAxisStyles.tickLine.show) {\n                xAxisHeight += xAxisStyles.tickLine.length;\n            }\n            if (xAxisStyles.tickText.show) {\n                xAxisHeight += xAxisStyles.tickText.marginStart + xAxisStyles.tickText.marginEnd + xAxisStyles.tickText.size;\n            }\n        }\n        var crosshairVerticalTextHeight = 0;\n        if (crosshairStyles.show && crosshairStyles.vertical.show && crosshairStyles.vertical.text.show) {\n            crosshairVerticalTextHeight += crosshairStyles.vertical.text.paddingTop + crosshairStyles.vertical.text.paddingBottom + crosshairStyles.vertical.text.borderSize * 2 + crosshairStyles.vertical.text.size;\n        }\n        return Math.max(xAxisHeight, crosshairVerticalTextHeight);\n    };\n    XAxisImp.prototype.getBounding = function() {\n        return this.getParent().getMainWidget().getBounding();\n    };\n    XAxisImp.prototype.convertTimestampFromPixel = function(pixel) {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var dataIndex = chartStore.coordinateToDataIndex(pixel);\n        return chartStore.dataIndexToTimestamp(dataIndex);\n    };\n    XAxisImp.prototype.convertTimestampToPixel = function(timestamp) {\n        var chartStore = this.getParent().getChart().getChartStore();\n        var dataIndex = chartStore.timestampToDataIndex(timestamp);\n        return chartStore.dataIndexToCoordinate(dataIndex);\n    };\n    XAxisImp.prototype.convertFromPixel = function(pixel) {\n        return this.getParent().getChart().getChartStore().coordinateToDataIndex(pixel);\n    };\n    XAxisImp.prototype.convertToPixel = function(value) {\n        return this.getParent().getChart().getChartStore().dataIndexToCoordinate(value);\n    };\n    XAxisImp.extend = function(template) {\n        var Custom = /** @class */ function(_super) {\n            __extends(Custom, _super);\n            function Custom(parent) {\n                return _super.call(this, parent, template) || this;\n            }\n            return Custom;\n        }(XAxisImp);\n        return Custom;\n    };\n    return XAxisImp;\n}(AxisImp);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var normal = {\n    name: \"normal\"\n};\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var xAxises = {\n    normal: XAxisImp.extend(normal)\n};\nfunction registerXAxis(axis) {\n    xAxises[axis.name] = XAxisImp.extend(axis);\n}\nfunction getXAxisClass(name) {\n    var _a;\n    return (_a = xAxises[name]) !== null && _a !== void 0 ? _a : xAxises.normal;\n}\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var XAxisPane = /** @class */ function(_super) {\n    __extends(XAxisPane, _super);\n    function XAxisPane() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    XAxisPane.prototype.createAxisComponent = function(name) {\n        var XAxisClass = getXAxisClass(name);\n        return new XAxisClass(this);\n    };\n    XAxisPane.prototype.createMainWidget = function(container) {\n        return new XAxisWidget(container, this);\n    };\n    return XAxisPane;\n}(DrawPane);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function throttle(func, wait) {\n    var previous = 0;\n    return function() {\n        var now = Date.now();\n        if (now - previous > wait) {\n            func.apply(this, arguments);\n            previous = now;\n        }\n    };\n}\n// export function memoize<R1 = any, R2 = any> (func: (...args: any[]) => R1, resolver?: (...args: any[]) => R2): (...args: any[]) => R1 {\n//   if (!isFunction(func) || (isValid(resolver) && !isFunction(resolver))) {\n//     throw new TypeError('Expected a function')\n//   }\n//   const memoized = function (...args: any[]): any {\n//     const key = isFunction(resolver) ? resolver.apply(this, args) : args[0]\n//     const cache = memoized.cache\n//     if (cache.has(key)) {\n//       return cache.get(key)\n//     }\n//     const result = func.apply(this, args)\n//     // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n//     memoized.cache = cache.set(key, result) || cache\n//     return result\n//   }\n//   // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n//   memoized.cache = new (memoize.Cache || Map)()\n//   return memoized\n// }\n// memoize.Cache = Map\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var SeparatorWidget = /** @class */ function(_super) {\n    __extends(SeparatorWidget, _super);\n    function SeparatorWidget(rootContainer, pane) {\n        var _this = _super.call(this, rootContainer, pane) || this;\n        _this._dragFlag = false;\n        _this._dragStartY = 0;\n        _this._topPaneHeight = 0;\n        _this._bottomPaneHeight = 0;\n        _this._topPane = null;\n        _this._bottomPane = null;\n        // eslint-disable-next-line @typescript-eslint/unbound-method -- ignore\n        _this._pressedMouseMoveEvent = throttle(_this._pressedTouchMouseMoveEvent, 20);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        _this.registerEvent(\"touchStartEvent\", _this._mouseDownEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"touchMoveEvent\", _this._pressedMouseMoveEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"touchEndEvent\", _this._mouseUpEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"mouseDownEvent\", _this._mouseDownEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"mouseUpEvent\", _this._mouseUpEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"pressedMouseMoveEvent\", _this._pressedMouseMoveEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"mouseEnterEvent\", _this._mouseEnterEvent.bind(_this))// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- ignore\n        .registerEvent(\"mouseLeaveEvent\", _this._mouseLeaveEvent.bind(_this));\n        return _this;\n    }\n    SeparatorWidget.prototype.getName = function() {\n        return WidgetNameConstants.SEPARATOR;\n    };\n    SeparatorWidget.prototype.checkEventOn = function() {\n        return true;\n    };\n    SeparatorWidget.prototype._mouseDownEvent = function(event) {\n        var _this = this;\n        this._dragFlag = true;\n        this._dragStartY = event.pageY;\n        var pane = this.getPane();\n        var chart = pane.getChart();\n        this._topPane = pane.getTopPane();\n        this._bottomPane = pane.getBottomPane();\n        var drawPanes = chart.getDrawPanes();\n        if (this._topPane.getOptions().state === \"minimize\" /* PaneState.Minimize */ ) {\n            var index = drawPanes.findIndex(function(pane) {\n                var _a;\n                return pane.getId() === ((_a = _this._topPane) === null || _a === void 0 ? void 0 : _a.getId());\n            });\n            for(var i = index - 1; i > -1; i--){\n                var pane_1 = drawPanes[i];\n                if (pane_1.getOptions().state !== \"minimize\" /* PaneState.Minimize */ ) {\n                    this._topPane = pane_1;\n                    break;\n                }\n            }\n        }\n        if (this._bottomPane.getOptions().state === \"minimize\" /* PaneState.Minimize */ ) {\n            var index = drawPanes.findIndex(function(pane) {\n                var _a;\n                return pane.getId() === ((_a = _this._bottomPane) === null || _a === void 0 ? void 0 : _a.getId());\n            });\n            for(var i = index + 1; i < drawPanes.length; i++){\n                var pane_2 = drawPanes[i];\n                if (pane_2.getOptions().state !== \"minimize\" /* PaneState.Minimize */ ) {\n                    this._bottomPane = pane_2;\n                    break;\n                }\n            }\n        }\n        this._topPaneHeight = this._topPane.getBounding().height;\n        this._bottomPaneHeight = this._bottomPane.getBounding().height;\n        return true;\n    };\n    SeparatorWidget.prototype._mouseUpEvent = function() {\n        this._dragFlag = false;\n        this._topPane = null;\n        this._bottomPane = null;\n        this._topPaneHeight = 0;\n        this._bottomPaneHeight = 0;\n        return this._mouseLeaveEvent();\n    };\n    SeparatorWidget.prototype._pressedTouchMouseMoveEvent = function(event) {\n        var dragDistance = event.pageY - this._dragStartY;\n        var isUpDrag = dragDistance < 0;\n        if (isValid(this._topPane) && isValid(this._bottomPane)) {\n            var bottomPaneOptions = this._bottomPane.getOptions();\n            if (this._topPane.getOptions().state !== \"minimize\" /* PaneState.Minimize */  && bottomPaneOptions.state !== \"minimize\" /* PaneState.Minimize */  && bottomPaneOptions.dragEnabled) {\n                var reducedPane = null;\n                var increasedPane = null;\n                var startDragReducedPaneHeight = 0;\n                var startDragIncreasedPaneHeight = 0;\n                if (isUpDrag) {\n                    reducedPane = this._topPane;\n                    increasedPane = this._bottomPane;\n                    startDragReducedPaneHeight = this._topPaneHeight;\n                    startDragIncreasedPaneHeight = this._bottomPaneHeight;\n                } else {\n                    reducedPane = this._bottomPane;\n                    increasedPane = this._topPane;\n                    startDragReducedPaneHeight = this._bottomPaneHeight;\n                    startDragIncreasedPaneHeight = this._topPaneHeight;\n                }\n                var reducedPaneMinHeight = reducedPane.getOptions().minHeight;\n                if (startDragReducedPaneHeight > reducedPaneMinHeight) {\n                    var reducedPaneHeight = Math.max(startDragReducedPaneHeight - Math.abs(dragDistance), reducedPaneMinHeight);\n                    var diffHeight = startDragReducedPaneHeight - reducedPaneHeight;\n                    reducedPane.setBounding({\n                        height: reducedPaneHeight\n                    });\n                    increasedPane.setBounding({\n                        height: startDragIncreasedPaneHeight + diffHeight\n                    });\n                    var currentPane = this.getPane();\n                    var chart = currentPane.getChart();\n                    chart.getChartStore().executeAction(ActionType.OnPaneDrag, {\n                        paneId: currentPane.getId()\n                    });\n                    chart.layout({\n                        measureHeight: true,\n                        measureWidth: true,\n                        update: true,\n                        buildYAxisTick: true,\n                        forceBuildYAxisTick: true\n                    });\n                }\n            }\n        }\n        return true;\n    };\n    SeparatorWidget.prototype._mouseEnterEvent = function() {\n        var pane = this.getPane();\n        var bottomPane = pane.getBottomPane();\n        if (bottomPane.getOptions().dragEnabled) {\n            var chart = pane.getChart();\n            var styles = chart.getStyles().separator;\n            this.getContainer().style.background = styles.activeBackgroundColor;\n            return true;\n        }\n        return false;\n    };\n    SeparatorWidget.prototype._mouseLeaveEvent = function() {\n        if (!this._dragFlag) {\n            this.getContainer().style.background = \"transparent\";\n            return true;\n        }\n        return false;\n    };\n    SeparatorWidget.prototype.createContainer = function() {\n        return createDom(\"div\", {\n            width: \"100%\",\n            height: \"\".concat(REAL_SEPARATOR_HEIGHT, \"px\"),\n            margin: \"0\",\n            padding: \"0\",\n            position: \"absolute\",\n            top: \"-3px\",\n            zIndex: \"20\",\n            boxSizing: \"border-box\",\n            cursor: \"ns-resize\"\n        });\n    };\n    SeparatorWidget.prototype.updateImp = function(container, _bounding, level) {\n        if (level === 4 /* UpdateLevel.All */  || level === 2 /* UpdateLevel.Separator */ ) {\n            var styles = this.getPane().getChart().getStyles().separator;\n            container.style.top = \"\".concat(-Math.floor((REAL_SEPARATOR_HEIGHT - styles.size) / 2), \"px\");\n            container.style.height = \"\".concat(REAL_SEPARATOR_HEIGHT, \"px\");\n        }\n    };\n    return SeparatorWidget;\n}(Widget);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var SeparatorPane = /** @class */ function(_super) {\n    __extends(SeparatorPane, _super);\n    function SeparatorPane(chart, id, topPane, bottomPane) {\n        var _this = _super.call(this, chart, id) || this;\n        _this.getContainer().style.overflow = \"\";\n        _this._topPane = topPane;\n        _this._bottomPane = bottomPane;\n        _this._separatorWidget = new SeparatorWidget(_this.getContainer(), _this);\n        return _this;\n    }\n    SeparatorPane.prototype.setBounding = function(rootBounding) {\n        merge(this.getBounding(), rootBounding);\n        return this;\n    };\n    SeparatorPane.prototype.getTopPane = function() {\n        return this._topPane;\n    };\n    SeparatorPane.prototype.setTopPane = function(pane) {\n        this._topPane = pane;\n        return this;\n    };\n    SeparatorPane.prototype.getBottomPane = function() {\n        return this._bottomPane;\n    };\n    SeparatorPane.prototype.setBottomPane = function(pane) {\n        this._bottomPane = pane;\n        return this;\n    };\n    SeparatorPane.prototype.getWidget = function() {\n        return this._separatorWidget;\n    };\n    SeparatorPane.prototype.getImage = function(_includeOverlay) {\n        var _a = this.getBounding(), width = _a.width, height = _a.height;\n        var styles = this.getChart().getStyles().separator;\n        var canvas = createDom(\"canvas\", {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: \"border-box\"\n        });\n        var ctx = canvas.getContext(\"2d\");\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.fillStyle = styles.color;\n        ctx.fillRect(0, 0, width, height);\n        return canvas;\n    };\n    SeparatorPane.prototype.updateImp = function(level, container, bounding) {\n        if (level === 4 /* UpdateLevel.All */  || level === 2 /* UpdateLevel.Separator */ ) {\n            var styles = this.getChart().getStyles().separator;\n            container.style.backgroundColor = styles.color;\n            container.style.height = \"\".concat(bounding.height, \"px\");\n            container.style.marginLeft = \"\".concat(bounding.left, \"px\");\n            container.style.width = \"\".concat(bounding.width, \"px\");\n            this._separatorWidget.update(level);\n        }\n    };\n    return SeparatorPane;\n}(Pane);\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function isFF() {\n    if (true) {\n        return false;\n    }\n    return window.navigator.userAgent.toLowerCase().includes(\"firefox\");\n}\nfunction isIOS() {\n    if (true) {\n        return false;\n    }\n    return /iPhone|iPad|iPod|iOS/.test(window.navigator.userAgent);\n}\n/* eslint-disable eslint-comments/require-description -- ignore */ var ManhattanDistance = {\n    CancelClick: 5,\n    CancelTap: 5,\n    DoubleClick: 5,\n    DoubleTap: 30\n};\nvar MouseEventButton = {\n    Left: 0,\n    Middle: 1,\n    Right: 2\n};\nvar TOUCH_MIN_RADIUS = 10;\n// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum\nvar SyntheticEvent = /** @class */ function() {\n    function SyntheticEvent(target, handler, options) {\n        var _this = this;\n        this._clickCount = 0;\n        this._clickTimeoutId = null;\n        this._clickCoordinate = {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n        };\n        this._tapCount = 0;\n        this._tapTimeoutId = null;\n        this._tapCoordinate = {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n        };\n        this._longTapTimeoutId = null;\n        this._longTapActive = false;\n        this._mouseMoveStartCoordinate = null;\n        this._touchMoveStartCoordinate = null;\n        this._touchMoveExceededManhattanDistance = false;\n        this._cancelClick = false;\n        this._cancelTap = false;\n        this._unsubscribeOutsideMouseEvents = null;\n        this._unsubscribeOutsideTouchEvents = null;\n        this._unsubscribeMobileSafariEvents = null;\n        this._unsubscribeMousemove = null;\n        this._unsubscribeMouseWheel = null;\n        this._unsubscribeContextMenu = null;\n        this._unsubscribeRootMouseEvents = null;\n        this._unsubscribeRootTouchEvents = null;\n        this._startPinchMiddleCoordinate = null;\n        this._startPinchDistance = 0;\n        this._pinchPrevented = false;\n        this._preventTouchDragProcess = false;\n        this._mousePressed = false;\n        this._lastTouchEventTimeStamp = 0;\n        // for touchstart/touchmove/touchend events we handle only first touch\n        // i.e. we don't support several active touches at the same time (except pinch event)\n        this._activeTouchId = null;\n        // accept all mouse leave events if it's not an iOS device\n        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler\n        this._acceptMouseLeave = !isIOS();\n        /**\n         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.\n         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.\n         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.\n         */ this._onFirefoxOutsideMouseUp = function(mouseUpEvent) {\n            _this._mouseUpHandler(mouseUpEvent);\n        };\n        /**\n         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.\n         * There are two possible solutions:\n         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.\n         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.\n         * https://developer.apple.com/forums/thread/125073\n         */ this._onMobileSafariDoubleClick = function(dblClickEvent) {\n            if (_this._firesTouchEvents(dblClickEvent)) {\n                ++_this._tapCount;\n                if (_this._tapTimeoutId !== null && _this._tapCount > 1) {\n                    var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._tapCoordinate).manhattanDistance;\n                    if (manhattanDistance < ManhattanDistance.DoubleTap && !_this._cancelTap) {\n                        _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.doubleTapEvent);\n                    }\n                    _this._resetTapTimeout();\n                }\n            } else {\n                ++_this._clickCount;\n                if (_this._clickTimeoutId !== null && _this._clickCount > 1) {\n                    var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._clickCoordinate).manhattanDistance;\n                    if (manhattanDistance < ManhattanDistance.DoubleClick && !_this._cancelClick) {\n                        _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.mouseDoubleClickEvent);\n                    }\n                    _this._resetClickTimeout();\n                }\n            }\n        };\n        this._target = target;\n        this._handler = handler;\n        this._options = options;\n        this._init();\n    }\n    SyntheticEvent.prototype.destroy = function() {\n        if (this._unsubscribeOutsideMouseEvents !== null) {\n            this._unsubscribeOutsideMouseEvents();\n            this._unsubscribeOutsideMouseEvents = null;\n        }\n        if (this._unsubscribeOutsideTouchEvents !== null) {\n            this._unsubscribeOutsideTouchEvents();\n            this._unsubscribeOutsideTouchEvents = null;\n        }\n        if (this._unsubscribeMousemove !== null) {\n            this._unsubscribeMousemove();\n            this._unsubscribeMousemove = null;\n        }\n        if (this._unsubscribeMouseWheel !== null) {\n            this._unsubscribeMouseWheel();\n            this._unsubscribeMouseWheel = null;\n        }\n        if (this._unsubscribeContextMenu !== null) {\n            this._unsubscribeContextMenu();\n            this._unsubscribeContextMenu = null;\n        }\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        if (this._unsubscribeMobileSafariEvents !== null) {\n            this._unsubscribeMobileSafariEvents();\n            this._unsubscribeMobileSafariEvents = null;\n        }\n        this._clearLongTapTimeout();\n        this._resetClickTimeout();\n    };\n    SyntheticEvent.prototype._mouseEnterHandler = function(enterEvent) {\n        var _this = this;\n        var _a, _b, _c;\n        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);\n        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundMouseMoveHandler = this._mouseMoveHandler.bind(this);\n        this._unsubscribeMousemove = function() {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener(\"mousemove\", boundMouseMoveHandler);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"mousemove\", boundMouseMoveHandler);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundMouseWheel = this._mouseWheelHandler.bind(this);\n        this._unsubscribeMouseWheel = function() {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener(\"wheel\", boundMouseWheel);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"wheel\", boundMouseWheel, {\n            passive: false\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        var boundContextMenu = this._contextMenuHandler.bind(this);\n        this._unsubscribeContextMenu = function() {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            _this._target.removeEventListener(\"contextmenu\", boundContextMenu);\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"contextmenu\", boundContextMenu, {\n            passive: false\n        });\n        if (this._firesTouchEvents(enterEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(enterEvent), this._handler.mouseEnterEvent);\n        this._acceptMouseLeave = true;\n    };\n    SyntheticEvent.prototype._resetClickTimeout = function() {\n        if (this._clickTimeoutId !== null) {\n            clearTimeout(this._clickTimeoutId);\n        }\n        this._clickCount = 0;\n        this._clickTimeoutId = null;\n        this._clickCoordinate = {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n        };\n    };\n    SyntheticEvent.prototype._resetTapTimeout = function() {\n        if (this._tapTimeoutId !== null) {\n            clearTimeout(this._tapTimeoutId);\n        }\n        this._tapCount = 0;\n        this._tapTimeoutId = null;\n        this._tapCoordinate = {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n        };\n    };\n    SyntheticEvent.prototype._mouseMoveHandler = function(moveEvent) {\n        if (this._mousePressed || this._touchMoveStartCoordinate !== null) {\n            return;\n        }\n        if (this._firesTouchEvents(moveEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(moveEvent), this._handler.mouseMoveEvent);\n        this._acceptMouseLeave = true;\n    };\n    SyntheticEvent.prototype._mouseWheelHandler = function(wheelEvent) {\n        if (Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {\n            if (!isValid(this._handler.mouseWheelHortEvent)) {\n                return;\n            }\n            this._preventDefault(wheelEvent);\n            if (Math.abs(wheelEvent.deltaX) === 0) {\n                return;\n            }\n            this._handler.mouseWheelHortEvent(this._makeCompatEvent(wheelEvent), -wheelEvent.deltaX);\n        } else {\n            if (!isValid(this._handler.mouseWheelVertEvent)) {\n                return;\n            }\n            var deltaY = -(wheelEvent.deltaY / 100);\n            if (deltaY === 0) {\n                return;\n            }\n            this._preventDefault(wheelEvent);\n            switch(wheelEvent.deltaMode){\n                case wheelEvent.DOM_DELTA_PAGE:\n                    {\n                        deltaY *= 120;\n                        break;\n                    }\n                case wheelEvent.DOM_DELTA_LINE:\n                    {\n                        deltaY *= 32;\n                        break;\n                    }\n            }\n            if (deltaY !== 0) {\n                var scale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));\n                this._handler.mouseWheelVertEvent(this._makeCompatEvent(wheelEvent), scale);\n            }\n        }\n    };\n    SyntheticEvent.prototype._contextMenuHandler = function(mouseEvent) {\n        this._preventDefault(mouseEvent);\n    };\n    SyntheticEvent.prototype._touchMoveHandler = function(moveEvent) {\n        var touch = this._touchWithId(moveEvent.changedTouches, this._activeTouchId);\n        if (touch === null) {\n            return;\n        }\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(moveEvent);\n        if (this._startPinchMiddleCoordinate !== null) {\n            return;\n        }\n        if (this._preventTouchDragProcess) {\n            return;\n        }\n        // prevent pinch if move event comes faster than the second touch\n        this._pinchPrevented = true;\n        var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._touchMoveStartCoordinate);\n        var xOffset = moveInfo.xOffset, yOffset = moveInfo.yOffset, manhattanDistance = moveInfo.manhattanDistance;\n        if (!this._touchMoveExceededManhattanDistance && manhattanDistance < ManhattanDistance.CancelTap) {\n            return;\n        }\n        if (!this._touchMoveExceededManhattanDistance) {\n            // first time when current position exceeded manhattan distance\n            // vertical drag is more important than horizontal drag\n            // because we scroll the page vertically often than horizontally\n            var correctedXOffset = xOffset * 0.5;\n            // a drag can be only if touch page scroll isn't allowed\n            var isVertDrag = yOffset >= correctedXOffset && !this._options.treatVertDragAsPageScroll();\n            var isHorzDrag = correctedXOffset > yOffset && !this._options.treatHorzDragAsPageScroll();\n            // if drag event happened then we should revert preventDefault state to original one\n            // and try to process the drag event\n            // else we shouldn't prevent default of the event and ignore processing the drag event\n            if (!isVertDrag && !isHorzDrag) {\n                this._preventTouchDragProcess = true;\n            }\n            this._touchMoveExceededManhattanDistance = true;\n            // if manhattan distance is more that 5 - we should cancel tap event\n            this._cancelTap = true;\n            this._clearLongTapTimeout();\n            this._resetTapTimeout();\n        }\n        if (!this._preventTouchDragProcess) {\n            this._processEvent(this._makeCompatEvent(moveEvent, touch), this._handler.touchMoveEvent);\n        // we should prevent default in case of touch only\n        // to prevent scroll of the page\n        // preventDefault(moveEvent)\n        }\n    };\n    SyntheticEvent.prototype._mouseMoveWithDownHandler = function(moveEvent) {\n        if (moveEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(moveEvent), this._mouseMoveStartCoordinate);\n        var manhattanDistance = moveInfo.manhattanDistance;\n        if (manhattanDistance >= ManhattanDistance.CancelClick) {\n            // if manhattan distance is more that 5 - we should cancel click event\n            this._cancelClick = true;\n            this._resetClickTimeout();\n        }\n        if (this._cancelClick) {\n            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded\n            this._processEvent(this._makeCompatEvent(moveEvent), this._handler.pressedMouseMoveEvent);\n        }\n    };\n    SyntheticEvent.prototype._mouseTouchMoveWithDownInfo = function(currentCoordinate, startCoordinate) {\n        var xOffset = Math.abs(startCoordinate.x - currentCoordinate.x);\n        var yOffset = Math.abs(startCoordinate.y - currentCoordinate.y);\n        var manhattanDistance = xOffset + yOffset;\n        return {\n            xOffset: xOffset,\n            yOffset: yOffset,\n            manhattanDistance: manhattanDistance\n        };\n    };\n    SyntheticEvent.prototype._touchEndHandler = function(touchEndEvent) {\n        var touch = this._touchWithId(touchEndEvent.changedTouches, this._activeTouchId);\n        if (touch === null && touchEndEvent.touches.length === 0) {\n            // something went wrong, somehow we missed the required touchend event\n            // probably the browser has not sent this event\n            touch = touchEndEvent.changedTouches[0];\n        }\n        if (touch === null) {\n            return;\n        }\n        this._activeTouchId = null;\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(touchEndEvent);\n        this._clearLongTapTimeout();\n        this._touchMoveStartCoordinate = null;\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        var compatEvent = this._makeCompatEvent(touchEndEvent, touch);\n        this._processEvent(compatEvent, this._handler.touchEndEvent);\n        ++this._tapCount;\n        if (this._tapTimeoutId !== null && this._tapCount > 1) {\n            // check that both clicks are near enough\n            var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._tapCoordinate).manhattanDistance;\n            if (manhattanDistance < ManhattanDistance.DoubleTap && !this._cancelTap) {\n                this._processEvent(compatEvent, this._handler.doubleTapEvent);\n            }\n            this._resetTapTimeout();\n        } else {\n            if (!this._cancelTap) {\n                this._processEvent(compatEvent, this._handler.tapEvent);\n                // do not fire mouse events if tap handler was executed\n                // prevent click event on new dom element (who appeared after tap)\n                if (isValid(this._handler.tapEvent)) {\n                    this._preventDefault(touchEndEvent);\n                }\n            }\n        }\n        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap\n        // we handle mouseDoubleClickEvent here ourselves\n        if (this._tapCount === 0) {\n            this._preventDefault(touchEndEvent);\n        }\n        if (touchEndEvent.touches.length === 0) {\n            if (this._longTapActive) {\n                this._longTapActive = false;\n                // prevent native click event\n                this._preventDefault(touchEndEvent);\n            }\n        }\n    };\n    SyntheticEvent.prototype._mouseUpHandler = function(mouseUpEvent) {\n        if (mouseUpEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var compatEvent = this._makeCompatEvent(mouseUpEvent);\n        this._mouseMoveStartCoordinate = null;\n        this._mousePressed = false;\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        if (isFF()) {\n            var rootElement = this._target.ownerDocument.documentElement;\n            rootElement.removeEventListener(\"mouseleave\", this._onFirefoxOutsideMouseUp);\n        }\n        if (this._firesTouchEvents(mouseUpEvent)) {\n            return;\n        }\n        this._processEvent(compatEvent, this._handler.mouseUpEvent);\n        ++this._clickCount;\n        if (this._clickTimeoutId !== null && this._clickCount > 1) {\n            // check that both clicks are near enough\n            var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(mouseUpEvent), this._clickCoordinate).manhattanDistance;\n            if (manhattanDistance < ManhattanDistance.DoubleClick && !this._cancelClick) {\n                this._processEvent(compatEvent, this._handler.mouseDoubleClickEvent);\n            }\n            this._resetClickTimeout();\n        } else {\n            if (!this._cancelClick) {\n                this._processEvent(compatEvent, this._handler.mouseClickEvent);\n            }\n        }\n    };\n    SyntheticEvent.prototype._clearLongTapTimeout = function() {\n        if (this._longTapTimeoutId === null) {\n            return;\n        }\n        clearTimeout(this._longTapTimeoutId);\n        this._longTapTimeoutId = null;\n    };\n    SyntheticEvent.prototype._touchStartHandler = function(downEvent) {\n        if (this._activeTouchId !== null) {\n            return;\n        }\n        var touch = downEvent.changedTouches[0];\n        this._activeTouchId = touch.identifier;\n        this._lastTouchEventTimeStamp = this._eventTimeStamp(downEvent);\n        var rootElement = this._target.ownerDocument.documentElement;\n        this._cancelTap = false;\n        this._touchMoveExceededManhattanDistance = false;\n        this._preventTouchDragProcess = false;\n        this._touchMoveStartCoordinate = this._getCoordinate(touch);\n        if (this._unsubscribeRootTouchEvents !== null) {\n            this._unsubscribeRootTouchEvents();\n            this._unsubscribeRootTouchEvents = null;\n        }\n        {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundTouchMoveWithDownHandler_1 = this._touchMoveHandler.bind(this);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundTouchEndHandler_1 = this._touchEndHandler.bind(this);\n            this._unsubscribeRootTouchEvents = function() {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener(\"touchmove\", boundTouchMoveWithDownHandler_1);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener(\"touchend\", boundTouchEndHandler_1);\n            };\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener(\"touchmove\", boundTouchMoveWithDownHandler_1, {\n                passive: false\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener(\"touchend\", boundTouchEndHandler_1, {\n                passive: false\n            });\n            this._clearLongTapTimeout();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, downEvent), 500 /* Delay.LongTap */ );\n        }\n        this._processEvent(this._makeCompatEvent(downEvent, touch), this._handler.touchStartEvent);\n        if (this._tapTimeoutId === null) {\n            this._tapCount = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._tapCoordinate = this._getCoordinate(touch);\n        }\n    };\n    SyntheticEvent.prototype._mouseDownHandler = function(downEvent) {\n        if (downEvent.button === MouseEventButton.Right) {\n            this._preventDefault(downEvent);\n            this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseRightClickEvent);\n            return;\n        }\n        if (downEvent.button !== MouseEventButton.Left) {\n            return;\n        }\n        var rootElement = this._target.ownerDocument.documentElement;\n        if (isFF()) {\n            rootElement.addEventListener(\"mouseleave\", this._onFirefoxOutsideMouseUp);\n        }\n        this._cancelClick = false;\n        this._mouseMoveStartCoordinate = this._getCoordinate(downEvent);\n        if (this._unsubscribeRootMouseEvents !== null) {\n            this._unsubscribeRootMouseEvents();\n            this._unsubscribeRootMouseEvents = null;\n        }\n        {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundMouseMoveWithDownHandler_1 = this._mouseMoveWithDownHandler.bind(this);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            var boundMouseUpHandler_1 = this._mouseUpHandler.bind(this);\n            this._unsubscribeRootMouseEvents = function() {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener(\"mousemove\", boundMouseMoveWithDownHandler_1);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                rootElement.removeEventListener(\"mouseup\", boundMouseUpHandler_1);\n            };\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener(\"mousemove\", boundMouseMoveWithDownHandler_1);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            rootElement.addEventListener(\"mouseup\", boundMouseUpHandler_1);\n        }\n        this._mousePressed = true;\n        if (this._firesTouchEvents(downEvent)) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseDownEvent);\n        if (this._clickTimeoutId === null) {\n            this._clickCount = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), 500 /* Delay.ResetClick */ );\n            this._clickCoordinate = this._getCoordinate(downEvent);\n        }\n    };\n    SyntheticEvent.prototype._init = function() {\n        var _this = this;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"mouseenter\", this._mouseEnterHandler.bind(this));\n        // Do not show context menu when something went wrong\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"touchcancel\", this._clearLongTapTimeout.bind(this));\n        {\n            var doc_1 = this._target.ownerDocument;\n            var outsideHandler_1 = function(event) {\n                if (_this._handler.mouseDownOutsideEvent == null) {\n                    return;\n                }\n                if (event.composed && _this._target.contains(event.composedPath()[0])) {\n                    return;\n                }\n                if (event.target !== null && _this._target.contains(event.target)) {\n                    return;\n                }\n                _this._handler.mouseDownOutsideEvent({\n                    x: 0,\n                    y: 0,\n                    pageX: 0,\n                    pageY: 0\n                });\n            };\n            this._unsubscribeOutsideTouchEvents = function() {\n                doc_1.removeEventListener(\"touchstart\", outsideHandler_1);\n            };\n            this._unsubscribeOutsideMouseEvents = function() {\n                doc_1.removeEventListener(\"mousedown\", outsideHandler_1);\n            };\n            doc_1.addEventListener(\"mousedown\", outsideHandler_1);\n            doc_1.addEventListener(\"touchstart\", outsideHandler_1, {\n                passive: true\n            });\n        }\n        if (isIOS()) {\n            this._unsubscribeMobileSafariEvents = function() {\n                _this._target.removeEventListener(\"dblclick\", _this._onMobileSafariDoubleClick);\n            };\n            this._target.addEventListener(\"dblclick\", this._onMobileSafariDoubleClick);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"mouseleave\", this._mouseLeaveHandler.bind(this));\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"touchstart\", this._touchStartHandler.bind(this), {\n            passive: true\n        });\n        this._target.addEventListener(\"mousedown\", function(e) {\n            if (e.button === MouseEventButton.Middle) {\n                // prevent incorrect scrolling event\n                e.preventDefault();\n                return false;\n            }\n            return undefined;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this._target.addEventListener(\"mousedown\", this._mouseDownHandler.bind(this));\n        this._initPinch();\n        // Hey mobile Safari, what's up?\n        // If mobile Safari doesn't have any touchmove handler with passive=false\n        // it treats a touchstart and the following touchmove events as cancelable=false,\n        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).\n        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this._target.addEventListener(\"touchmove\", function() {}, {\n            passive: false\n        });\n    };\n    SyntheticEvent.prototype._initPinch = function() {\n        var _this = this;\n        if (!isValid(this._handler.pinchStartEvent) && !isValid(this._handler.pinchEvent) && !isValid(this._handler.pinchEndEvent)) {\n            return;\n        }\n        this._target.addEventListener(\"touchstart\", function(event) {\n            _this._checkPinchState(event.touches);\n        }, {\n            passive: true\n        });\n        this._target.addEventListener(\"touchmove\", function(event) {\n            if (event.touches.length !== 2 || _this._startPinchMiddleCoordinate === null) {\n                return;\n            }\n            if (isValid(_this._handler.pinchEvent)) {\n                var currentDistance = _this._getTouchDistance(event.touches[0], event.touches[1]);\n                var scale = currentDistance / _this._startPinchDistance;\n                _this._handler.pinchEvent(__assign(__assign({}, _this._startPinchMiddleCoordinate), {\n                    pageX: 0,\n                    pageY: 0\n                }), scale);\n                _this._preventDefault(event);\n            }\n        }, {\n            passive: false\n        });\n        this._target.addEventListener(\"touchend\", function(event) {\n            _this._checkPinchState(event.touches);\n        });\n    };\n    SyntheticEvent.prototype._checkPinchState = function(touches) {\n        if (touches.length === 1) {\n            this._pinchPrevented = false;\n        }\n        if (touches.length !== 2 || this._pinchPrevented || this._longTapActive) {\n            this._stopPinch();\n        } else {\n            this._startPinch(touches);\n        }\n    };\n    SyntheticEvent.prototype._startPinch = function(touches) {\n        var box = this._target.getBoundingClientRect();\n        this._startPinchMiddleCoordinate = {\n            x: (touches[0].clientX - box.left + (touches[1].clientX - box.left)) / 2,\n            y: (touches[0].clientY - box.top + (touches[1].clientY - box.top)) / 2\n        };\n        this._startPinchDistance = this._getTouchDistance(touches[0], touches[1]);\n        if (isValid(this._handler.pinchStartEvent)) {\n            this._handler.pinchStartEvent({\n                x: 0,\n                y: 0,\n                pageX: 0,\n                pageY: 0\n            });\n        }\n        this._clearLongTapTimeout();\n    };\n    SyntheticEvent.prototype._stopPinch = function() {\n        if (this._startPinchMiddleCoordinate === null) {\n            return;\n        }\n        this._startPinchMiddleCoordinate = null;\n        if (isValid(this._handler.pinchEndEvent)) {\n            this._handler.pinchEndEvent({\n                x: 0,\n                y: 0,\n                pageX: 0,\n                pageY: 0\n            });\n        }\n    };\n    SyntheticEvent.prototype._mouseLeaveHandler = function(event) {\n        var _a, _b, _c;\n        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);\n        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);\n        if (this._firesTouchEvents(event)) {\n            return;\n        }\n        if (!this._acceptMouseLeave) {\n            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way\n            // just ignore this event if there was no mouse move or mouse enter events\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(event), this._handler.mouseLeaveEvent);\n        // accept all mouse leave events if it's not an iOS device\n        this._acceptMouseLeave = !isIOS();\n    };\n    SyntheticEvent.prototype._longTapHandler = function(event) {\n        var touch = this._touchWithId(event.touches, this._activeTouchId);\n        if (touch === null) {\n            return;\n        }\n        this._processEvent(this._makeCompatEvent(event, touch), this._handler.longTapEvent);\n        this._cancelTap = true;\n        // long tap is active until touchend event with 0 touches occurred\n        this._longTapActive = true;\n    };\n    SyntheticEvent.prototype._firesTouchEvents = function(e) {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (isValid((_a = e.sourceCapabilities) === null || _a === void 0 ? void 0 : _a.firesTouchEvents)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-expect-error\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n            return e.sourceCapabilities.firesTouchEvents;\n        }\n        return this._eventTimeStamp(e) < this._lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */ ;\n    };\n    SyntheticEvent.prototype._processEvent = function(event, callback) {\n        callback === null || callback === void 0 ? void 0 : callback.call(this._handler, event);\n    };\n    SyntheticEvent.prototype._makeCompatEvent = function(event, touch) {\n        var _this = this;\n        // TouchEvent has no clientX/Y coordinates:\n        // We have to use the last Touch instead\n        var eventLike = touch !== null && touch !== void 0 ? touch : event;\n        var box = this._target.getBoundingClientRect();\n        return {\n            x: eventLike.clientX - box.left,\n            y: eventLike.clientY - box.top,\n            pageX: eventLike.pageX,\n            pageY: eventLike.pageY,\n            isTouch: !event.type.startsWith(\"mouse\") && event.type !== \"contextmenu\" && event.type !== \"click\" && event.type !== \"wheel\",\n            preventDefault: function() {\n                if (event.type !== \"touchstart\") {\n                    // touchstart is passive and cannot be prevented\n                    _this._preventDefault(event);\n                }\n            }\n        };\n    };\n    SyntheticEvent.prototype._getTouchDistance = function(p1, p2) {\n        var xDiff = p1.clientX - p2.clientX;\n        var yDiff = p1.clientY - p2.clientY;\n        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    };\n    SyntheticEvent.prototype._preventDefault = function(event) {\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n    };\n    SyntheticEvent.prototype._getCoordinate = function(eventLike) {\n        return {\n            x: eventLike.pageX,\n            y: eventLike.pageY\n        };\n    };\n    SyntheticEvent.prototype._eventTimeStamp = function(e) {\n        var _a;\n        // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        return (_a = e.timeStamp) !== null && _a !== void 0 ? _a : performance.now();\n    };\n    SyntheticEvent.prototype._touchWithId = function(touches, id) {\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for(var i = 0; i < touches.length; ++i){\n            if (touches[i].identifier === id) {\n                return touches[i];\n            }\n        }\n        return null;\n    };\n    return SyntheticEvent;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var Event = /** @class */ function() {\n    function Event(container, chart) {\n        var _this = this;\n        // 惯性滚动开始时间\n        this._flingStartTime = new Date().getTime();\n        // 惯性滚动定时器\n        this._flingScrollRequestId = null;\n        // 开始滚动时坐标点\n        this._startScrollCoordinate = null;\n        // 开始触摸时坐标\n        this._touchCoordinate = null;\n        // 是否是取消了十字光标\n        this._touchCancelCrosshair = false;\n        // 是否缩放过\n        this._touchZoomed = false;\n        // 用来记录捏合缩放的尺寸\n        this._pinchScale = 1;\n        this._mouseDownWidget = null;\n        this._prevYAxisRange = null;\n        this._xAxisStartScaleCoordinate = null;\n        this._xAxisStartScaleDistance = 0;\n        this._xAxisScale = 1;\n        this._yAxisStartScaleDistance = 0;\n        this._mouseMoveTriggerWidgetInfo = {\n            pane: null,\n            widget: null\n        };\n        this._boundKeyBoardDownEvent = function(event) {\n            if (event.shiftKey) {\n                switch(event.code){\n                    case \"Equal\":\n                        {\n                            _this._chart.getChartStore().zoom(0.5);\n                            break;\n                        }\n                    case \"Minus\":\n                        {\n                            _this._chart.getChartStore().zoom(-0.5);\n                            break;\n                        }\n                    case \"ArrowLeft\":\n                        {\n                            var store = _this._chart.getChartStore();\n                            store.startScroll();\n                            store.scroll(-3 * store.getBarSpace().bar);\n                            break;\n                        }\n                    case \"ArrowRight\":\n                        {\n                            var store = _this._chart.getChartStore();\n                            store.startScroll();\n                            store.scroll(3 * store.getBarSpace().bar);\n                            break;\n                        }\n                }\n            }\n        };\n        this._container = container;\n        this._chart = chart;\n        this._event = new SyntheticEvent(container, this, {\n            treatVertDragAsPageScroll: function() {\n                return false;\n            },\n            treatHorzDragAsPageScroll: function() {\n                return false;\n            }\n        });\n        container.addEventListener(\"keydown\", this._boundKeyBoardDownEvent);\n    }\n    Event.prototype.pinchStartEvent = function() {\n        this._touchZoomed = true;\n        this._pinchScale = 1;\n        return true;\n    };\n    Event.prototype.pinchEvent = function(e, scale) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if ((pane === null || pane === void 0 ? void 0 : pane.getId()) !== PaneIdConstants.X_AXIS && (widget === null || widget === void 0 ? void 0 : widget.getName()) === WidgetNameConstants.MAIN) {\n            var event_1 = this._makeWidgetEvent(e, widget);\n            var zoomScale = (scale - this._pinchScale) * 5;\n            this._pinchScale = scale;\n            this._chart.getChartStore().zoom(zoomScale, {\n                x: event_1.x,\n                y: event_1.y\n            });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype.mouseWheelHortEvent = function(_, distance) {\n        var store = this._chart.getChartStore();\n        store.startScroll();\n        store.scroll(distance);\n        return true;\n    };\n    Event.prototype.mouseWheelVertEvent = function(e, scale) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var event = this._makeWidgetEvent(e, widget);\n        var name = widget === null || widget === void 0 ? void 0 : widget.getName();\n        if (name === WidgetNameConstants.MAIN) {\n            this._chart.getChartStore().zoom(scale, {\n                x: event.x,\n                y: event.y\n            });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype.mouseDownEvent = function(e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        this._mouseDownWidget = widget;\n        if (widget !== null) {\n            var event_2 = this._makeWidgetEvent(e, widget);\n            var name_1 = widget.getName();\n            switch(name_1){\n                case WidgetNameConstants.SEPARATOR:\n                    {\n                        return widget.dispatchEvent(\"mouseDownEvent\", event_2);\n                    }\n                case WidgetNameConstants.MAIN:\n                    {\n                        var yAxis = pane.getAxisComponent();\n                        if (!yAxis.getAutoCalcTickFlag()) {\n                            var range = yAxis.getRange();\n                            this._prevYAxisRange = __assign({}, range);\n                        }\n                        this._startScrollCoordinate = {\n                            x: event_2.x,\n                            y: event_2.y\n                        };\n                        this._chart.getChartStore().startScroll();\n                        return widget.dispatchEvent(\"mouseDownEvent\", event_2);\n                    }\n                case WidgetNameConstants.X_AXIS:\n                    {\n                        return this._processXAxisScrollStartEvent(widget, event_2);\n                    }\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        return this._processYAxisScaleStartEvent(widget, event_2);\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseMoveEvent = function(e) {\n        var _a, _b, _c;\n        var _d = this._findWidgetByEvent(e), pane = _d.pane, widget = _d.widget;\n        var event = this._makeWidgetEvent(e, widget);\n        if (((_a = this._mouseMoveTriggerWidgetInfo.pane) === null || _a === void 0 ? void 0 : _a.getId()) !== (pane === null || pane === void 0 ? void 0 : pane.getId()) || ((_b = this._mouseMoveTriggerWidgetInfo.widget) === null || _b === void 0 ? void 0 : _b.getName()) !== (widget === null || widget === void 0 ? void 0 : widget.getName())) {\n            widget === null || widget === void 0 ? void 0 : widget.dispatchEvent(\"mouseEnterEvent\", event);\n            (_c = this._mouseMoveTriggerWidgetInfo.widget) === null || _c === void 0 ? void 0 : _c.dispatchEvent(\"mouseLeaveEvent\", event);\n            this._mouseMoveTriggerWidgetInfo = {\n                pane: pane,\n                widget: widget\n            };\n        }\n        if (widget !== null) {\n            var name_2 = widget.getName();\n            switch(name_2){\n                case WidgetNameConstants.MAIN:\n                    {\n                        var consumed = widget.dispatchEvent(\"mouseMoveEvent\", event);\n                        var crosshair = {\n                            x: event.x,\n                            y: event.y,\n                            paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n                        };\n                        if (consumed) {\n                            crosshair = undefined;\n                            widget.getContainer().style.cursor = \"pointer\";\n                        } else {\n                            widget.getContainer().style.cursor = \"crosshair\";\n                        }\n                        this._chart.getChartStore().setCrosshair(crosshair);\n                        return consumed;\n                    }\n                case WidgetNameConstants.SEPARATOR:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        var consumed = widget.dispatchEvent(\"mouseMoveEvent\", event);\n                        this._chart.getChartStore().setCrosshair();\n                        return consumed;\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.pressedMouseMoveEvent = function(e) {\n        var _a, _b;\n        if (this._mouseDownWidget !== null && this._mouseDownWidget.getName() === WidgetNameConstants.SEPARATOR) {\n            return this._mouseDownWidget.dispatchEvent(\"pressedMouseMoveEvent\", e);\n        }\n        var _c = this._findWidgetByEvent(e), pane = _c.pane, widget = _c.widget;\n        if (widget !== null && ((_a = this._mouseDownWidget) === null || _a === void 0 ? void 0 : _a.getPane().getId()) === (pane === null || pane === void 0 ? void 0 : pane.getId()) && ((_b = this._mouseDownWidget) === null || _b === void 0 ? void 0 : _b.getName()) === widget.getName()) {\n            var event_3 = this._makeWidgetEvent(e, widget);\n            var name_3 = widget.getName();\n            switch(name_3){\n                case WidgetNameConstants.MAIN:\n                    {\n                        // eslint-disable-next-line @typescript-eslint/init-declarations -- ignore\n                        var crosshair = void 0;\n                        var consumed = widget.dispatchEvent(\"pressedMouseMoveEvent\", event_3);\n                        if (!consumed) {\n                            crosshair = {\n                                x: event_3.x,\n                                y: event_3.y,\n                                paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n                            };\n                            this._processMainScrollingEvent(widget, event_3);\n                        }\n                        this._chart.getChartStore().setCrosshair(crosshair, {\n                            forceInvalidate: true\n                        });\n                        return consumed;\n                    }\n                case WidgetNameConstants.X_AXIS:\n                    {\n                        return this._processXAxisScrollingEvent(widget, event_3);\n                    }\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        return this._processYAxisScalingEvent(widget, event_3);\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseUpEvent = function(e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_4 = this._makeWidgetEvent(e, widget);\n            var name_4 = widget.getName();\n            switch(name_4){\n                case WidgetNameConstants.MAIN:\n                case WidgetNameConstants.SEPARATOR:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        consumed = widget.dispatchEvent(\"mouseUpEvent\", event_4);\n                        break;\n                    }\n            }\n            if (consumed) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n            }\n        }\n        this._mouseDownWidget = null;\n        this._startScrollCoordinate = null;\n        this._prevYAxisRange = null;\n        this._xAxisStartScaleCoordinate = null;\n        this._xAxisStartScaleDistance = 0;\n        this._xAxisScale = 1;\n        this._yAxisStartScaleDistance = 0;\n        return consumed;\n    };\n    Event.prototype.mouseClickEvent = function(e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        if (widget !== null) {\n            var event_5 = this._makeWidgetEvent(e, widget);\n            return widget.dispatchEvent(\"mouseClickEvent\", event_5);\n        }\n        return false;\n    };\n    Event.prototype.mouseRightClickEvent = function(e) {\n        var widget = this._findWidgetByEvent(e).widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_6 = this._makeWidgetEvent(e, widget);\n            var name_5 = widget.getName();\n            switch(name_5){\n                case WidgetNameConstants.MAIN:\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        consumed = widget.dispatchEvent(\"mouseRightClickEvent\", event_6);\n                        break;\n                    }\n            }\n            if (consumed) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseDoubleClickEvent = function(e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if (widget !== null) {\n            var name_6 = widget.getName();\n            switch(name_6){\n                case WidgetNameConstants.MAIN:\n                    {\n                        var event_7 = this._makeWidgetEvent(e, widget);\n                        return widget.dispatchEvent(\"mouseDoubleClickEvent\", event_7);\n                    }\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        var yAxis = pane.getAxisComponent();\n                        if (!yAxis.getAutoCalcTickFlag()) {\n                            yAxis.setAutoCalcTickFlag(true);\n                            this._chart.layout({\n                                measureWidth: true,\n                                update: true,\n                                buildYAxisTick: true\n                            });\n                            return true;\n                        }\n                        break;\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.mouseLeaveEvent = function() {\n        this._chart.getChartStore().setCrosshair();\n        return true;\n    };\n    Event.prototype.touchStartEvent = function(e) {\n        var _a;\n        var _b = this._findWidgetByEvent(e), pane = _b.pane, widget = _b.widget;\n        if (widget !== null) {\n            var event_8 = this._makeWidgetEvent(e, widget);\n            (_a = event_8.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_8);\n            var name_7 = widget.getName();\n            switch(name_7){\n                case WidgetNameConstants.MAIN:\n                    {\n                        var chartStore = this._chart.getChartStore();\n                        if (widget.dispatchEvent(\"mouseDownEvent\", event_8)) {\n                            this._touchCancelCrosshair = true;\n                            this._touchCoordinate = null;\n                            chartStore.setCrosshair(undefined, {\n                                notInvalidate: true\n                            });\n                            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n                            return true;\n                        }\n                        if (this._flingScrollRequestId !== null) {\n                            cancelAnimationFrame(this._flingScrollRequestId);\n                            this._flingScrollRequestId = null;\n                        }\n                        this._flingStartTime = new Date().getTime();\n                        var yAxis = pane.getAxisComponent();\n                        if (!yAxis.getAutoCalcTickFlag()) {\n                            var range = yAxis.getRange();\n                            this._prevYAxisRange = __assign({}, range);\n                        }\n                        this._startScrollCoordinate = {\n                            x: event_8.x,\n                            y: event_8.y\n                        };\n                        chartStore.startScroll();\n                        this._touchZoomed = false;\n                        if (this._touchCoordinate !== null) {\n                            var xDif = event_8.x - this._touchCoordinate.x;\n                            var yDif = event_8.y - this._touchCoordinate.y;\n                            var radius = Math.sqrt(xDif * xDif + yDif * yDif);\n                            if (radius < TOUCH_MIN_RADIUS) {\n                                this._touchCoordinate = {\n                                    x: event_8.x,\n                                    y: event_8.y\n                                };\n                                chartStore.setCrosshair({\n                                    x: event_8.x,\n                                    y: event_8.y,\n                                    paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n                                });\n                            } else {\n                                this._touchCoordinate = null;\n                                this._touchCancelCrosshair = true;\n                                chartStore.setCrosshair();\n                            }\n                        }\n                        return true;\n                    }\n                case WidgetNameConstants.X_AXIS:\n                    {\n                        return this._processXAxisScrollStartEvent(widget, event_8);\n                    }\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        return this._processYAxisScaleStartEvent(widget, event_8);\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.touchMoveEvent = function(e) {\n        var _a;\n        var _b = this._findWidgetByEvent(e), pane = _b.pane, widget = _b.widget;\n        if (widget !== null) {\n            var event_9 = this._makeWidgetEvent(e, widget);\n            (_a = event_9.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_9);\n            var name_8 = widget.getName();\n            var chartStore = this._chart.getChartStore();\n            switch(name_8){\n                case WidgetNameConstants.MAIN:\n                    {\n                        if (widget.dispatchEvent(\"pressedMouseMoveEvent\", event_9)) {\n                            chartStore.setCrosshair(undefined, {\n                                notInvalidate: true\n                            });\n                            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n                            return true;\n                        }\n                        if (this._touchCoordinate !== null) {\n                            chartStore.setCrosshair({\n                                x: event_9.x,\n                                y: event_9.y,\n                                paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n                            });\n                        } else {\n                            this._processMainScrollingEvent(widget, event_9);\n                        }\n                        return true;\n                    }\n                case WidgetNameConstants.X_AXIS:\n                    {\n                        return this._processXAxisScrollingEvent(widget, event_9);\n                    }\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        return this._processYAxisScalingEvent(widget, event_9);\n                    }\n            }\n        }\n        return false;\n    };\n    Event.prototype.touchEndEvent = function(e) {\n        var _this = this;\n        var widget = this._findWidgetByEvent(e).widget;\n        if (widget !== null) {\n            var event_10 = this._makeWidgetEvent(e, widget);\n            var name_9 = widget.getName();\n            switch(name_9){\n                case WidgetNameConstants.MAIN:\n                    {\n                        widget.dispatchEvent(\"mouseUpEvent\", event_10);\n                        if (this._startScrollCoordinate !== null) {\n                            var time = new Date().getTime() - this._flingStartTime;\n                            var distance = event_10.x - this._startScrollCoordinate.x;\n                            var v_1 = distance / (time > 0 ? time : 1) * 20;\n                            if (time < 200 && Math.abs(v_1) > 0) {\n                                var store_1 = this._chart.getChartStore();\n                                var flingScroll_1 = function() {\n                                    _this._flingScrollRequestId = requestAnimationFrame(function() {\n                                        store_1.startScroll();\n                                        store_1.scroll(v_1);\n                                        v_1 = v_1 * (1 - 0.025);\n                                        if (Math.abs(v_1) < 1) {\n                                            if (_this._flingScrollRequestId !== null) {\n                                                cancelAnimationFrame(_this._flingScrollRequestId);\n                                                _this._flingScrollRequestId = null;\n                                            }\n                                        } else {\n                                            flingScroll_1();\n                                        }\n                                    });\n                                };\n                                flingScroll_1();\n                            }\n                        }\n                        return true;\n                    }\n                case WidgetNameConstants.X_AXIS:\n                case WidgetNameConstants.Y_AXIS:\n                    {\n                        var consumed = widget.dispatchEvent(\"mouseUpEvent\", event_10);\n                        if (consumed) {\n                            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n                        }\n                    }\n            }\n            this._startScrollCoordinate = null;\n            this._prevYAxisRange = null;\n            this._xAxisStartScaleCoordinate = null;\n            this._xAxisStartScaleDistance = 0;\n            this._xAxisScale = 1;\n            this._yAxisStartScaleDistance = 0;\n        }\n        return false;\n    };\n    Event.prototype.tapEvent = function(e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        var consumed = false;\n        if (widget !== null) {\n            var event_11 = this._makeWidgetEvent(e, widget);\n            var result = widget.dispatchEvent(\"mouseClickEvent\", event_11);\n            if (widget.getName() === WidgetNameConstants.MAIN) {\n                var event_12 = this._makeWidgetEvent(e, widget);\n                var chartStore = this._chart.getChartStore();\n                if (result) {\n                    this._touchCancelCrosshair = true;\n                    this._touchCoordinate = null;\n                    chartStore.setCrosshair(undefined, {\n                        notInvalidate: true\n                    });\n                    consumed = true;\n                } else {\n                    if (!this._touchCancelCrosshair && !this._touchZoomed) {\n                        this._touchCoordinate = {\n                            x: event_12.x,\n                            y: event_12.y\n                        };\n                        chartStore.setCrosshair({\n                            x: event_12.x,\n                            y: event_12.y,\n                            paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n                        }, {\n                            notInvalidate: true\n                        });\n                        consumed = true;\n                    }\n                    this._touchCancelCrosshair = false;\n                }\n            }\n            if (consumed || result) {\n                this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n            }\n        }\n        return consumed;\n    };\n    Event.prototype.doubleTapEvent = function(e) {\n        return this.mouseDoubleClickEvent(e);\n    };\n    Event.prototype.longTapEvent = function(e) {\n        var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;\n        if (widget !== null && widget.getName() === WidgetNameConstants.MAIN) {\n            var event_13 = this._makeWidgetEvent(e, widget);\n            this._touchCoordinate = {\n                x: event_13.x,\n                y: event_13.y\n            };\n            this._chart.getChartStore().setCrosshair({\n                x: event_13.x,\n                y: event_13.y,\n                paneId: pane === null || pane === void 0 ? void 0 : pane.getId()\n            });\n            return true;\n        }\n        return false;\n    };\n    Event.prototype._processMainScrollingEvent = function(widget, event) {\n        if (this._startScrollCoordinate !== null) {\n            var yAxis = widget.getPane().getAxisComponent();\n            if (this._prevYAxisRange !== null && !yAxis.getAutoCalcTickFlag() && yAxis.scrollZoomEnabled) {\n                var _a = this._prevYAxisRange, from = _a.from, to = _a.to, range = _a.range;\n                var distance_1 = 0;\n                if (yAxis.reverse) {\n                    distance_1 = this._startScrollCoordinate.y - event.y;\n                } else {\n                    distance_1 = event.y - this._startScrollCoordinate.y;\n                }\n                var bounding = widget.getBounding();\n                var scale = distance_1 / bounding.height;\n                var difRange = range * scale;\n                var newFrom = from + difRange;\n                var newTo = to + difRange;\n                var newRealFrom = yAxis.valueToRealValue(newFrom, {\n                    range: this._prevYAxisRange\n                });\n                var newRealTo = yAxis.valueToRealValue(newTo, {\n                    range: this._prevYAxisRange\n                });\n                var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, {\n                    range: this._prevYAxisRange\n                });\n                var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, {\n                    range: this._prevYAxisRange\n                });\n                yAxis.setRange({\n                    from: newFrom,\n                    to: newTo,\n                    range: newTo - newFrom,\n                    realFrom: newRealFrom,\n                    realTo: newRealTo,\n                    realRange: newRealTo - newRealFrom,\n                    displayFrom: newDisplayFrom,\n                    displayTo: newDisplayTo,\n                    displayRange: newDisplayTo - newDisplayFrom\n                });\n            }\n            var distance = event.x - this._startScrollCoordinate.x;\n            this._chart.getChartStore().scroll(distance);\n        }\n    };\n    Event.prototype._processXAxisScrollStartEvent = function(widget, event) {\n        var consumed = widget.dispatchEvent(\"mouseDownEvent\", event);\n        if (consumed) {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n        }\n        this._xAxisStartScaleCoordinate = {\n            x: event.x,\n            y: event.y\n        };\n        this._xAxisStartScaleDistance = event.pageX;\n        return consumed;\n    };\n    Event.prototype._processXAxisScrollingEvent = function(widget, event) {\n        var _a;\n        var consumed = widget.dispatchEvent(\"pressedMouseMoveEvent\", event);\n        if (!consumed) {\n            var xAxis = widget.getPane().getAxisComponent();\n            if (xAxis.scrollZoomEnabled && this._xAxisStartScaleDistance !== 0) {\n                var scale = this._xAxisStartScaleDistance / event.pageX;\n                if (Number.isFinite(scale)) {\n                    var zoomScale = (scale - this._xAxisScale) * 10;\n                    this._xAxisScale = scale;\n                    this._chart.getChartStore().zoom(zoomScale, (_a = this._xAxisStartScaleCoordinate) !== null && _a !== void 0 ? _a : undefined);\n                }\n            }\n        } else {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n        }\n        return consumed;\n    };\n    Event.prototype._processYAxisScaleStartEvent = function(widget, event) {\n        var consumed = widget.dispatchEvent(\"mouseDownEvent\", event);\n        if (consumed) {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n        }\n        var range = widget.getPane().getAxisComponent().getRange();\n        this._prevYAxisRange = __assign({}, range);\n        this._yAxisStartScaleDistance = event.pageY;\n        return consumed;\n    };\n    Event.prototype._processYAxisScalingEvent = function(widget, event) {\n        var consumed = widget.dispatchEvent(\"pressedMouseMoveEvent\", event);\n        if (!consumed) {\n            var yAxis = widget.getPane().getAxisComponent();\n            if (this._prevYAxisRange !== null && yAxis.scrollZoomEnabled && this._yAxisStartScaleDistance !== 0) {\n                var _a = this._prevYAxisRange, from = _a.from, to = _a.to, range = _a.range;\n                var scale = event.pageY / this._yAxisStartScaleDistance;\n                var newRange = range * scale;\n                var difRange = (newRange - range) / 2;\n                var newFrom = from - difRange;\n                var newTo = to + difRange;\n                var newRealFrom = yAxis.valueToRealValue(newFrom, {\n                    range: this._prevYAxisRange\n                });\n                var newRealTo = yAxis.valueToRealValue(newTo, {\n                    range: this._prevYAxisRange\n                });\n                var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, {\n                    range: this._prevYAxisRange\n                });\n                var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, {\n                    range: this._prevYAxisRange\n                });\n                yAxis.setRange({\n                    from: newFrom,\n                    to: newTo,\n                    range: newRange,\n                    realFrom: newRealFrom,\n                    realTo: newRealTo,\n                    realRange: newRealTo - newRealFrom,\n                    displayFrom: newDisplayFrom,\n                    displayTo: newDisplayTo,\n                    displayRange: newDisplayTo - newDisplayFrom\n                });\n                this._chart.layout({\n                    measureWidth: true,\n                    update: true,\n                    buildYAxisTick: true\n                });\n            }\n        } else {\n            this._chart.updatePane(1 /* UpdateLevel.Overlay */ );\n        }\n        return consumed;\n    };\n    Event.prototype._findWidgetByEvent = function(event) {\n        var e_1, _a, e_2, _b;\n        var x = event.x, y = event.y;\n        var separatorPanes = this._chart.getSeparatorPanes();\n        var separatorSize = this._chart.getStyles().separator.size;\n        try {\n            for(var separatorPanes_1 = __values(separatorPanes), separatorPanes_1_1 = separatorPanes_1.next(); !separatorPanes_1_1.done; separatorPanes_1_1 = separatorPanes_1.next()){\n                var _c = __read(separatorPanes_1_1.value, 2), pane_1 = _c[1];\n                var bounding = pane_1.getBounding();\n                var top_1 = bounding.top - Math.round((REAL_SEPARATOR_HEIGHT - separatorSize) / 2);\n                if (x >= bounding.left && x <= bounding.left + bounding.width && y >= top_1 && y <= top_1 + REAL_SEPARATOR_HEIGHT) {\n                    return {\n                        pane: pane_1,\n                        widget: pane_1.getWidget()\n                    };\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (separatorPanes_1_1 && !separatorPanes_1_1.done && (_a = separatorPanes_1.return)) _a.call(separatorPanes_1);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        var drawPanes = this._chart.getDrawPanes();\n        var pane = null;\n        try {\n            for(var drawPanes_1 = __values(drawPanes), drawPanes_1_1 = drawPanes_1.next(); !drawPanes_1_1.done; drawPanes_1_1 = drawPanes_1.next()){\n                var p = drawPanes_1_1.value;\n                var bounding = p.getBounding();\n                if (x >= bounding.left && x <= bounding.left + bounding.width && y >= bounding.top && y <= bounding.top + bounding.height) {\n                    pane = p;\n                    break;\n                }\n            }\n        } catch (e_2_1) {\n            e_2 = {\n                error: e_2_1\n            };\n        } finally{\n            try {\n                if (drawPanes_1_1 && !drawPanes_1_1.done && (_b = drawPanes_1.return)) _b.call(drawPanes_1);\n            } finally{\n                if (e_2) throw e_2.error;\n            }\n        }\n        var widget = null;\n        if (pane !== null) {\n            if (!isValid(widget)) {\n                var mainWidget = pane.getMainWidget();\n                var mainBounding = mainWidget.getBounding();\n                if (x >= mainBounding.left && x <= mainBounding.left + mainBounding.width && y >= mainBounding.top && y <= mainBounding.top + mainBounding.height) {\n                    widget = mainWidget;\n                }\n            }\n            if (!isValid(widget)) {\n                var yAxisWidget = pane.getYAxisWidget();\n                if (yAxisWidget !== null) {\n                    var yAxisBounding = yAxisWidget.getBounding();\n                    if (x >= yAxisBounding.left && x <= yAxisBounding.left + yAxisBounding.width && y >= yAxisBounding.top && y <= yAxisBounding.top + yAxisBounding.height) {\n                        widget = yAxisWidget;\n                    }\n                }\n            }\n        }\n        return {\n            pane: pane,\n            widget: widget\n        };\n    };\n    Event.prototype._makeWidgetEvent = function(event, widget) {\n        var _a, _b, _c;\n        var bounding = (_a = widget === null || widget === void 0 ? void 0 : widget.getBounding()) !== null && _a !== void 0 ? _a : null;\n        return __assign(__assign({}, event), {\n            x: event.x - ((_b = bounding === null || bounding === void 0 ? void 0 : bounding.left) !== null && _b !== void 0 ? _b : 0),\n            y: event.y - ((_c = bounding === null || bounding === void 0 ? void 0 : bounding.top) !== null && _c !== void 0 ? _c : 0)\n        });\n    };\n    Event.prototype.destroy = function() {\n        this._container.removeEventListener(\"keydown\", this._boundKeyBoardDownEvent);\n        this._event.destroy();\n    };\n    return Event;\n}();\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var DomPosition;\n(function(DomPosition) {\n    DomPosition[\"Root\"] = \"root\";\n    DomPosition[\"Main\"] = \"main\";\n    DomPosition[\"YAxis\"] = \"yAxis\";\n})(DomPosition || (DomPosition = {}));\nvar ChartImp = /** @class */ function() {\n    function ChartImp(container, options) {\n        this._chartBounding = createDefaultBounding();\n        this._drawPanes = [];\n        this._separatorPanes = new Map();\n        this._layoutOptions = {\n            sort: true,\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: false,\n            forceBuildYAxisTick: false\n        };\n        this._layoutPending = false;\n        this._initContainer(container);\n        this._chartEvent = new Event(this._chartContainer, this);\n        this._chartStore = new StoreImp(this, options);\n        this._initPanes(options);\n        this._layout();\n    }\n    ChartImp.prototype._initContainer = function(container) {\n        this._container = container;\n        this._chartContainer = createDom(\"div\", {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            outline: \"none\",\n            borderStyle: \"none\",\n            cursor: \"crosshair\",\n            boxSizing: \"border-box\",\n            userSelect: \"none\",\n            webkitUserSelect: \"none\",\n            overflow: \"hidden\",\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n            // @ts-expect-error\n            msUserSelect: \"none\",\n            MozUserSelect: \"none\",\n            webkitTapHighlightColor: \"transparent\"\n        });\n        this._chartContainer.tabIndex = 1;\n        container.appendChild(this._chartContainer);\n        this._cacheChartBounding();\n    };\n    ChartImp.prototype._cacheChartBounding = function() {\n        this._chartBounding.width = Math.floor(this._chartContainer.clientWidth);\n        this._chartBounding.height = Math.floor(this._chartContainer.clientHeight);\n    };\n    ChartImp.prototype._initPanes = function(options) {\n        var _this = this;\n        var _a;\n        var layout = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : [\n            {\n                type: \"candle\" /* LayoutChildType.Candle */ \n            }\n        ];\n        var createCandlePane = function(child) {\n            var _a, _b;\n            if (!isValid(_this._candlePane)) {\n                var paneOptions_1 = (_a = child.options) !== null && _a !== void 0 ? _a : {};\n                merge(paneOptions_1, {\n                    id: PaneIdConstants.CANDLE\n                });\n                _this._candlePane = _this._createPane(CandlePane, PaneIdConstants.CANDLE, paneOptions_1);\n                var content = (_b = child.content) !== null && _b !== void 0 ? _b : [];\n                content.forEach(function(v) {\n                    _this.createIndicator(v, true, paneOptions_1);\n                });\n            }\n        };\n        var createXAxisPane = function(ops) {\n            if (!isValid(_this._xAxisPane)) {\n                var pane = _this._createPane(XAxisPane, PaneIdConstants.X_AXIS, ops !== null && ops !== void 0 ? ops : {});\n                _this._xAxisPane = pane;\n            }\n        };\n        layout.forEach(function(child) {\n            var _a, _b, _c;\n            switch(child.type){\n                case \"candle\" /* LayoutChildType.Candle */ :\n                    {\n                        createCandlePane(child);\n                        break;\n                    }\n                case \"indicator\" /* LayoutChildType.Indicator */ :\n                    {\n                        var content = (_a = child.content) !== null && _a !== void 0 ? _a : [];\n                        if (content.length > 0) {\n                            var paneId = (_c = (_b = child.options) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : null;\n                            if (isValid(paneId)) {\n                                paneId = createId(PaneIdConstants.INDICATOR);\n                            }\n                            var paneOptions_2 = __assign(__assign({}, child.options), {\n                                id: paneId\n                            });\n                            content.forEach(function(v) {\n                                _this.createIndicator(v, true, paneOptions_2);\n                            });\n                        }\n                        break;\n                    }\n                case \"xAxis\" /* LayoutChildType.XAxis */ :\n                    {\n                        createXAxisPane(child.options);\n                        break;\n                    }\n            }\n        });\n        createCandlePane({});\n        createXAxisPane({\n            order: Number.MAX_SAFE_INTEGER\n        });\n    };\n    ChartImp.prototype._createPane = function(DrawPaneClass, id, options) {\n        var pane = new DrawPaneClass(this, id, options !== null && options !== void 0 ? options : {});\n        this._drawPanes.push(pane);\n        return pane;\n    };\n    ChartImp.prototype._recalculatePaneHeight = function(currentPane, currentHeight, changeHeight) {\n        if (changeHeight === 0) {\n            return false;\n        }\n        var normalStatePanes = this._drawPanes.filter(function(pane) {\n            var paneId = pane.getId();\n            return pane.getOptions().state === \"normal\" /* PaneState.Normal */  && paneId !== currentPane.getId() && paneId !== PaneIdConstants.X_AXIS;\n        });\n        var count = normalStatePanes.length;\n        if (count === 0) {\n            return false;\n        }\n        if (currentPane.getId() !== PaneIdConstants.CANDLE && isValid(this._candlePane) && this._candlePane.getOptions().state === \"normal\" /* PaneState.Normal */ ) {\n            var height = this._candlePane.getBounding().height;\n            if (height > 0) {\n                var minHeight = this._candlePane.getOptions().minHeight;\n                var newHeight = height + changeHeight;\n                if (newHeight < minHeight) {\n                    newHeight = minHeight;\n                    currentHeight -= height + changeHeight - newHeight;\n                }\n                this._candlePane.setBounding({\n                    height: newHeight\n                });\n            }\n        } else {\n            var remainingHeight_1 = changeHeight;\n            var normalStatePaneChangeHeight_1 = Math.floor(changeHeight / count);\n            normalStatePanes.forEach(function(pane, index) {\n                var height = pane.getBounding().height;\n                var newHeight = 0;\n                if (index === count - 1) {\n                    newHeight = height + remainingHeight_1;\n                } else {\n                    newHeight = height + normalStatePaneChangeHeight_1;\n                }\n                if (newHeight < pane.getOptions().minHeight) {\n                    newHeight = pane.getOptions().minHeight;\n                }\n                pane.setBounding({\n                    height: newHeight\n                });\n                remainingHeight_1 -= newHeight - height;\n            });\n            if (Math.abs(remainingHeight_1) > 0) {\n                currentHeight -= remainingHeight_1;\n            }\n        }\n        currentPane.setBounding({\n            height: currentHeight\n        });\n        return true;\n    };\n    ChartImp.prototype.getDrawPaneById = function(paneId) {\n        if (paneId === PaneIdConstants.CANDLE) {\n            return this._candlePane;\n        }\n        if (paneId === PaneIdConstants.X_AXIS) {\n            return this._xAxisPane;\n        }\n        var pane = this._drawPanes.find(function(p) {\n            return p.getId() === paneId;\n        });\n        return pane !== null && pane !== void 0 ? pane : null;\n    };\n    ChartImp.prototype.getContainer = function() {\n        return this._container;\n    };\n    ChartImp.prototype.getChartStore = function() {\n        return this._chartStore;\n    };\n    ChartImp.prototype.getXAxisPane = function() {\n        return this._xAxisPane;\n    };\n    ChartImp.prototype.getDrawPanes = function() {\n        return this._drawPanes;\n    };\n    ChartImp.prototype.getSeparatorPanes = function() {\n        return this._separatorPanes;\n    };\n    ChartImp.prototype.layout = function(options) {\n        var _this = this;\n        var _a, _b, _c, _d, _e, _f;\n        if ((_a = options.sort) !== null && _a !== void 0 ? _a : false) {\n            this._layoutOptions.sort = options.sort;\n        }\n        if ((_b = options.measureHeight) !== null && _b !== void 0 ? _b : false) {\n            this._layoutOptions.measureHeight = options.measureHeight;\n        }\n        if ((_c = options.measureWidth) !== null && _c !== void 0 ? _c : false) {\n            this._layoutOptions.measureWidth = options.measureWidth;\n        }\n        if ((_d = options.update) !== null && _d !== void 0 ? _d : false) {\n            this._layoutOptions.update = options.update;\n        }\n        if ((_e = options.buildYAxisTick) !== null && _e !== void 0 ? _e : false) {\n            this._layoutOptions.buildYAxisTick = options.buildYAxisTick;\n        }\n        if ((_f = options.buildYAxisTick) !== null && _f !== void 0 ? _f : false) {\n            this._layoutOptions.forceBuildYAxisTick = options.forceBuildYAxisTick;\n        }\n        if (!this._layoutPending) {\n            this._layoutPending = true;\n            Promise.resolve().then(function(_) {\n                _this._layout();\n                _this._layoutPending = false;\n            }).catch(function(_) {\n            // todo\n            });\n        }\n    };\n    ChartImp.prototype._layout = function() {\n        var _this = this;\n        var _a = this._layoutOptions, sort = _a.sort, measureHeight = _a.measureHeight, measureWidth = _a.measureWidth, update = _a.update, buildYAxisTick = _a.buildYAxisTick, forceBuildYAxisTick = _a.forceBuildYAxisTick;\n        if (sort) {\n            while(isValid(this._chartContainer.firstChild)){\n                this._chartContainer.removeChild(this._chartContainer.firstChild);\n            }\n            this._separatorPanes.clear();\n            this._drawPanes.sort(function(a, b) {\n                return a.getOptions().order - b.getOptions().order;\n            });\n            var prevPane_1 = null;\n            this._drawPanes.forEach(function(pane) {\n                if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                    if (isValid(prevPane_1)) {\n                        var separatorPane = new SeparatorPane(_this, \"\", prevPane_1, pane);\n                        _this._chartContainer.appendChild(separatorPane.getContainer());\n                        _this._separatorPanes.set(pane, separatorPane);\n                    }\n                    prevPane_1 = pane;\n                }\n                _this._chartContainer.appendChild(pane.getContainer());\n            });\n        }\n        if (measureHeight) {\n            var totalHeight = this._chartBounding.height;\n            var separatorSize_1 = this.getStyles().separator.size;\n            var xAxisHeight = this._xAxisPane.getAxisComponent().getAutoSize();\n            var remainingHeight_2 = totalHeight - xAxisHeight;\n            if (remainingHeight_2 < 0) {\n                remainingHeight_2 = 0;\n            }\n            this._drawPanes.forEach(function(pane) {\n                var paneId = pane.getId();\n                if (isValid(_this._separatorPanes.get(pane))) {\n                    remainingHeight_2 -= separatorSize_1;\n                }\n                if (paneId !== PaneIdConstants.X_AXIS && paneId !== PaneIdConstants.CANDLE && pane.getVisible()) {\n                    var paneHeight = pane.getBounding().height;\n                    if (paneHeight > remainingHeight_2) {\n                        paneHeight = remainingHeight_2;\n                        remainingHeight_2 = 0;\n                    } else {\n                        remainingHeight_2 -= paneHeight;\n                    }\n                    pane.setBounding({\n                        height: paneHeight\n                    });\n                }\n            });\n            this._candlePane.setBounding({\n                height: Math.max(remainingHeight_2, 0)\n            });\n            this._xAxisPane.setBounding({\n                height: xAxisHeight\n            });\n            var top_1 = 0;\n            this._drawPanes.forEach(function(pane) {\n                var separatorPane = _this._separatorPanes.get(pane);\n                if (isValid(separatorPane)) {\n                    separatorPane.setBounding({\n                        height: separatorSize_1,\n                        top: top_1\n                    });\n                    top_1 += separatorSize_1;\n                }\n                pane.setBounding({\n                    top: top_1\n                });\n                top_1 += pane.getBounding().height;\n            });\n        }\n        var forceMeasureWidth = measureWidth;\n        if (buildYAxisTick || forceBuildYAxisTick) {\n            this._drawPanes.forEach(function(pane) {\n                var success = pane.getAxisComponent().buildTicks(forceBuildYAxisTick);\n                forceMeasureWidth || (forceMeasureWidth = success);\n            });\n        }\n        if (forceMeasureWidth) {\n            var totalWidth = this._chartBounding.width;\n            var styles = this.getStyles();\n            var leftYAxisWidth_1 = 0;\n            var leftYAxisOutside_1 = true;\n            var rightYAxisWidth_1 = 0;\n            var rightYAxisOutside_1 = true;\n            this._drawPanes.forEach(function(pane) {\n                if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                    var yAxis = pane.getAxisComponent();\n                    var inside = yAxis.inside;\n                    var yAxisWidth = yAxis.getAutoSize();\n                    if (yAxis.position === AxisPosition.Left) {\n                        leftYAxisWidth_1 = Math.max(leftYAxisWidth_1, yAxisWidth);\n                        if (inside) {\n                            leftYAxisOutside_1 = false;\n                        }\n                    } else {\n                        rightYAxisWidth_1 = Math.max(rightYAxisWidth_1, yAxisWidth);\n                        if (inside) {\n                            rightYAxisOutside_1 = false;\n                        }\n                    }\n                }\n            });\n            var mainWidth = totalWidth;\n            var mainLeft = 0;\n            var mainRight = 0;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (leftYAxisOutside_1) {\n                mainWidth -= leftYAxisWidth_1;\n                mainLeft = leftYAxisWidth_1;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- ignore\n            if (rightYAxisOutside_1) {\n                mainWidth -= rightYAxisWidth_1;\n                mainRight = rightYAxisWidth_1;\n            }\n            this._chartStore.setTotalBarSpace(mainWidth);\n            var paneBounding_1 = {\n                width: totalWidth\n            };\n            var mainBounding_1 = {\n                width: mainWidth,\n                left: mainLeft,\n                right: mainRight\n            };\n            var leftYAxisBounding_1 = {\n                width: leftYAxisWidth_1\n            };\n            var rightYAxisBounding_1 = {\n                width: rightYAxisWidth_1\n            };\n            var separatorFill = styles.separator.fill;\n            var separatorBounding_1 = {};\n            if (!separatorFill) {\n                separatorBounding_1 = mainBounding_1;\n            } else {\n                separatorBounding_1 = paneBounding_1;\n            }\n            this._drawPanes.forEach(function(pane) {\n                var _a;\n                (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setBounding(separatorBounding_1);\n                pane.setBounding(paneBounding_1, mainBounding_1, leftYAxisBounding_1, rightYAxisBounding_1);\n            });\n        }\n        if (update) {\n            this._xAxisPane.getAxisComponent().buildTicks(true);\n            this.updatePane(4 /* UpdateLevel.All */ );\n        }\n        this._layoutOptions = {\n            sort: false,\n            measureHeight: false,\n            measureWidth: false,\n            update: false,\n            buildYAxisTick: false,\n            forceBuildYAxisTick: false\n        };\n    };\n    ChartImp.prototype.updatePane = function(level, paneId) {\n        var _this = this;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            pane === null || pane === void 0 ? void 0 : pane.update(level);\n        } else {\n            this._drawPanes.forEach(function(pane) {\n                var _a;\n                pane.update(level);\n                (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.update(level);\n            });\n        }\n    };\n    ChartImp.prototype.crosshairChange = function(crosshair) {\n        var _this = this;\n        if (this._chartStore.hasAction(ActionType.OnCrosshairChange)) {\n            var indicatorData_1 = {};\n            this._drawPanes.forEach(function(pane) {\n                var id = pane.getId();\n                var paneIndicatorData = {};\n                var indicators = _this._chartStore.getIndicatorsByPaneId(id);\n                indicators.forEach(function(indicator) {\n                    var _a;\n                    var result = indicator.result;\n                    paneIndicatorData[indicator.name] = result[(_a = crosshair.dataIndex) !== null && _a !== void 0 ? _a : result.length - 1];\n                });\n                indicatorData_1[id] = paneIndicatorData;\n            });\n            if (isString(crosshair.paneId)) {\n                this._chartStore.executeAction(ActionType.OnCrosshairChange, __assign(__assign({}, crosshair), {\n                    indicatorData: indicatorData_1\n                }));\n            }\n        }\n    };\n    ChartImp.prototype.getDom = function(paneId, position) {\n        var _a, _b;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            if (isValid(pane)) {\n                var pos = position !== null && position !== void 0 ? position : DomPosition.Root;\n                switch(pos){\n                    case DomPosition.Root:\n                        {\n                            return pane.getContainer();\n                        }\n                    case DomPosition.Main:\n                        {\n                            return pane.getMainWidget().getContainer();\n                        }\n                    case DomPosition.YAxis:\n                        {\n                            return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getContainer()) !== null && _b !== void 0 ? _b : null;\n                        }\n                }\n            }\n        } else {\n            return this._chartContainer;\n        }\n        return null;\n    };\n    ChartImp.prototype.getSize = function(paneId, position) {\n        var _a, _b;\n        if (isValid(paneId)) {\n            var pane = this.getDrawPaneById(paneId);\n            if (isValid(pane)) {\n                var pos = position !== null && position !== void 0 ? position : DomPosition.Root;\n                switch(pos){\n                    case DomPosition.Root:\n                        {\n                            return pane.getBounding();\n                        }\n                    case DomPosition.Main:\n                        {\n                            return pane.getMainWidget().getBounding();\n                        }\n                    case DomPosition.YAxis:\n                        {\n                            return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding()) !== null && _b !== void 0 ? _b : null;\n                        }\n                }\n            }\n        } else {\n            return this._chartBounding;\n        }\n        return null;\n    };\n    ChartImp.prototype.setPrecision = function(precision) {\n        this._chartStore.setPrecision(precision);\n    };\n    ChartImp.prototype.getPrecision = function() {\n        return this._chartStore.getPrecision();\n    };\n    ChartImp.prototype.setStyles = function(value) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setStyles(value);\n        });\n    };\n    ChartImp.prototype.getStyles = function() {\n        return this._chartStore.getStyles();\n    };\n    ChartImp.prototype.setCustomApi = function(api) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setCustomApi(api);\n        });\n    };\n    ChartImp.prototype.getCustomApi = function() {\n        return this._chartStore.getCustomApi();\n    };\n    ChartImp.prototype.setLocale = function(locale) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setLocale(locale);\n        });\n    };\n    ChartImp.prototype.getLocale = function() {\n        return this._chartStore.getLocale();\n    };\n    ChartImp.prototype.setTimezone = function(timezone) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setTimezone(timezone);\n        });\n    };\n    ChartImp.prototype.getTimezone = function() {\n        return this._chartStore.getTimezone();\n    };\n    ChartImp.prototype.setThousandsSeparator = function(thousandsSeparator) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setThousandsSeparator(thousandsSeparator);\n        });\n    };\n    ChartImp.prototype.getThousandsSeparator = function() {\n        return this._chartStore.getThousandsSeparator();\n    };\n    ChartImp.prototype.setDecimalFold = function(decimalFold) {\n        var _this = this;\n        this._setOptions(function() {\n            _this._chartStore.setDecimalFold(decimalFold);\n        });\n    };\n    ChartImp.prototype.getDecimalFold = function() {\n        return this._chartStore.getDecimalFold();\n    };\n    ChartImp.prototype._setOptions = function(fuc) {\n        fuc();\n        this.layout({\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true,\n            forceBuildYAxisTick: true\n        });\n    };\n    ChartImp.prototype.setOffsetRightDistance = function(distance) {\n        this._chartStore.setOffsetRightDistance(distance, true);\n    };\n    ChartImp.prototype.getOffsetRightDistance = function() {\n        return this._chartStore.getOffsetRightDistance();\n    };\n    ChartImp.prototype.setMaxOffsetLeftDistance = function(distance) {\n        if (distance < 0) {\n            logWarn(\"setMaxOffsetLeftDistance\", \"distance\", \"distance must greater than zero!!!\");\n            return;\n        }\n        this._chartStore.setMaxOffsetLeftDistance(distance);\n    };\n    ChartImp.prototype.setMaxOffsetRightDistance = function(distance) {\n        if (distance < 0) {\n            logWarn(\"setMaxOffsetRightDistance\", \"distance\", \"distance must greater than zero!!!\");\n            return;\n        }\n        this._chartStore.setMaxOffsetRightDistance(distance);\n    };\n    ChartImp.prototype.setLeftMinVisibleBarCount = function(barCount) {\n        if (barCount < 0) {\n            logWarn(\"setLeftMinVisibleBarCount\", \"barCount\", \"barCount must greater than zero!!!\");\n            return;\n        }\n        this._chartStore.setLeftMinVisibleBarCount(Math.ceil(barCount));\n    };\n    ChartImp.prototype.setRightMinVisibleBarCount = function(barCount) {\n        if (barCount < 0) {\n            logWarn(\"setRightMinVisibleBarCount\", \"barCount\", \"barCount must greater than zero!!!\");\n            return;\n        }\n        this._chartStore.setRightMinVisibleBarCount(Math.ceil(barCount));\n    };\n    ChartImp.prototype.setBarSpace = function(space) {\n        this._chartStore.setBarSpace(space);\n    };\n    ChartImp.prototype.getBarSpace = function() {\n        return this._chartStore.getBarSpace();\n    };\n    ChartImp.prototype.getVisibleRange = function() {\n        return this._chartStore.getVisibleRange();\n    };\n    ChartImp.prototype.clearData = function() {\n        this._chartStore.clearData();\n    };\n    ChartImp.prototype.getDataList = function() {\n        return this._chartStore.getDataList();\n    };\n    ChartImp.prototype.applyNewData = function(data, more) {\n        this._drawPanes.forEach(function(pane) {\n            pane.getAxisComponent().setAutoCalcTickFlag(true);\n        });\n        var loadDataMore = {\n            forward: false,\n            backward: false\n        };\n        if (isBoolean(more)) {\n            loadDataMore.forward = more;\n            loadDataMore.backward = more;\n        } else {\n            loadDataMore = __assign(__assign({}, loadDataMore), more);\n        }\n        this._chartStore.addData(data, LoadDataType.Init, loadDataMore);\n    };\n    ChartImp.prototype.updateData = function(data) {\n        this._chartStore.addData(data, LoadDataType.Update);\n    };\n    ChartImp.prototype.setLoadMoreDataCallback = function(cb) {\n        this._chartStore.setLoadMoreDataCallback(cb);\n    };\n    ChartImp.prototype.createIndicator = function(value, isStack, paneOptions) {\n        var _a;\n        var indicator = isString(value) ? {\n            name: value\n        } : value;\n        if (getIndicatorClass(indicator.name) === null) {\n            logWarn(\"createIndicator\", \"value\", \"indicator not supported, you may need to use registerIndicator to add one!!!\");\n            return null;\n        }\n        var paneOpts = paneOptions !== null && paneOptions !== void 0 ? paneOptions : {};\n        if (!isString(paneOpts.id)) {\n            paneOpts.id = createId(PaneIdConstants.INDICATOR);\n        }\n        if (!isString(indicator.id)) {\n            indicator.id = createId(indicator.name);\n        }\n        var result = this._chartStore.addIndicator(indicator, paneOpts.id, isStack !== null && isStack !== void 0 ? isStack : false);\n        if (result) {\n            var shouldSort = false;\n            if (!isValid(this.getDrawPaneById(paneOpts.id))) {\n                this._createPane(IndicatorPane, paneOpts.id, paneOpts);\n                (_a = paneOpts.height) !== null && _a !== void 0 ? _a : paneOpts.height = PANE_DEFAULT_HEIGHT;\n                shouldSort = true;\n            }\n            this.setPaneOptions(paneOpts);\n            this.layout({\n                sort: shouldSort,\n                measureHeight: true,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n            return indicator.id;\n        }\n        return null;\n    };\n    ChartImp.prototype.overrideIndicator = function(override) {\n        return this._chartStore.overrideIndicator(override);\n    };\n    ChartImp.prototype.getIndicators = function(filter) {\n        return this._chartStore.getIndicatorsByFilter(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.removeIndicator = function(filter) {\n        var _this = this;\n        var removed = this._chartStore.removeIndicator(filter !== null && filter !== void 0 ? filter : {});\n        if (removed) {\n            var shouldMeasureHeight_1 = false;\n            var paneIds_1 = [];\n            this._drawPanes.forEach(function(pane) {\n                var paneId = pane.getId();\n                if (paneId !== PaneIdConstants.CANDLE && paneId !== PaneIdConstants.X_AXIS) {\n                    paneIds_1.push(paneId);\n                }\n            });\n            paneIds_1.forEach(function(paneId) {\n                if (!_this._chartStore.hasIndicators(paneId)) {\n                    var index = _this._drawPanes.findIndex(function(pane) {\n                        return pane.getId() === paneId;\n                    });\n                    var pane = _this._drawPanes[index];\n                    if (isValid(pane)) {\n                        shouldMeasureHeight_1 = true;\n                        _this._recalculatePaneHeight(pane, 0, pane.getBounding().height);\n                        _this._drawPanes.splice(index, 1);\n                        pane.destroy();\n                    }\n                }\n            });\n            if (this._drawPanes.length === 2) {\n                this._candlePane.setVisible(true);\n                this._candlePane.setBounding({\n                    height: this._chartBounding.height - this._xAxisPane.getBounding().height\n                });\n            }\n            this.layout({\n                sort: shouldMeasureHeight_1,\n                measureHeight: shouldMeasureHeight_1,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n        }\n        return removed;\n    };\n    ChartImp.prototype.createOverlay = function(value) {\n        var _this = this;\n        var overlays = [];\n        var appointPaneFlags = [];\n        var build = function(overlay) {\n            if (!isValid(overlay.paneId) || _this.getDrawPaneById(overlay.paneId) === null) {\n                overlay.paneId = PaneIdConstants.CANDLE;\n                appointPaneFlags.push(false);\n            } else {\n                appointPaneFlags.push(true);\n            }\n            overlays.push(overlay);\n        };\n        if (isString(value)) {\n            build({\n                name: value\n            });\n        } else if (isArray(value)) {\n            value.forEach(function(v) {\n                var overlay = null;\n                if (isString(v)) {\n                    overlay = {\n                        name: v\n                    };\n                } else {\n                    overlay = v;\n                }\n                build(overlay);\n            });\n        } else {\n            build(value);\n        }\n        var ids = this._chartStore.addOverlays(overlays, appointPaneFlags);\n        if (isArray(value)) {\n            return ids;\n        }\n        return ids[0];\n    };\n    ChartImp.prototype.getOverlays = function(filter) {\n        return this._chartStore.getOverlaysByFilter(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.overrideOverlay = function(override) {\n        return this._chartStore.overrideOverlay(override);\n    };\n    ChartImp.prototype.removeOverlay = function(filter) {\n        return this._chartStore.removeOverlay(filter !== null && filter !== void 0 ? filter : {});\n    };\n    ChartImp.prototype.setPaneOptions = function(options) {\n        var e_1, _a;\n        var _this = this;\n        var _b;\n        var shouldMeasureHeight = false;\n        var shouldLayout = false;\n        var validId = isValid(options.id);\n        var _loop_1 = function(currentPane) {\n            var currentPaneId = currentPane.getId();\n            if (validId && options.id === currentPaneId || !validId) {\n                if (currentPaneId !== PaneIdConstants.X_AXIS) {\n                    if (isNumber(options.height) && options.height > 0) {\n                        var minHeight = Math.max((_b = options.minHeight) !== null && _b !== void 0 ? _b : currentPane.getOptions().minHeight, 0);\n                        var height = Math.max(minHeight, options.height);\n                        shouldLayout = true;\n                        shouldMeasureHeight = true;\n                        currentPane.setOriginalBounding({\n                            height: height\n                        });\n                        this_1._recalculatePaneHeight(currentPane, height, -height);\n                    }\n                    if (isValid(options.state) && currentPane.getOptions().state !== options.state) {\n                        shouldMeasureHeight = true;\n                        shouldLayout = true;\n                        var state = options.state;\n                        switch(state){\n                            case \"maximize\" /* PaneState.Maximize */ :\n                                {\n                                    var maximizePane = this_1._drawPanes.find(function(pane) {\n                                        var paneId = pane.getId();\n                                        return pane.getOptions().state === \"maximize\" /* PaneState.Maximize */  && paneId !== PaneIdConstants.X_AXIS;\n                                    });\n                                    if (!isValid(maximizePane)) {\n                                        if (currentPane.getOptions().state === \"normal\" /* PaneState.Normal */ ) {\n                                            currentPane.setOriginalBounding({\n                                                height: currentPane.getBounding().height\n                                            });\n                                        }\n                                        currentPane.setOptions({\n                                            state: state\n                                        });\n                                        var totalHeight = this_1._chartBounding.height;\n                                        currentPane.setBounding({\n                                            height: totalHeight - this_1._xAxisPane.getBounding().height\n                                        });\n                                        this_1._drawPanes.forEach(function(pane) {\n                                            var _a;\n                                            if (pane.getId() !== PaneIdConstants.X_AXIS && pane.getId() !== currentPaneId) {\n                                                pane.setBounding({\n                                                    height: pane.getOriginalBounding().height\n                                                });\n                                                pane.setVisible(false);\n                                                (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(false);\n                                            }\n                                        });\n                                    }\n                                    break;\n                                }\n                            case \"minimize\" /* PaneState.Minimize */ :\n                                {\n                                    var height = currentPane.getBounding().height;\n                                    var currentState = currentPane.getOptions().state;\n                                    var changeHeight = height - PANE_MIN_HEIGHT;\n                                    if (currentState === \"maximize\" /* PaneState.Maximize */ ) {\n                                        changeHeight = currentPane.getOriginalBounding().height - PANE_MIN_HEIGHT;\n                                    }\n                                    if (this_1._recalculatePaneHeight(currentPane, PANE_MIN_HEIGHT, changeHeight)) {\n                                        if (currentState === \"normal\" /* PaneState.Normal */ ) {\n                                            currentPane.setOriginalBounding({\n                                                height: height\n                                            });\n                                        }\n                                        currentPane.setOptions({\n                                            state: state\n                                        });\n                                    }\n                                    this_1._drawPanes.forEach(function(pane) {\n                                        var _a;\n                                        if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                                            pane.setVisible(true);\n                                            (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(true);\n                                        }\n                                    });\n                                    break;\n                                }\n                            default:\n                                {\n                                    var height = currentPane.getOriginalBounding().height;\n                                    if (this_1._recalculatePaneHeight(currentPane, height, currentPane.getBounding().height - height)) {\n                                        currentPane.setOptions({\n                                            state: state\n                                        });\n                                    }\n                                    this_1._drawPanes.forEach(function(pane) {\n                                        var _a;\n                                        if (pane.getId() !== PaneIdConstants.X_AXIS) {\n                                            pane.setVisible(true);\n                                            (_a = _this._separatorPanes.get(pane)) === null || _a === void 0 ? void 0 : _a.setVisible(true);\n                                        }\n                                    });\n                                    break;\n                                }\n                        }\n                    }\n                }\n                if (isValid(options.axis)) {\n                    shouldLayout = true;\n                }\n                var ops = __assign({}, options);\n                delete ops.state;\n                currentPane.setOptions(ops);\n                if (currentPaneId === options.id) {\n                    return \"break\";\n                }\n            }\n        };\n        var this_1 = this;\n        try {\n            for(var _c = __values(this._drawPanes), _d = _c.next(); !_d.done; _d = _c.next()){\n                var currentPane = _d.value;\n                var state_1 = _loop_1(currentPane);\n                if (state_1 === \"break\") break;\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        if (shouldLayout) {\n            this.layout({\n                measureHeight: shouldMeasureHeight,\n                measureWidth: true,\n                update: true,\n                buildYAxisTick: true,\n                forceBuildYAxisTick: true\n            });\n        }\n    };\n    ChartImp.prototype.getPaneOptions = function(id) {\n        var _a;\n        if (isValid(id)) {\n            var pane = this.getDrawPaneById(id);\n            return (_a = pane === null || pane === void 0 ? void 0 : pane.getOptions()) !== null && _a !== void 0 ? _a : null;\n        }\n        return this._drawPanes.map(function(pane) {\n            return pane.getOptions();\n        });\n    };\n    ChartImp.prototype.setZoomEnabled = function(enabled) {\n        this._chartStore.setZoomEnabled(enabled);\n    };\n    ChartImp.prototype.isZoomEnabled = function() {\n        return this._chartStore.isZoomEnabled();\n    };\n    ChartImp.prototype.setScrollEnabled = function(enabled) {\n        this._chartStore.setScrollEnabled(enabled);\n    };\n    ChartImp.prototype.isScrollEnabled = function() {\n        return this._chartStore.isScrollEnabled();\n    };\n    ChartImp.prototype.scrollByDistance = function(distance, animationDuration) {\n        var _this = this;\n        var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;\n        this._chartStore.startScroll();\n        if (duration > 0) {\n            var animation = new Animation({\n                duration: duration\n            });\n            animation.doFrame(function(frameTime) {\n                var progressDistance = distance * (frameTime / duration);\n                _this._chartStore.scroll(progressDistance);\n            });\n            animation.start();\n        } else {\n            this._chartStore.scroll(distance);\n        }\n    };\n    ChartImp.prototype.scrollToRealTime = function(animationDuration) {\n        var barSpace = this._chartStore.getBarSpace().bar;\n        var difBarCount = this._chartStore.getLastBarRightSideDiffBarCount() - this._chartStore.getInitialOffsetRightDistance() / barSpace;\n        var distance = difBarCount * barSpace;\n        this.scrollByDistance(distance, animationDuration);\n    };\n    ChartImp.prototype.scrollToDataIndex = function(dataIndex, animationDuration) {\n        var distance = (this._chartStore.getLastBarRightSideDiffBarCount() + (this.getDataList().length - 1 - dataIndex)) * this._chartStore.getBarSpace().bar;\n        this.scrollByDistance(distance, animationDuration);\n    };\n    ChartImp.prototype.scrollToTimestamp = function(timestamp, animationDuration) {\n        var dataIndex = binarySearchNearest(this.getDataList(), \"timestamp\", timestamp);\n        this.scrollToDataIndex(dataIndex, animationDuration);\n    };\n    ChartImp.prototype.zoomAtCoordinate = function(scale, coordinate, animationDuration) {\n        var _this = this;\n        var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;\n        var barSpace = this._chartStore.getBarSpace().bar;\n        var scaleBarSpace = barSpace * scale;\n        var difSpace = scaleBarSpace - barSpace;\n        if (duration > 0) {\n            var prevProgressBarSpace_1 = 0;\n            var animation = new Animation({\n                duration: duration\n            });\n            animation.doFrame(function(frameTime) {\n                var progressBarSpace = difSpace * (frameTime / duration);\n                var scale = (progressBarSpace - prevProgressBarSpace_1) / _this._chartStore.getBarSpace().bar * SCALE_MULTIPLIER;\n                _this._chartStore.zoom(scale, coordinate);\n                prevProgressBarSpace_1 = progressBarSpace;\n            });\n            animation.start();\n        } else {\n            this._chartStore.zoom(difSpace / barSpace * SCALE_MULTIPLIER, coordinate);\n        }\n    };\n    ChartImp.prototype.zoomAtDataIndex = function(scale, dataIndex, animationDuration) {\n        var x = this._chartStore.dataIndexToCoordinate(dataIndex);\n        this.zoomAtCoordinate(scale, {\n            x: x,\n            y: 0\n        }, animationDuration);\n    };\n    ChartImp.prototype.zoomAtTimestamp = function(scale, timestamp, animationDuration) {\n        var dataIndex = binarySearchNearest(this.getDataList(), \"timestamp\", timestamp);\n        this.zoomAtDataIndex(scale, dataIndex, animationDuration);\n    };\n    ChartImp.prototype.convertToPixel = function(points, filter) {\n        var _this = this;\n        var _a;\n        var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;\n        var coordinates = [];\n        if (paneId !== PaneIdConstants.X_AXIS) {\n            var pane = this.getDrawPaneById(paneId);\n            if (pane !== null) {\n                var bounding_1 = pane.getBounding();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                var ps = [].concat(points);\n                var xAxis_1 = this._xAxisPane.getAxisComponent();\n                var yAxis_1 = pane.getAxisComponent();\n                coordinates = ps.map(function(point) {\n                    var coordinate = {};\n                    var dataIndex = point.dataIndex;\n                    if (isNumber(point.timestamp)) {\n                        dataIndex = _this._chartStore.timestampToDataIndex(point.timestamp);\n                    }\n                    if (isNumber(dataIndex)) {\n                        coordinate.x = xAxis_1.convertToPixel(dataIndex);\n                    }\n                    if (isNumber(point.value)) {\n                        var y = yAxis_1.convertToPixel(point.value);\n                        coordinate.y = absolute ? bounding_1.top + y : y;\n                    }\n                    return coordinate;\n                });\n            }\n        }\n        return isArray(points) ? coordinates : (_a = coordinates[0]) !== null && _a !== void 0 ? _a : {};\n    };\n    ChartImp.prototype.convertFromPixel = function(coordinates, filter) {\n        var _this = this;\n        var _a;\n        var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;\n        var points = [];\n        if (paneId !== PaneIdConstants.X_AXIS) {\n            var pane = this.getDrawPaneById(paneId);\n            if (pane !== null) {\n                var bounding_2 = pane.getBounding();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore\n                // @ts-expect-error\n                var cs = [].concat(coordinates);\n                var xAxis_2 = this._xAxisPane.getAxisComponent();\n                var yAxis_2 = pane.getAxisComponent();\n                points = cs.map(function(coordinate) {\n                    var _a;\n                    var point = {};\n                    if (isNumber(coordinate.x)) {\n                        var dataIndex = xAxis_2.convertFromPixel(coordinate.x);\n                        point.dataIndex = dataIndex;\n                        point.timestamp = (_a = _this._chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : undefined;\n                    }\n                    if (isNumber(coordinate.y)) {\n                        var y = absolute ? coordinate.y - bounding_2.top : coordinate.y;\n                        point.value = yAxis_2.convertFromPixel(y);\n                    }\n                    return point;\n                });\n            }\n        }\n        return isArray(coordinates) ? points : (_a = points[0]) !== null && _a !== void 0 ? _a : {};\n    };\n    ChartImp.prototype.executeAction = function(type, data) {\n        var _a;\n        switch(type){\n            case ActionType.OnCrosshairChange:\n                {\n                    var crosshair = __assign({}, data);\n                    (_a = crosshair.paneId) !== null && _a !== void 0 ? _a : crosshair.paneId = PaneIdConstants.CANDLE;\n                    this._chartStore.setCrosshair(crosshair, {\n                        notExecuteAction: true\n                    });\n                    break;\n                }\n        }\n    };\n    ChartImp.prototype.subscribeAction = function(type, callback) {\n        this._chartStore.subscribeAction(type, callback);\n    };\n    ChartImp.prototype.unsubscribeAction = function(type, callback) {\n        this._chartStore.unsubscribeAction(type, callback);\n    };\n    ChartImp.prototype.getConvertPictureUrl = function(includeOverlay, type, backgroundColor) {\n        var _this = this;\n        var _a = this._chartBounding, width = _a.width, height = _a.height;\n        var canvas = createDom(\"canvas\", {\n            width: \"\".concat(width, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            boxSizing: \"border-box\"\n        });\n        var ctx = canvas.getContext(\"2d\");\n        var pixelRatio = getPixelRatio(canvas);\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        ctx.scale(pixelRatio, pixelRatio);\n        ctx.fillStyle = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : \"#FFFFFF\";\n        ctx.fillRect(0, 0, width, height);\n        var overlayFlag = includeOverlay !== null && includeOverlay !== void 0 ? includeOverlay : false;\n        this._drawPanes.forEach(function(pane) {\n            var separatorPane = _this._separatorPanes.get(pane);\n            if (isValid(separatorPane)) {\n                var separatorBounding = separatorPane.getBounding();\n                ctx.drawImage(separatorPane.getImage(overlayFlag), separatorBounding.left, separatorBounding.top, separatorBounding.width, separatorBounding.height);\n            }\n            var bounding = pane.getBounding();\n            ctx.drawImage(pane.getImage(overlayFlag), 0, bounding.top, width, bounding.height);\n        });\n        return canvas.toDataURL(\"image/\".concat(type !== null && type !== void 0 ? type : \"jpeg\"));\n    };\n    ChartImp.prototype.resize = function() {\n        this._cacheChartBounding();\n        this.layout({\n            measureHeight: true,\n            measureWidth: true,\n            update: true,\n            buildYAxisTick: true,\n            forceBuildYAxisTick: true\n        });\n    };\n    ChartImp.prototype.destroy = function() {\n        this._chartEvent.destroy();\n        this._drawPanes.forEach(function(pane) {\n            pane.destroy();\n        });\n        this._drawPanes = [];\n        this._separatorPanes.clear();\n        this._container.removeChild(this._chartContainer);\n    };\n    return ChartImp;\n}();\n/**\n *       ___           ___                   ___           ___           ___           ___           ___           ___           ___\n *      /\\__\\         /\\__\\      ___        /\\__\\         /\\  \\         /\\  \\         /\\__\\         /\\  \\         /\\  \\         /\\  \\\n *     /:/  /        /:/  /     /\\  \\      /::|  |       /::\\  \\       /::\\  \\       /:/  /        /::\\  \\       /::\\  \\        \\:\\  \\\n *    /:/__/        /:/  /      \\:\\  \\    /:|:|  |      /:/\\:\\  \\     /:/\\:\\  \\     /:/__/        /:/\\:\\  \\     /:/\\:\\  \\        \\:\\  \\\n *   /::\\__\\____   /:/  /       /::\\__\\  /:/|:|  |__   /::\\~\\:\\  \\   /:/  \\:\\  \\   /::\\  \\ ___   /::\\~\\:\\  \\   /::\\~\\:\\  \\       /::\\  \\\n *  /:/\\:::::\\__\\ /:/__/     __/:/\\/__/ /:/ |:| /\\__\\ /:/\\:\\ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:\\  /\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\     /:/\\:\\__\\\n *  \\/_|:|~~|~    \\:\\  \\    /\\/:/  /    \\/__|:|/:/  / \\:\\~\\:\\ \\/__/ \\:\\  \\  \\/__/ \\/__\\:\\/:/  / \\/__\\:\\/:/  / \\/_|::\\/:/  /    /:/  \\/__/\n *     |:|  |      \\:\\  \\   \\::/__/         |:/:/  /   \\:\\ \\:\\__\\    \\:\\  \\            \\::/  /       \\::/  /     |:|::/  /    /:/  /\n *     |:|  |       \\:\\  \\   \\:\\__\\         |::/  /     \\:\\ \\/__/     \\:\\  \\           /:/  /        /:/  /      |:|\\/__/     \\/__/\n *     |:|  |        \\:\\__\\   \\/__/         /:/  /       \\:\\__\\        \\:\\__\\         /:/  /        /:/  /       |:|  |\n *      \\|__|         \\/__/                 \\/__/         \\/__/         \\/__/         \\/__/         \\/__/         \\|__|\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n\n * http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var charts = new Map();\nvar chartBaseId = 1;\n/**\n * Chart version\n * @return {string}\n */ function version() {\n    return \"10.0.0-alpha5\";\n}\n/**\n * Init chart instance\n * @param ds\n * @param options\n * @returns {Chart}\n */ function init(ds, options) {\n    logTag();\n    var dom = null;\n    if (isString(ds)) {\n        dom = document.getElementById(ds);\n    } else {\n        dom = ds;\n    }\n    if (dom === null) {\n        logError(\"\", \"\", \"The chart cannot be initialized correctly. Please check the parameters. The chart container cannot be null and child elements need to be added!!!\");\n        return null;\n    }\n    var chart = charts.get(dom.id);\n    if (isValid(chart)) {\n        logWarn(\"\", \"\", \"The chart has been initialized on the dom！！！\");\n        return chart;\n    }\n    var id = \"k_line_chart_\".concat(chartBaseId++);\n    chart = new ChartImp(dom, options);\n    chart.id = id;\n    dom.setAttribute(\"k-line-chart-id\", id);\n    charts.set(id, chart);\n    return chart;\n}\n/**\n * Destroy chart instance\n * @param dcs\n */ function dispose(dcs) {\n    var _a, _b;\n    var id = null;\n    if (dcs instanceof ChartImp) {\n        id = dcs.id;\n    } else {\n        var dom = null;\n        if (isString(dcs)) {\n            dom = document.getElementById(dcs);\n        } else {\n            dom = dcs;\n        }\n        id = (_a = dom === null || dom === void 0 ? void 0 : dom.getAttribute(\"k-line-chart-id\")) !== null && _a !== void 0 ? _a : null;\n    }\n    if (id !== null) {\n        (_b = charts.get(id)) === null || _b === void 0 ? void 0 : _b.destroy();\n        charts.delete(id);\n    }\n}\nvar utils = {\n    clone: clone,\n    merge: merge,\n    isString: isString,\n    isNumber: isNumber,\n    isValid: isValid,\n    isObject: isObject,\n    isArray: isArray,\n    isFunction: isFunction,\n    isBoolean: isBoolean,\n    formatValue: formatValue,\n    formatPrecision: formatPrecision,\n    formatBigNumber: formatBigNumber,\n    formatDate: formatTimestampToString,\n    formatThousands: formatThousands,\n    formatFoldDecimal: formatFoldDecimal,\n    calcTextWidth: calcTextWidth,\n    getLinearSlopeIntercept: getLinearSlopeIntercept,\n    getLinearYFromSlopeIntercept: getLinearYFromSlopeIntercept,\n    getLinearYFromCoordinates: getLinearYFromCoordinates,\n    checkCoordinateOnArc: checkCoordinateOnArc,\n    checkCoordinateOnCircle: checkCoordinateOnCircle,\n    checkCoordinateOnLine: checkCoordinateOnLine,\n    checkCoordinateOnPolygon: checkCoordinateOnPolygon,\n    checkCoordinateOnRect: checkCoordinateOnRect,\n    checkCoordinateOnText: checkCoordinateOnText\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMva2xpbmVjaGFydHMvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0tBS0ssR0FDTDs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsOERBQThELEdBRTlELElBQUlBLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFBRTtJQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztBQUM1QjtBQUVBLFNBQVNTLFVBQVVWLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlVLFVBQVUseUJBQXlCQyxPQUFPWCxLQUFLO0lBQzdERixjQUFjQyxHQUFHQztJQUNqQixTQUFTWTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHZDtJQUFHO0lBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT2EsTUFBTSxDQUFDZCxLQUFNWSxDQUFBQSxHQUFHTixTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJTSxJQUFHO0FBQ3RGO0FBRUEsSUFBSUcsV0FBVztJQUNYQSxXQUFXZCxPQUFPZSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMs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QUFJd0gsTUFBTTtRQUNWLElBQUl6WixTQUFTbW5FLE1BQU07WUFDZjF0RCxNQUFNOUwsU0FBU3E1RCxjQUFjLENBQUNHO1FBQ2xDLE9BQ0s7WUFDRDF0RCxNQUFNMHREO1FBQ1Y7UUFDQWwxRCxLQUFLLENBQUMzRyxLQUFLbU8sUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUkydEQsWUFBWSxDQUFDLGtCQUFpQixNQUFPLFFBQVE5N0QsT0FBTyxLQUFLLElBQUlBLEtBQUs7SUFDL0g7SUFDQSxJQUFJMkcsT0FBTyxNQUFNO1FBQ1o1RSxDQUFBQSxLQUFLczVELE9BQU9ucEQsR0FBRyxDQUFDdkwsR0FBRSxNQUFPLFFBQVE1RSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpNkIsT0FBTztRQUNyRXEvQixPQUFPbm1DLE1BQU0sQ0FBQ3Z1QjtJQUNsQjtBQUNKO0FBQ0EsSUFBSW8xRCxRQUFRO0lBQ1IvbkUsT0FBT0E7SUFDUFIsT0FBT0E7SUFDUGtCLFVBQVVBO0lBQ1ZMLFVBQVVBO0lBQ1ZOLFNBQVNBO0lBQ1RKLFVBQVVBO0lBQ1ZPLFNBQVNBO0lBQ1RFLFlBQVlBO0lBQ1pLLFdBQVdBO0lBQ1hzSyxhQUFhQTtJQUNiMEIsaUJBQWlCQTtJQUNqQkcsaUJBQWlCQTtJQUNqQjhwQixZQUFZbnFCO0lBQ1pNLGlCQUFpQkE7SUFDakJPLG1CQUFtQkE7SUFDbkJnQixlQUFlQTtJQUNmeWlCLHlCQUF5QkE7SUFDekJDLDhCQUE4QkE7SUFDOUJFLDJCQUEyQkE7SUFDM0JxYixzQkFBc0JBO0lBQ3RCcEMseUJBQXlCQTtJQUN6QjFaLHVCQUF1QkE7SUFDdkJtYSwwQkFBMEJBO0lBQzFCTyx1QkFBdUJBO0lBQ3ZCVyx1QkFBdUJBO0FBQzNCO0FBRXVlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9sbGluZ2VyLWJhbmRzLWluZGljYXRvci8uL25vZGVfbW9kdWxlcy9rbGluZWNoYXJ0cy9kaXN0L2luZGV4LmVzbS5qcz8wMDBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogS0xpbmVDaGFydCB2MTAuMC4wLWFscGhhNVxuICAgICAqIENvcHlyaWdodCAoYykgMjAxOSBsaWh1LlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIEFwYWNoZSBMaWNlbnNlIDIuMCBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSk7XHJcbiAgICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBpZ25vcmVcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKCghaXNPYmplY3QodGFyZ2V0KSAmJiAhaXNPYmplY3Qoc291cmNlKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgLS0gaWdub3JlXG4gICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIGlnbm9yZVxuICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHRhcmdldFByb3ApKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lKHRhcmdldCkge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBpZ25vcmVcbiAgICB2YXIgY29weSA9IG51bGw7XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBjb3B5ID0gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb3B5ID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAtLSBpZ25vcmVcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktdHlwZS1wYXJhbWV0ZXJzIC0tIGlnbm9yZVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgJiYgaXNWYWxpZCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNwYXJlbnQoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPT09ICd0cmFuc3BhcmVudCcgfHxcbiAgICAgICAgY29sb3IgPT09ICdub25lJyB8fFxuICAgICAgICAvXltyUl1bZ0ddW0JiXVtBYV1cXCgoW1xcc10qKDJbMC00XVswLTldfDI1WzAtNV18WzAxXT9bMC05XVswLTldPylbXFxzXSosKXszfVtcXHNdKjBbXFxzXSpcXCkkLy50ZXN0KGNvbG9yKSB8fFxuICAgICAgICAvXltoSF1bU3NdW0xsXVtBYV1cXCgoW1xcc10qKDM2MO+9nDNbMC01XVswLTldfFswMTJdP1swLTldWzAtOV0/KVtcXHNdKiwpKFtcXHNdKigoMTAwfFswLTldWzAtOV0/KSV8MClbXFxzXSosKXsyfShbXFxzXSowW1xcc10qKVxcKSQvLnRlc3QoY29sb3IpO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2IoaGV4LCBhbHBoYSkge1xuICAgIHZhciBoID0gaGV4LnJlcGxhY2UoL14jLywgJycpO1xuICAgIHZhciBpID0gcGFyc2VJbnQoaCwgMTYpO1xuICAgIHZhciByID0gKGkgPj4gMTYpICYgMjU1O1xuICAgIHZhciBnID0gKGkgPj4gOCkgJiAyNTU7XG4gICAgdmFyIGIgPSBpICYgMjU1O1xuICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KHIsIFwiLCBcIikuY29uY2F0KGcsIFwiLCBcIikuY29uY2F0KGIsIFwiLCBcIikuY29uY2F0KGFscGhhICE9PSBudWxsICYmIGFscGhhICE9PSB2b2lkIDAgPyBhbHBoYSA6IDEsIFwiKVwiKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIGxpbmUgdHlwZVxuICovXG52YXIgTGluZVR5cGU7XG4oZnVuY3Rpb24gKExpbmVUeXBlKSB7XG4gICAgTGluZVR5cGVbXCJEYXNoZWRcIl0gPSBcImRhc2hlZFwiO1xuICAgIExpbmVUeXBlW1wiU29saWRcIl0gPSBcInNvbGlkXCI7XG59KShMaW5lVHlwZSB8fCAoTGluZVR5cGUgPSB7fSkpO1xudmFyIFBhdGhUeXBlO1xuKGZ1bmN0aW9uIChQYXRoVHlwZSkge1xuICAgIFBhdGhUeXBlW1wiU3Ryb2tlXCJdID0gXCJzdHJva2VcIjtcbiAgICBQYXRoVHlwZVtcIkZpbGxcIl0gPSBcImZpbGxcIjtcbn0pKFBhdGhUeXBlIHx8IChQYXRoVHlwZSA9IHt9KSk7XG52YXIgUG9seWdvblR5cGU7XG4oZnVuY3Rpb24gKFBvbHlnb25UeXBlKSB7XG4gICAgUG9seWdvblR5cGVbXCJTdHJva2VcIl0gPSBcInN0cm9rZVwiO1xuICAgIFBvbHlnb25UeXBlW1wiRmlsbFwiXSA9IFwiZmlsbFwiO1xuICAgIFBvbHlnb25UeXBlW1wiU3Ryb2tlRmlsbFwiXSA9IFwic3Ryb2tlX2ZpbGxcIjtcbn0pKFBvbHlnb25UeXBlIHx8IChQb2x5Z29uVHlwZSA9IHt9KSk7XG52YXIgVG9vbHRpcFNob3dSdWxlO1xuKGZ1bmN0aW9uIChUb29sdGlwU2hvd1J1bGUpIHtcbiAgICBUb29sdGlwU2hvd1J1bGVbXCJBbHdheXNcIl0gPSBcImFsd2F5c1wiO1xuICAgIFRvb2x0aXBTaG93UnVsZVtcIkZvbGxvd0Nyb3NzXCJdID0gXCJmb2xsb3dfY3Jvc3NcIjtcbiAgICBUb29sdGlwU2hvd1J1bGVbXCJOb25lXCJdID0gXCJub25lXCI7XG59KShUb29sdGlwU2hvd1J1bGUgfHwgKFRvb2x0aXBTaG93UnVsZSA9IHt9KSk7XG52YXIgVG9vbHRpcFNob3dUeXBlO1xuKGZ1bmN0aW9uIChUb29sdGlwU2hvd1R5cGUpIHtcbiAgICBUb29sdGlwU2hvd1R5cGVbXCJTdGFuZGFyZFwiXSA9IFwic3RhbmRhcmRcIjtcbiAgICBUb29sdGlwU2hvd1R5cGVbXCJSZWN0XCJdID0gXCJyZWN0XCI7XG59KShUb29sdGlwU2hvd1R5cGUgfHwgKFRvb2x0aXBTaG93VHlwZSA9IHt9KSk7XG52YXIgVG9vbHRpcEZlYXR1cmVUeXBlO1xuKGZ1bmN0aW9uIChUb29sdGlwRmVhdHVyZVR5cGUpIHtcbiAgICBUb29sdGlwRmVhdHVyZVR5cGVbXCJQYXRoXCJdID0gXCJwYXRoXCI7XG4gICAgVG9vbHRpcEZlYXR1cmVUeXBlW1wiSWNvbkZvbnRcIl0gPSBcImljb25fZm9udFwiO1xufSkoVG9vbHRpcEZlYXR1cmVUeXBlIHx8IChUb29sdGlwRmVhdHVyZVR5cGUgPSB7fSkpO1xudmFyIFRvb2x0aXBGZWF0dXJlUG9zaXRpb247XG4oZnVuY3Rpb24gKFRvb2x0aXBGZWF0dXJlUG9zaXRpb24pIHtcbiAgICBUb29sdGlwRmVhdHVyZVBvc2l0aW9uW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIFRvb2x0aXBGZWF0dXJlUG9zaXRpb25bXCJNaWRkbGVcIl0gPSBcIm1pZGRsZVwiO1xuICAgIFRvb2x0aXBGZWF0dXJlUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbn0pKFRvb2x0aXBGZWF0dXJlUG9zaXRpb24gfHwgKFRvb2x0aXBGZWF0dXJlUG9zaXRpb24gPSB7fSkpO1xudmFyIENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb247XG4oZnVuY3Rpb24gKENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24pIHtcbiAgICBDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uW1wiRml4ZWRcIl0gPSBcImZpeGVkXCI7XG4gICAgQ2FuZGxlVG9vbHRpcFJlY3RQb3NpdGlvbltcIlBvaW50ZXJcIl0gPSBcInBvaW50ZXJcIjtcbn0pKENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24gfHwgKENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24gPSB7fSkpO1xudmFyIENhbmRsZVR5cGU7XG4oZnVuY3Rpb24gKENhbmRsZVR5cGUpIHtcbiAgICBDYW5kbGVUeXBlW1wiQ2FuZGxlU29saWRcIl0gPSBcImNhbmRsZV9zb2xpZFwiO1xuICAgIENhbmRsZVR5cGVbXCJDYW5kbGVTdHJva2VcIl0gPSBcImNhbmRsZV9zdHJva2VcIjtcbiAgICBDYW5kbGVUeXBlW1wiQ2FuZGxlVXBTdHJva2VcIl0gPSBcImNhbmRsZV91cF9zdHJva2VcIjtcbiAgICBDYW5kbGVUeXBlW1wiQ2FuZGxlRG93blN0cm9rZVwiXSA9IFwiY2FuZGxlX2Rvd25fc3Ryb2tlXCI7XG4gICAgQ2FuZGxlVHlwZVtcIk9obGNcIl0gPSBcIm9obGNcIjtcbiAgICBDYW5kbGVUeXBlW1wiQXJlYVwiXSA9IFwiYXJlYVwiO1xufSkoQ2FuZGxlVHlwZSB8fCAoQ2FuZGxlVHlwZSA9IHt9KSk7XG52YXIgQ2FuZGxlQ29sb3JDb21wYXJlUnVsZTtcbihmdW5jdGlvbiAoQ2FuZGxlQ29sb3JDb21wYXJlUnVsZSkge1xuICAgIENhbmRsZUNvbG9yQ29tcGFyZVJ1bGVbXCJDdXJyZW50T3BlblwiXSA9IFwiY3VycmVudF9vcGVuXCI7XG4gICAgQ2FuZGxlQ29sb3JDb21wYXJlUnVsZVtcIlByZXZpb3VzQ2xvc2VcIl0gPSBcInByZXZpb3VzX2Nsb3NlXCI7XG59KShDYW5kbGVDb2xvckNvbXBhcmVSdWxlIHx8IChDYW5kbGVDb2xvckNvbXBhcmVSdWxlID0ge30pKTtcbnZhciBDb2xvciA9IHtcbiAgICBSRUQ6ICcjRjkyODU1JyxcbiAgICBHUkVFTjogJyMyREMwOEUnLFxuICAgIFdISVRFOiAnI0ZGRkZGRicsXG4gICAgR1JFWTogJyM3NjgwOEYnLFxuICAgIEJMVUU6ICcjMTY3N0ZGJ1xufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRHcmlkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICBjb2xvcjogJyNFREVERUQnLFxuICAgICAgICAgICAgc3R5bGU6IExpbmVUeXBlLkRhc2hlZCxcbiAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgY29sb3I6ICcjRURFREVEJyxcbiAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5EYXNoZWQsXG4gICAgICAgICAgICBkYXNoZWRWYWx1ZTogWzIsIDJdXG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgZGVmYXVsdCBjYW5kbGUgc3R5bGVcbiAqIEB0eXBlIHt7YXJlYToge2JhY2tncm91bmRDb2xvcjogW3tvZmZzZXQ6IG51bWJlciwgY29sb3I6IHN0cmluZ30sIHtvZmZzZXQ6IG51bWJlciwgY29sb3I6IHN0cmluZ31dLCBsaW5lQ29sb3I6IHN0cmluZywgbGluZVNpemU6IG51bWJlciwgdmFsdWU6IHN0cmluZ30sIGJhcjoge25vQ2hhbmdlQ29sb3I6IHN0cmluZywgdXBDb2xvcjogc3RyaW5nLCBkb3duQ29sb3I6IHN0cmluZ30sIHRvb2x0aXA6IHtyZWN0OiB7b2Zmc2V0VG9wOiBudW1iZXIsIGZpbGxDb2xvcjogc3RyaW5nLCBib3JkZXJDb2xvcjogc3RyaW5nLCBwYWRkaW5nQm90dG9tOiBudW1iZXIsIGJvcmRlclJhZGl1czogbnVtYmVyLCBwYWRkaW5nUmlnaHQ6IG51bWJlciwgYm9yZGVyU2l6ZTogbnVtYmVyLCBvZmZzZXRMZWZ0OiBudW1iZXIsIHBhZGRpbmdUb3A6IG51bWJlciwgcGFkZGluZ0xlZnQ6IG51bWJlciwgb2Zmc2V0UmlnaHQ6IG51bWJlcn0sIHNob3dSdWxlOiBzdHJpbmcsIHZhbHVlczogbnVsbCwgc2hvd1R5cGU6IHN0cmluZywgdGV4dDoge21hcmdpblJpZ2h0OiBudW1iZXIsIHNpemU6IG51bWJlciwgY29sb3I6IHN0cmluZywgd2VpZ2h0OiBzdHJpbmcsIG1hcmdpbkJvdHRvbTogbnVtYmVyLCBmYW1pbHk6IHN0cmluZywgbWFyZ2luVG9wOiBudW1iZXIsIG1hcmdpbkxlZnQ6IG51bWJlcn0sIGxhYmVsczogc3RyaW5nW119LCB0eXBlOiBzdHJpbmcsIHByaWNlTWFyazoge2hpZ2g6IHt0ZXh0TWFyZ2luOiBudW1iZXIsIHRleHRTaXplOiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIHRleHRGYW1pbHk6IHN0cmluZywgc2hvdzogYm9vbGVhbiwgdGV4dFdlaWdodDogc3RyaW5nfSwgbGFzdDoge25vQ2hhbmdlQ29sb3I6IHN0cmluZywgdXBDb2xvcjogc3RyaW5nLCBsaW5lOiB7ZGFzaFZhbHVlOiBudW1iZXJbXSwgc2l6ZTogbnVtYmVyLCBzaG93OiBib29sZWFuLCBzdHlsZTogc3RyaW5nfSwgc2hvdzogYm9vbGVhbiwgdGV4dDoge3BhZGRpbmdCb3R0b206IG51bWJlciwgc2l6ZTogbnVtYmVyLCBjb2xvcjogc3RyaW5nLCBwYWRkaW5nUmlnaHQ6IG51bWJlciwgc2hvdzogYm9vbGVhbiwgd2VpZ2h0OiBzdHJpbmcsIHBhZGRpbmdUb3A6IG51bWJlciwgZmFtaWx5OiBzdHJpbmcsIHBhZGRpbmdMZWZ0OiBudW1iZXJ9LCBkb3duQ29sb3I6IHN0cmluZ30sIGxvdzoge3RleHRNYXJnaW46IG51bWJlciwgdGV4dFNpemU6IG51bWJlciwgY29sb3I6IHN0cmluZywgdGV4dEZhbWlseTogc3RyaW5nLCBzaG93OiBib29sZWFuLCB0ZXh0V2VpZ2h0OiBzdHJpbmd9LCBzaG93OiBib29sZWFufX19XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRDYW5kbGVTdHlsZSgpIHtcbiAgICB2YXIgaGlnaExvdyA9IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgY29sb3I6IENvbG9yLkdSRVksXG4gICAgICAgIHRleHRPZmZzZXQ6IDUsXG4gICAgICAgIHRleHRTaXplOiAxMCxcbiAgICAgICAgdGV4dEZhbWlseTogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgdGV4dFdlaWdodDogJ25vcm1hbCdcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IENhbmRsZVR5cGUuQ2FuZGxlU29saWQsXG4gICAgICAgIGJhcjoge1xuICAgICAgICAgICAgY29tcGFyZVJ1bGU6IENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUuQ3VycmVudE9wZW4sXG4gICAgICAgICAgICB1cENvbG9yOiBDb2xvci5HUkVFTixcbiAgICAgICAgICAgIGRvd25Db2xvcjogQ29sb3IuUkVELFxuICAgICAgICAgICAgbm9DaGFuZ2VDb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgIHVwQm9yZGVyQ29sb3I6IENvbG9yLkdSRUVOLFxuICAgICAgICAgICAgZG93bkJvcmRlckNvbG9yOiBDb2xvci5SRUQsXG4gICAgICAgICAgICBub0NoYW5nZUJvcmRlckNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICAgICAgdXBXaWNrQ29sb3I6IENvbG9yLkdSRUVOLFxuICAgICAgICAgICAgZG93bldpY2tDb2xvcjogQ29sb3IuUkVELFxuICAgICAgICAgICAgbm9DaGFuZ2VXaWNrQ29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgbGluZVNpemU6IDIsXG4gICAgICAgICAgICBsaW5lQ29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6ICdjbG9zZScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFt7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhleFRvUmdiKENvbG9yLkJMVUUsIDAuMDEpXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoZXhUb1JnYihDb2xvci5CTFVFLCAwLjIpXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgIHJpcHBsZUNvbG9yOiBoZXhUb1JnYihDb2xvci5CTFVFLCAwLjMpLFxuICAgICAgICAgICAgICAgIHJpcHBsZVJhZGl1czogOCxcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJpY2VNYXJrOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgaGlnaDogX19hc3NpZ24oe30sIGhpZ2hMb3cpLFxuICAgICAgICAgICAgbG93OiBfX2Fzc2lnbih7fSwgaGlnaExvdyksXG4gICAgICAgICAgICBsYXN0OiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21wYXJlUnVsZTogQ2FuZGxlQ29sb3JDb21wYXJlUnVsZS5DdXJyZW50T3BlbixcbiAgICAgICAgICAgICAgICB1cENvbG9yOiBDb2xvci5HUkVFTixcbiAgICAgICAgICAgICAgICBkb3duQ29sb3I6IENvbG9yLlJFRCxcbiAgICAgICAgICAgICAgICBub0NoYW5nZUNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IExpbmVUeXBlLkRhc2hlZCxcbiAgICAgICAgICAgICAgICAgICAgZGFzaGVkVmFsdWU6IFs0LCA0XSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA0LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiA0LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclNpemU6IDAsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5XSElURSxcbiAgICAgICAgICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIG9mZnNldExlZnQ6IDQsXG4gICAgICAgICAgICBvZmZzZXRUb3A6IDYsXG4gICAgICAgICAgICBvZmZzZXRSaWdodDogNCxcbiAgICAgICAgICAgIG9mZnNldEJvdHRvbTogNixcbiAgICAgICAgICAgIHNob3dSdWxlOiBUb29sdGlwU2hvd1J1bGUuQWx3YXlzLFxuICAgICAgICAgICAgc2hvd1R5cGU6IFRvb2x0aXBTaG93VHlwZS5TdGFuZGFyZCxcbiAgICAgICAgICAgIGN1c3RvbTogW1xuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICd0aW1lJywgdmFsdWU6ICd7dGltZX0nIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ29wZW4nLCB2YWx1ZTogJ3tvcGVufScgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAnaGlnaCcsIHZhbHVlOiAne2hpZ2h9JyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdsb3cnLCB2YWx1ZTogJ3tsb3d9JyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdjbG9zZScsIHZhbHVlOiAne2Nsb3NlfScgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAndm9sdW1lJywgdmFsdWU6ICd7dm9sdW1lfScgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ24vYScsXG4gICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24uRml4ZWQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogNCxcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiA0LFxuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogNCxcbiAgICAgICAgICAgICAgICBvZmZzZXRSaWdodDogNCxcbiAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b206IDQsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgICAgICAgICAgICAgIGJvcmRlclNpemU6IDEsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjRjJGM0Y1JyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNGRUZFRkUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZhbWlseTogJ0hlbHZldGljYSBOZXVlJyxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDgsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiA0LFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiA4LFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogR2V0IGRlZmF1bHQgaW5kaWNhdG9yIHN0eWxlXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRJbmRpY2F0b3JTdHlsZSgpIHtcbiAgICB2YXIgYWxwaGFHcmVlbiA9IGhleFRvUmdiKENvbG9yLkdSRUVOLCAwLjcpO1xuICAgIHZhciBhbHBoYVJlZCA9IGhleFRvUmdiKENvbG9yLlJFRCwgMC43KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvaGxjOiB7XG4gICAgICAgICAgICBjb21wYXJlUnVsZTogQ2FuZGxlQ29sb3JDb21wYXJlUnVsZS5DdXJyZW50T3BlbixcbiAgICAgICAgICAgIHVwQ29sb3I6IGFscGhhR3JlZW4sXG4gICAgICAgICAgICBkb3duQ29sb3I6IGFscGhhUmVkLFxuICAgICAgICAgICAgbm9DaGFuZ2VDb2xvcjogQ29sb3IuR1JFWVxuICAgICAgICB9LFxuICAgICAgICBiYXJzOiBbe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl0sXG4gICAgICAgICAgICAgICAgdXBDb2xvcjogYWxwaGFHcmVlbixcbiAgICAgICAgICAgICAgICBkb3duQ29sb3I6IGFscGhhUmVkLFxuICAgICAgICAgICAgICAgIG5vQ2hhbmdlQ29sb3I6IENvbG9yLkdSRVlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBsaW5lczogWycjRkY5NjAwJywgJyM5MzVFQkQnLCBDb2xvci5CTFVFLCAnI0UxMUQ3NCcsICcjMDFDNUM0J10ubWFwKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgZGFzaGVkVmFsdWU6IFsyLCAyXSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9KTsgfSksXG4gICAgICAgIGNpcmNsZXM6IFt7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLkZpbGwsXG4gICAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgICAgIGJvcmRlclNpemU6IDEsXG4gICAgICAgICAgICAgICAgYm9yZGVyRGFzaGVkVmFsdWU6IFsyLCAyXSxcbiAgICAgICAgICAgICAgICB1cENvbG9yOiBhbHBoYUdyZWVuLFxuICAgICAgICAgICAgICAgIGRvd25Db2xvcjogYWxwaGFSZWQsXG4gICAgICAgICAgICAgICAgbm9DaGFuZ2VDb2xvcjogQ29sb3IuR1JFWVxuICAgICAgICAgICAgfV0sXG4gICAgICAgIGxhc3RWYWx1ZU1hcms6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5XSElURSxcbiAgICAgICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgICAgICBmYW1pbHk6ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyU2l6ZTogMCxcbiAgICAgICAgICAgICAgICBib3JkZXJEYXNoZWRWYWx1ZTogWzIsIDJdLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIG9mZnNldExlZnQ6IDQsXG4gICAgICAgICAgICBvZmZzZXRUb3A6IDYsXG4gICAgICAgICAgICBvZmZzZXRSaWdodDogNCxcbiAgICAgICAgICAgIG9mZnNldEJvdHRvbTogNixcbiAgICAgICAgICAgIHNob3dSdWxlOiBUb29sdGlwU2hvd1J1bGUuQWx3YXlzLFxuICAgICAgICAgICAgc2hvd1R5cGU6IFRvb2x0aXBTaG93VHlwZS5TdGFuZGFyZCxcbiAgICAgICAgICAgIHNob3dOYW1lOiB0cnVlLFxuICAgICAgICAgICAgc2hvd1BhcmFtczogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJ24vYScsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgY29sb3I6IENvbG9yLkdSRVksXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogOCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDQsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IDgsXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiA0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEF4aXNTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBzaXplOiAnYXV0bycsXG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6ICcjREREREREJyxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfSxcbiAgICAgICAgdGlja1RleHQ6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBjb2xvcjogQ29sb3IuR1JFWSxcbiAgICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICAgICAgZmFtaWx5OiAnSGVsdmV0aWNhIE5ldWUnLFxuICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgIG1hcmdpblN0YXJ0OiA0LFxuICAgICAgICAgICAgbWFyZ2luRW5kOiA2XG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIGxlbmd0aDogMyxcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q3Jvc3NoYWlyU3R5bGUoKSB7XG4gICAgZnVuY3Rpb24gaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogTGluZVR5cGUuRGFzaGVkLFxuICAgICAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbNCwgMl0sXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBjb2xvcjogQ29sb3IuR1JFWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBDb2xvci5XSElURSxcbiAgICAgICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgICAgICBmYW1pbHk6ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogTGluZVR5cGUuU29saWQsXG4gICAgICAgICAgICAgICAgYm9yZGVyRGFzaGVkVmFsdWU6IFsyLCAyXSxcbiAgICAgICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBDb2xvci5HUkVZLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuR1JFWVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICBob3Jpem9udGFsOiBpdGVtKCksXG4gICAgICAgIHZlcnRpY2FsOiBpdGVtKClcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdE92ZXJsYXlTdHlsZSgpIHtcbiAgICB2YXIgcG9pbnRCb3JkZXJDb2xvciA9IGhleFRvUmdiKENvbG9yLkJMVUUsIDAuMzUpO1xuICAgIHZhciBhbHBoYUJnID0gaGV4VG9SZ2IoQ29sb3IuQkxVRSwgMC4yNSk7XG4gICAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5GaWxsLFxuICAgICAgICAgICAgY29sb3I6IENvbG9yLldISVRFLFxuICAgICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgICAgICBmYW1pbHk6ICdIZWx2ZXRpY2EgTmV1ZScsXG4gICAgICAgICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgYm9yZGVyRGFzaGVkVmFsdWU6IFsyLCAyXSxcbiAgICAgICAgICAgIGJvcmRlclNpemU6IDEsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA0LFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogNCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLkJMVUVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHBvaW50Qm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgYWN0aXZlQ29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICBhY3RpdmVCb3JkZXJDb2xvcjogcG9pbnRCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIGFjdGl2ZUJvcmRlclNpemU6IDMsXG4gICAgICAgICAgICBhY3RpdmVSYWRpdXM6IDVcbiAgICAgICAgfSxcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgc3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLkZpbGwsXG4gICAgICAgICAgICBjb2xvcjogYWxwaGFCZyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbjoge1xuICAgICAgICAgICAgc3R5bGU6IFBvbHlnb25UeXBlLkZpbGwsXG4gICAgICAgICAgICBjb2xvcjogQ29sb3IuQkxVRSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgYm9yZGVyU2l6ZTogMSxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgY2lyY2xlOiB7XG4gICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuRmlsbCxcbiAgICAgICAgICAgIGNvbG9yOiBhbHBoYUJnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IENvbG9yLkJMVUUsXG4gICAgICAgICAgICBib3JkZXJTaXplOiAxLFxuICAgICAgICAgICAgYm9yZGVyU3R5bGU6IExpbmVUeXBlLlNvbGlkLFxuICAgICAgICAgICAgYm9yZGVyRGFzaGVkVmFsdWU6IFsyLCAyXVxuICAgICAgICB9LFxuICAgICAgICBhcmM6IHtcbiAgICAgICAgICAgIHN0eWxlOiBMaW5lVHlwZS5Tb2xpZCxcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvci5CTFVFLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIGRhc2hlZFZhbHVlOiBbMiwgMl1cbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogdGV4dCgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTZXBhcmF0b3JTdHlsZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICBjb2xvcjogJyNEREREREQnLFxuICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICBhY3RpdmVCYWNrZ3JvdW5kQ29sb3I6IGhleFRvUmdiKENvbG9yLkJMVUUsIDAuMDgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JpZDogZ2V0RGVmYXVsdEdyaWRTdHlsZSgpLFxuICAgICAgICBjYW5kbGU6IGdldERlZmF1bHRDYW5kbGVTdHlsZSgpLFxuICAgICAgICBpbmRpY2F0b3I6IGdldERlZmF1bHRJbmRpY2F0b3JTdHlsZSgpLFxuICAgICAgICB4QXhpczogZ2V0RGVmYXVsdEF4aXNTdHlsZSgpLFxuICAgICAgICB5QXhpczogZ2V0RGVmYXVsdEF4aXNTdHlsZSgpLFxuICAgICAgICBzZXBhcmF0b3I6IGdldERlZmF1bHRTZXBhcmF0b3JTdHlsZSgpLFxuICAgICAgICBjcm9zc2hhaXI6IGdldERlZmF1bHRDcm9zc2hhaXJTdHlsZSgpLFxuICAgICAgICBvdmVybGF5OiBnZXREZWZhdWx0T3ZlcmxheVN0eWxlKClcbiAgICB9O1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERVYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcbmZ1bmN0aW9uIGxvZyh0ZW1wbGF0ZVRleHQsIHRhZ1N0eWxlLCBtZXNzYWdlU3R5bGUsIGFwaSwgaW52YWxpZFBhcmFtLCBhcHBlbmQpIHtcbiAgICBpZiAoREVWKSB7XG4gICAgICAgIHZhciBhcGlTdHIgPSBhcGkgIT09ICcnID8gXCJDYWxsIGFwaSBgXCIuY29uY2F0KGFwaSwgXCJgXCIpLmNvbmNhdChpbnZhbGlkUGFyYW0gIT09ICcnIHx8IGFwcGVuZCAhPT0gJycgPyAnLCAnIDogJy4nKSA6ICcnO1xuICAgICAgICB2YXIgaW52YWxpZFBhcmFtU3RyID0gaW52YWxpZFBhcmFtICE9PSAnJyA/IFwiaW52YWxpZCBwYXJhbWV0ZXIgYFwiLmNvbmNhdChpbnZhbGlkUGFyYW0sIFwiYFwiKS5jb25jYXQoYXBwZW5kICE9PSAnJyA/ICcsICcgOiAnLicpIDogJyc7XG4gICAgICAgIHZhciBhcHBlbmRTdHIgPSBhcHBlbmQgIT09ICcnID8gYXBwZW5kIDogJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKHRlbXBsYXRlVGV4dCwgdGFnU3R5bGUsIG1lc3NhZ2VTdHlsZSwgYXBpU3RyLCBpbnZhbGlkUGFyYW1TdHIsIGFwcGVuZFN0cik7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9nV2FybihhcGksIGludmFsaWRQYXJhbSwgYXBwZW5kKSB7XG4gICAgbG9nKCclY/CfmJEga2xpbmVjaGFydHMgd2FybmluZyVjICVzJXMlcycsICdwYWRkaW5nOjNweCA0cHg7Ym9yZGVyLXJhZGl1czoycHg7Y29sb3I6I2ZmZmZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNGRjk2MDAnLCAnY29sb3I6I0ZGOTYwMCcsIGFwaSwgaW52YWxpZFBhcmFtLCBhcHBlbmQgIT09IG51bGwgJiYgYXBwZW5kICE9PSB2b2lkIDAgPyBhcHBlbmQgOiAnJyk7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihhcGksIGludmFsaWRQYXJhbSwgYXBwZW5kKSB7XG4gICAgbG9nKCclY/CfmJ8ga2xpbmVjaGFydHMgZXJyb3IlYyAlcyVzJXMnLCAncGFkZGluZzozcHggNHB4O2JvcmRlci1yYWRpdXM6MnB4O2NvbG9yOiNmZmZmZmY7YmFja2dyb3VuZC1jb2xvcjojRjkyODU1OycsICdjb2xvcjojRjkyODU1OycsIGFwaSwgaW52YWxpZFBhcmFtLCBhcHBlbmQgKTtcbn1cbmZ1bmN0aW9uIGxvZ1RhZygpIHtcbiAgICBsb2coJyVj4p2k77iPIFdlbGNvbWUgdG8ga2xpbmVjaGFydHMuIFZlcnNpb24gaXMgMTAuMC4wLWFscGhhNScsICdib3JkZXItcmFkaXVzOjRweDtib3JkZXI6ZGFzaGVkIDFweCAjMTY3N0ZGO2xpbmUtaGVpZ2h0OjcwcHg7cGFkZGluZzowIDIwcHg7bWFyZ2luOjE2cHggMDtmb250LXNpemU6MTRweDtjb2xvcjojMTY3N0ZGOycsICcnLCAnJywgJycsICcnKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG52YXIgcmVQcm9wTmFtZSA9IFJlZ0V4cCgnW14uW1xcXFxdXSsnICsgJ3wnICtcbiAgICAnXFxcXFsoPzonICtcbiAgICAnKFteXCJcXCddW15bXSopJyArICd8JyArXG4gICAgJyhbXCJcXCddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDInICtcbiAgICAnKVxcXFxdJyArICd8JyArXG4gICAgJyg/PSg/OlxcXFwufFxcXFxbXFxcXF0pKD86XFxcXC58XFxcXFtcXFxcXXwkKSknLCAnZycpO1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUoZGF0YSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICB2YXIgcGF0aF8xID0gW107XG4gICAgICAgIGtleS5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChzdWJTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IHN1YlN0cmluZztcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgayA9IGFyZ3NbMl0ucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZChhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIGsgPSBhcmdzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhfMS5wdXNoKGspO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZGF0YTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gcGF0aF8xLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlzVmFsaWQodmFsdWUpICYmIGluZGV4IDwgbGVuZ3RoXzEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlW3BhdGhfMVtpbmRleCsrXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodmFsdWUpID8gdmFsdWUgOiAoZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogJy0tJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB2b2lkIDAgPyBkZWZhdWx0VmFsdWUgOiAnLS0nO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZXN0YW1wVG9EYXRlVGltZShkYXRlVGltZUZvcm1hdCwgdGltZXN0YW1wKSB7XG4gICAgdmFyIGRhdGUgPSB7fTtcbiAgICBkYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzKG5ldyBEYXRlKHRpbWVzdGFtcCkpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzoge1xuICAgICAgICAgICAgICAgIGRhdGUuWVlZWSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiB7XG4gICAgICAgICAgICAgICAgZGF0ZS5NTSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGF5Jzoge1xuICAgICAgICAgICAgICAgIGRhdGUuREQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiB7XG4gICAgICAgICAgICAgICAgZGF0ZS5ISCA9IHZhbHVlID09PSAnMjQnID8gJzAwJyA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzoge1xuICAgICAgICAgICAgICAgIGRhdGUubW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IHtcbiAgICAgICAgICAgICAgICBkYXRlLnNzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVzdGFtcFRvU3RyaW5nKGRhdGVUaW1lRm9ybWF0LCB0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgIHZhciBkYXRlID0gZm9ybWF0VGltZXN0YW1wVG9EYXRlVGltZShkYXRlVGltZUZvcm1hdCwgdGltZXN0YW1wKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gLS0gaWdub3JlXG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC9ZWVlZfE1NfEREfEhIfG1tfHNzL2csIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRhdGVba2V5XTsgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgIHZhciB2ID0gK3ZhbHVlO1xuICAgIGlmIChpc051bWJlcih2KSkge1xuICAgICAgICByZXR1cm4gdi50b0ZpeGVkKHByZWNpc2lvbiAhPT0gbnVsbCAmJiBwcmVjaXNpb24gIT09IHZvaWQgMCA/IHByZWNpc2lvbiA6IDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gZm9ybWF0QmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIHYgPSArdmFsdWU7XG4gICAgaWYgKGlzTnVtYmVyKHYpKSB7XG4gICAgICAgIGlmICh2ID4gMTAwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KCsoKHYgLyAxMDAwMDAwMDAwKS50b0ZpeGVkKDMpKSwgXCJCXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID4gMTAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KCsoKHYgLyAxMDAwMDAwKS50b0ZpeGVkKDMpKSwgXCJNXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID4gMTAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KCsoKHYgLyAxMDAwKS50b0ZpeGVkKDMpKSwgXCJLXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRUaG91c2FuZHModmFsdWUsIHNpZ24pIHtcbiAgICB2YXIgdmwgPSBcIlwiLmNvbmNhdCh2YWx1ZSk7XG4gICAgaWYgKHNpZ24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2bDtcbiAgICB9XG4gICAgaWYgKHZsLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgdmFyIGFyciA9IHZsLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhcnJbMF0ucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSskKS9nLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuIFwiXCIuY29uY2F0KCQxKS5jb25jYXQoc2lnbik7IH0pLCBcIi5cIikuY29uY2F0KGFyclsxXSk7XG4gICAgfVxuICAgIHJldHVybiB2bC5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyQpL2csIGZ1bmN0aW9uICgkMSkgeyByZXR1cm4gXCJcIi5jb25jYXQoJDEpLmNvbmNhdChzaWduKTsgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRGb2xkRGVjaW1hbCh2YWx1ZSwgdGhyZXNob2xkKSB7XG4gICAgdmFyIHZsID0gXCJcIi5jb25jYXQodmFsdWUpO1xuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKCdcXFxcLjB7JyArIHRocmVzaG9sZCArICcsfVsxLTldWzAtOV0qJCcpO1xuICAgIGlmIChyZWcudGVzdCh2bCkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHZsLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHYgPSByZXN1bHRbbGFzdEluZGV4XTtcbiAgICAgICAgdmFyIG1hdGNoID0gLzAqLy5leGVjKHYpO1xuICAgICAgICBpZiAoaXNWYWxpZChtYXRjaCkpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdFtsYXN0SW5kZXhdID0gdi5yZXBsYWNlKC8wKi8sIFwiMHtcIi5jb25jYXQoY291bnQsIFwifVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmw7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIG1lYXN1cmVDdHggPSBudWxsO1xuLyoqXG4gKiBHZXQgcGl4ZWwgcmF0aW9cbiAqIEBwYXJhbSBjYW52YXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oY2FudmFzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gY2FudmFzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VQaXhlbFJhdGlvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9udChzaXplLCB3ZWlnaHQsIGZhbWlseSkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh3ZWlnaHQgIT09IG51bGwgJiYgd2VpZ2h0ICE9PSB2b2lkIDAgPyB3ZWlnaHQgOiAnbm9ybWFsJywgXCIgXCIpLmNvbmNhdChzaXplICE9PSBudWxsICYmIHNpemUgIT09IHZvaWQgMCA/IHNpemUgOiAxMiwgXCJweCBcIikuY29uY2F0KGZhbWlseSAhPT0gbnVsbCAmJiBmYW1pbHkgIT09IHZvaWQgMCA/IGZhbWlseSA6ICdIZWx2ZXRpY2EgTmV1ZScpO1xufVxuLyoqXG4gKiBNZWFzdXJlIHRoZSB3aWR0aCBvZiB0ZXh0XG4gKiBAcGFyYW0gdGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2FsY1RleHRXaWR0aCh0ZXh0LCBzaXplLCB3ZWlnaHQsIGZhbWlseSkge1xuICAgIGlmICghaXNWYWxpZChtZWFzdXJlQ3R4KSkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXMpO1xuICAgICAgICBtZWFzdXJlQ3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIG1lYXN1cmVDdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIG1lYXN1cmVDdHguZm9udCA9IGNyZWF0ZUZvbnQoc2l6ZSwgd2VpZ2h0LCBmYW1pbHkpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1lYXN1cmVDdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGgpO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBBY3Rpb25UeXBlO1xuKGZ1bmN0aW9uIChBY3Rpb25UeXBlKSB7XG4gICAgQWN0aW9uVHlwZVtcIk9uWm9vbVwiXSA9IFwib25ab29tXCI7XG4gICAgQWN0aW9uVHlwZVtcIk9uU2Nyb2xsXCJdID0gXCJvblNjcm9sbFwiO1xuICAgIEFjdGlvblR5cGVbXCJPblZpc2libGVSYW5nZUNoYW5nZVwiXSA9IFwib25WaXNpYmxlUmFuZ2VDaGFuZ2VcIjtcbiAgICBBY3Rpb25UeXBlW1wiT25DYW5kbGVUb29sdGlwRmVhdHVyZUNsaWNrXCJdID0gXCJvbkNhbmRsZVRvb2x0aXBGZWF0dXJlQ2xpY2tcIjtcbiAgICBBY3Rpb25UeXBlW1wiT25Dcm9zc2hhaXJDaGFuZ2VcIl0gPSBcIm9uQ3Jvc3NoYWlyQ2hhbmdlXCI7XG4gICAgQWN0aW9uVHlwZVtcIk9uQ2FuZGxlQmFyQ2xpY2tcIl0gPSBcIm9uQ2FuZGxlQmFyQ2xpY2tcIjtcbiAgICBBY3Rpb25UeXBlW1wiT25QYW5lRHJhZ1wiXSA9IFwib25QYW5lRHJhZ1wiO1xufSkoQWN0aW9uVHlwZSB8fCAoQWN0aW9uVHlwZSA9IHt9KSk7XG52YXIgQWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIEFjdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBY3Rpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFjdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSW5kaWNhdG9yU2VyaWVzO1xuKGZ1bmN0aW9uIChJbmRpY2F0b3JTZXJpZXMpIHtcbiAgICBJbmRpY2F0b3JTZXJpZXNbXCJOb3JtYWxcIl0gPSBcIm5vcm1hbFwiO1xuICAgIEluZGljYXRvclNlcmllc1tcIlByaWNlXCJdID0gXCJwcmljZVwiO1xuICAgIEluZGljYXRvclNlcmllc1tcIlZvbHVtZVwiXSA9IFwidm9sdW1lXCI7XG59KShJbmRpY2F0b3JTZXJpZXMgfHwgKEluZGljYXRvclNlcmllcyA9IHt9KSk7XG52YXIgSW5kaWNhdG9yRXZlbnRUYXJnZXQ7XG4oZnVuY3Rpb24gKEluZGljYXRvckV2ZW50VGFyZ2V0KSB7XG4gICAgSW5kaWNhdG9yRXZlbnRUYXJnZXRbXCJGZWF0dXJlXCJdID0gXCJmZWF0dXJlXCI7XG59KShJbmRpY2F0b3JFdmVudFRhcmdldCB8fCAoSW5kaWNhdG9yRXZlbnRUYXJnZXQgPSB7fSkpO1xudmFyIEluZGljYXRvckRhdGFTdGF0ZTtcbihmdW5jdGlvbiAoSW5kaWNhdG9yRGF0YVN0YXRlKSB7XG4gICAgSW5kaWNhdG9yRGF0YVN0YXRlW1wiTG9hZGluZ1wiXSA9IFwibG9hZGluZ1wiO1xuICAgIEluZGljYXRvckRhdGFTdGF0ZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIEluZGljYXRvckRhdGFTdGF0ZVtcIlJlYWR5XCJdID0gXCJyZWFkeVwiO1xufSkoSW5kaWNhdG9yRGF0YVN0YXRlIHx8IChJbmRpY2F0b3JEYXRhU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gZWFjaEZpZ3VyZXMoaW5kaWNhdG9yLCBkYXRhSW5kZXgsIGRlZmF1bHRTdHlsZXMsIGVhY2hGaWd1cmVDYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBpbmRpY2F0b3IucmVzdWx0O1xuICAgIHZhciBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXM7XG4gICAgdmFyIHN0eWxlcyA9IGluZGljYXRvci5zdHlsZXM7XG4gICAgdmFyIGNpcmNsZVN0eWxlcyA9IGZvcm1hdFZhbHVlKHN0eWxlcywgJ2NpcmNsZXMnLCBkZWZhdWx0U3R5bGVzLmNpcmNsZXMpO1xuICAgIHZhciBjaXJjbGVTdHlsZUNvdW50ID0gY2lyY2xlU3R5bGVzLmxlbmd0aDtcbiAgICB2YXIgYmFyU3R5bGVzID0gZm9ybWF0VmFsdWUoc3R5bGVzLCAnYmFycycsIGRlZmF1bHRTdHlsZXMuYmFycyk7XG4gICAgdmFyIGJhclN0eWxlQ291bnQgPSBiYXJTdHlsZXMubGVuZ3RoO1xuICAgIHZhciBsaW5lU3R5bGVzID0gZm9ybWF0VmFsdWUoc3R5bGVzLCAnbGluZXMnLCBkZWZhdWx0U3R5bGVzLmxpbmVzKTtcbiAgICB2YXIgbGluZVN0eWxlQ291bnQgPSBsaW5lU3R5bGVzLmxlbmd0aDtcbiAgICB2YXIgY2lyY2xlQ291bnQgPSAwO1xuICAgIHZhciBiYXJDb3VudCA9IDA7XG4gICAgdmFyIGxpbmVDb3VudCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9pbml0LWRlY2xhcmF0aW9ucyAgLS0gaWdub3JlXG4gICAgdmFyIGRlZmF1bHRGaWd1cmVTdHlsZXM7XG4gICAgdmFyIGZpZ3VyZUluZGV4ID0gMDtcbiAgICBmaWd1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZpZ3VyZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NpcmNsZSc6IHtcbiAgICAgICAgICAgICAgICBmaWd1cmVJbmRleCA9IGNpcmNsZUNvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXNfMSA9IGNpcmNsZVN0eWxlc1tjaXJjbGVDb3VudCAlIGNpcmNsZVN0eWxlQ291bnRdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRGaWd1cmVTdHlsZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3R5bGVzXzEpLCB7IGNvbG9yOiBzdHlsZXNfMS5ub0NoYW5nZUNvbG9yIH0pO1xuICAgICAgICAgICAgICAgIGNpcmNsZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdiYXInOiB7XG4gICAgICAgICAgICAgICAgZmlndXJlSW5kZXggPSBiYXJDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzXzIgPSBiYXJTdHlsZXNbYmFyQ291bnQgJSBiYXJTdHlsZUNvdW50XTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RmlndXJlU3R5bGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlc18yKSwgeyBjb2xvcjogc3R5bGVzXzIubm9DaGFuZ2VDb2xvciB9KTtcbiAgICAgICAgICAgICAgICBiYXJDb3VudCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGluZSc6IHtcbiAgICAgICAgICAgICAgICBmaWd1cmVJbmRleCA9IGxpbmVDb3VudDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RmlndXJlU3R5bGVzID0gbGluZVN0eWxlc1tsaW5lQ291bnQgJSBsaW5lU3R5bGVDb3VudF07XG4gICAgICAgICAgICAgICAgbGluZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWQoZmlndXJlLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc3MgPSAoX2EgPSBmaWd1cmUuc3R5bGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChmaWd1cmUsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXY6IHJlc3VsdFtkYXRhSW5kZXggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogcmVzdWx0W2RhdGFJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IHJlc3VsdFtkYXRhSW5kZXggKyAxXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yOiBpbmRpY2F0b3IsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0eWxlczogZGVmYXVsdFN0eWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIGVhY2hGaWd1cmVDYWxsYmFjayhmaWd1cmUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0RmlndXJlU3R5bGVzKSwgc3MpLCBmaWd1cmVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciBJbmRpY2F0b3JJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5kaWNhdG9ySW1wKGluZGljYXRvcikge1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IDQ7XG4gICAgICAgIHRoaXMuY2FsY1BhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLnNob3VsZE9obGMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRGb3JtYXRCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy56TGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLnNlcmllcyA9IEluZGljYXRvclNlcmllcy5Ob3JtYWw7XG4gICAgICAgIHRoaXMuZmlndXJlcyA9IFtdO1xuICAgICAgICB0aGlzLm1pblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSBmdW5jdGlvbiAocHJldiwgY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGNhbGMgPSBKU09OLnN0cmluZ2lmeShwcmV2LmNhbGNQYXJhbXMpICE9PSBKU09OLnN0cmluZ2lmeShjdXJyZW50LmNhbGNQYXJhbXMpIHx8XG4gICAgICAgICAgICAgICAgcHJldi5maWd1cmVzICE9PSBjdXJyZW50LmZpZ3VyZXMgfHxcbiAgICAgICAgICAgICAgICBwcmV2LmNhbGMgIT09IGN1cnJlbnQuY2FsYztcbiAgICAgICAgICAgIHZhciBkcmF3ID0gY2FsYyB8fFxuICAgICAgICAgICAgICAgIHByZXYuc2hvcnROYW1lICE9PSBjdXJyZW50LnNob3J0TmFtZSB8fFxuICAgICAgICAgICAgICAgIHByZXYuc2VyaWVzICE9PSBjdXJyZW50LnNlcmllcyB8fFxuICAgICAgICAgICAgICAgIHByZXYubWluVmFsdWUgIT09IGN1cnJlbnQubWluVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBwcmV2Lm1heFZhbHVlICE9PSBjdXJyZW50Lm1heFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgcHJldi5wcmVjaXNpb24gIT09IGN1cnJlbnQucHJlY2lzaW9uIHx8XG4gICAgICAgICAgICAgICAgcHJldi5zaG91bGRPaGxjICE9PSBjdXJyZW50LnNob3VsZE9obGMgfHxcbiAgICAgICAgICAgICAgICBwcmV2LnNob3VsZEZvcm1hdEJpZ051bWJlciAhPT0gY3VycmVudC5zaG91bGRGb3JtYXRCaWdOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICBwcmV2LnZpc2libGUgIT09IGN1cnJlbnQudmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgIHByZXYuekxldmVsICE9PSBjdXJyZW50LnpMZXZlbCB8fFxuICAgICAgICAgICAgICAgIHByZXYuZXh0ZW5kRGF0YSAhPT0gY3VycmVudC5leHRlbmREYXRhIHx8XG4gICAgICAgICAgICAgICAgcHJldi5yZWdlbmVyYXRlRmlndXJlcyAhPT0gY3VycmVudC5yZWdlbmVyYXRlRmlndXJlcyB8fFxuICAgICAgICAgICAgICAgIHByZXYuY3JlYXRlVG9vbHRpcERhdGFTb3VyY2UgIT09IGN1cnJlbnQuY3JlYXRlVG9vbHRpcERhdGFTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICBwcmV2LmRyYXcgIT09IGN1cnJlbnQuZHJhdztcbiAgICAgICAgICAgIHJldHVybiB7IGNhbGM6IGNhbGMsIGRyYXc6IGRyYXcgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHRoaXMucmVnZW5lcmF0ZUZpZ3VyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBEYXRhU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmF3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkRhdGFTdGF0ZUNoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX2xvY2tTZXJpZXNQcmVjaXNpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdmVycmlkZShpbmRpY2F0b3IpO1xuICAgICAgICB0aGlzLl9sb2NrU2VyaWVzUHJlY2lzaW9uID0gZmFsc2U7XG4gICAgfVxuICAgIEluZGljYXRvckltcC5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfYyA9IHRoaXMsIHJlc3VsdCA9IF9jLnJlc3VsdCwgY3VycmVudE90aGVycyA9IF9fcmVzdChfYywgW1wicmVzdWx0XCJdKTtcbiAgICAgICAgdGhpcy5fcHJldkluZGljYXRvciA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjbG9uZShjdXJyZW50T3RoZXJzKSksIHsgcmVzdWx0OiByZXN1bHQgfSk7XG4gICAgICAgIHZhciBpZCA9IGluZGljYXRvci5pZCwgbmFtZSA9IGluZGljYXRvci5uYW1lLCBzaG9ydE5hbWUgPSBpbmRpY2F0b3Iuc2hvcnROYW1lLCBwcmVjaXNpb24gPSBpbmRpY2F0b3IucHJlY2lzaW9uLCBzdHlsZXMgPSBpbmRpY2F0b3Iuc3R5bGVzLCBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXMsIGNhbGNQYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcywgb3RoZXJzID0gX19yZXN0KGluZGljYXRvciwgW1wiaWRcIiwgXCJuYW1lXCIsIFwic2hvcnROYW1lXCIsIFwicHJlY2lzaW9uXCIsIFwic3R5bGVzXCIsIFwiZmlndXJlc1wiLCBcImNhbGNQYXJhbXNcIl0pO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMuaWQpICYmIGlzU3RyaW5nKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJpbmcodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gIC0tIGlnbm9yZVxuICAgICAgICB0aGlzLnNob3J0TmFtZSA9IChfYSA9IHNob3J0TmFtZSAhPT0gbnVsbCAmJiBzaG9ydE5hbWUgIT09IHZvaWQgMCA/IHNob3J0TmFtZSA6IHRoaXMuc2hvcnROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLm5hbWU7XG4gICAgICAgIGlmIChpc051bWJlcihwcmVjaXNpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2xvY2tTZXJpZXNQcmVjaXNpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKHN0eWxlcykpIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuc3R5bGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAodGhpcy5zdHlsZXMgPSB7fSk7XG4gICAgICAgICAgICBtZXJnZSh0aGlzLnN0eWxlcywgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZSh0aGlzLCBvdGhlcnMpO1xuICAgICAgICBpZiAoaXNWYWxpZChjYWxjUGFyYW1zKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxjUGFyYW1zID0gY2FsY1BhcmFtcztcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMucmVnZW5lcmF0ZUZpZ3VyZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWd1cmVzID0gdGhpcy5yZWdlbmVyYXRlRmlndXJlcyh0aGlzLmNhbGNQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlndXJlcyA9IGZpZ3VyZXMgIT09IG51bGwgJiYgZmlndXJlcyAhPT0gdm9pZCAwID8gZmlndXJlcyA6IHRoaXMuZmlndXJlcztcbiAgICB9O1xuICAgIEluZGljYXRvckltcC5wcm90b3R5cGUuc2V0U2VyaWVzUHJlY2lzaW9uID0gZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2tTZXJpZXNQcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmRpY2F0b3JJbXAucHJvdG90eXBlLnNob3VsZFVwZGF0ZUltcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNvcnQgPSB0aGlzLl9wcmV2SW5kaWNhdG9yLnpMZXZlbCAhPT0gdGhpcy56TGV2ZWw7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNob3VsZFVwZGF0ZSh0aGlzLl9wcmV2SW5kaWNhdG9yLCB0aGlzKTtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjYWxjOiByZXN1bHQsIGRyYXc6IHJlc3VsdCwgc29ydDogc29ydCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgeyBzb3J0OiBzb3J0IH0pO1xuICAgIH07XG4gICAgSW5kaWNhdG9ySW1wLnByb3RvdHlwZS5jYWxjSW1wID0gZnVuY3Rpb24gKGRhdGFMaXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxjKGRhdGFMaXN0LCB0aGlzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JJbXAuZXh0ZW5kID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBDdXN0b20gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3VzdG9tKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0ZW1wbGF0ZSkgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDdXN0b207XG4gICAgICAgIH0oSW5kaWNhdG9ySW1wKSk7XG4gICAgICAgIHJldHVybiBDdXN0b207XG4gICAgfTtcbiAgICByZXR1cm4gSW5kaWNhdG9ySW1wO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgT3ZlcmxheU1vZGU7XG4oZnVuY3Rpb24gKE92ZXJsYXlNb2RlKSB7XG4gICAgT3ZlcmxheU1vZGVbXCJOb3JtYWxcIl0gPSBcIm5vcm1hbFwiO1xuICAgIE92ZXJsYXlNb2RlW1wiV2Vha01hZ25ldFwiXSA9IFwid2Vha19tYWduZXRcIjtcbiAgICBPdmVybGF5TW9kZVtcIlN0cm9uZ01hZ25ldFwiXSA9IFwic3Ryb25nX21hZ25ldFwiO1xufSkoT3ZlcmxheU1vZGUgfHwgKE92ZXJsYXlNb2RlID0ge30pKTtcbmZ1bmN0aW9uIGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KHRhcmdldEV2ZW50VHlwZSwgZmlndXJlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBpZ25vcmVFdmVudCA9IChfYSA9IGZpZ3VyZSA9PT0gbnVsbCB8fCBmaWd1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZ3VyZS5pZ25vcmVFdmVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgaWYgKGlzQm9vbGVhbihpZ25vcmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuICFpZ25vcmVFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuICFpZ25vcmVFdmVudC5pbmNsdWRlcyh0YXJnZXRFdmVudFR5cGUpO1xufVxudmFyIE9WRVJMQVlfRFJBV19TVEVQX1NUQVJUID0gMTtcbnZhciBPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRCA9IC0xO1xudmFyIE9WRVJMQVlfSURfUFJFRklYID0gJ292ZXJsYXlfJztcbnZhciBPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYID0gJ292ZXJsYXlfZmlndXJlXyc7XG52YXIgT3ZlcmxheUltcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5SW1wKG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy5ncm91cElkID0gJyc7XG4gICAgICAgIHRoaXMudG90YWxTdGVwID0gMTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IE9WRVJMQVlfRFJBV19TVEVQX1NUQVJUO1xuICAgICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy56TGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLm5lZWREZWZhdWx0UG9pbnRGaWd1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZWVkRGVmYXVsdFhBeGlzRmlndXJlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmVlZERlZmF1bHRZQXhpc0ZpZ3VyZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vZGUgPSBPdmVybGF5TW9kZS5Ob3JtYWw7XG4gICAgICAgIHRoaXMubW9kZVNlbnNpdGl2aXR5ID0gODtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmNyZWF0ZVBvaW50RmlndXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3JlYXRlWEF4aXNGaWd1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jcmVhdGVZQXhpc0ZpZ3VyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBlcmZvcm1FdmVudFByZXNzZWRNb3ZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMub25EcmF3U3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uRHJhd2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMub25EcmF3RW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkRvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblJpZ2h0Q2xpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUHJlc3NlZE1vdmVTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMub25QcmVzc2VkTW92aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblByZXNzZWRNb3ZlRW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk1vdXNlRW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uTW91c2VMZWF2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25SZW1vdmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkRlc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmV2WkxldmVsID0gMDtcbiAgICAgICAgdGhpcy5fcHJldlByZXNzZWRQb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXZQcmVzc2VkUG9pbnRzID0gW107XG4gICAgICAgIHRoaXMub3ZlcnJpZGUob3ZlcmxheSk7XG4gICAgfVxuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5fcHJldk92ZXJsYXkgPSBjbG9uZSh0aGlzKTtcbiAgICAgICAgdmFyIGlkID0gb3ZlcmxheS5pZCwgbmFtZSA9IG92ZXJsYXkubmFtZTsgb3ZlcmxheS5jdXJyZW50U3RlcDsgdmFyIHBvaW50cyA9IG92ZXJsYXkucG9pbnRzLCBzdHlsZXMgPSBvdmVybGF5LnN0eWxlcywgb3RoZXJzID0gX19yZXN0KG92ZXJsYXksIFtcImlkXCIsIFwibmFtZVwiLCBcImN1cnJlbnRTdGVwXCIsIFwicG9pbnRzXCIsIFwic3R5bGVzXCJdKTtcbiAgICAgICAgbWVyZ2UodGhpcywgb3RoZXJzKTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMuaWQpICYmIGlzU3RyaW5nKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKHN0eWxlcykpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc3R5bGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5zdHlsZXMgPSB7fSk7XG4gICAgICAgICAgICBtZXJnZSh0aGlzLnN0eWxlcywgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShwb2ludHMpICYmIHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcmVwZWF0VG90YWxTdGVwID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBvaW50cyksIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID49IHRoaXMudG90YWxTdGVwIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRDtcbiAgICAgICAgICAgICAgICByZXBlYXRUb3RhbFN0ZXAgPSB0aGlzLnRvdGFsU3RlcCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gcG9pbnRzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgcmVwZWF0VG90YWxTdGVwID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnQgd3JvbmcgZHJhd2luZyBkdWUgdG8gd3JvbmcgcG9pbnRzXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLnBlcmZvcm1FdmVudE1vdmVGb3JEcmF3aW5nKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0VG90YWxTdGVwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogaSArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtUG9pbnQ6IHRoaXMucG9pbnRzW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwID09PSBPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRCkge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucGVyZm9ybUV2ZW50UHJlc3NlZE1vdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IHRoaXMuY3VycmVudFN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybVBvaW50SW5kZXg6IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1Qb2ludDogdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuZ2V0UHJldlpMZXZlbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByZXZaTGV2ZWw7IH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuc2V0UHJldlpMZXZlbCA9IGZ1bmN0aW9uICh6TGV2ZWwpIHsgdGhpcy5fcHJldlpMZXZlbCA9IHpMZXZlbDsgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5zaG91bGRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3J0ID0gdGhpcy5fcHJldk92ZXJsYXkuekxldmVsICE9PSB0aGlzLnpMZXZlbDtcbiAgICAgICAgdmFyIGRyYXcgPSBzb3J0IHx8XG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLl9wcmV2T3ZlcmxheSkgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMucG9pbnRzKSB8fFxuICAgICAgICAgICAgdGhpcy5fcHJldk92ZXJsYXkudmlzaWJsZSAhPT0gdGhpcy52aXNpYmxlIHx8XG4gICAgICAgICAgICB0aGlzLl9wcmV2T3ZlcmxheS5leHRlbmREYXRhICE9PSB0aGlzLmV4dGVuZERhdGEgfHxcbiAgICAgICAgICAgIHRoaXMuX3ByZXZPdmVybGF5LnN0eWxlcyAhPT0gdGhpcy5zdHlsZXM7XG4gICAgICAgIHJldHVybiB7IHNvcnQ6IHNvcnQsIGRyYXc6IGRyYXcgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLm5leHRTdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RlcCA9PT0gdGhpcy50b3RhbFN0ZXAgLSAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gT1ZFUkxBWV9EUkFXX1NURVBfRklOSVNIRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGVwKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLmZvcmNlQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRDtcbiAgICB9O1xuICAgIE92ZXJsYXlJbXAucHJvdG90eXBlLmlzRHJhd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXAgIT09IE9WRVJMQVlfRFJBV19TVEVQX0ZJTklTSEVEO1xuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuaXNTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0ZXAgPT09IE9WRVJMQVlfRFJBV19TVEVQX1NUQVJUO1xuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuZXZlbnRNb3ZlRm9yRHJhd2luZyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwb2ludEluZGV4ID0gdGhpcy5jdXJyZW50U3RlcCAtIDE7XG4gICAgICAgIHZhciBuZXdQb2ludCA9IHt9O1xuICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgbmV3UG9pbnQudGltZXN0YW1wID0gcG9pbnQudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihwb2ludC5kYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICBuZXdQb2ludC5kYXRhSW5kZXggPSBwb2ludC5kYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnZhbHVlKSkge1xuICAgICAgICAgICAgbmV3UG9pbnQudmFsdWUgPSBwb2ludC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50c1twb2ludEluZGV4XSA9IG5ld1BvaW50O1xuICAgICAgICAoX2EgPSB0aGlzLnBlcmZvcm1FdmVudE1vdmVGb3JEcmF3aW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjdXJyZW50U3RlcDogdGhpcy5jdXJyZW50U3RlcCxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBwZXJmb3JtUG9pbnRJbmRleDogcG9pbnRJbmRleCxcbiAgICAgICAgICAgIHBlcmZvcm1Qb2ludDogbmV3UG9pbnRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5ldmVudFByZXNzZWRQb2ludE1vdmUgPSBmdW5jdGlvbiAocG9pbnQsIHBvaW50SW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnBvaW50c1twb2ludEluZGV4XS50aW1lc3RhbXAgPSBwb2ludC50aW1lc3RhbXA7XG4gICAgICAgIGlmIChpc051bWJlcihwb2ludC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzW3BvaW50SW5kZXhdLnZhbHVlID0gcG9pbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5wZXJmb3JtRXZlbnRQcmVzc2VkTW92ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY3VycmVudFN0ZXA6IHRoaXMuY3VycmVudFN0ZXAsXG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgcGVyZm9ybVBvaW50SW5kZXg6IHBvaW50SW5kZXgsXG4gICAgICAgICAgICBwZXJmb3JtUG9pbnQ6IHRoaXMucG9pbnRzW3BvaW50SW5kZXhdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3ZlcmxheUltcC5wcm90b3R5cGUuc3RhcnRQcmVzc2VkTW92ZSA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB0aGlzLl9wcmV2UHJlc3NlZFBvaW50ID0gX19hc3NpZ24oe30sIHBvaW50KTtcbiAgICAgICAgdGhpcy5fcHJldlByZXNzZWRQb2ludHMgPSBjbG9uZSh0aGlzLnBvaW50cyk7XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLnByb3RvdHlwZS5ldmVudFByZXNzZWRPdGhlck1vdmUgPSBmdW5jdGlvbiAocG9pbnQsIGNoYXJ0U3RvcmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZQcmVzc2VkUG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaWZEYXRhSW5kZXhfMSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQuZGF0YUluZGV4KSAmJiBpc051bWJlcih0aGlzLl9wcmV2UHJlc3NlZFBvaW50LmRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBkaWZEYXRhSW5kZXhfMSA9IHBvaW50LmRhdGFJbmRleCAtIHRoaXMuX3ByZXZQcmVzc2VkUG9pbnQuZGF0YUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpZlZhbHVlXzEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnZhbHVlKSAmJiBpc051bWJlcih0aGlzLl9wcmV2UHJlc3NlZFBvaW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpZlZhbHVlXzEgPSBwb2ludC52YWx1ZSAtIHRoaXMuX3ByZXZQcmVzc2VkUG9pbnQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHRoaXMuX3ByZXZQcmVzc2VkUG9pbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocC50aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuZGF0YUluZGV4ID0gY2hhcnRTdG9yZS50aW1lc3RhbXBUb0RhdGFJbmRleChwLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdQb2ludCA9IF9fYXNzaWduKHt9LCBwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoZGlmRGF0YUluZGV4XzEpICYmIGlzTnVtYmVyKHAuZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQb2ludC5kYXRhSW5kZXggPSBwLmRhdGFJbmRleCArIGRpZkRhdGFJbmRleF8xO1xuICAgICAgICAgICAgICAgICAgICBuZXdQb2ludC50aW1lc3RhbXAgPSAoX2EgPSBjaGFydFN0b3JlLmRhdGFJbmRleFRvVGltZXN0YW1wKG5ld1BvaW50LmRhdGFJbmRleCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGRpZlZhbHVlXzEpICYmIGlzTnVtYmVyKHAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BvaW50LnZhbHVlID0gcC52YWx1ZSArIGRpZlZhbHVlXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQb2ludDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmVybGF5SW1wLmV4dGVuZCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgQ3VzdG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEN1c3RvbSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEN1c3RvbSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGUpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgICAgICB9KE92ZXJsYXlJbXApKTtcbiAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5SW1wO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgRm9ybWF0RGF0ZVR5cGU7XG4oZnVuY3Rpb24gKEZvcm1hdERhdGVUeXBlKSB7XG4gICAgRm9ybWF0RGF0ZVR5cGVbRm9ybWF0RGF0ZVR5cGVbXCJUb29sdGlwXCJdID0gMF0gPSBcIlRvb2x0aXBcIjtcbiAgICBGb3JtYXREYXRlVHlwZVtGb3JtYXREYXRlVHlwZVtcIkNyb3NzaGFpclwiXSA9IDFdID0gXCJDcm9zc2hhaXJcIjtcbiAgICBGb3JtYXREYXRlVHlwZVtGb3JtYXREYXRlVHlwZVtcIlhBeGlzXCJdID0gMl0gPSBcIlhBeGlzXCI7XG59KShGb3JtYXREYXRlVHlwZSB8fCAoRm9ybWF0RGF0ZVR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRCb3VuZGluZyhib3VuZGluZykge1xuICAgIHZhciBkZWZhdWx0Qm91bmRpbmcgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgaWYgKGlzVmFsaWQoYm91bmRpbmcpKSB7XG4gICAgICAgIG1lcmdlKGRlZmF1bHRCb3VuZGluZywgYm91bmRpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEJvdW5kaW5nO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX1JFUVVFU1RfSUQgPSAtMTtcbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAyMCk7XG59XG5mdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIHtcbiAgICBpZiAoaXNGdW5jdGlvbih3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHtcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCAxKTtcbn1cbmZ1bmN0aW9uIGNhbmNlbElkbGVDYWxsYmFjayhpZCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2spKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZCk7XG4gICAgfVxufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBBbmltYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHsgZHVyYXRpb246IDUwMCwgaXRlcmF0aW9uQ291bnQ6IDEgfTtcbiAgICAgICAgdGhpcy5fY3VycmVudEl0ZXJhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgbWVyZ2UodGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fcnVubmluZykge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3RoaXMuX3RpbWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmZUaW1lIDwgX3RoaXMuX29wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuX2RvRnJhbWVDYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoX3RoaXMsIGRpZmZUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY3VycmVudEl0ZXJhdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY3VycmVudEl0ZXJhdGlvbkNvdW50IDwgX3RoaXMuX29wdGlvbnMuaXRlcmF0aW9uQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICB9O1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZG9GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9kb0ZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnNldER1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnNldEl0ZXJhdGlvbkNvdW50ID0gZnVuY3Rpb24gKGl0ZXJhdGlvbkNvdW50KSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuaXRlcmF0aW9uQ291bnQgPSBpdGVyYXRpb25Db3VudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9kb0ZyYW1lQ2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuX29wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBiYXNlSWQgPSAxO1xudmFyIHByZXZJZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuZnVuY3Rpb24gY3JlYXRlSWQocHJlZml4KSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGlmICh0aW1lc3RhbXAgPT09IHByZXZJZFRpbWVzdGFtcCkge1xuICAgICAgICArK2Jhc2VJZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJhc2VJZCA9IDE7XG4gICAgfVxuICAgIHByZXZJZFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4ICE9PSBudWxsICYmIHByZWZpeCAhPT0gdm9pZCAwID8gcHJlZml4IDogJycpLmNvbmNhdCh0aW1lc3RhbXAsIFwiX1wiKS5jb25jYXQoYmFzZUlkKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENyZWF0ZSBkb21cbiAqIEBwYXJhbSB0YWdOYW1lXG4gKiBAcGFyYW0gc3R5bGVzXG4gKiBAcmV0dXJuIHsqfVxuICovXG5mdW5jdGlvbiBjcmVhdGVEb20odGFnTmFtZSwgc3R5bGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIHZhciBzID0gc3R5bGVzICE9PSBudWxsICYmIHN0eWxlcyAhPT0gdm9pZCAwID8gc3R5bGVzIDoge307XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiAtLSBpZ25vcmVcbiAgICBmb3IgKHZhciBrZXkgaW4gcykge1xuICAgICAgICAoZG9tLnN0eWxlKVtrZXldID0gKF9hID0gc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEJpbmFyeSBzZWFyY2ggZm9yIHRoZSBuZWFyZXN0IHJlc3VsdFxuICogQHBhcmFtIGRhdGFMaXN0XG4gKiBAcGFyYW0gdmFsdWVLZXlcbiAqIEBwYXJhbSB0YXJnZXRWYWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2hOZWFyZXN0KGRhdGFMaXN0LCB2YWx1ZUtleSwgdGFyZ2V0VmFsdWUpIHtcbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgdmFyIHJpZ2h0ID0gMDtcbiAgICBmb3IgKHJpZ2h0ID0gZGF0YUxpc3QubGVuZ3RoIC0gMTsgbGVmdCAhPT0gcmlnaHQ7KSB7XG4gICAgICAgIHZhciBtaWRJbmRleCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcbiAgICAgICAgdmFyIG1pZCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgdmFyIG1pZFZhbHVlID0gZGF0YUxpc3RbbWlkSW5kZXhdW3ZhbHVlS2V5XTtcbiAgICAgICAgaWYgKHRhcmdldFZhbHVlID09PSBkYXRhTGlzdFtsZWZ0XVt2YWx1ZUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gZGF0YUxpc3RbcmlnaHRdW3ZhbHVlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRWYWx1ZSA9PT0gbWlkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPiBtaWRWYWx1ZSkge1xuICAgICAgICAgICAgbGVmdCA9IG1pZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBtaWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlkIDw9IDIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xufVxuLyoqXG4gKiDkvJjljJbmlbDlrZdcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfG51bWJlcn1cbiAqL1xuZnVuY3Rpb24gbmljZSh2YWx1ZSkge1xuICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IobG9nMTAodmFsdWUpKTtcbiAgICB2YXIgZXhwMTAgPSBpbmRleDEwKGV4cG9uZW50KTtcbiAgICB2YXIgZiA9IHZhbHVlIC8gZXhwMTA7IC8vIDEgPD0gZiA8IDEwXG4gICAgdmFyIG5mID0gMDtcbiAgICBpZiAoZiA8IDEuNSkge1xuICAgICAgICBuZiA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYgPCAyLjUpIHtcbiAgICAgICAgbmYgPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChmIDwgMy41KSB7XG4gICAgICAgIG5mID0gMztcbiAgICB9XG4gICAgZWxzZSBpZiAoZiA8IDQuNSkge1xuICAgICAgICBuZiA9IDQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYgPCA1LjUpIHtcbiAgICAgICAgbmYgPSA1O1xuICAgIH1cbiAgICBlbHNlIGlmIChmIDwgNi41KSB7XG4gICAgICAgIG5mID0gNjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5mID0gODtcbiAgICB9XG4gICAgdmFsdWUgPSBuZiAqIGV4cDEwO1xuICAgIHJldHVybiArdmFsdWUudG9GaXhlZChNYXRoLmFicyhleHBvbmVudCkpO1xufVxuLyoqXG4gKiBSb3VuZFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBwcmVjaXNpb24gIT09IG51bGwgJiYgcHJlY2lzaW9uICE9PSB2b2lkIDAgPyBwcmVjaXNpb24gOiAwKTtcbiAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xufVxuLyoqXG4gKiBHZXQgcHJlY2lzaW9uXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcnxudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFByZWNpc2lvbih2YWx1ZSkge1xuICAgIHZhciBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHZhciBlSW5kZXggPSBzdHIuaW5kZXhPZignZScpO1xuICAgIGlmIChlSW5kZXggPiAwKSB7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSArc3RyLnNsaWNlKGVJbmRleCArIDEpO1xuICAgICAgICByZXR1cm4gcHJlY2lzaW9uIDwgMCA/IC1wcmVjaXNpb24gOiAwO1xuICAgIH1cbiAgICB2YXIgZG90SW5kZXggPSBzdHIuaW5kZXhPZignLicpO1xuICAgIHJldHVybiBkb3RJbmRleCA8IDAgPyAwIDogc3RyLmxlbmd0aCAtIDEgLSBkb3RJbmRleDtcbn1cbmZ1bmN0aW9uIGdldE1heE1pbihkYXRhTGlzdCwgbWF4S2V5LCBtaW5LZXkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBtYXhNaW4gPSBbTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXTtcbiAgICB2YXIgZGF0YUxlbmd0aCA9IGRhdGFMaXN0Lmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGRhdGFMZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpbmRleF07XG4gICAgICAgIG1heE1pblswXSA9IE1hdGgubWF4KCgoX2EgPSBkYXRhW21heEtleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSwgbWF4TWluWzBdKTtcbiAgICAgICAgbWF4TWluWzFdID0gTWF0aC5taW4oKChfYiA9IGRhdGFbbWluS2V5XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCBtYXhNaW5bMV0pO1xuICAgICAgICArK2luZGV4O1xuICAgIH1cbiAgICByZXR1cm4gbWF4TWluO1xufVxuLyoqXG4gKiBsb2cxMFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGxvZzEwKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2cxMCh2YWx1ZSk7XG59XG4vKipcbiAqIGluZGV4IDEwXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaW5kZXgxMCh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdmFsdWUpO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBMb2FkRGF0YVR5cGU7XG4oZnVuY3Rpb24gKExvYWREYXRhVHlwZSkge1xuICAgIExvYWREYXRhVHlwZVtcIkluaXRcIl0gPSBcImluaXRcIjtcbiAgICBMb2FkRGF0YVR5cGVbXCJGb3J3YXJkXCJdID0gXCJmb3J3YXJkXCI7XG4gICAgTG9hZERhdGFUeXBlW1wiQmFja3dhcmRcIl0gPSBcImJhY2t3YXJkXCI7XG4gICAgTG9hZERhdGFUeXBlW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbn0pKExvYWREYXRhVHlwZSB8fCAoTG9hZERhdGFUeXBlID0ge30pKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0VmlzaWJsZVJhbmdlKCkge1xuICAgIHJldHVybiB7IGZyb206IDAsIHRvOiAwLCByZWFsRnJvbTogMCwgcmVhbFRvOiAwIH07XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUYXNrSWQoKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJ18nKTtcbn1cbnZhciBUYXNrU2NoZWR1bGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tTY2hlZHVsZXIodGFza3MpIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkID0gREVGQVVMVF9SRVFVRVNUX0lEO1xuICAgICAgICB0aGlzLl90YXNrcyA9IHRhc2tzICE9PSBudWxsICYmIHRhc2tzICE9PSB2b2lkIDAgPyB0YXNrcyA6IFtdO1xuICAgICAgICB0aGlzLl9vcGVyYXRlVGFza3MoKTtcbiAgICB9XG4gICAgVGFza1NjaGVkdWxlci5wcm90b3R5cGUuX29wZXJhdGVUYXNrcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkICE9PSBERUZBVUxUX1JFUVVFU1RfSUQpIHtcbiAgICAgICAgICAgIGNhbmNlbElkbGVDYWxsYmFjayh0aGlzLl9yZXF1ZXN0SWRsZUNhbGxiYWNrSWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkbGVDYWxsYmFja0lkID0gREVGQVVMVF9SRVFVRVNUX0lEO1xuICAgICAgICB9XG4gICAgICAgIGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbigpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SWRsZUNhbGxiYWNrSWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGZ1bmN0aW9uIChkZWFkbGluZSkgeyBfdGhpcy5fcnVuVGFza3MoZGVhZGxpbmUpOyB9KTtcbiAgICB9O1xuICAgIFRhc2tTY2hlZHVsZXIucHJvdG90eXBlLl9ydW5UYXNrcyA9IGZ1bmN0aW9uIChkZWFkbGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZGVhZGxpbmUudGltZVJlbWFpbmluZygpID4gMCAmJiB0aGlzLl90YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRoaXMuX3Rhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0YXNrID09PSBudWxsIHx8IHRhc2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhc2suaGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWRsZUNhbGxiYWNrSWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGZ1bmN0aW9uIChkZWFkbGluZSkgeyBfdGhpcy5fcnVuVGFza3MoZGVhZGxpbmUpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFza1NjaGVkdWxlci5wcm90b3R5cGUuYWRkVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX29wZXJhdGVUYXNrcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fdGFza3MuZmluZEluZGV4KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmlkID09PSB0YXNrLmlkOyB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rhc2tzW2luZGV4XSA9IHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVGFza1NjaGVkdWxlci5wcm90b3R5cGUucmVtb3ZlVGFzayA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vcGVyYXRlVGFza3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3Rhc2tzLmZpbmRJbmRleChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pZCA9PT0gaWQ7IH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFza3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFRhc2tTY2hlZHVsZXI7XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBUaW1lV2VpZ2h0Q29uc3RhbnRzID0ge1xuICAgIFllYXI6IDM2NSAqIDI0ICogMzYwMCxcbiAgICBNb250aDogMzAgKiAyNCAqIDM2MDAsXG4gICAgRGF5OiAyNCAqIDM2MDAsXG4gICAgSG91cjogMzYwMCxcbiAgICBNaW51dGU6IDYwLFxuICAgIFNlY29uZDogMVxufTtcbmZ1bmN0aW9uIGNsYXNzaWZ5VGltZVdlaWdodFRpY2tzKG1hcCwgZGF0YUxpc3QsIGRhdGVUaW1lRm9ybWF0LCBiYXNlRGF0YUluZGV4LCBtaW5UaW1lU3Bhbiwgc3RhcnRUaW1lc3RhbXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGJhc2VEYXRhSW5kZXggPT09IHZvaWQgMCkgeyBiYXNlRGF0YUluZGV4ID0gMDsgfVxuICAgIHZhciBwcmV2RGF0ZVRpbWUgPSBudWxsO1xuICAgIHZhciBwcmV2VGltZXN0YW1wID0gc3RhcnRUaW1lc3RhbXAgIT09IG51bGwgJiYgc3RhcnRUaW1lc3RhbXAgIT09IHZvaWQgMCA/IHN0YXJ0VGltZXN0YW1wIDogbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBkYXRhTGlzdFtpXS50aW1lc3RhbXA7XG4gICAgICAgIHZhciB3ZWlnaHQgPSBUaW1lV2VpZ2h0Q29uc3RhbnRzLk1pbnV0ZTtcbiAgICAgICAgdmFyIGRhdGVUaW1lID0gZm9ybWF0VGltZXN0YW1wVG9EYXRlVGltZShkYXRlVGltZUZvcm1hdCwgdGltZXN0YW1wKTtcbiAgICAgICAgaWYgKGlzVmFsaWQocHJldkRhdGVUaW1lKSkge1xuICAgICAgICAgICAgaWYgKGRhdGVUaW1lLllZWVkgIT09IHByZXZEYXRlVGltZS5ZWVlZKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gVGltZVdlaWdodENvbnN0YW50cy5ZZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZVRpbWUuTU0gIT09IHByZXZEYXRlVGltZS5NTSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuTW9udGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlVGltZS5ERCAhPT0gcHJldkRhdGVUaW1lLkREKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gVGltZVdlaWdodENvbnN0YW50cy5EYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlVGltZS5ISCAhPT0gcHJldkRhdGVUaW1lLkhIKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gVGltZVdlaWdodENvbnN0YW50cy5Ib3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZVRpbWUubW0gIT09IHByZXZEYXRlVGltZS5tbSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IFRpbWVXZWlnaHRDb25zdGFudHMuTWludXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gVGltZVdlaWdodENvbnN0YW50cy5TZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHByZXZUaW1lc3RhbXApICYmIGlzTnVtYmVyKG1pblRpbWVTcGFuID09PSBudWxsIHx8IG1pblRpbWVTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW5UaW1lU3Bhbi5jb21wYXJlKSkge1xuICAgICAgICAgICAgbWluVGltZVNwYW4uY29tcGFyZSA9IE1hdGgubWluKG1pblRpbWVTcGFuLmNvbXBhcmUsIHRpbWVzdGFtcCAtIHByZXZUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50VGltZVdlaWdodExpc3QgPSAoX2EgPSBtYXAuZ2V0KHdlaWdodCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBjdXJyZW50VGltZVdlaWdodExpc3QucHVzaCh7IGRhdGFJbmRleDogaSArIGJhc2VEYXRhSW5kZXgsIHdlaWdodDogd2VpZ2h0LCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgbWFwLnNldCh3ZWlnaHQsIGN1cnJlbnRUaW1lV2VpZ2h0TGlzdCk7XG4gICAgICAgIHByZXZEYXRlVGltZSA9IGRhdGVUaW1lO1xuICAgICAgICBwcmV2VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGNCZXR3ZWVuVGltZVdlaWdodFRpY2tCYXJDb3VudChiYXJTcGFjZSwgdGV4dFN0eWxlcykge1xuICAgIHZhciBzcGFjZSA9IE1hdGgubWF4KGNhbGNUZXh0V2lkdGgoJzAwMDAtMDAtMDAgMDA6MDA6MDAnLCB0ZXh0U3R5bGVzLnNpemUsIHRleHRTdHlsZXMud2VpZ2h0LCB0ZXh0U3R5bGVzLmZhbWlseSksIDE0Nik7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzcGFjZSAvIGJhclNwYWNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVXZWlnaHRUaWNrTGlzdChtYXAsIGJhclNwYWNlLCB0ZXh0U3R5bGVzKSB7XG4gICAgdmFyIGJhckNvdW50ID0gY2FsY0JldHdlZW5UaW1lV2VpZ2h0VGlja0JhckNvdW50KGJhclNwYWNlLCB0ZXh0U3R5bGVzKTtcbiAgICB2YXIgb3B0VGltZVdlaWdodFRpY2tMaXN0ID0gW107XG4gICAgQXJyYXkuZnJvbShtYXAua2V5cygpKS5zb3J0KGZ1bmN0aW9uICh3MSwgdzIpIHsgcmV0dXJuIHcyIC0gdzE7IH0pLmZvckVhY2goZnVuY3Rpb24gKHdlaWdodCkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWVXZWlnaHRUaWNrTGlzdCA9IG1hcC5nZXQod2VpZ2h0KTtcbiAgICAgICAgdmFyIHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3QgPSBvcHRUaW1lV2VpZ2h0VGlja0xpc3Q7XG4gICAgICAgIG9wdFRpbWVXZWlnaHRUaWNrTGlzdCA9IFtdO1xuICAgICAgICB2YXIgcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdExlbmd0aCA9IHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgY3VycmVudFRpbWVXZWlnaHRUaWNrTGlzdExlbmd0aCA9IGN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3RMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRpbWVXZWlnaHRUaWNrID0gY3VycmVudFRpbWVXZWlnaHRUaWNrTGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aW1lV2VpZ2h0VGljay5kYXRhSW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAocHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXIgPCBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RUaW1lV2VpZ2h0VGljayA9IHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RbcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXJdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBsYXN0VGltZVdlaWdodFRpY2suZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgb3B0VGltZVdlaWdodFRpY2tMaXN0LnB1c2gobGFzdFRpbWVXZWlnaHRUaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICByaWdodEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByaWdodEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRJbmRleCAtIGN1cnJlbnRJbmRleCA+PSBiYXJDb3VudCAmJiBjdXJyZW50SW5kZXggLSBsZWZ0SW5kZXggPj0gYmFyQ291bnQpIHtcbiAgICAgICAgICAgICAgICBvcHRUaW1lV2VpZ2h0VGlja0xpc3QucHVzaCh0aW1lV2VpZ2h0VGljayk7XG4gICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0UG9pbnRlciA8IHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RMZW5ndGg7IHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyKyspIHtcbiAgICAgICAgICAgIG9wdFRpbWVXZWlnaHRUaWNrTGlzdC5wdXNoKHByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RbcHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdFBvaW50ZXJdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvcHRUaW1lV2VpZ2h0VGlja0xpc3Q7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBhdmVyYWdlIHByaWNlXG4gKi9cbnZhciBhdmVyYWdlUHJpY2UgPSB7XG4gICAgbmFtZTogJ0FWUCcsXG4gICAgc2hvcnROYW1lOiAnQVZQJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5QcmljZSxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2F2cCcsIHRpdGxlOiAnQVZQOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0KSB7XG4gICAgICAgIHZhciB0b3RhbFR1cm5vdmVyID0gMDtcbiAgICAgICAgdmFyIHRvdGFsVm9sdW1lID0gMDtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGF2cCA9IHt9O1xuICAgICAgICAgICAgdmFyIHR1cm5vdmVyID0gKF9hID0ga0xpbmVEYXRhLnR1cm5vdmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgdmFyIHZvbHVtZSA9IChfYiA9IGtMaW5lRGF0YS52b2x1bWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgICAgICB0b3RhbFR1cm5vdmVyICs9IHR1cm5vdmVyO1xuICAgICAgICAgICAgdG90YWxWb2x1bWUgKz0gdm9sdW1lO1xuICAgICAgICAgICAgaWYgKHRvdGFsVm9sdW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgYXZwLmF2cCA9IHRvdGFsVHVybm92ZXIgLyB0b3RhbFZvbHVtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdnA7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGF3ZXNvbWVPc2NpbGxhdG9yID0ge1xuICAgIG5hbWU6ICdBTycsXG4gICAgc2hvcnROYW1lOiAnQU8nLFxuICAgIGNhbGNQYXJhbXM6IFs1LCAzNF0sXG4gICAgZmlndXJlczogW3tcbiAgICAgICAgICAgIGtleTogJ2FvJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQU86ICcsXG4gICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgIGJhc2VWYWx1ZTogMCxcbiAgICAgICAgICAgIHN0eWxlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGluZGljYXRvciA9IF9hLmluZGljYXRvciwgZGVmYXVsdFN0eWxlcyA9IF9hLmRlZmF1bHRTdHlsZXM7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBkYXRhLnByZXYsIGN1cnJlbnQgPSBkYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZBbyA9IChfYiA9IHByZXYgPT09IG51bGwgfHwgcHJldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldi5hbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBbyA9IChfYyA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5hbykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBbyA+IHByZXZBbykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdiYXJzWzBdLnVwQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5iYXJzKVswXS51cENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2JhcnNbMF0uZG93bkNvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0uZG93bkNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gY3VycmVudEFvID4gcHJldkFvID8gUG9seWdvblR5cGUuU3Ryb2tlIDogUG9seWdvblR5cGUuRmlsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb2xvcjogY29sb3IsIHN0eWxlOiBzdHlsZSwgYm9yZGVyQ29sb3I6IGNvbG9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIG1heFBlcmlvZCA9IE1hdGgubWF4KHBhcmFtc1swXSwgcGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIHNob3J0U3VtID0gMDtcbiAgICAgICAgdmFyIGxvbmdTdW0gPSAwO1xuICAgICAgICB2YXIgc2hvcnQgPSAwO1xuICAgICAgICB2YXIgbG9uZyA9IDA7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIGFvID0ge307XG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gKGtMaW5lRGF0YS5sb3cgKyBrTGluZURhdGEuaGlnaCkgLyAyO1xuICAgICAgICAgICAgc2hvcnRTdW0gKz0gbWlkZGxlO1xuICAgICAgICAgICAgbG9uZ1N1bSArPSBtaWRkbGU7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgc2hvcnQgPSBzaG9ydFN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgYWdvS0xpbmVEYXRhID0gZGF0YUxpc3RbaSAtIChwYXJhbXNbMF0gLSAxKV07XG4gICAgICAgICAgICAgICAgc2hvcnRTdW0gLT0gKChhZ29LTGluZURhdGEubG93ICsgYWdvS0xpbmVEYXRhLmhpZ2gpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMV0gLSAxKSB7XG4gICAgICAgICAgICAgICAgbG9uZyA9IGxvbmdTdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgdmFyIGFnb0tMaW5lRGF0YSA9IGRhdGFMaXN0W2kgLSAocGFyYW1zWzFdIC0gMSldO1xuICAgICAgICAgICAgICAgIGxvbmdTdW0gLT0gKChhZ29LTGluZURhdGEubG93ICsgYWdvS0xpbmVEYXRhLmhpZ2gpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBtYXhQZXJpb2QgLSAxKSB7XG4gICAgICAgICAgICAgICAgYW8uYW8gPSBzaG9ydCAtIGxvbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW87XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBCSUFTXG4gKiDkuZbnprvnjoc9WyjlvZPml6XmlLbnm5jku7ctTuaXpeW5s+Wdh+S7tykvTuaXpeW5s+Wdh+S7t10qMTAwJVxuICovXG52YXIgYmlhcyA9IHtcbiAgICBuYW1lOiAnQklBUycsXG4gICAgc2hvcnROYW1lOiAnQklBUycsXG4gICAgY2FsY1BhcmFtczogWzYsIDEyLCAyNF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2JpYXMxJywgdGl0bGU6ICdCSUFTNjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnYmlhczInLCB0aXRsZTogJ0JJQVMxMjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnYmlhczMnLCB0aXRsZTogJ0JJQVMyNDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIHJlZ2VuZXJhdGVGaWd1cmVzOiBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiAoeyBrZXk6IFwiYmlhc1wiLmNvbmNhdChpICsgMSksIHRpdGxlOiBcIkJJQVNcIi5jb25jYXQocCwgXCI6IFwiKSwgdHlwZTogJ2xpbmUnIH0pOyB9KTsgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIGZpZ3VyZXMgPSBpbmRpY2F0b3IuZmlndXJlcztcbiAgICAgICAgdmFyIGNsb3NlU3VtcyA9IFtdO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBiaWFzID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY2xvc2VTdW1zW2luZGV4XSA9ICgoX2EgPSBjbG9zZVN1bXNbaW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIGNsb3NlO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFuID0gY2xvc2VTdW1zW2luZGV4XSAvIHBhcmFtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGJpYXNbZmlndXJlc1tpbmRleF0ua2V5XSA9IChjbG9zZSAtIG1lYW4pIC8gbWVhbiAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VTdW1zW2luZGV4XSAtPSBkYXRhTGlzdFtpIC0gKHAgLSAxKV0uY2xvc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmlhcztcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIOiuoeeul+W4g+ael+aMh+agh+S4reeahOagh+WHhuW3rlxuICogQHBhcmFtIGRhdGFMaXN0XG4gKiBAcGFyYW0gbWFcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Qm9sbE1kKGRhdGFMaXN0LCBtYSkge1xuICAgIHZhciBkYXRhU2l6ZSA9IGRhdGFMaXN0Lmxlbmd0aDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBjbG9zZU1hID0gZGF0YS5jbG9zZSAtIG1hO1xuICAgICAgICBzdW0gKz0gY2xvc2VNYSAqIGNsb3NlTWE7XG4gICAgfSk7XG4gICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bSAvIGRhdGFTaXplKTtcbn1cbi8qKlxuICogQk9MTFxuICovXG52YXIgYm9sbGluZ2VyQmFuZHMgPSB7XG4gICAgbmFtZTogJ0JPTEwnLFxuICAgIHNob3J0TmFtZTogJ0JPTEwnLFxuICAgIHNlcmllczogSW5kaWNhdG9yU2VyaWVzLlByaWNlLFxuICAgIGNhbGNQYXJhbXM6IFsyMCwgMl0sXG4gICAgcHJlY2lzaW9uOiAyLFxuICAgIHNob3VsZE9obGM6IHRydWUsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ3VwJywgdGl0bGU6ICdVUDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWlkJywgdGl0bGU6ICdNSUQ6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2RuJywgdGl0bGU6ICdETjogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIHAgPSBwYXJhbXNbMF0gLSAxO1xuICAgICAgICB2YXIgY2xvc2VTdW0gPSAwO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHZhciBib2xsID0ge307XG4gICAgICAgICAgICBjbG9zZVN1bSArPSBjbG9zZTtcbiAgICAgICAgICAgIGlmIChpID49IHApIHtcbiAgICAgICAgICAgICAgICBib2xsLm1pZCA9IGNsb3NlU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIHZhciBtZCA9IGdldEJvbGxNZChkYXRhTGlzdC5zbGljZShpIC0gcCwgaSArIDEpLCBib2xsLm1pZCk7XG4gICAgICAgICAgICAgICAgYm9sbC51cCA9IGJvbGwubWlkICsgcGFyYW1zWzFdICogbWQ7XG4gICAgICAgICAgICAgICAgYm9sbC5kbiA9IGJvbGwubWlkIC0gcGFyYW1zWzFdICogbWQ7XG4gICAgICAgICAgICAgICAgY2xvc2VTdW0gLT0gZGF0YUxpc3RbaSAtIHBdLmNsb3NlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvbGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBCUkFSXG4gKiDpu5jorqTlj4LmlbDmmK8yNuOAglxuICog5YWs5byPTuaXpUJSPU7ml6XlhoXvvIhI77yNQ1nvvInkuYvlkozpmaTku6VO5pel5YaF77yIQ1nvvI1M77yJ5LmL5ZKMKjEwMO+8jFxuICog5YW25Lit77yMSOS4uuW9k+aXpeacgOmrmOS7t++8jEzkuLrlvZPml6XmnIDkvY7ku7fvvIxDWeS4uuWJjeS4gOS6pOaYk+aXpeeahOaUtuebmOS7t++8jE7kuLrorr7lrprnmoTml7bpl7Tlj4LmlbDjgIJcbiAqIE7ml6VBUj0oTuaXpeWGhe+8iEjvvI1P77yJ5LmL5ZKM6Zmk5LulTuaXpeWGhe+8iE/vvI1M77yJ5LmL5ZKMKSoxMDDvvIxcbiAqIOWFtuS4re+8jEjkuLrlvZPml6XmnIDpq5jku7fvvIxM5Li65b2T5pel5pyA5L2O5Lu377yMT+S4uuW9k+aXpeW8gOebmOS7t++8jE7kuLrorr7lrprnmoTml7bpl7Tlj4LmlbBcbiAqXG4gKi9cbnZhciBicmFyID0ge1xuICAgIG5hbWU6ICdCUkFSJyxcbiAgICBzaG9ydE5hbWU6ICdCUkFSJyxcbiAgICBjYWxjUGFyYW1zOiBbMjZdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdicicsIHRpdGxlOiAnQlI6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2FyJywgdGl0bGU6ICdBUjogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIGhjeSA9IDA7XG4gICAgICAgIHZhciBjeWwgPSAwO1xuICAgICAgICB2YXIgaG8gPSAwO1xuICAgICAgICB2YXIgb2wgPSAwO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgYnJhciA9IHt9O1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgIHZhciBsb3cgPSBrTGluZURhdGEubG93O1xuICAgICAgICAgICAgdmFyIG9wZW4gPSBrTGluZURhdGEub3BlbjtcbiAgICAgICAgICAgIHZhciBwcmV2Q2xvc2UgPSAoKF9hID0gZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGEpLmNsb3NlO1xuICAgICAgICAgICAgaG8gKz0gKGhpZ2ggLSBvcGVuKTtcbiAgICAgICAgICAgIG9sICs9IChvcGVuIC0gbG93KTtcbiAgICAgICAgICAgIGhjeSArPSAoaGlnaCAtIHByZXZDbG9zZSk7XG4gICAgICAgICAgICBjeWwgKz0gKHByZXZDbG9zZSAtIGxvdyk7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYXIuYXIgPSBobyAvIG9sICogMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhci5hciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjeWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhci5iciA9IGhjeSAvIGN5bCAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYXIuYnIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWdvS0xpbmVEYXRhID0gZGF0YUxpc3RbaSAtIChwYXJhbXNbMF0gLSAxKV07XG4gICAgICAgICAgICAgICAgdmFyIGFnb0hpZ2ggPSBhZ29LTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgICAgICB2YXIgYWdvTG93ID0gYWdvS0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICB2YXIgYWdvT3BlbiA9IGFnb0tMaW5lRGF0YS5vcGVuO1xuICAgICAgICAgICAgICAgIHZhciBhZ29QcmVDbG9zZSA9ICgoX2IgPSBkYXRhTGlzdFtpIC0gcGFyYW1zWzBdXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0YUxpc3RbaSAtIChwYXJhbXNbMF0gLSAxKV0pLmNsb3NlO1xuICAgICAgICAgICAgICAgIGhjeSAtPSAoYWdvSGlnaCAtIGFnb1ByZUNsb3NlKTtcbiAgICAgICAgICAgICAgICBjeWwgLT0gKGFnb1ByZUNsb3NlIC0gYWdvTG93KTtcbiAgICAgICAgICAgICAgICBobyAtPSAoYWdvSGlnaCAtIGFnb09wZW4pO1xuICAgICAgICAgICAgICAgIG9sIC09IChhZ29PcGVuIC0gYWdvTG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBicmFyO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIOWkmuepuuaMh+agh1xuICog5YWs5byPOiBCQkkgPSAoTUEoQ0xPU0UsIE0pICsgTUEoQ0xPU0UsIE4pICsgTUEoQ0xPU0UsIE8pICsgTUEoQ0xPU0UsIFApKSAvIDRcbiAqXG4gKi9cbnZhciBidWxsQW5kQmVhckluZGV4ID0ge1xuICAgIG5hbWU6ICdCQkknLFxuICAgIHNob3J0TmFtZTogJ0JCSScsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXG4gICAgcHJlY2lzaW9uOiAyLFxuICAgIGNhbGNQYXJhbXM6IFszLCA2LCAxMiwgMjRdLFxuICAgIHNob3VsZE9obGM6IHRydWUsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2JiaScsIHRpdGxlOiAnQkJJOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgbWF4UGVyaW9kID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBhcmFtcyksIGZhbHNlKSk7XG4gICAgICAgIHZhciBjbG9zZVN1bXMgPSBbXTtcbiAgICAgICAgdmFyIG1hcyA9IFtdO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBiYmkgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjbG9zZVN1bXNbaW5kZXhdID0gKChfYSA9IGNsb3NlU3Vtc1tpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICsgY2xvc2U7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFzW2luZGV4XSA9IGNsb3NlU3Vtc1tpbmRleF0gLyBwO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVN1bXNbaW5kZXhdIC09IGRhdGFMaXN0W2kgLSAocCAtIDEpXS5jbG9zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpID49IG1heFBlcmlvZCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFTdW1fMSA9IDA7XG4gICAgICAgICAgICAgICAgbWFzLmZvckVhY2goZnVuY3Rpb24gKG1hKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hU3VtXzEgKz0gbWE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmJpLmJiaSA9IG1hU3VtXzEgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJiaTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENDSVxuICogQ0NJ77yITuaXpe+8iT3vvIhUUO+8jU1B77yJw7dNRMO3MC4wMTVcbiAqIOWFtuS4re+8jFRQPe+8iOacgOmrmOS7tyvmnIDkvY7ku7cr5pS255uY5Lu377yJw7czXG4gKiBNQT3ov5FO5pelVFDku7fnmoTntK/orqHkuYvlkozDt05cbiAqIE1EPei/kU7ml6VUUCAtIOW9k+WJjU1B57ud5a+55YC855qE57Sv6K6h5LmL5ZKMw7dOXG4gKlxuICovXG52YXIgY29tbW9kaXR5Q2hhbm5lbEluZGV4ID0ge1xuICAgIG5hbWU6ICdDQ0knLFxuICAgIHNob3J0TmFtZTogJ0NDSScsXG4gICAgY2FsY1BhcmFtczogWzIwXSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnY2NpJywgdGl0bGU6ICdDQ0k6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBwID0gcGFyYW1zWzBdIC0gMTtcbiAgICAgICAgdmFyIHRwU3VtID0gMDtcbiAgICAgICAgdmFyIHRwTGlzdCA9IFtdO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBjY2kgPSB7fTtcbiAgICAgICAgICAgIHZhciB0cCA9IChrTGluZURhdGEuaGlnaCArIGtMaW5lRGF0YS5sb3cgKyBrTGluZURhdGEuY2xvc2UpIC8gMztcbiAgICAgICAgICAgIHRwU3VtICs9IHRwO1xuICAgICAgICAgICAgdHBMaXN0LnB1c2godHApO1xuICAgICAgICAgICAgaWYgKGkgPj0gcCkge1xuICAgICAgICAgICAgICAgIHZhciBtYVRwXzEgPSB0cFN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgc2xpY2VUcExpc3QgPSB0cExpc3Quc2xpY2UoaSAtIHAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgc3VtXzEgPSAwO1xuICAgICAgICAgICAgICAgIHNsaWNlVHBMaXN0LmZvckVhY2goZnVuY3Rpb24gKHRwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bV8xICs9IE1hdGguYWJzKHRwIC0gbWFUcF8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWQgPSBzdW1fMSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICBjY2kuY2NpID0gbWQgIT09IDAgPyAodHAgLSBtYVRwXzEpIC8gbWQgLyAwLjAxNSA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIGFnb1RwID0gKGRhdGFMaXN0W2kgLSBwXS5oaWdoICsgZGF0YUxpc3RbaSAtIHBdLmxvdyArIGRhdGFMaXN0W2kgLSBwXS5jbG9zZSkgLyAzO1xuICAgICAgICAgICAgICAgIHRwU3VtIC09IGFnb1RwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNjaTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Knd3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTUlEOj1SRUYoSElHSCtMT1csMSkvMjtcbiAqIENSOlNVTShNQVgoMCxISUdILU1JRCksTikvU1VNKE1BWCgwLE1JRC1MT1cpLE4pKjEwMDtcbiAqIE1BMTpSRUYoTUEoQ1IsTTEpLE0xLzIuNSsxKTtcbiAqIE1BMjpSRUYoTUEoQ1IsTTIpLE0yLzIuNSsxKTtcbiAqIE1BMzpSRUYoTUEoQ1IsTTMpLE0zLzIuNSsxKTtcbiAqIE1BNDpSRUYoTUEoQ1IsTTQpLE00LzIuNSsxKTtcbiAqIE1JROi1i+WAvDoo5pio5pel5pyA6auY5Lu3K+aYqOaXpeacgOS9juS7tykvMlxuICog6L6T5Ye65bim54q26IO96YeP57q/OjDlkozmnIDpq5jku7ctTUlE55qE6L6D5aSn5YC855qETuaXpee0r+WSjC8w5ZKMTUlELeacgOS9juS7t+eahOi+g+Wkp+WAvOeahE7ml6XntK/lkowqMTAwXG4gKiDovpPlh7pNQTE6TTEoNSkvMi41KzHml6XliY3nmoRDUueahE0xKDUp5pel566A5Y2V56e75Yqo5bmz5Z2HXG4gKiDovpPlh7pNQTI6TTIoMTApLzIuNSsx5pel5YmN55qEQ1LnmoRNMigxMCnml6XnroDljZXnp7vliqjlubPlnYdcbiAqIOi+k+WHuk1BMzpNMygyMCkvMi41KzHml6XliY3nmoRDUueahE0zKDIwKeaXpeeugOWNleenu+WKqOW5s+Wdh1xuICog6L6T5Ye6TUE0Ok00LzIuNSsx5pel5YmN55qEQ1LnmoRNNOaXpeeugOWNleenu+WKqOW5s+Wdh1xuICpcbiAqL1xudmFyIGN1cnJlbnRSYXRpbyA9IHtcbiAgICBuYW1lOiAnQ1InLFxuICAgIHNob3J0TmFtZTogJ0NSJyxcbiAgICBjYWxjUGFyYW1zOiBbMjYsIDEwLCAyMCwgNDAsIDYwXSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnY3InLCB0aXRsZTogJ0NSOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTEnLCB0aXRsZTogJ01BMTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWEyJywgdGl0bGU6ICdNQTI6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMycsIHRpdGxlOiAnTUEzOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTQnLCB0aXRsZTogJ01BNDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIG1hMUZvcndhcmRQZXJpb2QgPSBNYXRoLmNlaWwocGFyYW1zWzFdIC8gMi41ICsgMSk7XG4gICAgICAgIHZhciBtYTJGb3J3YXJkUGVyaW9kID0gTWF0aC5jZWlsKHBhcmFtc1syXSAvIDIuNSArIDEpO1xuICAgICAgICB2YXIgbWEzRm9yd2FyZFBlcmlvZCA9IE1hdGguY2VpbChwYXJhbXNbM10gLyAyLjUgKyAxKTtcbiAgICAgICAgdmFyIG1hNEZvcndhcmRQZXJpb2QgPSBNYXRoLmNlaWwocGFyYW1zWzRdIC8gMi41ICsgMSk7XG4gICAgICAgIHZhciBtYTFTdW0gPSAwO1xuICAgICAgICB2YXIgbWExTGlzdCA9IFtdO1xuICAgICAgICB2YXIgbWEyU3VtID0gMDtcbiAgICAgICAgdmFyIG1hMkxpc3QgPSBbXTtcbiAgICAgICAgdmFyIG1hM1N1bSA9IDA7XG4gICAgICAgIHZhciBtYTNMaXN0ID0gW107XG4gICAgICAgIHZhciBtYTRTdW0gPSAwO1xuICAgICAgICB2YXIgbWE0TGlzdCA9IFtdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIHZhciBjciA9IHt9O1xuICAgICAgICAgICAgdmFyIHByZXZEYXRhID0gKF9hID0gZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGE7XG4gICAgICAgICAgICB2YXIgcHJldk1pZCA9IChwcmV2RGF0YS5oaWdoICsgcHJldkRhdGEuY2xvc2UgKyBwcmV2RGF0YS5sb3cgKyBwcmV2RGF0YS5vcGVuKSAvIDQ7XG4gICAgICAgICAgICB2YXIgaGlnaFN1YlByZU1pZCA9IE1hdGgubWF4KDAsIGtMaW5lRGF0YS5oaWdoIC0gcHJldk1pZCk7XG4gICAgICAgICAgICB2YXIgcHJlTWlkU3ViTG93ID0gTWF0aC5tYXgoMCwgcHJldk1pZCAtIGtMaW5lRGF0YS5sb3cpO1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVNaWRTdWJMb3cgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3IuY3IgPSBoaWdoU3ViUHJlTWlkIC8gcHJlTWlkU3ViTG93ICogMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3IuY3IgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYTFTdW0gKz0gY3IuY3I7XG4gICAgICAgICAgICAgICAgbWEyU3VtICs9IGNyLmNyO1xuICAgICAgICAgICAgICAgIG1hM1N1bSArPSBjci5jcjtcbiAgICAgICAgICAgICAgICBtYTRTdW0gKz0gY3IuY3I7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzFdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBtYTFMaXN0LnB1c2gobWExU3VtIC8gcGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzFdICsgbWExRm9yd2FyZFBlcmlvZCAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyLm1hMSA9IG1hMUxpc3RbbWExTGlzdC5sZW5ndGggLSAxIC0gbWExRm9yd2FyZFBlcmlvZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWExU3VtIC09ICgoX2IgPSByZXN1bHRbaSAtIChwYXJhbXNbMV0gLSAxKV0uY3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKyBwYXJhbXNbMl0gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hMkxpc3QucHVzaChtYTJTdW0gLyBwYXJhbXNbMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKyBwYXJhbXNbMl0gKyBtYTJGb3J3YXJkUGVyaW9kIC0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3IubWEyID0gbWEyTGlzdFttYTJMaXN0Lmxlbmd0aCAtIDEgLSBtYTJGb3J3YXJkUGVyaW9kXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYTJTdW0gLT0gKChfYyA9IHJlc3VsdFtpIC0gKHBhcmFtc1syXSAtIDEpXS5jcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1szXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWEzTGlzdC5wdXNoKG1hM1N1bSAvIHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSArIHBhcmFtc1szXSArIG1hM0ZvcndhcmRQZXJpb2QgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjci5tYTMgPSBtYTNMaXN0W21hM0xpc3QubGVuZ3RoIC0gMSAtIG1hM0ZvcndhcmRQZXJpb2RdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hM1N1bSAtPSAoKF9kID0gcmVzdWx0W2kgLSAocGFyYW1zWzNdIC0gMSldLmNyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzRdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBtYTRMaXN0LnB1c2gobWE0U3VtIC8gcGFyYW1zWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzRdICsgbWE0Rm9yd2FyZFBlcmlvZCAtIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyLm1hNCA9IG1hNExpc3RbbWE0TGlzdC5sZW5ndGggLSAxIC0gbWE0Rm9yd2FyZFBlcmlvZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWE0U3VtIC09ICgoX2UgPSByZXN1bHRbaSAtIChwYXJhbXNbNF0gLSAxKV0uY3IpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERNQVxuICog5YWs5byP77yaRElGOk1BKENMT1NFLE4xKS1NQShDTE9TRSxOMik7RElGTUE6TUEoRElGLE0pXG4gKi9cbnZhciBkaWZmZXJlbnRPZk1vdmluZ0F2ZXJhZ2UgPSB7XG4gICAgbmFtZTogJ0RNQScsXG4gICAgc2hvcnROYW1lOiAnRE1BJyxcbiAgICBjYWxjUGFyYW1zOiBbMTAsIDUwLCAxMF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2RtYScsIHRpdGxlOiAnRE1BOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdhbWEnLCB0aXRsZTogJ0FNQTogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIG1heFBlcmlvZCA9IE1hdGgubWF4KHBhcmFtc1swXSwgcGFyYW1zWzFdKTtcbiAgICAgICAgdmFyIGNsb3NlU3VtMSA9IDA7XG4gICAgICAgIHZhciBjbG9zZVN1bTIgPSAwO1xuICAgICAgICB2YXIgZG1hU3VtID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBkbWEgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbG9zZSA9IGtMaW5lRGF0YS5jbG9zZTtcbiAgICAgICAgICAgIGNsb3NlU3VtMSArPSBjbG9zZTtcbiAgICAgICAgICAgIGNsb3NlU3VtMiArPSBjbG9zZTtcbiAgICAgICAgICAgIHZhciBtYTEgPSAwO1xuICAgICAgICAgICAgdmFyIG1hMiA9IDA7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgbWExID0gY2xvc2VTdW0xIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIGNsb3NlU3VtMSAtPSBkYXRhTGlzdFtpIC0gKHBhcmFtc1swXSAtIDEpXS5jbG9zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1sxXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBtYTIgPSBjbG9zZVN1bTIgLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgY2xvc2VTdW0yIC09IGRhdGFMaXN0W2kgLSAocGFyYW1zWzFdIC0gMSldLmNsb3NlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gbWF4UGVyaW9kIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkaWYgPSBtYTEgLSBtYTI7XG4gICAgICAgICAgICAgICAgZG1hLmRtYSA9IGRpZjtcbiAgICAgICAgICAgICAgICBkbWFTdW0gKz0gZGlmO1xuICAgICAgICAgICAgICAgIGlmIChpID49IG1heFBlcmlvZCArIHBhcmFtc1syXSAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG1hLmFtYSA9IGRtYVN1bSAvIHBhcmFtc1syXTtcbiAgICAgICAgICAgICAgICAgICAgZG1hU3VtIC09ICgoX2EgPSByZXN1bHRbaSAtIChwYXJhbXNbMl0gLSAxKV0uZG1hKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkbWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRE1JXG4gKlxuICogTVRSOj1FWFBNRU1BKE1BWChNQVgoSElHSC1MT1csQUJTKEhJR0gtUkVGKENMT1NFLDEpKSksQUJTKFJFRihDTE9TRSwxKS1MT1cpKSxOKVxuICogSEQgOj1ISUdILVJFRihISUdILDEpO1xuICogTEQgOj1SRUYoTE9XLDEpLUxPVztcbiAqIERNUDo9RVhQTUVNQShJRihIRD4wJiZIRD5MRCxIRCwwKSxOKTtcbiAqIERNTTo9RVhQTUVNQShJRihMRD4wJiZMRD5IRCxMRCwwKSxOKTtcbiAqXG4gKiBQREk6IERNUCoxMDAvTVRSO1xuICogTURJOiBETU0qMTAwL01UUjtcbiAqIEFEWDogRVhQTUVNQShBQlMoTURJLVBESSkvKE1ESStQREkpKjEwMCxNTSk7XG4gKiBBRFhSOkVYUE1FTUEoQURYLE1NKTtcbiAqIOWFrOW8j+WQq+S5ie+8mlxuICogTVRS6LWL5YC8OuacgOmrmOS7ty3mnIDkvY7ku7flkozmnIDpq5jku7ct5pio5pS255qE57ud5a+55YC855qE6L6D5aSn5YC85ZKM5pio5pS2LeacgOS9juS7t+eahOe7neWvueWAvOeahOi+g+Wkp+WAvOeahE7ml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYdcbiAqIEhE6LWL5YC8OuacgOmrmOS7ty3mmKjml6XmnIDpq5jku7dcbiAqIExE6LWL5YC8OuaYqOaXpeacgOS9juS7ty3mnIDkvY7ku7dcbiAqIERNUOi1i+WAvDrlpoLmnpxIRD4w5bm25LiUSEQ+TEQs6L+U5ZueSEQs5ZCm5YiZ6L+U5ZueMOeahE7ml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYdcbiAqIERNTei1i+WAvDrlpoLmnpxMRD4w5bm25LiUTEQ+SEQs6L+U5ZueTEQs5ZCm5YiZ6L+U5ZueMOeahE7ml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYdcbiAqIOi+k+WHulBESTpETVAqMTAwL01UUlxuICog6L6T5Ye6TURJOkRNTSoxMDAvTVRSXG4gKiDovpPlh7pBRFg6TURJLVBESeeahOe7neWvueWAvC8oTURJK1BESSkqMTAw55qETU3ml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYdcbiAqIOi+k+WHukFEWFI6QURY55qETU3ml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYdcbiAqXG4gKi9cbnZhciBkaXJlY3Rpb25hbE1vdmVtZW50SW5kZXggPSB7XG4gICAgbmFtZTogJ0RNSScsXG4gICAgc2hvcnROYW1lOiAnRE1JJyxcbiAgICBjYWxjUGFyYW1zOiBbMTQsIDZdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdwZGknLCB0aXRsZTogJ1BESTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWRpJywgdGl0bGU6ICdNREk6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2FkeCcsIHRpdGxlOiAnQURYOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdhZHhyJywgdGl0bGU6ICdBRFhSOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgdHJTdW0gPSAwO1xuICAgICAgICB2YXIgaFN1bSA9IDA7XG4gICAgICAgIHZhciBsU3VtID0gMDtcbiAgICAgICAgdmFyIG10ciA9IDA7XG4gICAgICAgIHZhciBkbXAgPSAwO1xuICAgICAgICB2YXIgZG1tID0gMDtcbiAgICAgICAgdmFyIGR4U3VtID0gMDtcbiAgICAgICAgdmFyIGFkeCA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGRtaSA9IHt9O1xuICAgICAgICAgICAgdmFyIHByZXZLTGluZURhdGEgPSAoX2EgPSBkYXRhTGlzdFtpIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGtMaW5lRGF0YTtcbiAgICAgICAgICAgIHZhciBwcmVDbG9zZSA9IHByZXZLTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICB2YXIgaGlnaCA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgdmFyIGxvdyA9IGtMaW5lRGF0YS5sb3c7XG4gICAgICAgICAgICB2YXIgaGwgPSBoaWdoIC0gbG93O1xuICAgICAgICAgICAgdmFyIGhjeSA9IE1hdGguYWJzKGhpZ2ggLSBwcmVDbG9zZSk7XG4gICAgICAgICAgICB2YXIgbGN5ID0gTWF0aC5hYnMocHJlQ2xvc2UgLSBsb3cpO1xuICAgICAgICAgICAgdmFyIGhoeSA9IGhpZ2ggLSBwcmV2S0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICB2YXIgbHlsID0gcHJldktMaW5lRGF0YS5sb3cgLSBsb3c7XG4gICAgICAgICAgICB2YXIgdHIgPSBNYXRoLm1heChNYXRoLm1heChobCwgaGN5KSwgbGN5KTtcbiAgICAgICAgICAgIHZhciBoID0gKGhoeSA+IDAgJiYgaGh5ID4gbHlsKSA/IGhoeSA6IDA7XG4gICAgICAgICAgICB2YXIgbCA9IChseWwgPiAwICYmIGx5bCA+IGhoeSkgPyBseWwgOiAwO1xuICAgICAgICAgICAgdHJTdW0gKz0gdHI7XG4gICAgICAgICAgICBoU3VtICs9IGg7XG4gICAgICAgICAgICBsU3VtICs9IGw7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG10ciA9IG10ciAtIG10ciAvIHBhcmFtc1swXSArIHRyO1xuICAgICAgICAgICAgICAgICAgICBkbXAgPSBkbXAgLSBkbXAgLyBwYXJhbXNbMF0gKyBoO1xuICAgICAgICAgICAgICAgICAgICBkbW0gPSBkbW0gLSBkbW0gLyBwYXJhbXNbMF0gKyBsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXRyID0gdHJTdW07XG4gICAgICAgICAgICAgICAgICAgIGRtcCA9IGhTdW07XG4gICAgICAgICAgICAgICAgICAgIGRtbSA9IGxTdW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwZGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtZGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChtdHIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGRpID0gZG1wICogMTAwIC8gbXRyO1xuICAgICAgICAgICAgICAgICAgICBtZGkgPSBkbW0gKiAxMDAgLyBtdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRtaS5wZGkgPSBwZGk7XG4gICAgICAgICAgICAgICAgZG1pLm1kaSA9IG1kaTtcbiAgICAgICAgICAgICAgICB2YXIgZHggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChtZGkgKyBwZGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicygobWRpIC0gcGRpKSkgLyAobWRpICsgcGRpKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHhTdW0gKz0gZHg7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICogMiAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gKiAyIC0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR4ID0gKGFkeCAqIChwYXJhbXNbMF0gLSAxKSArIGR4KSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkeCA9IGR4U3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRtaS5hZHggPSBhZHg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAqIDIgKyBwYXJhbXNbMV0gLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbWkuYWR4ciA9ICgoKF9iID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLmFkeCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyBhZHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRtaSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKlxuICogRU1WIOeugOaYk+azouWKqOaMh+agh1xuICog5YWs5byP77yaXG4gKiBBPe+8iOS7iuaXpeacgOmrmCvku4rml6XmnIDkvY7vvIkvMlxuICogQj3vvIjliY3ml6XmnIDpq5gr5YmN5pel5pyA5L2O77yJLzJcbiAqIEM95LuK5pel5pyA6auYLeS7iuaXpeacgOS9jlxuICogRU0977yIQS1C77yJKkMv5LuK5pel5oiQ5Lqk6aKdXG4gKiBFTVY9TuaXpeWGhUVN55qE57Sv5ZKMXG4gKiBNQUVNVj1FTVbnmoRN5pel55qE566A5Y2V56e75Yqo5bmz5Z2HXG4gKlxuICovXG52YXIgZWFzZU9mTW92ZW1lbnRWYWx1ZSA9IHtcbiAgICBuYW1lOiAnRU1WJyxcbiAgICBzaG9ydE5hbWU6ICdFTVYnLFxuICAgIGNhbGNQYXJhbXM6IFsxNCwgOV0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2VtdicsIHRpdGxlOiAnRU1WOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYUVtdicsIHRpdGxlOiAnTUFFTVY6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBlbXZWYWx1ZVN1bSA9IDA7XG4gICAgICAgIHZhciBlbXZWYWx1ZUxpc3QgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgZW12ID0ge307XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldktMaW5lRGF0YSA9IGRhdGFMaXN0W2kgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgICAgIHZhciBsb3cgPSBrTGluZURhdGEubG93O1xuICAgICAgICAgICAgICAgIHZhciB2b2x1bWUgPSAoX2EgPSBrTGluZURhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZU1vdmVkID0gKGhpZ2ggKyBsb3cpIC8gMiAtIChwcmV2S0xpbmVEYXRhLmhpZ2ggKyBwcmV2S0xpbmVEYXRhLmxvdykgLyAyO1xuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUgPT09IDAgfHwgaGlnaCAtIGxvdyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlbXYuZW12ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHZvbHVtZSAvIDEwMDAwMDAwMCAvIChoaWdoIC0gbG93KTtcbiAgICAgICAgICAgICAgICAgICAgZW12LmVtdiA9IGRpc3RhbmNlTW92ZWQgLyByYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW12VmFsdWVTdW0gKz0gZW12LmVtdjtcbiAgICAgICAgICAgICAgICBlbXZWYWx1ZUxpc3QucHVzaChlbXYuZW12KTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZW12Lm1hRW12ID0gZW12VmFsdWVTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGVtdlZhbHVlU3VtIC09IGVtdlZhbHVlTGlzdFtpIC0gcGFyYW1zWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW12O1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRU1BIOaMh+aVsOenu+WKqOW5s+Wdh1xuICovXG52YXIgZXhwb25lbnRpYWxNb3ZpbmdBdmVyYWdlID0ge1xuICAgIG5hbWU6ICdFTUEnLFxuICAgIHNob3J0TmFtZTogJ0VNQScsXG4gICAgc2VyaWVzOiBJbmRpY2F0b3JTZXJpZXMuUHJpY2UsXG4gICAgY2FsY1BhcmFtczogWzYsIDEyLCAyMF0sXG4gICAgcHJlY2lzaW9uOiAyLFxuICAgIHNob3VsZE9obGM6IHRydWUsXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2VtYTEnLCB0aXRsZTogJ0VNQTY6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2VtYTInLCB0aXRsZTogJ0VNQTEyOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdlbWEzJywgdGl0bGU6ICdFTUEyMDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIHJlZ2VuZXJhdGVGaWd1cmVzOiBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiAoeyBrZXk6IFwiZW1hXCIuY29uY2F0KGkgKyAxKSwgdGl0bGU6IFwiRU1BXCIuY29uY2F0KHAsIFwiOiBcIiksIHR5cGU6ICdsaW5lJyB9KTsgfSk7IH0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zLCBmaWd1cmVzID0gaW5kaWNhdG9yLmZpZ3VyZXM7XG4gICAgICAgIHZhciBjbG9zZVN1bSA9IDA7XG4gICAgICAgIHZhciBlbWFWYWx1ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgZW1hID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBjbG9zZVN1bSArPSBjbG9zZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gcCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYVZhbHVlc1tpbmRleF0gPSAoMiAqIGNsb3NlICsgKHAgLSAxKSAqIGVtYVZhbHVlc1tpbmRleF0pIC8gKHAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYVZhbHVlc1tpbmRleF0gPSBjbG9zZVN1bSAvIHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW1hW2ZpZ3VyZXNbaW5kZXhdLmtleV0gPSBlbWFWYWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVtYTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIG10bVxuICog5YWs5byPIE1UTe+8iE7ml6XvvIk9Q++8jUNOXG4gKi9cbnZhciBtb21lbnR1bSA9IHtcbiAgICBuYW1lOiAnTVRNJyxcbiAgICBzaG9ydE5hbWU6ICdNVE0nLFxuICAgIGNhbGNQYXJhbXM6IFsxMiwgNl0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ210bScsIHRpdGxlOiAnTVRNOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYU10bScsIHRpdGxlOiAnTUFNVE06ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBtdG1TdW0gPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIG10bSA9IHt9O1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFnb0Nsb3NlID0gZGF0YUxpc3RbaSAtIHBhcmFtc1swXV0uY2xvc2U7XG4gICAgICAgICAgICAgICAgbXRtLm10bSA9IGNsb3NlXzEgLSBhZ29DbG9zZTtcbiAgICAgICAgICAgICAgICBtdG1TdW0gKz0gbXRtLm10bTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKyBwYXJhbXNbMV0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG10bS5tYU10bSA9IG10bVN1bSAvIHBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgbXRtU3VtIC09ICgoX2EgPSByZXN1bHRbaSAtIChwYXJhbXNbMV0gLSAxKV0ubXRtKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTUEg56e75Yqo5bmz5Z2HXG4gKi9cbnZhciBtb3ZpbmdBdmVyYWdlID0ge1xuICAgIG5hbWU6ICdNQScsXG4gICAgc2hvcnROYW1lOiAnTUEnLFxuICAgIHNlcmllczogSW5kaWNhdG9yU2VyaWVzLlByaWNlLFxuICAgIGNhbGNQYXJhbXM6IFs1LCAxMCwgMzAsIDYwXSxcbiAgICBwcmVjaXNpb246IDIsXG4gICAgc2hvdWxkT2hsYzogdHJ1ZSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnbWExJywgdGl0bGU6ICdNQTU6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMicsIHRpdGxlOiAnTUExMDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWEzJywgdGl0bGU6ICdNQTMwOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYTQnLCB0aXRsZTogJ01BNjA6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICByZWdlbmVyYXRlRmlndXJlczogZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gKHsga2V5OiBcIm1hXCIuY29uY2F0KGkgKyAxKSwgdGl0bGU6IFwiTUFcIi5jb25jYXQocCwgXCI6IFwiKSwgdHlwZTogJ2xpbmUnIH0pOyB9KTsgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIGZpZ3VyZXMgPSBpbmRpY2F0b3IuZmlndXJlcztcbiAgICAgICAgdmFyIGNsb3NlU3VtcyA9IFtdO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBtYSA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNsb3NlU3Vtc1tpbmRleF0gPSAoKF9hID0gY2xvc2VTdW1zW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyBjbG9zZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYVtmaWd1cmVzW2luZGV4XS5rZXldID0gY2xvc2VTdW1zW2luZGV4XSAvIHA7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlU3Vtc1tpbmRleF0gLT0gZGF0YUxpc3RbaSAtIChwIC0gMSldLmNsb3NlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTUFDRO+8muWPguaVsOW/q+e6v+enu+WKqOW5s+Wdh+OAgeaFoue6v+enu+WKqOW5s+Wdh+OAgeenu+WKqOW5s+Wdh++8jFxuICog6buY6K6k5Y+C5pWw5YC8MTLjgIEyNuOAgTnjgIJcbiAqIOWFrOW8j++8muKSiOmmluWFiOWIhuWIq+iuoeeul+WHuuaUtuebmOS7tzEy5pel5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2H57q/5LiOMjbml6XmjIfmlbDlubPmu5Hnp7vliqjlubPlnYfnur/vvIzliIbliKvorrDkuLpFTUEoMTLvvInkuI5FTUEoMjbvvInjgIJcbiAqIOKSieaxgui/meS4pOadoeaMh+aVsOW5s+a7keenu+WKqOW5s+Wdh+e6v+eahOW3ru+8jOWNs++8mkRJRkYgPSBFTUEoU0hPUlQpIO+8jSBFTUEoTE9ORynjgIJcbiAqIOKSiuWGjeiuoeeul0RJRkbnmoRN5pel55qE5bmz5Z2H55qE5oyH5pWw5bmz5ruR56e75Yqo5bmz5Z2H57q/77yM6K6w5Li6REVB44CCXG4gKiDikovmnIDlkI7nlKhESUZG5YePREVB77yM5b6XTUFDROOAgk1BQ0TpgJrluLjnu5jliLbmiJDlm7Tnu5Xpm7bovbTnur/ms6LliqjnmoTmn7HlvaLlm77jgIJNQUNE5p+x54q25aSn5LqOMOa2qOminOiJsu+8jOWwj+S6jjDot4zpopzoibLjgIJcbiAqL1xudmFyIG1vdmluZ0F2ZXJhZ2VDb252ZXJnZW5jZURpdmVyZ2VuY2UgPSB7XG4gICAgbmFtZTogJ01BQ0QnLFxuICAgIHNob3J0TmFtZTogJ01BQ0QnLFxuICAgIGNhbGNQYXJhbXM6IFsxMiwgMjYsIDldLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdkaWYnLCB0aXRsZTogJ0RJRjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnZGVhJywgdGl0bGU6ICdERUE6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdtYWNkJyxcbiAgICAgICAgICAgIHRpdGxlOiAnTUFDRDogJyxcbiAgICAgICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICAgICAgYmFzZVZhbHVlOiAwLFxuICAgICAgICAgICAgc3R5bGVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSwgaW5kaWNhdG9yID0gX2EuaW5kaWNhdG9yLCBkZWZhdWx0U3R5bGVzID0gX2EuZGVmYXVsdFN0eWxlcztcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGRhdGEucHJldiwgY3VycmVudCA9IGRhdGEuY3VycmVudDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldk1hY2QgPSAoX2IgPSBwcmV2ID09PSBudWxsIHx8IHByZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXYubWFjZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRNYWNkID0gKF9jID0gY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Lm1hY2QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWFjZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS51cENvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0udXBDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRNYWNkIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdiYXJzWzBdLmRvd25Db2xvcicsIChkZWZhdWx0U3R5bGVzLmJhcnMpWzBdLmRvd25Db2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdiYXJzWzBdLm5vQ2hhbmdlQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5iYXJzKVswXS5ub0NoYW5nZUNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gcHJldk1hY2QgPCBjdXJyZW50TWFjZCA/IFBvbHlnb25UeXBlLlN0cm9rZSA6IFBvbHlnb25UeXBlLkZpbGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3R5bGU6IHN0eWxlLCBjb2xvcjogY29sb3IsIGJvcmRlckNvbG9yOiBjb2xvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBjbG9zZVN1bSA9IDA7XG4gICAgICAgIHZhciBlbWFTaG9ydCA9IDA7XG4gICAgICAgIHZhciBlbWFMb25nID0gMDtcbiAgICAgICAgdmFyIGRpZiA9IDA7XG4gICAgICAgIHZhciBkaWZTdW0gPSAwO1xuICAgICAgICB2YXIgZGVhID0gMDtcbiAgICAgICAgdmFyIG1heFBlcmlvZCA9IE1hdGgubWF4KHBhcmFtc1swXSwgcGFyYW1zWzFdKTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgbWFjZCA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgY2xvc2VTdW0gKz0gY2xvc2U7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYVNob3J0ID0gKDIgKiBjbG9zZSArIChwYXJhbXNbMF0gLSAxKSAqIGVtYVNob3J0KSAvIChwYXJhbXNbMF0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYVNob3J0ID0gY2xvc2VTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzFdIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gcGFyYW1zWzFdIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWFMb25nID0gKDIgKiBjbG9zZSArIChwYXJhbXNbMV0gLSAxKSAqIGVtYUxvbmcpIC8gKHBhcmFtc1sxXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW1hTG9uZyA9IGNsb3NlU3VtIC8gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IG1heFBlcmlvZCAtIDEpIHtcbiAgICAgICAgICAgICAgICBkaWYgPSBlbWFTaG9ydCAtIGVtYUxvbmc7XG4gICAgICAgICAgICAgICAgbWFjZC5kaWYgPSBkaWY7XG4gICAgICAgICAgICAgICAgZGlmU3VtICs9IGRpZjtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBtYXhQZXJpb2QgKyBwYXJhbXNbMl0gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gbWF4UGVyaW9kICsgcGFyYW1zWzJdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVhID0gKGRpZiAqIDIgKyBkZWEgKiAocGFyYW1zWzJdIC0gMSkpIC8gKHBhcmFtc1syXSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVhID0gZGlmU3VtIC8gcGFyYW1zWzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hY2QubWFjZCA9IChkaWYgLSBkZWEpICogMjtcbiAgICAgICAgICAgICAgICAgICAgbWFjZC5kZWEgPSBkZWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hY2Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBPQlZcbiAqIE9CViA9IFJFRihPQlYpICsgc2lnbiAqIFZcbiAqL1xudmFyIG9uQmFsYW5jZVZvbHVtZSA9IHtcbiAgICBuYW1lOiAnT0JWJyxcbiAgICBzaG9ydE5hbWU6ICdPQlYnLFxuICAgIGNhbGNQYXJhbXM6IFszMF0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ29idicsIHRpdGxlOiAnT0JWOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYU9idicsIHRpdGxlOiAnTUFPQlY6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciBvYnZTdW0gPSAwO1xuICAgICAgICB2YXIgb2xkT2J2ID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIHZhciBwcmV2S0xpbmVEYXRhID0gKF9hID0gZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGE7XG4gICAgICAgICAgICBpZiAoa0xpbmVEYXRhLmNsb3NlIDwgcHJldktMaW5lRGF0YS5jbG9zZSkge1xuICAgICAgICAgICAgICAgIG9sZE9idiAtPSAoKF9iID0ga0xpbmVEYXRhLnZvbHVtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrTGluZURhdGEuY2xvc2UgPiBwcmV2S0xpbmVEYXRhLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgb2xkT2J2ICs9ICgoX2MgPSBrTGluZURhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYnYgPSB7IG9idjogb2xkT2J2IH07XG4gICAgICAgICAgICBvYnZTdW0gKz0gb2xkT2J2O1xuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIG9idi5tYU9idiA9IG9idlN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICBvYnZTdW0gLT0gKChfZCA9IHJlc3VsdFtpIC0gKHBhcmFtc1swXSAtIDEpXS5vYnYpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob2J2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIOS7t+mHj+i2i+WKv+aMh+agh1xuICog5YWs5byPOlxuICogWCA9IChDTE9TRSAtIFJFRihDTE9TRSwgMSkpIC8gUkVGKENMT1NFLCAxKSAqIFZPTFVNRVxuICogUFZUID0gU1VNKFgpXG4gKlxuICovXG52YXIgcHJpY2VBbmRWb2x1bWVUcmVuZCA9IHtcbiAgICBuYW1lOiAnUFZUJyxcbiAgICBzaG9ydE5hbWU6ICdQVlQnLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdwdnQnLCB0aXRsZTogJ1BWVDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIHB2dCA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgdmFyIHZvbHVtZSA9IChfYSA9IGtMaW5lRGF0YS52b2x1bWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgICAgICB2YXIgcHJldkNsb3NlID0gKChfYiA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoga0xpbmVEYXRhKS5jbG9zZTtcbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHByZXZDbG9zZSAqIHZvbHVtZTtcbiAgICAgICAgICAgIGlmICh0b3RhbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSAoY2xvc2UgLSBwcmV2Q2xvc2UpIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKz0geDtcbiAgICAgICAgICAgIHB2dC5wdnQgPSBzdW07XG4gICAgICAgICAgICByZXR1cm4gcHZ0O1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUFNZXG4gKiDlhazlvI/vvJpQU1k9TuaXpeWGheeahOS4iua2qOWkqeaVsC9Ow5cxMDAl44CCXG4gKi9cbnZhciBwc3ljaG9sb2dpY2FsTGluZSA9IHtcbiAgICBuYW1lOiAnUFNZJyxcbiAgICBzaG9ydE5hbWU6ICdQU1knLFxuICAgIGNhbGNQYXJhbXM6IFsxMiwgNl0sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ3BzeScsIHRpdGxlOiAnUFNZOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYVBzeScsIHRpdGxlOiAnTUFQU1k6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciB1cENvdW50ID0gMDtcbiAgICAgICAgdmFyIHBzeVN1bSA9IDA7XG4gICAgICAgIHZhciB1cExpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgcHN5ID0ge307XG4gICAgICAgICAgICB2YXIgcHJldkNsb3NlID0gKChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhKS5jbG9zZTtcbiAgICAgICAgICAgIHZhciB1cEZsYWcgPSBrTGluZURhdGEuY2xvc2UgLSBwcmV2Q2xvc2UgPiAwID8gMSA6IDA7XG4gICAgICAgICAgICB1cExpc3QucHVzaCh1cEZsYWcpO1xuICAgICAgICAgICAgdXBDb3VudCArPSB1cEZsYWc7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgcHN5LnBzeSA9IHVwQ291bnQgLyBwYXJhbXNbMF0gKiAxMDA7XG4gICAgICAgICAgICAgICAgcHN5U3VtICs9IHBzeS5wc3k7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzFdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBwc3kubWFQc3kgPSBwc3lTdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHBzeVN1bSAtPSAoKF9iID0gcmVzdWx0W2kgLSAocGFyYW1zWzFdIC0gMSldLnBzeSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwQ291bnQgLT0gdXBMaXN0W2kgLSAocGFyYW1zWzBdIC0gMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gocHN5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIOWPmOWKqOeOh+aMh+agh1xuICog5YWs5byP77yaUk9DID0gKENMT1NFIC0gUkVGKENMT1NFLCBOKSkgLyBSRUYoQ0xPU0UsIE4pXG4gKi9cbnZhciByYXRlT2ZDaGFuZ2UgPSB7XG4gICAgbmFtZTogJ1JPQycsXG4gICAgc2hvcnROYW1lOiAnUk9DJyxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDZdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICdyb2MnLCB0aXRsZTogJ1JPQzogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWFSb2MnLCB0aXRsZTogJ01BUk9DOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciByb2NTdW0gPSAwO1xuICAgICAgICBkYXRhTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgcm9jID0ge307XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICAgICAgdmFyIGFnb0Nsb3NlID0gKChfYSA9IGRhdGFMaXN0W2kgLSBwYXJhbXNbMF1dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhTGlzdFtpIC0gKHBhcmFtc1swXSAtIDEpXSkuY2xvc2U7XG4gICAgICAgICAgICAgICAgaWYgKGFnb0Nsb3NlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvYy5yb2MgPSAoY2xvc2VfMSAtIGFnb0Nsb3NlKSAvIGFnb0Nsb3NlICogMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9jLnJvYyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvY1N1bSArPSByb2Mucm9jO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAtIDEgKyBwYXJhbXNbMV0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvYy5tYVJvYyA9IHJvY1N1bSAvIHBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcm9jU3VtIC09ICgoX2IgPSByZXN1bHRbaSAtIChwYXJhbXNbMV0gLSAxKV0ucm9jKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChyb2MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUlNJXG4gKiBSU0kgPSBTVU0oTUFYKENMT1NFIC0gUkVGKENMT1NFLDEpLDApLE4pIC8gU1VNKEFCUyhDTE9TRSAtIFJFRihDTE9TRSwxKSksTikgw5cgMTAwXG4gKi9cbnZhciByZWxhdGl2ZVN0cmVuZ3RoSW5kZXggPSB7XG4gICAgbmFtZTogJ1JTSScsXG4gICAgc2hvcnROYW1lOiAnUlNJJyxcbiAgICBjYWxjUGFyYW1zOiBbNiwgMTIsIDI0XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAncnNpMScsIHRpdGxlOiAnUlNJMTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAncnNpMicsIHRpdGxlOiAnUlNJMjogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAncnNpMycsIHRpdGxlOiAnUlNJMzogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIHJlZ2VuZXJhdGVGaWd1cmVzOiBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICB2YXIgbnVtID0gaW5kZXggKyAxO1xuICAgICAgICByZXR1cm4geyBrZXk6IFwicnNpXCIuY29uY2F0KG51bSksIHRpdGxlOiBcIlJTSVwiLmNvbmNhdChudW0sIFwiOiBcIiksIHR5cGU6ICdsaW5lJyB9O1xuICAgIH0pOyB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcywgZmlndXJlcyA9IGluZGljYXRvci5maWd1cmVzO1xuICAgICAgICB2YXIgc3VtQ2xvc2VBcyA9IFtdO1xuICAgICAgICB2YXIgc3VtQ2xvc2VCcyA9IFtdO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciByc2kgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcmV2Q2xvc2UgPSAoKF9hID0gZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGEpLmNsb3NlO1xuICAgICAgICAgICAgdmFyIHRtcCA9IGtMaW5lRGF0YS5jbG9zZSAtIHByZXZDbG9zZTtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmICh0bXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bUNsb3NlQXNbaW5kZXhdID0gKChfYSA9IHN1bUNsb3NlQXNbaW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bUNsb3NlQnNbaW5kZXhdID0gKChfYiA9IHN1bUNsb3NlQnNbaW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArIE1hdGguYWJzKHRtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID49IHAgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW1DbG9zZUJzW2luZGV4XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnNpW2ZpZ3VyZXNbaW5kZXhdLmtleV0gPSAxMDAgLSAoMTAwLjAgLyAoMSArIHN1bUNsb3NlQXNbaW5kZXhdIC8gc3VtQ2xvc2VCc1tpbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJzaVtmaWd1cmVzW2luZGV4XS5rZXldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWdvRGF0YSA9IGRhdGFMaXN0W2kgLSAocCAtIDEpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFnb1ByZURhdGEgPSAoX2MgPSBkYXRhTGlzdFtpIC0gcF0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGFnb0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZ29UbXAgPSBhZ29EYXRhLmNsb3NlIC0gYWdvUHJlRGF0YS5jbG9zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnb1RtcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bUNsb3NlQXNbaW5kZXhdIC09IGFnb1RtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bUNsb3NlQnNbaW5kZXhdIC09IE1hdGguYWJzKGFnb1RtcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByc2k7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBzbWFcbiAqL1xudmFyIHNpbXBsZU1vdmluZ0F2ZXJhZ2UgPSB7XG4gICAgbmFtZTogJ1NNQScsXG4gICAgc2hvcnROYW1lOiAnU01BJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5QcmljZSxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDJdLFxuICAgIHByZWNpc2lvbjogMixcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnc21hJywgdGl0bGU6ICdTTUE6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBzaG91bGRPaGxjOiB0cnVlLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIGNsb3NlU3VtID0gMDtcbiAgICAgICAgdmFyIHNtYVZhbHVlID0gMDtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgc21hID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBjbG9zZVN1bSArPSBjbG9zZTtcbiAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IHBhcmFtc1swXSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc21hVmFsdWUgPSAoY2xvc2UgKiBwYXJhbXNbMV0gKyBzbWFWYWx1ZSAqIChwYXJhbXNbMF0gLSBwYXJhbXNbMV0gKyAxKSkgLyAocGFyYW1zWzBdICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzbWFWYWx1ZSA9IGNsb3NlU3VtIC8gcGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbWEuc21hID0gc21hVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc21hO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogS0RKXG4gKlxuICog5b2T5pelS+WAvD0yLzPDl+WJjeS4gOaXpUvlgLwrMS8zw5flvZPml6VSU1ZcbiAqIOW9k+aXpUTlgLw9Mi8zw5fliY3kuIDml6VE5YC8KzEvM8OX5b2T5pelS+WAvFxuICog6Iul5peg5YmN5LiA5pelSyDlgLzkuI5E5YC877yM5YiZ5Y+v5YiG5Yir55SoNTDmnaXku6Pmm7/jgIJcbiAqIErlgLw9MyrlvZPml6VL5YC8LTIq5b2T5pelROWAvFxuICovXG52YXIgc3RvY2ggPSB7XG4gICAgbmFtZTogJ0tESicsXG4gICAgc2hvcnROYW1lOiAnS0RKJyxcbiAgICBjYWxjUGFyYW1zOiBbOSwgMywgM10sXG4gICAgZmlndXJlczogW1xuICAgICAgICB7IGtleTogJ2snLCB0aXRsZTogJ0s6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2QnLCB0aXRsZTogJ0Q6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ2onLCB0aXRsZTogJ0o6ICcsIHR5cGU6ICdsaW5lJyB9XG4gICAgXSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICB2YXIga2RqID0ge307XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBrTGluZURhdGEuY2xvc2U7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxobiA9IGdldE1heE1pbihkYXRhTGlzdC5zbGljZShpIC0gKHBhcmFtc1swXSAtIDEpLCBpICsgMSksICdoaWdoJywgJ2xvdycpO1xuICAgICAgICAgICAgICAgIHZhciBobiA9IGxoblswXTtcbiAgICAgICAgICAgICAgICB2YXIgbG4gPSBsaG5bMV07XG4gICAgICAgICAgICAgICAgdmFyIGhuU3ViTG4gPSBobiAtIGxuO1xuICAgICAgICAgICAgICAgIHZhciByc3YgPSAoY2xvc2UgLSBsbikgLyAoaG5TdWJMbiA9PT0gMCA/IDEgOiBoblN1YkxuKSAqIDEwMDtcbiAgICAgICAgICAgICAgICBrZGouayA9ICgocGFyYW1zWzFdIC0gMSkgKiAoKF9iID0gKF9hID0gcmVzdWx0W2kgLSAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmspICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDUwKSArIHJzdikgLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAga2RqLmQgPSAoKHBhcmFtc1syXSAtIDEpICogKChfZCA9IChfYyA9IHJlc3VsdFtpIC0gMV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiA1MCkgKyBrZGouaykgLyBwYXJhbXNbMl07XG4gICAgICAgICAgICAgICAga2RqLmogPSAzLjAgKiBrZGouayAtIDIuMCAqIGtkai5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2RqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgc3RvcEFuZFJldmVyc2UgPSB7XG4gICAgbmFtZTogJ1NBUicsXG4gICAgc2hvcnROYW1lOiAnU0FSJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5QcmljZSxcbiAgICBjYWxjUGFyYW1zOiBbMiwgMiwgMjBdLFxuICAgIHByZWNpc2lvbjogMixcbiAgICBzaG91bGRPaGxjOiB0cnVlLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnc2FyJyxcbiAgICAgICAgICAgIHRpdGxlOiAnU0FSOiAnLFxuICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSwgaW5kaWNhdG9yID0gX2EuaW5kaWNhdG9yLCBkZWZhdWx0U3R5bGVzID0gX2EuZGVmYXVsdFN0eWxlcztcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGRhdGEuY3VycmVudDtcbiAgICAgICAgICAgICAgICB2YXIgc2FyID0gKF9iID0gY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LnNhcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGZITCA9ICgoKF9jID0gY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmhpZ2gpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApICsgKChfZCA9IGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5sb3cpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApKSAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gc2FyIDwgaGFsZkhMXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2NpcmNsZXNbMF0udXBDb2xvcicsIChkZWZhdWx0U3R5bGVzLmNpcmNsZXMpWzBdLnVwQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0VmFsdWUoaW5kaWNhdG9yLnN0eWxlcywgJ2NpcmNsZXNbMF0uZG93bkNvbG9yJywgKGRlZmF1bHRTdHlsZXMuY2lyY2xlcylbMF0uZG93bkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb2xvcjogY29sb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgc3RhcnRBZiA9IHBhcmFtc1swXSAvIDEwMDtcbiAgICAgICAgdmFyIHN0ZXAgPSBwYXJhbXNbMV0gLyAxMDA7XG4gICAgICAgIHZhciBtYXhBZiA9IHBhcmFtc1syXSAvIDEwMDtcbiAgICAgICAgLy8g5Yqg6YCf5Zug5a2QXG4gICAgICAgIHZhciBhZiA9IHN0YXJ0QWY7XG4gICAgICAgIC8vIOaegeWAvFxuICAgICAgICB2YXIgZXAgPSAtMTAwO1xuICAgICAgICAvLyDliKTmlq3mmK/kuIrmtqjov5jmmK/kuIvot4wgIGZhbHNl77ya5LiL6LeMXG4gICAgICAgIHZhciBpc0luY3JlYXNpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNhciA9IDA7XG4gICAgICAgIHJldHVybiBkYXRhTGlzdC5tYXAoZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgLy8g5LiK5LiA5Liq5ZGo5pyf55qEc2FyXG4gICAgICAgICAgICB2YXIgcHJlU2FyID0gc2FyO1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBrTGluZURhdGEuaGlnaDtcbiAgICAgICAgICAgIHZhciBsb3cgPSBrTGluZURhdGEubG93O1xuICAgICAgICAgICAgaWYgKGlzSW5jcmVhc2luZykge1xuICAgICAgICAgICAgICAgIC8vIOS4iua2qFxuICAgICAgICAgICAgICAgIGlmIChlcCA9PT0gLTEwMCB8fCBlcCA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5Yid5aeL5YyW5YC8XG4gICAgICAgICAgICAgICAgICAgIGVwID0gaGlnaDtcbiAgICAgICAgICAgICAgICAgICAgYWYgPSBNYXRoLm1pbihhZiArIHN0ZXAsIG1heEFmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2FyID0gcHJlU2FyICsgYWYgKiAoZXAgLSBwcmVTYXIpO1xuICAgICAgICAgICAgICAgIHZhciBsb3dNaW4gPSBNYXRoLm1pbihkYXRhTGlzdFtNYXRoLm1heCgxLCBpKSAtIDFdLmxvdywgbG93KTtcbiAgICAgICAgICAgICAgICBpZiAoc2FyID4ga0xpbmVEYXRhLmxvdykge1xuICAgICAgICAgICAgICAgICAgICBzYXIgPSBlcDtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5Yid5aeL5YyW5YC8XG4gICAgICAgICAgICAgICAgICAgIGFmID0gc3RhcnRBZjtcbiAgICAgICAgICAgICAgICAgICAgZXAgPSAtMTAwO1xuICAgICAgICAgICAgICAgICAgICBpc0luY3JlYXNpbmcgPSAhaXNJbmNyZWFzaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzYXIgPiBsb3dNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2FyID0gbG93TWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlcCA9PT0gLTEwMCB8fCBlcCA+IGxvdykge1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDliJ3lp4vljJblgLxcbiAgICAgICAgICAgICAgICAgICAgZXAgPSBsb3c7XG4gICAgICAgICAgICAgICAgICAgIGFmID0gTWF0aC5taW4oYWYgKyBzdGVwLCBtYXhBZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhciA9IHByZVNhciArIGFmICogKGVwIC0gcHJlU2FyKTtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaE1heCA9IE1hdGgubWF4KGRhdGFMaXN0W01hdGgubWF4KDEsIGkpIC0gMV0uaGlnaCwgaGlnaCk7XG4gICAgICAgICAgICAgICAgaWYgKHNhciA8IGtMaW5lRGF0YS5oaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhciA9IGVwO1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDliJ3lp4vljJblgLxcbiAgICAgICAgICAgICAgICAgICAgYWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBlcCA9IC0xMDA7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5jcmVhc2luZyA9ICFpc0luY3JlYXNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNhciA8IGhpZ2hNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FyID0gaGlnaE1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBoaWdoOiBoaWdoLCBsb3c6IGxvdywgc2FyOiBzYXIgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Knd3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogdHJpeFxuICpcbiAqIFRSPeaUtuebmOS7t+eahE7ml6XmjIfmlbDnp7vliqjlubPlnYfnmoRO5pel5oyH5pWw56e75Yqo5bmz5Z2H55qETuaXpeaMh+aVsOenu+WKqOW5s+Wdh++8m1xuICogVFJJWD0oVFIt5pio5pelVFIpL+aYqOaXpVRSKjEwMO+8m1xuICogTUFUUklYPVRSSVjnmoRN5pel566A5Y2V56e75Yqo5bmz5Z2H77ybXG4gKiDpu5jorqTlj4LmlbBO6K6+5Li6MTLvvIzpu5jorqTlj4LmlbBN6K6+5Li6Oe+8m1xuICog6buY6K6k5Y+C5pWwMTLjgIE5XG4gKiDlhazlvI/vvJpNVFI6PUVNQShFTUEoRU1BKENMT1NFLE4pLE4pLE4pXG4gKiBUUklYOihNVFItUkVGKE1UUiwxKSkvUkVGKE1UUiwxKSoxMDA7XG4gKiBUUk1BOk1BKFRSSVgsTSlcbiAqXG4gKi9cbnZhciB0cmlwbGVFeHBvbmVudGlhbGx5U21vb3RoZWRBdmVyYWdlID0ge1xuICAgIG5hbWU6ICdUUklYJyxcbiAgICBzaG9ydE5hbWU6ICdUUklYJyxcbiAgICBjYWxjUGFyYW1zOiBbMTIsIDldLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICd0cml4JywgdGl0bGU6ICdUUklYOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYVRyaXgnLCB0aXRsZTogJ01BVFJJWDogJywgdHlwZTogJ2xpbmUnIH1cbiAgICBdLFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgdmFyIGNsb3NlU3VtID0gMDtcbiAgICAgICAgdmFyIGVtYTEgPSAwO1xuICAgICAgICB2YXIgZW1hMiA9IDA7XG4gICAgICAgIHZhciBvbGRUciA9IDA7XG4gICAgICAgIHZhciBlbWExU3VtID0gMDtcbiAgICAgICAgdmFyIGVtYTJTdW0gPSAwO1xuICAgICAgICB2YXIgdHJpeFN1bSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgdHJpeCA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgY2xvc2VTdW0gKz0gY2xvc2U7XG4gICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBwYXJhbXNbMF0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYTEgPSAoMiAqIGNsb3NlICsgKHBhcmFtc1swXSAtIDEpICogZW1hMSkgLyAocGFyYW1zWzBdICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbWExID0gY2xvc2VTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtYTFTdW0gKz0gZW1hMTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKiAyIC0gMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHBhcmFtc1swXSAqIDIgLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWEyID0gKDIgKiBlbWExICsgKHBhcmFtc1swXSAtIDEpICogZW1hMikgLyAocGFyYW1zWzBdICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWEyID0gZW1hMVN1bSAvIHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbWEyU3VtICs9IGVtYTI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IHBhcmFtc1swXSAqIDMgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaXhWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IHBhcmFtc1swXSAqIDMgLSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIgPSAoMiAqIGVtYTIgKyAocGFyYW1zWzBdIC0gMSkgKiBvbGRUcikgLyAocGFyYW1zWzBdICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpeFZhbHVlID0gKHRyIC0gb2xkVHIpIC8gb2xkVHIgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ciA9IGVtYTJTdW0gLyBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUciA9IHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpeC50cml4ID0gdHJpeFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpeFN1bSArPSB0cml4VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBwYXJhbXNbMF0gKiAzICsgcGFyYW1zWzFdIC0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXgubWFUcml4ID0gdHJpeFN1bSAvIHBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cml4U3VtIC09ICgoX2EgPSByZXN1bHRbaSAtIChwYXJhbXNbMV0gLSAxKV0udHJpeCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0cml4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRWb2x1bWVGaWd1cmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiAndm9sdW1lJyxcbiAgICAgICAgdGl0bGU6ICdWT0xVTUU6ICcsXG4gICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICBiYXNlVmFsdWU6IDAsXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGluZGljYXRvciA9IF9hLmluZGljYXRvciwgZGVmYXVsdFN0eWxlcyA9IF9hLmRlZmF1bHRTdHlsZXM7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGRhdGEuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvci5zdHlsZXMsICdiYXJzWzBdLm5vQ2hhbmdlQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5iYXJzKVswXS5ub0NoYW5nZUNvbG9yKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuY2xvc2UgPiBjdXJyZW50Lm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS51cENvbG9yJywgKGRlZmF1bHRTdHlsZXMuYmFycylbMF0udXBDb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQuY2xvc2UgPCBjdXJyZW50Lm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3Iuc3R5bGVzLCAnYmFyc1swXS5kb3duQ29sb3InLCAoZGVmYXVsdFN0eWxlcy5iYXJzKVswXS5kb3duQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNvbG9yOiBjb2xvciB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciB2b2x1bWUgPSB7XG4gICAgbmFtZTogJ1ZPTCcsXG4gICAgc2hvcnROYW1lOiAnVk9MJyxcbiAgICBzZXJpZXM6IEluZGljYXRvclNlcmllcy5Wb2x1bWUsXG4gICAgY2FsY1BhcmFtczogWzUsIDEwLCAyMF0sXG4gICAgc2hvdWxkRm9ybWF0QmlnTnVtYmVyOiB0cnVlLFxuICAgIHByZWNpc2lvbjogMCxcbiAgICBtaW5WYWx1ZTogMCxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAnbWExJywgdGl0bGU6ICdNQTU6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ21hMicsIHRpdGxlOiAnTUExMDogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnbWEzJywgdGl0bGU6ICdNQTIwOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgZ2V0Vm9sdW1lRmlndXJlKClcbiAgICBdLFxuICAgIHJlZ2VuZXJhdGVGaWd1cmVzOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBmaWd1cmVzID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gKHsga2V5OiBcIm1hXCIuY29uY2F0KGkgKyAxKSwgdGl0bGU6IFwiTUFcIi5jb25jYXQocCwgXCI6IFwiKSwgdHlwZTogJ2xpbmUnIH0pOyB9KTtcbiAgICAgICAgZmlndXJlcy5wdXNoKGdldFZvbHVtZUZpZ3VyZSgpKTtcbiAgICAgICAgcmV0dXJuIGZpZ3VyZXM7XG4gICAgfSxcbiAgICBjYWxjOiBmdW5jdGlvbiAoZGF0YUxpc3QsIGluZGljYXRvcikge1xuICAgICAgICB2YXIgcGFyYW1zID0gaW5kaWNhdG9yLmNhbGNQYXJhbXMsIGZpZ3VyZXMgPSBpbmRpY2F0b3IuZmlndXJlcztcbiAgICAgICAgdmFyIHZvbFN1bXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGRhdGFMaXN0Lm1hcChmdW5jdGlvbiAoa0xpbmVEYXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgdm9sdW1lID0gKF9hID0ga0xpbmVEYXRhLnZvbHVtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIHZhciB2b2wgPSB7IHZvbHVtZTogdm9sdW1lLCBvcGVuOiBrTGluZURhdGEub3BlbiwgY2xvc2U6IGtMaW5lRGF0YS5jbG9zZSB9O1xuICAgICAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2b2xTdW1zW2luZGV4XSA9ICgoX2EgPSB2b2xTdW1zW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyB2b2x1bWU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9sW2ZpZ3VyZXNbaW5kZXhdLmtleV0gPSB2b2xTdW1zW2luZGV4XSAvIHA7XG4gICAgICAgICAgICAgICAgICAgIHZvbFN1bXNbaW5kZXhdIC09ICgoX2IgPSBkYXRhTGlzdFtpIC0gKHAgLSAxKV0udm9sdW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2b2w7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBWUlxuICogVlI977yIVVZTKzEvMlBWU++8iS/vvIhEVlMrMS8yUFZT77yJXG4gKiAyNOWkqeS7peadpeWHoeaYr+iCoeS7t+S4iua2qOmCo+S4gOWkqeeahOaIkOS6pOmHj+mDveensOS4ukFW77yM5bCGMjTlpKnlhoXnmoRBVuaAu+WSjOebuOWKoOWQjuensOS4ulVWU1xuICogMjTlpKnku6XmnaXlh6HmmK/ogqHku7fkuIvot4zpgqPkuIDlpKnnmoTmiJDkuqTph4/pg73np7DkuLpCVu+8jOWwhjI05aSp5YaF55qEQlbmgLvlkoznm7jliqDlkI7np7DkuLpEVlNcbiAqIDI05aSp5Lul5p2l5Yeh5piv6IKh5Lu35LiN5rao5LiN6LeM77yM5YiZ6YKj5LiA5aSp55qE5oiQ5Lqk6YeP6YO956ew5Li6Q1bvvIzlsIYyNOWkqeWGheeahENW5oC75ZKM55u45Yqg5ZCO56ew5Li6UFZTXG4gKlxuICovXG52YXIgdm9sdW1lUmF0aW8gPSB7XG4gICAgbmFtZTogJ1ZSJyxcbiAgICBzaG9ydE5hbWU6ICdWUicsXG4gICAgY2FsY1BhcmFtczogWzI2LCA2XSxcbiAgICBmaWd1cmVzOiBbXG4gICAgICAgIHsga2V5OiAndnInLCB0aXRsZTogJ1ZSOiAnLCB0eXBlOiAnbGluZScgfSxcbiAgICAgICAgeyBrZXk6ICdtYVZyJywgdGl0bGU6ICdNQVZSOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgY2FsYzogZnVuY3Rpb24gKGRhdGFMaXN0LCBpbmRpY2F0b3IpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGluZGljYXRvci5jYWxjUGFyYW1zO1xuICAgICAgICB2YXIgdXZzID0gMDtcbiAgICAgICAgdmFyIGR2cyA9IDA7XG4gICAgICAgIHZhciBwdnMgPSAwO1xuICAgICAgICB2YXIgdnJTdW0gPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGRhdGFMaXN0LmZvckVhY2goZnVuY3Rpb24gKGtMaW5lRGF0YSwgaSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIHZhciB2ciA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgdmFyIHByZUNsb3NlID0gKChfYSA9IGRhdGFMaXN0W2kgLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga0xpbmVEYXRhKS5jbG9zZTtcbiAgICAgICAgICAgIHZhciB2b2x1bWUgPSAoX2IgPSBrTGluZURhdGEudm9sdW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICAgICAgaWYgKGNsb3NlID4gcHJlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB1dnMgKz0gdm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2UgPCBwcmVDbG9zZSkge1xuICAgICAgICAgICAgICAgIGR2cyArPSB2b2x1bWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdnMgKz0gdm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmUHZzID0gcHZzIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoZHZzICsgaGFsZlB2cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2ci52ciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ci52ciA9ICh1dnMgKyBoYWxmUHZzKSAvIChkdnMgKyBoYWxmUHZzKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdnJTdW0gKz0gdnIudnI7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcGFyYW1zWzBdICsgcGFyYW1zWzFdIC0gMikge1xuICAgICAgICAgICAgICAgICAgICB2ci5tYVZyID0gdnJTdW0gLyBwYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHZyU3VtIC09ICgoX2MgPSByZXN1bHRbaSAtIChwYXJhbXNbMV0gLSAxKV0udnIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYWdvRGF0YSA9IGRhdGFMaXN0W2kgLSAocGFyYW1zWzBdIC0gMSldO1xuICAgICAgICAgICAgICAgIHZhciBhZ29QcmVEYXRhID0gKF9kID0gZGF0YUxpc3RbaSAtIHBhcmFtc1swXV0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGFnb0RhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGFnb0Nsb3NlID0gYWdvRGF0YS5jbG9zZTtcbiAgICAgICAgICAgICAgICB2YXIgYWdvVm9sdW1lID0gKF9lID0gYWdvRGF0YS52b2x1bWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFnb0Nsb3NlID4gYWdvUHJlRGF0YS5jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB1dnMgLT0gYWdvVm9sdW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZ29DbG9zZSA8IGFnb1ByZURhdGEuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHZzIC09IGFnb1ZvbHVtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB2cyAtPSBhZ29Wb2x1bWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogV1JcbiAqIOWFrOW8jyBXUihOKSA9IDEwMCAqIFsgQyAtIEhJR0goTikgXSAvIFsgSElHSChOKS1MT1coTikgXVxuICovXG52YXIgd2lsbGlhbXNSID0ge1xuICAgIG5hbWU6ICdXUicsXG4gICAgc2hvcnROYW1lOiAnV1InLFxuICAgIGNhbGNQYXJhbXM6IFs2LCAxMCwgMTRdLFxuICAgIGZpZ3VyZXM6IFtcbiAgICAgICAgeyBrZXk6ICd3cjEnLCB0aXRsZTogJ1dSMTogJywgdHlwZTogJ2xpbmUnIH0sXG4gICAgICAgIHsga2V5OiAnd3IyJywgdGl0bGU6ICdXUjI6ICcsIHR5cGU6ICdsaW5lJyB9LFxuICAgICAgICB7IGtleTogJ3dyMycsIHRpdGxlOiAnV1IzOiAnLCB0eXBlOiAnbGluZScgfVxuICAgIF0sXG4gICAgcmVnZW5lcmF0ZUZpZ3VyZXM6IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuICh7IGtleTogXCJ3clwiLmNvbmNhdChpICsgMSksIHRpdGxlOiBcIldSXCIuY29uY2F0KGkgKyAxLCBcIjogXCIpLCB0eXBlOiAnbGluZScgfSk7IH0pOyB9LFxuICAgIGNhbGM6IGZ1bmN0aW9uIChkYXRhTGlzdCwgaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcywgZmlndXJlcyA9IGluZGljYXRvci5maWd1cmVzO1xuICAgICAgICByZXR1cm4gZGF0YUxpc3QubWFwKGZ1bmN0aW9uIChrTGluZURhdGEsIGkpIHtcbiAgICAgICAgICAgIHZhciB3ciA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsb3NlID0ga0xpbmVEYXRhLmNsb3NlO1xuICAgICAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyYW0gLSAxO1xuICAgICAgICAgICAgICAgIGlmIChpID49IHApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhsbiA9IGdldE1heE1pbihkYXRhTGlzdC5zbGljZShpIC0gcCwgaSArIDEpLCAnaGlnaCcsICdsb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhuID0gaGxuWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG4gPSBobG5bMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoblN1YkxuID0gaG4gLSBsbjtcbiAgICAgICAgICAgICAgICAgICAgd3JbZmlndXJlc1tpbmRleF0ua2V5XSA9IGhuU3ViTG4gPT09IDAgPyAwIDogKGNsb3NlIC0gaG4pIC8gaG5TdWJMbiAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB3cjtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaW5kaWNhdG9ycyA9IHt9O1xudmFyIGV4dGVuc2lvbnMkMiA9IFtcbiAgICBhdmVyYWdlUHJpY2UsIGF3ZXNvbWVPc2NpbGxhdG9yLCBiaWFzLCBib2xsaW5nZXJCYW5kcywgYnJhcixcbiAgICBidWxsQW5kQmVhckluZGV4LCBjb21tb2RpdHlDaGFubmVsSW5kZXgsIGN1cnJlbnRSYXRpbywgZGlmZmVyZW50T2ZNb3ZpbmdBdmVyYWdlLFxuICAgIGRpcmVjdGlvbmFsTW92ZW1lbnRJbmRleCwgZWFzZU9mTW92ZW1lbnRWYWx1ZSwgZXhwb25lbnRpYWxNb3ZpbmdBdmVyYWdlLCBtb21lbnR1bSxcbiAgICBtb3ZpbmdBdmVyYWdlLCBtb3ZpbmdBdmVyYWdlQ29udmVyZ2VuY2VEaXZlcmdlbmNlLCBvbkJhbGFuY2VWb2x1bWUsIHByaWNlQW5kVm9sdW1lVHJlbmQsXG4gICAgcHN5Y2hvbG9naWNhbExpbmUsIHJhdGVPZkNoYW5nZSwgcmVsYXRpdmVTdHJlbmd0aEluZGV4LCBzaW1wbGVNb3ZpbmdBdmVyYWdlLFxuICAgIHN0b2NoLCBzdG9wQW5kUmV2ZXJzZSwgdHJpcGxlRXhwb25lbnRpYWxseVNtb290aGVkQXZlcmFnZSwgdm9sdW1lLCB2b2x1bWVSYXRpbywgd2lsbGlhbXNSXG5dO1xuZXh0ZW5zaW9ucyQyLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgIGluZGljYXRvcnNbaW5kaWNhdG9yLm5hbWVdID0gSW5kaWNhdG9ySW1wLmV4dGVuZChpbmRpY2F0b3IpO1xufSk7XG5mdW5jdGlvbiByZWdpc3RlckluZGljYXRvcihpbmRpY2F0b3IpIHtcbiAgICBpbmRpY2F0b3JzW2luZGljYXRvci5uYW1lXSA9IEluZGljYXRvckltcC5leHRlbmQoaW5kaWNhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldEluZGljYXRvckNsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IGluZGljYXRvcnNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRJbmRpY2F0b3JzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpbmRpY2F0b3JzKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgZmlib25hY2NpTGluZSA9IHtcbiAgICBuYW1lOiAnZmlib25hY2NpTGluZScsXG4gICAgdG90YWxTdGVwOiAzLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGNoYXJ0ID0gX2EuY2hhcnQsIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmcsIG92ZXJsYXkgPSBfYS5vdmVybGF5LCB5QXhpcyA9IF9hLnlBeGlzO1xuICAgICAgICB2YXIgcG9pbnRzID0gb3ZlcmxheS5wb2ludHM7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uXzEgPSAwO1xuICAgICAgICAgICAgaWYgKChfYiA9IHlBeGlzID09PSBudWxsIHx8IHlBeGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5QXhpcy5pc0luQ2FuZGxlKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb25fMSA9IGNoYXJ0LmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydC5nZXRJbmRpY2F0b3JzKHsgcGFuZUlkOiBvdmVybGF5LnBhbmVJZCB9KTtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb25fMSA9IE1hdGgubWF4KHByZWNpc2lvbl8xLCBpbmRpY2F0b3IucHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lc18xID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dHNfMSA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0WF8xID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRYXzEgPSBib3VuZGluZy53aWR0aDtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxICYmIGlzTnVtYmVyKHBvaW50c1swXS52YWx1ZSkgJiYgaXNOdW1iZXIocG9pbnRzWzFdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50cyA9IFsxLCAwLjc4NiwgMC42MTgsIDAuNSwgMC4zODIsIDAuMjM2LCAwXTtcbiAgICAgICAgICAgICAgICB2YXIgeURpZl8xID0gY29vcmRpbmF0ZXNbMF0ueSAtIGNvb3JkaW5hdGVzWzFdLnk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlRGlmXzEgPSBwb2ludHNbMF0udmFsdWUgLSBwb2ludHNbMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgcGVyY2VudHMuZm9yRWFjaChmdW5jdGlvbiAocGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gY29vcmRpbmF0ZXNbMV0ueSArIHlEaWZfMSAqIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYXJ0LmdldERlY2ltYWxGb2xkKCkuZm9ybWF0KGNoYXJ0LmdldFRob3VzYW5kc1NlcGFyYXRvcigpLmZvcm1hdCgoKChfYSA9IHBvaW50c1sxXS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyB2YWx1ZURpZl8xICogcGVyY2VudCkudG9GaXhlZChwcmVjaXNpb25fMSkpKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXNfMS5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WF8xLCB5OiB5IH0sIHsgeDogZW5kWF8xLCB5OiB5IH1dIH0pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0c18xLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc3RhcnRYXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIi5jb25jYXQodmFsdWUsIFwiIChcIikuY29uY2F0KChwZXJjZW50ICogMTAwKS50b0ZpeGVkKDEpLCBcIiUpXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmU6ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGxpbmVzXzFcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgaXNDaGVja0V2ZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHRleHRzXzFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBob3Jpem9udGFsUmF5TGluZSA9IHtcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFJheUxpbmUnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcywgYm91bmRpbmcgPSBfYS5ib3VuZGluZztcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IDAsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY29vcmRpbmF0ZXNbMV0pICYmIGNvb3JkaW5hdGVzWzBdLnggPCBjb29yZGluYXRlc1sxXS54KSB7XG4gICAgICAgICAgICBjb29yZGluYXRlLnggPSBib3VuZGluZy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogW2Nvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlXSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRQcmVzc2VkTW92ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgcG9pbnRzWzBdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgICAgICBwb2ludHNbMV0udmFsdWUgPSBwZXJmb3JtUG9pbnQudmFsdWU7XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RlcCA9IF9hLmN1cnJlbnRTdGVwLCBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVwID09PSAyKSB7XG4gICAgICAgICAgICBwb2ludHNbMF0udmFsdWUgPSBwZXJmb3JtUG9pbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBob3Jpem9udGFsU2VnbWVudCA9IHtcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFNlZ21lbnQnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IGxpbmVzXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRQcmVzc2VkTW92ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgcG9pbnRzWzBdLnZhbHVlID0gcGVyZm9ybVBvaW50LnZhbHVlO1xuICAgICAgICBwb2ludHNbMV0udmFsdWUgPSBwZXJmb3JtUG9pbnQudmFsdWU7XG4gICAgfSxcbiAgICBwZXJmb3JtRXZlbnRNb3ZlRm9yRHJhd2luZzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RlcCA9IF9hLmN1cnJlbnRTdGVwLCBwb2ludHMgPSBfYS5wb2ludHMsIHBlcmZvcm1Qb2ludCA9IF9hLnBlcmZvcm1Qb2ludDtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVwID09PSAyKSB7XG4gICAgICAgICAgICBwb2ludHNbMF0udmFsdWUgPSBwZXJmb3JtUG9pbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBob3Jpem9udGFsU3RyYWlnaHRMaW5lID0ge1xuICAgIG5hbWU6ICdob3Jpem9udGFsU3RyYWlnaHRMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDIsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY29vcmRpbmF0ZXNbMF0ueVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGJvdW5kaW5nLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNvb3JkaW5hdGVzWzBdLnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEV2ZW50ZnVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50ZnVsKCkge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zZXQobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50ZnVsLnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50LCBvdGhlcikge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoaXNWYWxpZChjYWxsYmFjaykgJiYgdGhpcy5jaGVja0V2ZW50T24oZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZlbnQsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGUuY2hlY2tFdmVudE9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLl9jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bC5jaGVja0V2ZW50T24oZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50ZnVsLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV2ZW50LCBvdGhlcikge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXS5kaXNwYXRjaEV2ZW50KG5hbWUsIGV2ZW50LCBvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9uRXZlbnQobmFtZSwgZXZlbnQsIG90aGVyKTtcbiAgICB9O1xuICAgIEV2ZW50ZnVsLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChldmVudGZ1bCkge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGV2ZW50ZnVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudGZ1bC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRmdWw7XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERVZJQVRJT04gPSAyO1xudmFyIEZpZ3VyZUltcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlndXJlSW1wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpZ3VyZUltcChmaWd1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXR0cnMgPSBmaWd1cmUuYXR0cnM7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IGZpZ3VyZS5zdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmlndXJlSW1wLnByb3RvdHlwZS5jaGVja0V2ZW50T24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFdmVudE9uSW1wKGV2ZW50LCB0aGlzLmF0dHJzLCB0aGlzLnN0eWxlcyk7XG4gICAgfTtcbiAgICBGaWd1cmVJbXAucHJvdG90eXBlLnNldEF0dHJzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBGaWd1cmVJbXAucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmlndXJlSW1wLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB0aGlzLmRyYXdJbXAoY3R4LCB0aGlzLmF0dHJzLCB0aGlzLnN0eWxlcyk7XG4gICAgfTtcbiAgICBGaWd1cmVJbXAuZXh0ZW5kID0gZnVuY3Rpb24gKGZpZ3VyZSkge1xuICAgICAgICB2YXIgQ3VzdG9tID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEN1c3RvbSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEN1c3RvbSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDdXN0b20ucHJvdG90eXBlLmNoZWNrRXZlbnRPbkltcCA9IGZ1bmN0aW9uIChjb29yZGluYXRlLCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZ3VyZS5jaGVja0V2ZW50T24oY29vcmRpbmF0ZSwgYXR0cnMsIHN0eWxlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ3VzdG9tLnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGZpZ3VyZS5kcmF3KGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICAgICAgfShGaWd1cmVJbXApKTtcbiAgICAgICAgcmV0dXJuIEN1c3RvbTtcbiAgICB9O1xuICAgIHJldHVybiBGaWd1cmVJbXA7XG59KEV2ZW50ZnVsKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT25MaW5lKGNvb3JkaW5hdGUsIGF0dHJzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgbGluZXMgPSBsaW5lcy5jb25jYXQoYXR0cnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGxpbmVzXzEgPSBfX3ZhbHVlcyhsaW5lcyksIGxpbmVzXzFfMSA9IGxpbmVzXzEubmV4dCgpOyAhbGluZXNfMV8xLmRvbmU7IGxpbmVzXzFfMSA9IGxpbmVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbGluZV8xID0gbGluZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZV8xLmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2Q29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q29vcmRpbmF0ZS54ID09PSBjdXJyZW50Q29vcmRpbmF0ZS54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocHJldkNvb3JkaW5hdGUueSAtIGNvb3JkaW5hdGUueSkgKyBNYXRoLmFicyhjdXJyZW50Q29vcmRpbmF0ZS55IC0gY29vcmRpbmF0ZS55KSAtIE1hdGguYWJzKHByZXZDb29yZGluYXRlLnkgLSBjdXJyZW50Q29vcmRpbmF0ZS55KSA8IERFVklBVElPTiArIERFVklBVElPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGNvb3JkaW5hdGUueCAtIHByZXZDb29yZGluYXRlLngpIDwgREVWSUFUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2IgPSBnZXRMaW5lYXJTbG9wZUludGVyY2VwdChwcmV2Q29vcmRpbmF0ZSwgY3VycmVudENvb3JkaW5hdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBnZXRMaW5lYXJZRnJvbVNsb3BlSW50ZXJjZXB0KGtiLCBjb29yZGluYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5RGlmID0gTWF0aC5hYnMoeSAtIGNvb3JkaW5hdGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocHJldkNvb3JkaW5hdGUueCAtIGNvb3JkaW5hdGUueCkgKyBNYXRoLmFicyhjdXJyZW50Q29vcmRpbmF0ZS54IC0gY29vcmRpbmF0ZS54KSAtIE1hdGguYWJzKHByZXZDb29yZGluYXRlLnggLSBjdXJyZW50Q29vcmRpbmF0ZS54KSA8IERFVklBVElPTiArIERFVklBVElPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlEaWYgKiB5RGlmIC8gKGtiWzBdICoga2JbMF0gKyAxKSA8IERFVklBVElPTiAqIERFVklBVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobGluZXNfMV8xICYmICFsaW5lc18xXzEuZG9uZSAmJiAoX2EgPSBsaW5lc18xLnJldHVybikpIF9hLmNhbGwobGluZXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRMaW5lYXJZRnJvbVNsb3BlSW50ZXJjZXB0KGtiLCBjb29yZGluYXRlKSB7XG4gICAgaWYgKGtiICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlLnggKiBrYlswXSArIGtiWzFdO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZS55O1xufVxuLyoqXG4gKiDojrflj5bngrnlnKjkuKTngrnlhrPlrprnmoTkuIDmrKHlh73mlbDkuIrnmoR55YC8XG4gKiBAcGFyYW0gY29vcmRpbmF0ZTFcbiAqIEBwYXJhbSBjb29yZGluYXRlMlxuICogQHBhcmFtIHRhcmdldENvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZWFyWUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIsIHRhcmdldENvb3JkaW5hdGUpIHtcbiAgICB2YXIga2IgPSBnZXRMaW5lYXJTbG9wZUludGVyY2VwdChjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIpO1xuICAgIHJldHVybiBnZXRMaW5lYXJZRnJvbVNsb3BlSW50ZXJjZXB0KGtiLCB0YXJnZXRDb29yZGluYXRlKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVhclNsb3BlSW50ZXJjZXB0KGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMikge1xuICAgIHZhciBkaWZYID0gY29vcmRpbmF0ZTEueCAtIGNvb3JkaW5hdGUyLng7XG4gICAgaWYgKGRpZlggIT09IDApIHtcbiAgICAgICAgdmFyIGsgPSAoY29vcmRpbmF0ZTEueSAtIGNvb3JkaW5hdGUyLnkpIC8gZGlmWDtcbiAgICAgICAgdmFyIGIgPSBjb29yZGluYXRlMS55IC0gayAqIGNvb3JkaW5hdGUxLng7XG4gICAgICAgIHJldHVybiBbaywgYl07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGluZVRvKGN0eCwgY29vcmRpbmF0ZXMsIHNtb290aCkge1xuICAgIHZhciBsZW5ndGggPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIHNtb290aFBhcmFtID0gaXNOdW1iZXIoc21vb3RoKSA/IChzbW9vdGggPiAwICYmIHNtb290aCA8IDEgPyBzbW9vdGggOiAwKSA6IChzbW9vdGggPyAwLjUgOiAwKTtcbiAgICBpZiAoKHNtb290aFBhcmFtID4gMCkgJiYgbGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgY3B4MCA9IGNvb3JkaW5hdGVzWzBdLng7XG4gICAgICAgIHZhciBjcHkwID0gY29vcmRpbmF0ZXNbMF0ueTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmV2Q29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2kgLSAxXTtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgICB2YXIgbmV4dENvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpICsgMV07XG4gICAgICAgICAgICB2YXIgZHgwMSA9IGNvb3JkaW5hdGUueCAtIHByZXZDb29yZGluYXRlLng7XG4gICAgICAgICAgICB2YXIgZHkwMSA9IGNvb3JkaW5hdGUueSAtIHByZXZDb29yZGluYXRlLnk7XG4gICAgICAgICAgICB2YXIgZHgxMiA9IG5leHRDb29yZGluYXRlLnggLSBjb29yZGluYXRlLng7XG4gICAgICAgICAgICB2YXIgZHkxMiA9IG5leHRDb29yZGluYXRlLnkgLSBjb29yZGluYXRlLnk7XG4gICAgICAgICAgICB2YXIgZHgwMiA9IG5leHRDb29yZGluYXRlLnggLSBwcmV2Q29vcmRpbmF0ZS54O1xuICAgICAgICAgICAgdmFyIGR5MDIgPSBuZXh0Q29vcmRpbmF0ZS55IC0gcHJldkNvb3JkaW5hdGUueTtcbiAgICAgICAgICAgIHZhciBwcmV2U2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeDAxICogZHgwMSArIGR5MDEgKiBkeTAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0U2VnbWVudExlbmd0aCA9IE1hdGguc3FydChkeDEyICogZHgxMiArIGR5MTIgKiBkeTEyKTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50TGVuZ3RoUmF0aW8gPSBuZXh0U2VnbWVudExlbmd0aCAvIChuZXh0U2VnbWVudExlbmd0aCArIHByZXZTZWdtZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q3B4ID0gY29vcmRpbmF0ZS54ICsgZHgwMiAqIHNtb290aFBhcmFtICogc2VnbWVudExlbmd0aFJhdGlvO1xuICAgICAgICAgICAgdmFyIG5leHRDcHkgPSBjb29yZGluYXRlLnkgKyBkeTAyICogc21vb3RoUGFyYW0gKiBzZWdtZW50TGVuZ3RoUmF0aW87XG4gICAgICAgICAgICBuZXh0Q3B4ID0gTWF0aC5taW4obmV4dENweCwgTWF0aC5tYXgobmV4dENvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS54KSk7XG4gICAgICAgICAgICBuZXh0Q3B5ID0gTWF0aC5taW4obmV4dENweSwgTWF0aC5tYXgobmV4dENvb3JkaW5hdGUueSwgY29vcmRpbmF0ZS55KSk7XG4gICAgICAgICAgICBuZXh0Q3B4ID0gTWF0aC5tYXgobmV4dENweCwgTWF0aC5taW4obmV4dENvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS54KSk7XG4gICAgICAgICAgICBuZXh0Q3B5ID0gTWF0aC5tYXgobmV4dENweSwgTWF0aC5taW4obmV4dENvb3JkaW5hdGUueSwgY29vcmRpbmF0ZS55KSk7XG4gICAgICAgICAgICBkeDAyID0gbmV4dENweCAtIGNvb3JkaW5hdGUueDtcbiAgICAgICAgICAgIGR5MDIgPSBuZXh0Q3B5IC0gY29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgdmFyIGNweDEgPSBjb29yZGluYXRlLnggLSBkeDAyICogcHJldlNlZ21lbnRMZW5ndGggLyBuZXh0U2VnbWVudExlbmd0aDtcbiAgICAgICAgICAgIHZhciBjcHkxID0gY29vcmRpbmF0ZS55IC0gZHkwMiAqIHByZXZTZWdtZW50TGVuZ3RoIC8gbmV4dFNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICBjcHgxID0gTWF0aC5taW4oY3B4MSwgTWF0aC5tYXgocHJldkNvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS54KSk7XG4gICAgICAgICAgICBjcHkxID0gTWF0aC5taW4oY3B5MSwgTWF0aC5tYXgocHJldkNvb3JkaW5hdGUueSwgY29vcmRpbmF0ZS55KSk7XG4gICAgICAgICAgICBjcHgxID0gTWF0aC5tYXgoY3B4MSwgTWF0aC5taW4ocHJldkNvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS54KSk7XG4gICAgICAgICAgICBjcHkxID0gTWF0aC5tYXgoY3B5MSwgTWF0aC5taW4ocHJldkNvb3JkaW5hdGUueSwgY29vcmRpbmF0ZS55KSk7XG4gICAgICAgICAgICBkeDAyID0gY29vcmRpbmF0ZS54IC0gY3B4MTtcbiAgICAgICAgICAgIGR5MDIgPSBjb29yZGluYXRlLnkgLSBjcHkxO1xuICAgICAgICAgICAgbmV4dENweCA9IGNvb3JkaW5hdGUueCArIGR4MDIgKiBuZXh0U2VnbWVudExlbmd0aCAvIHByZXZTZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgbmV4dENweSA9IGNvb3JkaW5hdGUueSArIGR5MDIgKiBuZXh0U2VnbWVudExlbmd0aCAvIHByZXZTZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY29vcmRpbmF0ZS54LCBjb29yZGluYXRlLnkpO1xuICAgICAgICAgICAgY3B4MCA9IG5leHRDcHg7XG4gICAgICAgICAgICBjcHkwID0gbmV4dENweTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdENvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tsZW5ndGggLSAxXTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3B4MCwgY3B5MCwgbGFzdENvb3JkaW5hdGUueCwgbGFzdENvb3JkaW5hdGUueSwgbGFzdENvb3JkaW5hdGUueCwgbGFzdENvb3JkaW5hdGUueSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNvb3JkaW5hdGVzW2ldLngsIGNvb3JkaW5hdGVzW2ldLnkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgbGluZXMgPSBsaW5lcy5jb25jYXQoYXR0cnMpO1xuICAgIHZhciBfYSA9IHN0eWxlcy5zdHlsZSwgc3R5bGUgPSBfYSA9PT0gdm9pZCAwID8gTGluZVR5cGUuU29saWQgOiBfYSwgX2IgPSBzdHlsZXMuc21vb3RoLCBzbW9vdGggPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBzdHlsZXMuc2l6ZSwgc2l6ZSA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gc3R5bGVzLmNvbG9yLCBjb2xvciA9IF9kID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9kLCBfZSA9IHN0eWxlcy5kYXNoZWRWYWx1ZSwgZGFzaGVkVmFsdWUgPSBfZSA9PT0gdm9pZCAwID8gWzIsIDJdIDogX2U7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgaWYgKHN0eWxlID09PSBMaW5lVHlwZS5EYXNoZWQpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlZFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIHZhciBjb3JyZWN0aW9uID0gc2l6ZSAlIDIgPT09IDEgPyAwLjUgOiAwO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgIChjb29yZGluYXRlc1swXS54ID09PSBjb29yZGluYXRlc1sxXS54IHx8XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdLnkgPT09IGNvb3JkaW5hdGVzWzFdLnkpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS54ID09PSBjb29yZGluYXRlc1sxXS54KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29vcmRpbmF0ZXNbMF0ueCArIGNvcnJlY3Rpb24sIGNvb3JkaW5hdGVzWzBdLnkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvb3JkaW5hdGVzWzFdLnggKyBjb3JyZWN0aW9uLCBjb29yZGluYXRlc1sxXS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29vcmRpbmF0ZXNbMF0ueCwgY29vcmRpbmF0ZXNbMF0ueSArIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNvb3JkaW5hdGVzWzFdLngsIGNvb3JkaW5hdGVzWzFdLnkgKyBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb29yZGluYXRlc1swXS54LCBjb29yZGluYXRlc1swXS55KTtcbiAgICAgICAgICAgICAgICBsaW5lVG8oY3R4LCBjb29yZGluYXRlcywgc21vb3RoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciBsaW5lID0ge1xuICAgIG5hbWU6ICdsaW5lJyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uTGluZSxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdMaW5lKGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIOiOt+WPluW5s+ihjOe6v1xuICogQHBhcmFtIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gYm91bmRpbmdcbiAqIEBwYXJhbSBleHRlbmRQYXJhbGxlbExpbmVDb3VudFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRQYXJhbGxlbExpbmVzKGNvb3JkaW5hdGVzLCBib3VuZGluZywgZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnQpIHtcbiAgICB2YXIgY291bnQgPSBleHRlbmRQYXJhbGxlbExpbmVDb3VudCAhPT0gbnVsbCAmJiBleHRlbmRQYXJhbGxlbExpbmVDb3VudCAhPT0gdm9pZCAwID8gZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnQgOiAwO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChjb29yZGluYXRlc1swXS54ID09PSBjb29yZGluYXRlc1sxXS54KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRZID0gYm91bmRpbmcuaGVpZ2h0O1xuICAgICAgICAgICAgbGluZXMucHVzaCh7IGNvb3JkaW5hdGVzOiBbeyB4OiBjb29yZGluYXRlc1swXS54LCB5OiBzdGFydFkgfSwgeyB4OiBjb29yZGluYXRlc1swXS54LCB5OiBlbmRZIH1dIH0pO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IGNvb3JkaW5hdGVzWzJdLngsIHk6IHN0YXJ0WSB9LCB7IHg6IGNvb3JkaW5hdGVzWzJdLngsIHk6IGVuZFkgfV0gfSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gY29vcmRpbmF0ZXNbMF0ueCAtIGNvb3JkaW5hdGVzWzJdLng7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZGlzdGFuY2UgKiAoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IGNvb3JkaW5hdGVzWzBdLnggKyBkLCB5OiBzdGFydFkgfSwgeyB4OiBjb29yZGluYXRlc1swXS54ICsgZCwgeTogZW5kWSB9XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gMDtcbiAgICAgICAgICAgIHZhciBlbmRYID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICB2YXIga2IgPSBnZXRMaW5lYXJTbG9wZUludGVyY2VwdChjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0pO1xuICAgICAgICAgICAgdmFyIGsgPSBrYlswXTtcbiAgICAgICAgICAgIHZhciBiID0ga2JbMV07XG4gICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WCwgeTogc3RhcnRYICogayArIGIgfSwgeyB4OiBlbmRYLCB5OiBlbmRYICogayArIGIgfV0gfSk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHZhciBiMSA9IGNvb3JkaW5hdGVzWzJdLnkgLSBrICogY29vcmRpbmF0ZXNbMl0ueDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WCwgeTogc3RhcnRYICogayArIGIxIH0sIHsgeDogZW5kWCwgeTogZW5kWCAqIGsgKyBiMSB9XSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiIC0gYjE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiMiA9IGIgKyBkaXN0YW5jZSAqIChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBjb29yZGluYXRlczogW3sgeDogc3RhcnRYLCB5OiBzdGFydFggKiBrICsgYjIgfSwgeyB4OiBlbmRYLCB5OiBlbmRYICogayArIGIyIH1dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG52YXIgcGFyYWxsZWxTdHJhaWdodExpbmUgPSB7XG4gICAgbmFtZTogJ3BhcmFsbGVsU3RyYWlnaHRMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDQsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBnZXRQYXJhbGxlbExpbmVzKGNvb3JkaW5hdGVzLCBib3VuZGluZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBwcmljZUNoYW5uZWxMaW5lID0ge1xuICAgIG5hbWU6ICdwcmljZUNoYW5uZWxMaW5lJyxcbiAgICB0b3RhbFN0ZXA6IDQsXG4gICAgbmVlZERlZmF1bHRQb2ludEZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFhBeGlzRmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WUF4aXNGaWd1cmU6IHRydWUsXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmc7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBnZXRQYXJhbGxlbExpbmVzKGNvb3JkaW5hdGVzLCBib3VuZGluZywgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBwcmljZUxpbmUgPSB7XG4gICAgbmFtZTogJ3ByaWNlTGluZScsXG4gICAgdG90YWxTdGVwOiAyLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGNoYXJ0ID0gX2EuY2hhcnQsIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmcsIG92ZXJsYXkgPSBfYS5vdmVybGF5LCB5QXhpcyA9IF9hLnlBeGlzO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgaWYgKChfYiA9IHlBeGlzID09PSBudWxsIHx8IHlBeGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5QXhpcy5pc0luQ2FuZGxlKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGNoYXJ0LmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydC5nZXRJbmRpY2F0b3JzKHsgcGFuZUlkOiBvdmVybGF5LnBhbmVJZCB9KTtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgocHJlY2lzaW9uLCBpbmRpY2F0b3IucHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IChvdmVybGF5LnBvaW50cylbMF0udmFsdWUsIHZhbHVlID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IFtjb29yZGluYXRlc1swXSwgeyB4OiBib3VuZGluZy53aWR0aCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9XSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBpZ25vcmVFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4OiBjb29yZGluYXRlc1swXS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBjb29yZGluYXRlc1swXS55LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGFydC5nZXREZWNpbWFsRm9sZCgpLmZvcm1hdChjaGFydC5nZXRUaG91c2FuZHNTZXBhcmF0b3IoKS5mb3JtYXQodmFsdWUudG9GaXhlZChwcmVjaXNpb24pKSksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lOiAnYm90dG9tJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFJheUxpbmUoY29vcmRpbmF0ZXMsIGJvdW5kaW5nKSB7XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzWzBdLnggPT09IGNvb3JkaW5hdGVzWzFdLnggJiYgY29vcmRpbmF0ZXNbMF0ueSAhPT0gY29vcmRpbmF0ZXNbMV0ueSkge1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzWzBdLnkgPCBjb29yZGluYXRlc1sxXS55KSB7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogY29vcmRpbmF0ZXNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogYm91bmRpbmcuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvb3JkaW5hdGVzWzBdLnggPiBjb29yZGluYXRlc1sxXS54KSB7XG4gICAgICAgICAgICBjb29yZGluYXRlID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogZ2V0TGluZWFyWUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0sIHsgeDogMCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSB7XG4gICAgICAgICAgICAgICAgeDogYm91bmRpbmcud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogZ2V0TGluZWFyWUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0sIHsgeDogYm91bmRpbmcud2lkdGgsIHk6IGNvb3JkaW5hdGVzWzBdLnkgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29vcmRpbmF0ZXM6IFtjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxudmFyIHJheUxpbmUgPSB7XG4gICAgbmFtZTogJ3JheUxpbmUnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcywgYm91bmRpbmcgPSBfYS5ib3VuZGluZztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IGdldFJheUxpbmUoY29vcmRpbmF0ZXMsIGJvdW5kaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHNlZ21lbnQgPSB7XG4gICAgbmFtZTogJ3NlZ21lbnQnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBzdHJhaWdodExpbmUgPSB7XG4gICAgbmFtZTogJ3N0cmFpZ2h0TGluZScsXG4gICAgdG90YWxTdGVwOiAzLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ueCA9PT0gY29vcmRpbmF0ZXNbMV0ueCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmRpbmF0ZXNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY29vcmRpbmF0ZXNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGJvdW5kaW5nLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZ2V0TGluZWFyWUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0sIHsgeDogMCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogYm91bmRpbmcud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGdldExpbmVhcllGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdLCB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiBjb29yZGluYXRlc1swXS55IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgdmVydGljYWxSYXlMaW5lID0ge1xuICAgIG5hbWU6ICd2ZXJ0aWNhbFJheUxpbmUnLFxuICAgIHRvdGFsU3RlcDogMyxcbiAgICBuZWVkRGVmYXVsdFBvaW50RmlndXJlOiB0cnVlLFxuICAgIG5lZWREZWZhdWx0WEF4aXNGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRZQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcywgYm91bmRpbmcgPSBfYS5ib3VuZGluZztcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IGNvb3JkaW5hdGVzWzBdLngsIHk6IDAgfTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS55IDwgY29vcmRpbmF0ZXNbMV0ueSkge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA9IGJvdW5kaW5nLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvb3JkaW5hdGVzOiBbY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVdIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHBlcmZvcm1FdmVudFByZXNzZWRNb3ZlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IF9hLnBvaW50cywgcGVyZm9ybVBvaW50ID0gX2EucGVyZm9ybVBvaW50O1xuICAgICAgICBwb2ludHNbMF0udGltZXN0YW1wID0gcGVyZm9ybVBvaW50LnRpbWVzdGFtcDtcbiAgICAgICAgcG9pbnRzWzBdLmRhdGFJbmRleCA9IHBlcmZvcm1Qb2ludC5kYXRhSW5kZXg7XG4gICAgICAgIHBvaW50c1sxXS50aW1lc3RhbXAgPSBwZXJmb3JtUG9pbnQudGltZXN0YW1wO1xuICAgICAgICBwb2ludHNbMV0uZGF0YUluZGV4ID0gcGVyZm9ybVBvaW50LmRhdGFJbmRleDtcbiAgICB9LFxuICAgIHBlcmZvcm1FdmVudE1vdmVGb3JEcmF3aW5nOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGVwID0gX2EuY3VycmVudFN0ZXAsIHBvaW50cyA9IF9hLnBvaW50cywgcGVyZm9ybVBvaW50ID0gX2EucGVyZm9ybVBvaW50O1xuICAgICAgICBpZiAoY3VycmVudFN0ZXAgPT09IDIpIHtcbiAgICAgICAgICAgIHBvaW50c1swXS50aW1lc3RhbXAgPSBwZXJmb3JtUG9pbnQudGltZXN0YW1wO1xuICAgICAgICAgICAgcG9pbnRzWzBdLmRhdGFJbmRleCA9IHBlcmZvcm1Qb2ludC5kYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB2ZXJ0aWNhbFNlZ21lbnQgPSB7XG4gICAgbmFtZTogJ3ZlcnRpY2FsU2VnbWVudCcsXG4gICAgdG90YWxTdGVwOiAzLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50UHJlc3NlZE1vdmU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIHBvaW50c1swXS50aW1lc3RhbXAgPSBwZXJmb3JtUG9pbnQudGltZXN0YW1wO1xuICAgICAgICBwb2ludHNbMF0uZGF0YUluZGV4ID0gcGVyZm9ybVBvaW50LmRhdGFJbmRleDtcbiAgICAgICAgcG9pbnRzWzFdLnRpbWVzdGFtcCA9IHBlcmZvcm1Qb2ludC50aW1lc3RhbXA7XG4gICAgICAgIHBvaW50c1sxXS5kYXRhSW5kZXggPSBwZXJmb3JtUG9pbnQuZGF0YUluZGV4O1xuICAgIH0sXG4gICAgcGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmc6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY3VycmVudFN0ZXAgPSBfYS5jdXJyZW50U3RlcCwgcG9pbnRzID0gX2EucG9pbnRzLCBwZXJmb3JtUG9pbnQgPSBfYS5wZXJmb3JtUG9pbnQ7XG4gICAgICAgIGlmIChjdXJyZW50U3RlcCA9PT0gMikge1xuICAgICAgICAgICAgcG9pbnRzWzBdLnRpbWVzdGFtcCA9IHBlcmZvcm1Qb2ludC50aW1lc3RhbXA7XG4gICAgICAgICAgICBwb2ludHNbMF0uZGF0YUluZGV4ID0gcGVyZm9ybVBvaW50LmRhdGFJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHZlcnRpY2FsU3RyYWlnaHRMaW5lID0ge1xuICAgIG5hbWU6ICd2ZXJ0aWNhbFN0cmFpZ2h0TGluZScsXG4gICAgdG90YWxTdGVwOiAyLFxuICAgIG5lZWREZWZhdWx0UG9pbnRGaWd1cmU6IHRydWUsXG4gICAgbmVlZERlZmF1bHRYQXhpc0ZpZ3VyZTogdHJ1ZSxcbiAgICBuZWVkRGVmYXVsdFlBeGlzRmlndXJlOiB0cnVlLFxuICAgIGNyZWF0ZVBvaW50RmlndXJlczogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IF9hLmNvb3JkaW5hdGVzLCBib3VuZGluZyA9IF9hLmJvdW5kaW5nO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvb3JkaW5hdGVzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogYm91bmRpbmcuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgc2ltcGxlQW5ub3RhdGlvbiA9IHtcbiAgICBuYW1lOiAnc2ltcGxlQW5ub3RhdGlvbicsXG4gICAgdG90YWxTdGVwOiAyLFxuICAgIHN0eWxlczoge1xuICAgICAgICBsaW5lOiB7IHN0eWxlOiBMaW5lVHlwZS5EYXNoZWQgfVxuICAgIH0sXG4gICAgY3JlYXRlUG9pbnRGaWd1cmVzOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgb3ZlcmxheSA9IF9hLm92ZXJsYXksIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIGlmIChpc1ZhbGlkKG92ZXJsYXkuZXh0ZW5kRGF0YSkpIHtcbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihvdmVybGF5LmV4dGVuZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9ICgoX2IgPSBvdmVybGF5LmV4dGVuZERhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSAob3ZlcmxheS5leHRlbmREYXRhKG92ZXJsYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRYID0gY29vcmRpbmF0ZXNbMF0ueDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGNvb3JkaW5hdGVzWzBdLnkgLSA2O1xuICAgICAgICB2YXIgbGluZUVuZFkgPSBzdGFydFkgLSA1MDtcbiAgICAgICAgdmFyIGFycm93RW5kWSA9IGxpbmVFbmRZIC0gNTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY29vcmRpbmF0ZXM6IFt7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0sIHsgeDogc3RhcnRYLCB5OiBsaW5lRW5kWSB9XSB9LFxuICAgICAgICAgICAgICAgIGlnbm9yZUV2ZW50OiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogW3sgeDogc3RhcnRYLCB5OiBsaW5lRW5kWSB9LCB7IHg6IHN0YXJ0WCAtIDQsIHk6IGFycm93RW5kWSB9LCB7IHg6IHN0YXJ0WCArIDQsIHk6IGFycm93RW5kWSB9XSB9LFxuICAgICAgICAgICAgICAgIGlnbm9yZUV2ZW50OiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBhdHRyczogeyB4OiBzdGFydFgsIHk6IGFycm93RW5kWSwgdGV4dDogdGV4dCwgYWxpZ246ICdjZW50ZXInLCBiYXNlbGluZTogJ2JvdHRvbScgfSxcbiAgICAgICAgICAgICAgICBpZ25vcmVFdmVudDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHNpbXBsZVRhZyA9IHtcbiAgICBuYW1lOiAnc2ltcGxlVGFnJyxcbiAgICB0b3RhbFN0ZXA6IDIsXG4gICAgc3R5bGVzOiB7XG4gICAgICAgIGxpbmU6IHsgc3R5bGU6IExpbmVUeXBlLkRhc2hlZCB9XG4gICAgfSxcbiAgICBjcmVhdGVQb2ludEZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgYm91bmRpbmcgPSBfYS5ib3VuZGluZywgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogMCwgeTogY29vcmRpbmF0ZXNbMF0ueSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiBjb29yZGluYXRlc1swXS55IH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWdub3JlRXZlbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVZQXhpc0ZpZ3VyZXM6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICB2YXIgY2hhcnQgPSBfYS5jaGFydCwgb3ZlcmxheSA9IF9hLm92ZXJsYXksIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIGJvdW5kaW5nID0gX2EuYm91bmRpbmcsIHlBeGlzID0gX2EueUF4aXM7XG4gICAgICAgIHZhciBpc0Zyb21aZXJvID0gKF9iID0geUF4aXMgPT09IG51bGwgfHwgeUF4aXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHlBeGlzLmlzRnJvbVplcm8oKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgaWYgKGlzRnJvbVplcm8pIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIHggPSBib3VuZGluZy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoaXNWYWxpZChvdmVybGF5LmV4dGVuZERhdGEpKSB7XG4gICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24ob3ZlcmxheS5leHRlbmREYXRhKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSAoKF9jID0gb3ZlcmxheS5leHRlbmREYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb3ZlcmxheS5leHRlbmREYXRhKG92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZCh0ZXh0KSAmJiBpc051bWJlcihvdmVybGF5LnBvaW50c1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRleHQgPSBmb3JtYXRQcmVjaXNpb24ob3ZlcmxheS5wb2ludHNbMF0udmFsdWUsIGNoYXJ0LmdldFByZWNpc2lvbigpLnByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIGF0dHJzOiB7IHg6IHgsIHk6IGNvb3JkaW5hdGVzWzBdLnksIHRleHQ6IHRleHQsIGFsaWduOiB0ZXh0QWxpZ24sIGJhc2VsaW5lOiAnbWlkZGxlJyB9IH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgb3ZlcmxheXMgPSB7fTtcbnZhciBleHRlbnNpb25zJDEgPSBbXG4gICAgZmlib25hY2NpTGluZSwgaG9yaXpvbnRhbFJheUxpbmUsIGhvcml6b250YWxTZWdtZW50LCBob3Jpem9udGFsU3RyYWlnaHRMaW5lLFxuICAgIHBhcmFsbGVsU3RyYWlnaHRMaW5lLCBwcmljZUNoYW5uZWxMaW5lLCBwcmljZUxpbmUsIHJheUxpbmUsIHNlZ21lbnQsXG4gICAgc3RyYWlnaHRMaW5lLCB2ZXJ0aWNhbFJheUxpbmUsIHZlcnRpY2FsU2VnbWVudCwgdmVydGljYWxTdHJhaWdodExpbmUsXG4gICAgc2ltcGxlQW5ub3RhdGlvbiwgc2ltcGxlVGFnXG5dO1xuZXh0ZW5zaW9ucyQxLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgb3ZlcmxheXNbdGVtcGxhdGUubmFtZV0gPSBPdmVybGF5SW1wLmV4dGVuZCh0ZW1wbGF0ZSk7XG59KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyT3ZlcmxheSh0ZW1wbGF0ZSkge1xuICAgIG92ZXJsYXlzW3RlbXBsYXRlLm5hbWVdID0gT3ZlcmxheUltcC5leHRlbmQodGVtcGxhdGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmxheUlubmVyQ2xhc3MobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gb3ZlcmxheXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRPdmVybGF5Q2xhc3MobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gb3ZlcmxheXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRPdmVybGF5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmxheXMpO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBsaWdodCA9IHtcbiAgICBncmlkOiB7XG4gICAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0VERURFRCdcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0VERURFRCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuZGxlOiB7XG4gICAgICAgIHByaWNlTWFyazoge1xuICAgICAgICAgICAgaGlnaDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb3c6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM3NjgwOEYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNGRUZFRkUnLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnI0YyRjNGNSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjNzY4MDhGJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpbmRpY2F0b3I6IHtcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgeEF4aXM6IHtcbiAgICAgICAgYXhpc0xpbmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICAgICAgfSxcbiAgICAgICAgdGlja1RleHQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgfSxcbiAgICAgICAgdGlja0xpbmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgeUF4aXM6IHtcbiAgICAgICAgYXhpc0xpbmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICAgICAgfSxcbiAgICAgICAgdGlja1RleHQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnIzc2ODA4RidcbiAgICAgICAgfSxcbiAgICAgICAgdGlja0xpbmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VwYXJhdG9yOiB7XG4gICAgICAgIGNvbG9yOiAnI0RERERERCdcbiAgICB9LFxuICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBob3Jpem9udGFsOiB7XG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjNzY4MDhGJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyM2ODZENzYnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM2ODZENzYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjNzY4MDhGJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyM2ODZENzYnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM2ODZENzYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBkYXJrID0ge1xuICAgIGdyaWQ6IHtcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgICAgY29sb3I6ICcjMjkyOTI5J1xuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICAgICAgY29sb3I6ICcjMjkyOTI5J1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5kbGU6IHtcbiAgICAgICAgcHJpY2VNYXJrOiB7XG4gICAgICAgICAgICBoaWdoOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjOTI5QUE1J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvdzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkyOUFBNSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgxMCwgMTAsIDEwLCAuNiknLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgxMCwgMTAsIDEwLCAuNiknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkyOUFBNSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5kaWNhdG9yOiB7XG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHhBeGlzOiB7XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tUZXh0OiB7XG4gICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHlBeGlzOiB7XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tUZXh0OiB7XG4gICAgICAgICAgICBjb2xvcjogJyM5MjlBQTUnXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tMaW5lOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlcGFyYXRvcjoge1xuICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gICAgfSxcbiAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkyOUFBNSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzczYTQwJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzczYTQwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzkyOUFBNSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzczYTQwJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzczYTQwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgc3R5bGVzID0ge1xuICAgIGxpZ2h0OiBsaWdodCxcbiAgICBkYXJrOiBkYXJrXG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXMobmFtZSwgc3MpIHtcbiAgICBzdHlsZXNbbmFtZV0gPSBzcztcbn1cbmZ1bmN0aW9uIGdldFN0eWxlcyhuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBzdHlsZXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFBBTkVfTUlOX0hFSUdIVCA9IDMwO1xudmFyIFBBTkVfREVGQVVMVF9IRUlHSFQgPSAxMDA7XG52YXIgUGFuZUlkQ29uc3RhbnRzID0ge1xuICAgIENBTkRMRTogJ2NhbmRsZV9wYW5lJyxcbiAgICBJTkRJQ0FUT1I6ICdpbmRpY2F0b3JfcGFuZV8nLFxuICAgIFhfQVhJUzogJ3hfYXhpc19wYW5lJ1xufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQmFyU3BhY2VMaW1pdENvbnN0YW50cyA9IHtcbiAgICBNSU46IDEsXG4gICAgTUFYOiA1MFxufTtcbnZhciBERUZBVUxUX0JBUl9TUEFDRSA9IDEwO1xudmFyIERFRkFVTFRfT0ZGU0VUX1JJR0hUX0RJU1RBTkNFID0gODA7XG52YXIgQkFSX0dBUF9SQVRJTyA9IDAuMjtcbnZhciBTQ0FMRV9NVUxUSVBMSUVSID0gMTA7XG52YXIgREVGQVVMVF9NSU5fVElNRV9TUEFOID0gMTUgKiA2MCAqIDEwMDA7XG52YXIgU3RvcmVJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmVJbXAoY2hhcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0eWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3R5bGVzID0gZ2V0RGVmYXVsdFN0eWxlcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VzdG9tIGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VzdG9tQXBpID0ge1xuICAgICAgICAgICAgZm9ybWF0RGF0ZTogZnVuY3Rpb24gKHRpbWVzdGFtcCwgZm9ybWF0KSB7IHJldHVybiBmb3JtYXRUaW1lc3RhbXBUb1N0cmluZyhfdGhpcy5fZGF0ZVRpbWVGb3JtYXQsIHRpbWVzdGFtcCwgZm9ybWF0KTsgfSxcbiAgICAgICAgICAgIGZvcm1hdEJpZ051bWJlcjogZm9ybWF0QmlnTnVtYmVyXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2NhbGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9ICdlbi1VUyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaG91c2FuZHMgc2VwYXJhdG9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aG91c2FuZHNTZXBhcmF0b3IgPSB7XG4gICAgICAgICAgICBzaWduOiAnLCcsXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZm9ybWF0VGhvdXNhbmRzKHZhbHVlLCBfdGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yLnNpZ24pOyB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNpbWFsIGZvbGRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RlY2ltYWxGb2xkID0ge1xuICAgICAgICAgICAgdGhyZXNob2xkOiAzLFxuICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGZvcm1hdEZvbGREZWNpbWFsKHZhbHVlLCBfdGhpcy5fZGVjaW1hbEZvbGQudGhyZXNob2xkKTsgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpY2UgYW5kIHZvbHVtZSBwcmVjaXNpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHsgcHJpY2U6IDIsIHZvbHVtZTogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSBzb3VyY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RhdGFMaXN0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIG1vcmUgZGF0YSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZE1vcmVEYXRhQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgbG9hZGluZyBkYXRhIGZsYWdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgKiBXaGV0aGVyIHRoZXJlIGFyZSBmb3J3YXJkIGFuZCBiYWNrd2FyZCBtb3JlIGZsYWdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWREYXRhTW9yZSA9IHsgZm9yd2FyZDogZmFsc2UsIGJhY2t3YXJkOiBmYWxzZSB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGUgZW5hYmxlZCBmbGFnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl96b29tRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgZW5hYmxlZCBmbGFnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdGFsIHNwYWNlIG9mIGRyYXdpbmcgYXJlYVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG90YWxCYXJTcGFjZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGFjZSBvY2N1cGllZCBieSBhIHNpbmdsZSBwaWVjZSBvZiBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXJTcGFjZSA9IERFRkFVTFRfQkFSX1NQQUNFO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzdGFuY2UgZnJvbSB0aGUgbGFzdCBkYXRhIHRvIHRoZSByaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRSaWdodERpc3RhbmNlID0gREVGQVVMVF9PRkZTRVRfUklHSFRfRElTVEFOQ0U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGJhciB0byB0aGUgcmlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBmcm9tIHRoZSBsYXN0IGRhdGEgd2hlbiBzY3JvbGxpbmcgc3RhcnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGFydExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIGxpbWl0IHJvbGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Njcm9sbExpbWl0Um9sZSA9IDAgLyogU2Nyb2xsTGltaXRSb2xlLkJhckNvdW50ICovO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIHRvIHRoZSBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHZpc2libGUgYmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9taW5WaXNpYmxlQmFyQ291bnQgPSB7IGxlZnQ6IDIsIHJpZ2h0OiAyIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgdG8gdGhlIGxlZnRtb3N0IGFuZCByaWdodG1vc3QgZGlzdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21heE9mZnNldERpc3RhbmNlID0geyBsZWZ0OiA1MCwgcmlnaHQ6IDUwIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCBhbmQgZW5kIHBvaW50cyBvZiB2aXNpYmxlIGFyZWEgZGF0YSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlID0gZ2V0RGVmYXVsdFZpc2libGVSYW5nZSgpO1xuICAgICAgICB0aGlzLl90aW1lV2VpZ2h0VGlja01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdGltZVdlaWdodFRpY2tMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX21pblRpbWVTcGFuID0geyBjb21wYXJlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgY2FsYzogREVGQVVMVF9NSU5fVElNRV9TUEFOIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaXNpYmxlIGRhdGEgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZURhdGFMaXN0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaXNpYmxlIGhpZ2hlc3QgbG93ZXN0IHByaWNlIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZSA9IFtcbiAgICAgICAgICAgIHsgeDogMCwgcHJpY2U6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0sXG4gICAgICAgICAgICB7IHg6IDAsIHByaWNlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9XG4gICAgICAgIF07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcm9zc2hhaXIgaW5mb1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3Jvc3NoYWlyID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RpdmUgdG9vbHRpcCBpY29uIGluZm9cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZVRvb2x0aXBGZWF0dXJlSW5mbyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3Rpb25zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdG9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmRpY2F0b3JzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFzayBzY2hlZHVsZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Rhc2tTY2hlZHVsZXIgPSBuZXcgVGFza1NjaGVkdWxlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcmxheVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3ZlcmxheXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVybGF5IGluZm9ybWF0aW9uIGluIHBhaW50aW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJsYXkgaW5mb3JtYXRpb24gYnkgdGhlIG1vdXNlIHByZXNzZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByZXNzZWRPdmVybGF5SW5mbyA9IHtcbiAgICAgICAgICAgIHBhbmVJZDogJycsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgZmlndXJlVHlwZTogMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovLFxuICAgICAgICAgICAgZmlndXJlSW5kZXg6IC0xLFxuICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVybGF5IGluZm9ybWF0aW9uIGJ5IGhvdmVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3Zlck92ZXJsYXlJbmZvID0ge1xuICAgICAgICAgICAgcGFuZUlkOiAnJyxcbiAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICBmaWd1cmVUeXBlOiAwIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLk5vbmUgKi8sXG4gICAgICAgICAgICBmaWd1cmVJbmRleDogLTEsXG4gICAgICAgICAgICBmaWd1cmU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJsYXkgaW5mb3JtYXRpb24gYnkgdGhlIG1vdXNlIGNsaWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jbGlja092ZXJsYXlJbmZvID0ge1xuICAgICAgICAgICAgcGFuZUlkOiAnJyxcbiAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICBmaWd1cmVUeXBlOiAwIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLk5vbmUgKi8sXG4gICAgICAgICAgICBmaWd1cmVJbmRleDogLTEsXG4gICAgICAgICAgICBmaWd1cmU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fY2FsY09wdGltYWxCYXJTcGFjZSgpO1xuICAgICAgICB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gdGhpcy5fb2Zmc2V0UmlnaHREaXN0YW5jZSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgc3R5bGVzID0gX2Euc3R5bGVzLCBsb2NhbGUgPSBfYS5sb2NhbGUsIHRpbWV6b25lID0gX2EudGltZXpvbmUsIGN1c3RvbUFwaSA9IF9hLmN1c3RvbUFwaSwgdGhvdXNhbmRzU2VwYXJhdG9yID0gX2EudGhvdXNhbmRzU2VwYXJhdG9yLCBkZWNpbWFsRm9sZCA9IF9hLmRlY2ltYWxGb2xkO1xuICAgICAgICBpZiAoaXNWYWxpZChzdHlsZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldExvY2FsZShsb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VGltZXpvbmUodGltZXpvbmUgIT09IG51bGwgJiYgdGltZXpvbmUgIT09IHZvaWQgMCA/IHRpbWV6b25lIDogJycpO1xuICAgICAgICBpZiAoaXNWYWxpZChjdXN0b21BcGkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1c3RvbUFwaShjdXN0b21BcGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKHRob3VzYW5kc1NlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGhvdXNhbmRzU2VwYXJhdG9yKHRob3VzYW5kc1NlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWQoZGVjaW1hbEZvbGQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldERlY2ltYWxGb2xkKGRlY2ltYWxGb2xkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0U3R5bGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBzdHlsZXMgPSBudWxsO1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcy5fc3R5bGVzLCBzdHlsZXMpO1xuICAgICAgICAvLyBgY2FuZGxlLnRvb2x0aXAuY3VzdG9tYCBzaG91bGQgb3ZlcnJpZGVcbiAgICAgICAgaWYgKGlzQXJyYXkoKF9iID0gKF9hID0gc3R5bGVzID09PSBudWxsIHx8IHN0eWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVzLmNhbmRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2x0aXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXN0b20pKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMuY2FuZGxlLnRvb2x0aXAuY3VzdG9tID0gc3R5bGVzLmNhbmRsZS50b29sdGlwLmN1c3RvbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0Q3VzdG9tQXBpID0gZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICBtZXJnZSh0aGlzLl9jdXN0b21BcGksIGFwaSk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0Q3VzdG9tQXBpID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VzdG9tQXBpOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRMb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlKSB7IHRoaXMuX2xvY2FsZSA9IGxvY2FsZTsgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0TG9jYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYWxlOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRUaW1lem9uZSA9IGZ1bmN0aW9uICh0aW1lem9uZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5fZGF0ZVRpbWVGb3JtYXQpIHx8XG4gICAgICAgICAgICAodGhpcy5nZXRUaW1lem9uZSgpICE9PSB0aW1lem9uZSkpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgICAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgICAgICAgICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICAgICAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgIHNlY29uZDogJzItZGlnaXQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRpbWVab25lID0gdGltZXpvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0ZVRpbWVGb3JtYXQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRlVGltZUZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbicsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dXYXJuKCcnLCAnJywgJ1RpbWV6b25lIGlzIGVycm9yISEhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZVRpbWVGb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc2lmeVRpbWVXZWlnaHRUaWNrcyh0aGlzLl9kYXRhTGlzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0ZVRpbWVGb3JtYXQgPSBkYXRlVGltZUZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFRpbWV6b25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0ZVRpbWVGb3JtYXQucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7IH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldERhdGVUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWVGb3JtYXQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gKHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgICAgICBtZXJnZSh0aGlzLl90aG91c2FuZHNTZXBhcmF0b3IsIHRob3VzYW5kc1NlcGFyYXRvcik7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXREZWNpbWFsRm9sZCA9IGZ1bmN0aW9uIChkZWNpbWFsRm9sZCkgeyBtZXJnZSh0aGlzLl9kZWNpbWFsRm9sZCwgZGVjaW1hbEZvbGQpOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXREZWNpbWFsRm9sZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlY2ltYWxGb2xkOyB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVjaXNpb247XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKHByZWNpc2lvbikge1xuICAgICAgICBtZXJnZSh0aGlzLl9wcmVjaXNpb24sIHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXplSW5kaWNhdG9yU2VyaWVzUHJlY2lzaW9uKCk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0RGF0YUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhTGlzdDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRWaXNpYmxlUmFuZ2VEYXRhTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSYW5nZURhdGFMaXN0O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFZpc2libGVSYW5nZUhpZ2hMb3dQcmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIG1vcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgYWRqdXN0RmxhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aENoYW5nZSA9IDA7XG4gICAgICAgIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhTGVuZ3RoQ2hhbmdlID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExvYWREYXRhVHlwZS5Jbml0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFMaXN0ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmJhY2t3YXJkID0gKF9hID0gbW9yZSA9PT0gbnVsbCB8fCBtb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3JlLmJhY2t3YXJkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmZvcndhcmQgPSAoX2IgPSBtb3JlID09PSBudWxsIHx8IG1vcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vcmUuZm9yd2FyZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzKHRoaXMuX2RhdGFMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPZmZzZXRSaWdodERpc3RhbmNlKHRoaXMuX29mZnNldFJpZ2h0RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgTG9hZERhdGFUeXBlLkJhY2t3YXJkOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzKGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTGlzdCA9IHRoaXMuX2RhdGFMaXN0LmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmJhY2t3YXJkID0gKF9jID0gbW9yZSA9PT0gbnVsbCB8fCBtb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3JlLmJhY2t3YXJkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0RmxhZyA9IGRhdGFMZW5ndGhDaGFuZ2UgPiAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBMb2FkRGF0YVR5cGUuRm9yd2FyZDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTGlzdCA9IGRhdGEuY29uY2F0KHRoaXMuX2RhdGFMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NpZnlUaW1lV2VpZ2h0VGlja3ModGhpcy5fZGF0YUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRGF0YU1vcmUuZm9yd2FyZCA9IChfZCA9IG1vcmUgPT09IG51bGwgfHwgbW9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9yZS5mb3J3YXJkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0RmxhZyA9IGRhdGFMZW5ndGhDaGFuZ2UgPiAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkYXRhQ291bnQgPSB0aGlzLl9kYXRhTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hlcmUgaW5kaXZpZHVhbCBkYXRhIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IGRhdGEudGltZXN0YW1wO1xuICAgICAgICAgICAgdmFyIGxhc3REYXRhVGltZXN0YW1wID0gZm9ybWF0VmFsdWUodGhpcy5fZGF0YUxpc3RbZGF0YUNvdW50IC0gMV0sICd0aW1lc3RhbXAnLCAwKTtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPiBsYXN0RGF0YVRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzKFtkYXRhXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3QucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA9IHRoaXMuZ2V0TGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQoLS1sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YUxlbmd0aENoYW5nZSA9IDE7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRqdXN0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lc3RhbXAgPT09IGxhc3REYXRhVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3RbZGF0YUNvdW50IC0gMV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkanVzdEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBpZiAoYWRqdXN0RmxhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkanVzdFZpc2libGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Jvc3NoYWlyKHRoaXMuX2Nyb3NzaGFpciwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJJbmRpY2F0b3JzID0gdGhpcy5nZXRJbmRpY2F0b3JzQnlGaWx0ZXIoe30pO1xuICAgICAgICAgICAgICAgIGZpbHRlckluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJbmRpY2F0b3JDYWxjVGFzayhpbmRpY2F0b3IsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0TG9hZE1vcmVEYXRhQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fbG9hZE1vcmVEYXRhQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5fY2FsY09wdGltYWxCYXJTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwZWNpYWxCYXJTcGFjZSA9IDQ7XG4gICAgICAgIHZhciByYXRpbyA9IDEgLSBCQVJfR0FQX1JBVElPICogTWF0aC5hdGFuKE1hdGgubWF4KHNwZWNpYWxCYXJTcGFjZSwgdGhpcy5fYmFyU3BhY2UpIC0gc3BlY2lhbEJhclNwYWNlKSAvIChNYXRoLlBJICogMC41KTtcbiAgICAgICAgdmFyIGdhcEJhclNwYWNlID0gTWF0aC5taW4oTWF0aC5mbG9vcih0aGlzLl9iYXJTcGFjZSAqIHJhdGlvKSwgTWF0aC5mbG9vcih0aGlzLl9iYXJTcGFjZSkpO1xuICAgICAgICBpZiAoZ2FwQmFyU3BhY2UgJSAyID09PSAwICYmIGdhcEJhclNwYWNlICsgMiA+PSB0aGlzLl9iYXJTcGFjZSkge1xuICAgICAgICAgICAgLS1nYXBCYXJTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nYXBCYXJTcGFjZSA9IE1hdGgubWF4KDEsIGdhcEJhclNwYWNlKTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5fY2xhc3NpZnlUaW1lV2VpZ2h0VGlja3MgPSBmdW5jdGlvbiAobmV3RGF0YUxpc3QsIGlzVXBkYXRlKSB7XG4gICAgICAgIHZhciBiYXNlRGF0YUluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXZUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICBpZiAoaXNVcGRhdGUgIT09IG51bGwgJiYgaXNVcGRhdGUgIT09IHZvaWQgMCA/IGlzVXBkYXRlIDogZmFsc2UpIHtcbiAgICAgICAgICAgIGJhc2VEYXRhSW5kZXggPSB0aGlzLl9kYXRhTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBwcmV2VGltZXN0YW1wID0gdGhpcy5fZGF0YUxpc3RbYmFzZURhdGFJbmRleCAtIDFdLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVXZWlnaHRUaWNrTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9taW5UaW1lU3BhbiA9IHsgY29tcGFyZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGNhbGM6IERFRkFVTFRfTUlOX1RJTUVfU1BBTiB9O1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzaWZ5VGltZVdlaWdodFRpY2tzKHRoaXMuX3RpbWVXZWlnaHRUaWNrTWFwLCBuZXdEYXRhTGlzdCwgdGhpcy5fZGF0ZVRpbWVGb3JtYXQsIGJhc2VEYXRhSW5kZXgsIHRoaXMuX21pblRpbWVTcGFuLCBwcmV2VGltZXN0YW1wKTtcbiAgICAgICAgaWYgKHRoaXMuX21pblRpbWVTcGFuLmNvbXBhcmUgIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5UaW1lU3Bhbi5jYWxjID0gdGhpcy5fbWluVGltZVNwYW4uY29tcGFyZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aW1lV2VpZ2h0VGlja0xpc3QgPSBjcmVhdGVUaW1lV2VpZ2h0VGlja0xpc3QodGhpcy5fdGltZVdlaWdodFRpY2tNYXAsIHRoaXMuX2JhclNwYWNlLCB0aGlzLl9zdHlsZXMueEF4aXMudGlja1RleHQpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFRpbWVXZWlnaHRUaWNrTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVXZWlnaHRUaWNrTGlzdDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5fYWRqdXN0VmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciB0b3RhbEJhckNvdW50ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgdmlzaWJsZUJhckNvdW50ID0gdGhpcy5fdG90YWxCYXJTcGFjZSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB2YXIgbGVmdE1pblZpc2libGVCYXJDb3VudCA9IDA7XG4gICAgICAgIHZhciByaWdodE1pblZpc2libGVCYXJDb3VudCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPT09IDEgLyogU2Nyb2xsTGltaXRSb2xlLkRpc3RhbmNlICovKSB7XG4gICAgICAgICAgICBsZWZ0TWluVmlzaWJsZUJhckNvdW50ID0gKHRoaXMuX3RvdGFsQmFyU3BhY2UgLSB0aGlzLl9tYXhPZmZzZXREaXN0YW5jZS5yaWdodCkgLyB0aGlzLl9iYXJTcGFjZTtcbiAgICAgICAgICAgIHJpZ2h0TWluVmlzaWJsZUJhckNvdW50ID0gKHRoaXMuX3RvdGFsQmFyU3BhY2UgLSB0aGlzLl9tYXhPZmZzZXREaXN0YW5jZS5sZWZ0KSAvIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdE1pblZpc2libGVCYXJDb3VudCA9IHRoaXMuX21pblZpc2libGVCYXJDb3VudC5sZWZ0O1xuICAgICAgICAgICAgcmlnaHRNaW5WaXNpYmxlQmFyQ291bnQgPSB0aGlzLl9taW5WaXNpYmxlQmFyQ291bnQucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGVmdE1pblZpc2libGVCYXJDb3VudCA9IE1hdGgubWF4KDAsIGxlZnRNaW5WaXNpYmxlQmFyQ291bnQpO1xuICAgICAgICByaWdodE1pblZpc2libGVCYXJDb3VudCA9IE1hdGgubWF4KDAsIHJpZ2h0TWluVmlzaWJsZUJhckNvdW50KTtcbiAgICAgICAgdmFyIG1heFJpZ2h0T2Zmc2V0QmFyQ291bnQgPSB2aXNpYmxlQmFyQ291bnQgLSBNYXRoLm1pbihsZWZ0TWluVmlzaWJsZUJhckNvdW50LCB0b3RhbEJhckNvdW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPiBtYXhSaWdodE9mZnNldEJhckNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gbWF4UmlnaHRPZmZzZXRCYXJDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUmlnaHRPZmZzZXRCYXJDb3VudCA9IC10b3RhbEJhckNvdW50ICsgTWF0aC5taW4ocmlnaHRNaW5WaXNpYmxlQmFyQ291bnQsIHRvdGFsQmFyQ291bnQpO1xuICAgICAgICBpZiAodGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA8IG1pblJpZ2h0T2Zmc2V0QmFyQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSBtaW5SaWdodE9mZnNldEJhckNvdW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0byA9IE1hdGgucm91bmQodGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCArIHRvdGFsQmFyQ291bnQgKyAwLjUpO1xuICAgICAgICB2YXIgcmVhbFRvID0gdG87XG4gICAgICAgIGlmICh0byA+IHRvdGFsQmFyQ291bnQpIHtcbiAgICAgICAgICAgIHRvID0gdG90YWxCYXJDb3VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbSA9IE1hdGgucm91bmQodG8gLSB2aXNpYmxlQmFyQ291bnQpIC0gMTtcbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhbEZyb20gPSB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID4gMCA/IE1hdGgucm91bmQodG90YWxCYXJDb3VudCArIHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgLSB2aXNpYmxlQmFyQ291bnQpIC0gMSA6IGZyb207XG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZSA9IHsgZnJvbTogZnJvbSwgdG86IHRvLCByZWFsRnJvbTogcmVhbEZyb20sIHJlYWxUbzogcmVhbFRvIH07XG4gICAgICAgIHRoaXMuZXhlY3V0ZUFjdGlvbihBY3Rpb25UeXBlLk9uVmlzaWJsZVJhbmdlQ2hhbmdlLCB0aGlzLl92aXNpYmxlUmFuZ2UpO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VEYXRhTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl92aXNpYmxlUmFuZ2VIaWdoTG93UHJpY2UgPSBbXG4gICAgICAgICAgICB7IHg6IDAsIHByaWNlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB9LFxuICAgICAgICAgICAgeyB4OiAwLCBwcmljZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gcmVhbEZyb207IGkgPCByZWFsVG87IGkrKykge1xuICAgICAgICAgICAgdmFyIGtMaW5lRGF0YSA9IHRoaXMuX2RhdGFMaXN0W2ldO1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmRhdGFJbmRleFRvQ29vcmRpbmF0ZShpKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZURhdGFMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIGRhdGFJbmRleDogaSxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldjogKF9hID0gdGhpcy5fZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBrTGluZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGtMaW5lRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogKF9iID0gdGhpcy5fZGF0YUxpc3RbaSAtIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBrTGluZURhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGtMaW5lRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlWzBdLnByaWNlIDwga0xpbmVEYXRhLmhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlWzBdLnByaWNlID0ga0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVswXS54ID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZVsxXS5wcmljZSA+IGtMaW5lRGF0YS5sb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlWzFdLnByaWNlID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlWzFdLnggPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNb3JlIHByb2Nlc3NpbmcgYW5kIGxvYWRpbmcsIG1vcmUgbG9hZGluZyBpZiB0aGVyZSBhcmUgY2FsbGJhY2sgbWV0aG9kcyBhbmQgbm8gZGF0YSBpcyBiZWluZyBsb2FkZWRcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nICYmIGlzVmFsaWQodGhpcy5fbG9hZE1vcmVEYXRhQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWREYXRhTW9yZS5mb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBMb2FkRGF0YVR5cGUuRm9yd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYyA9IHRoaXMuX2RhdGFMaXN0WzBdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChkYXRhLCBtb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkRGF0YShkYXRhLCBMb2FkRGF0YVR5cGUuRm9yd2FyZCwgeyBmb3J3YXJkOiBtb3JlICE9PSBudWxsICYmIG1vcmUgIT09IHZvaWQgMCA/IG1vcmUgOiBmYWxzZSwgYmFja3dhcmQ6IG1vcmUgIT09IG51bGwgJiYgbW9yZSAhPT0gdm9pZCAwID8gbW9yZSA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSB0b3RhbEJhckNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvYWREYXRhTW9yZS5iYWNrd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTG9hZERhdGFUeXBlLkJhY2t3YXJkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9kID0gdGhpcy5fZGF0YUxpc3RbdG90YWxCYXJDb3VudCAtIDFdKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChkYXRhLCBtb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkRGF0YShkYXRhLCBMb2FkRGF0YVR5cGUuQmFja3dhcmQsIHsgZm9yd2FyZDogbW9yZSAhPT0gbnVsbCAmJiBtb3JlICE9PSB2b2lkIDAgPyBtb3JlIDogZmFsc2UsIGJhY2t3YXJkOiBtb3JlICE9PSBudWxsICYmIG1vcmUgIT09IHZvaWQgMCA/IG1vcmUgOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZE1vcmVEYXRhQ2FsbGJhY2socGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldEJhclNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFyOiB0aGlzLl9iYXJTcGFjZSxcbiAgICAgICAgICAgIGhhbGZCYXI6IHRoaXMuX2JhclNwYWNlIC8gMixcbiAgICAgICAgICAgIGdhcEJhcjogdGhpcy5fZ2FwQmFyU3BhY2UsXG4gICAgICAgICAgICBoYWxmR2FwQmFyOiBNYXRoLmZsb29yKHRoaXMuX2dhcEJhclNwYWNlIC8gMilcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRCYXJTcGFjZSA9IGZ1bmN0aW9uIChiYXJTcGFjZSwgYWRqdXN0QmVmb3JlRnVuYykge1xuICAgICAgICBpZiAoYmFyU3BhY2UgPCBCYXJTcGFjZUxpbWl0Q29uc3RhbnRzLk1JTiB8fCBiYXJTcGFjZSA+IEJhclNwYWNlTGltaXRDb25zdGFudHMuTUFYIHx8IHRoaXMuX2JhclNwYWNlID09PSBiYXJTcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JhclNwYWNlID0gYmFyU3BhY2U7XG4gICAgICAgIHRoaXMuX3RpbWVXZWlnaHRUaWNrTGlzdCA9IGNyZWF0ZVRpbWVXZWlnaHRUaWNrTGlzdCh0aGlzLl90aW1lV2VpZ2h0VGlja01hcCwgdGhpcy5fYmFyU3BhY2UsIHRoaXMuX3N0eWxlcy54QXhpcy50aWNrVGV4dCk7XG4gICAgICAgIHRoaXMuX2NhbGNPcHRpbWFsQmFyU3BhY2UoKTtcbiAgICAgICAgYWRqdXN0QmVmb3JlRnVuYyA9PT0gbnVsbCB8fCBhZGp1c3RCZWZvcmVGdW5jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGp1c3RCZWZvcmVGdW5jKCk7XG4gICAgICAgIHRoaXMuX2FkanVzdFZpc2libGVSYW5nZSgpO1xuICAgICAgICB0aGlzLnNldENyb3NzaGFpcih0aGlzLl9jcm9zc2hhaXIsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldFRvdGFsQmFyU3BhY2UgPSBmdW5jdGlvbiAodG90YWxTcGFjZSkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxCYXJTcGFjZSAhPT0gdG90YWxTcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxCYXJTcGFjZSA9IHRvdGFsU3BhY2U7XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Jvc3NoYWlyKHRoaXMuX2Nyb3NzaGFpciwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0T2Zmc2V0UmlnaHREaXN0YW5jZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgaXNVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0UmlnaHREaXN0YW5jZSA9IHRoaXMuX3Njcm9sbExpbWl0Um9sZSA9PT0gMSAvKiBTY3JvbGxMaW1pdFJvbGUuRGlzdGFuY2UgKi8gPyBNYXRoLm1pbih0aGlzLl9tYXhPZmZzZXREaXN0YW5jZS5yaWdodCwgZGlzdGFuY2UpIDogZGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSB0aGlzLl9vZmZzZXRSaWdodERpc3RhbmNlIC8gdGhpcy5fYmFyU3BhY2U7XG4gICAgICAgIGlmIChpc1VwZGF0ZSAhPT0gbnVsbCAmJiBpc1VwZGF0ZSAhPT0gdm9pZCAwID8gaXNVcGRhdGUgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLnNldENyb3NzaGFpcih0aGlzLl9jcm9zc2hhaXIsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmxheW91dCh7XG4gICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0SW5pdGlhbE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRSaWdodERpc3RhbmNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ICogdGhpcy5fYmFyU3BhY2UpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSBmdW5jdGlvbiAoYmFyQ291bnQpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCA9IGJhckNvdW50O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldE1heE9mZnNldExlZnREaXN0YW5jZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPSAxIC8qIFNjcm9sbExpbWl0Um9sZS5EaXN0YW5jZSAqLztcbiAgICAgICAgdGhpcy5fbWF4T2Zmc2V0RGlzdGFuY2UubGVmdCA9IGRpc3RhbmNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldE1heE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsTGltaXRSb2xlID0gMSAvKiBTY3JvbGxMaW1pdFJvbGUuRGlzdGFuY2UgKi87XG4gICAgICAgIHRoaXMuX21heE9mZnNldERpc3RhbmNlLnJpZ2h0ID0gZGlzdGFuY2U7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0TGVmdE1pblZpc2libGVCYXJDb3VudCA9IGZ1bmN0aW9uIChiYXJDb3VudCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPSAwIC8qIFNjcm9sbExpbWl0Um9sZS5CYXJDb3VudCAqLztcbiAgICAgICAgdGhpcy5fbWluVmlzaWJsZUJhckNvdW50LmxlZnQgPSBiYXJDb3VudDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRSaWdodE1pblZpc2libGVCYXJDb3VudCA9IGZ1bmN0aW9uIChiYXJDb3VudCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxMaW1pdFJvbGUgPSAwIC8qIFNjcm9sbExpbWl0Um9sZS5CYXJDb3VudCAqLztcbiAgICAgICAgdGhpcy5fbWluVmlzaWJsZUJhckNvdW50LnJpZ2h0ID0gYmFyQ291bnQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0VmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVJhbmdlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnN0YXJ0U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGFydExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgPSB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50O1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlzdGFuY2VCYXJDb3VudCA9IGRpc3RhbmNlIC8gdGhpcy5fYmFyU3BhY2U7XG4gICAgICAgIHZhciBwcmV2TGFzdEJhclJpZ2h0U2lkZURpc3RhbmNlID0gdGhpcy5fbGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCAqIHRoaXMuX2JhclNwYWNlO1xuICAgICAgICB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ID0gdGhpcy5fc3RhcnRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IC0gZGlzdGFuY2VCYXJDb3VudDtcbiAgICAgICAgdGhpcy5fYWRqdXN0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NoYWlyKHRoaXMuX2Nyb3NzaGFpciwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9jaGFydC5sYXlvdXQoe1xuICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZWFsRGlzdGFuY2UgPSBNYXRoLnJvdW5kKHByZXZMYXN0QmFyUmlnaHRTaWRlRGlzdGFuY2UgLSB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50ICogdGhpcy5fYmFyU3BhY2UpO1xuICAgICAgICBpZiAocmVhbERpc3RhbmNlICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oQWN0aW9uVHlwZS5PblNjcm9sbCwgeyBkaXN0YW5jZTogcmVhbERpc3RhbmNlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0RGF0YUJ5RGF0YUluZGV4ID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9kYXRhTGlzdFtkYXRhSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmNvb3JkaW5hdGVUb0Zsb2F0SW5kZXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZGF0YUNvdW50ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgZGVsdGFGcm9tUmlnaHQgPSAodGhpcy5fdG90YWxCYXJTcGFjZSAtIHgpIC8gdGhpcy5fYmFyU3BhY2U7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGFDb3VudCArIHRoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgLSBkZWx0YUZyb21SaWdodDtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoaW5kZXggKiAxMDAwMDAwKSAvIDEwMDAwMDA7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZGF0YUluZGV4VG9UaW1lc3RhbXAgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9kYXRhTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXREYXRhQnlEYXRhSW5kZXgoZGF0YUluZGV4KTtcbiAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRhdGFJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFMaXN0W2xhc3RJbmRleF0udGltZXN0YW1wICsgdGhpcy5fbWluVGltZVNwYW4uY2FsYyAqIChkYXRhSW5kZXggLSBsYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUxpc3RbMF0udGltZXN0YW1wIC0gdGhpcy5fbWluVGltZVNwYW4uY2FsYyAqIE1hdGguYWJzKGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUudGltZXN0YW1wVG9EYXRhSW5kZXggPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9kYXRhTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdFRpbWVzdGFtcCA9IHRoaXMuX2RhdGFMaXN0W2xhc3RJbmRleF0udGltZXN0YW1wO1xuICAgICAgICBpZiAodGltZXN0YW1wID4gbGFzdFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleCArIE1hdGguZmxvb3IoKHRpbWVzdGFtcCAtIGxhc3RUaW1lc3RhbXApIC8gdGhpcy5fbWluVGltZVNwYW4uY2FsYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0VGltZXN0YW1wID0gdGhpcy5fZGF0YUxpc3RbMF0udGltZXN0YW1wO1xuICAgICAgICBpZiAodGltZXN0YW1wIDwgZmlyc3RUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh0aW1lc3RhbXAgLSBmaXJzdFRpbWVzdGFtcCkgLyB0aGlzLl9taW5UaW1lU3Bhbi5jYWxjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluYXJ5U2VhcmNoTmVhcmVzdCh0aGlzLl9kYXRhTGlzdCwgJ3RpbWVzdGFtcCcsIHRpbWVzdGFtcCk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZGF0YUluZGV4VG9Db29yZGluYXRlID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgZGF0YUNvdW50ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgZGVsdGFGcm9tUmlnaHQgPSBkYXRhQ291bnQgKyB0aGlzLl9sYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IC0gZGF0YUluZGV4O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLl90b3RhbEJhclNwYWNlIC0gKGRlbHRhRnJvbVJpZ2h0IC0gMC41KSAqIHRoaXMuX2JhclNwYWNlICsgMC41KTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5jb29yZGluYXRlVG9EYXRhSW5kZXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuY29vcmRpbmF0ZVRvRmxvYXRJbmRleCh4KSkgLSAxO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGNvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuX3pvb21FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHpvb21Db29yZGluYXRlID0gY29vcmRpbmF0ZSAhPT0gbnVsbCAmJiBjb29yZGluYXRlICE9PSB2b2lkIDAgPyBjb29yZGluYXRlIDogbnVsbDtcbiAgICAgICAgaWYgKCFpc051bWJlcih6b29tQ29vcmRpbmF0ZSA9PT0gbnVsbCB8fCB6b29tQ29vcmRpbmF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogem9vbUNvb3JkaW5hdGUueCkpIHtcbiAgICAgICAgICAgIHpvb21Db29yZGluYXRlID0geyB4OiAoX2EgPSB0aGlzLl9jcm9zc2hhaXIueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fdG90YWxCYXJTcGFjZSAvIDIgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHpvb21Db29yZGluYXRlLng7XG4gICAgICAgIHZhciBmbG9hdEluZGV4ID0gdGhpcy5jb29yZGluYXRlVG9GbG9hdEluZGV4KHgpO1xuICAgICAgICB2YXIgcHJldkJhclNwYWNlID0gdGhpcy5fYmFyU3BhY2U7XG4gICAgICAgIHZhciBiYXJTcGFjZSA9IHRoaXMuX2JhclNwYWNlICsgc2NhbGUgKiAodGhpcy5fYmFyU3BhY2UgLyBTQ0FMRV9NVUxUSVBMSUVSKTtcbiAgICAgICAgdGhpcy5zZXRCYXJTcGFjZShiYXJTcGFjZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQgKz0gKGZsb2F0SW5kZXggLSBfdGhpcy5jb29yZGluYXRlVG9GbG9hdEluZGV4KHgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZWFsU2NhbGUgPSB0aGlzLl9iYXJTcGFjZSAvIHByZXZCYXJTcGFjZTtcbiAgICAgICAgaWYgKHJlYWxTY2FsZSAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25ab29tLCB7IHNjYWxlOiByZWFsU2NhbGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5zZXRab29tRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX3pvb21FbmFibGVkID0gZW5hYmxlZDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5pc1pvb21FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fem9vbUVuYWJsZWQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0U2Nyb2xsRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbEVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmlzU2Nyb2xsRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVuYWJsZWQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0Q3Jvc3NoYWlyID0gZnVuY3Rpb24gKGNyb3NzaGFpciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBub3RJbnZhbGlkYXRlID0gX2Iubm90SW52YWxpZGF0ZSwgbm90RXhlY3V0ZUFjdGlvbiA9IF9iLm5vdEV4ZWN1dGVBY3Rpb24sIGZvcmNlSW52YWxpZGF0ZSA9IF9iLmZvcmNlSW52YWxpZGF0ZTtcbiAgICAgICAgdmFyIGNyID0gY3Jvc3NoYWlyICE9PSBudWxsICYmIGNyb3NzaGFpciAhPT0gdm9pZCAwID8gY3Jvc3NoYWlyIDoge307XG4gICAgICAgIHZhciByZWFsRGF0YUluZGV4ID0gMDtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IDA7XG4gICAgICAgIGlmIChpc051bWJlcihjci54KSkge1xuICAgICAgICAgICAgcmVhbERhdGFJbmRleCA9IHRoaXMuY29vcmRpbmF0ZVRvRGF0YUluZGV4KGNyLngpO1xuICAgICAgICAgICAgaWYgKHJlYWxEYXRhSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlYWxEYXRhSW5kZXggPiB0aGlzLl9kYXRhTGlzdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgZGF0YUluZGV4ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFJbmRleCA9IHJlYWxEYXRhSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFsRGF0YUluZGV4ID0gdGhpcy5fZGF0YUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IHJlYWxEYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtMaW5lRGF0YSA9IHRoaXMuX2RhdGFMaXN0W2RhdGFJbmRleF07XG4gICAgICAgIHZhciByZWFsWCA9IHRoaXMuZGF0YUluZGV4VG9Db29yZGluYXRlKHJlYWxEYXRhSW5kZXgpO1xuICAgICAgICB2YXIgcHJldkNyb3NzaGFpciA9IHsgeDogdGhpcy5fY3Jvc3NoYWlyLngsIHk6IHRoaXMuX2Nyb3NzaGFpci55LCBwYW5lSWQ6IHRoaXMuX2Nyb3NzaGFpci5wYW5lSWQgfTtcbiAgICAgICAgdGhpcy5fY3Jvc3NoYWlyID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNyKSwgeyByZWFsWDogcmVhbFgsIGtMaW5lRGF0YToga0xpbmVEYXRhLCByZWFsRGF0YUluZGV4OiByZWFsRGF0YUluZGV4LCBkYXRhSW5kZXg6IGRhdGFJbmRleCwgdGltZXN0YW1wOiAoX2EgPSB0aGlzLmRhdGFJbmRleFRvVGltZXN0YW1wKHJlYWxEYXRhSW5kZXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIGlmIChwcmV2Q3Jvc3NoYWlyLnggIT09IGNyLnggfHxcbiAgICAgICAgICAgIHByZXZDcm9zc2hhaXIueSAhPT0gY3IueSB8fFxuICAgICAgICAgICAgcHJldkNyb3NzaGFpci5wYW5lSWQgIT09IGNyLnBhbmVJZCB8fFxuICAgICAgICAgICAgKGZvcmNlSW52YWxpZGF0ZSAhPT0gbnVsbCAmJiBmb3JjZUludmFsaWRhdGUgIT09IHZvaWQgMCA/IGZvcmNlSW52YWxpZGF0ZSA6IGZhbHNlKSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoa0xpbmVEYXRhKSAmJiAhKG5vdEV4ZWN1dGVBY3Rpb24gIT09IG51bGwgJiYgbm90RXhlY3V0ZUFjdGlvbiAhPT0gdm9pZCAwID8gbm90RXhlY3V0ZUFjdGlvbiA6IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmNyb3NzaGFpckNoYW5nZSh0aGlzLl9jcm9zc2hhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEobm90SW52YWxpZGF0ZSAhPT0gbnVsbCAmJiBub3RJbnZhbGlkYXRlICE9PSB2b2lkIDAgPyBub3RJbnZhbGlkYXRlIDogZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDojrflj5Zjcm9zc2hhaXLkv6Hmga9cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRDcm9zc2hhaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcm9zc2hhaXI7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0QWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvID0gaW5mbyAhPT0gbnVsbCAmJiBpbmZvICE9PSB2b2lkIDAgPyBpbmZvIDogbnVsbDtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRBY3RpdmVUb29sdGlwRmVhdHVyZUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUb29sdGlwRmVhdHVyZUluZm87XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZXhlY3V0ZUFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fYWN0aW9ucy5nZXQodHlwZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGVjdXRlKGRhdGEpO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnN1YnNjcmliZUFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aW9ucy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMuc2V0KHR5cGUsIG5ldyBBY3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fYWN0aW9ucy5nZXQodHlwZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnVuc3Vic2NyaWJlQWN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25zLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoYWN0aW9uKSkge1xuICAgICAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5kZWxldGUodHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5oYXNBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5fYWN0aW9ucy5nZXQodHlwZSk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKGFjdGlvbikgJiYgIWFjdGlvbi5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX3NvcnRJbmRpY2F0b3JzID0gZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc1N0cmluZyhwYW5lSWQpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9pbmRpY2F0b3JzLmdldChwYW5lSWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29ydChmdW5jdGlvbiAoaTEsIGkyKSB7IHJldHVybiBpMS56TGV2ZWwgLSBpMi56TGV2ZWw7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lSW5kaWNhdG9ycykge1xuICAgICAgICAgICAgICAgIHBhbmVJbmRpY2F0b3JzLnNvcnQoZnVuY3Rpb24gKGkxLCBpMikgeyByZXR1cm4gaTEuekxldmVsIC0gaTIuekxldmVsOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX2FkZEluZGljYXRvckNhbGNUYXNrID0gZnVuY3Rpb24gKGluZGljYXRvciwgbG9hZERhdGFUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Rhc2tTY2hlZHVsZXIuYWRkVGFzayh7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVUYXNrSWQoaW5kaWNhdG9yLmlkKSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gaW5kaWNhdG9yLm9uRGF0YVN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbmRpY2F0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEluZGljYXRvckRhdGFTdGF0ZS5Mb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBsb2FkRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmNhbGNJbXAoX3RoaXMuX2RhdGFMaXN0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGluZGljYXRvci5vbkRhdGFTdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEluZGljYXRvckRhdGFTdGF0ZS5SZWFkeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBsb2FkRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yOiBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGluZGljYXRvci5vbkRhdGFTdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW5kaWNhdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogSW5kaWNhdG9yRGF0YVN0YXRlLkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbG9hZERhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yOiBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmFkZEluZGljYXRvciA9IGZ1bmN0aW9uIChjcmVhdGUsIHBhbmVJZCwgaXNTdGFjaykge1xuICAgICAgICB2YXIgbmFtZSA9IGNyZWF0ZS5uYW1lO1xuICAgICAgICB2YXIgZmlsdGVySW5kaWNhdG9ycyA9IHRoaXMuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyKGNyZWF0ZSk7XG4gICAgICAgIGlmIChmaWx0ZXJJbmRpY2F0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFuZUluZGljYXRvcnMgPSB0aGlzLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lSWQpO1xuICAgICAgICB2YXIgSW5kaWNhdG9yQ2xhenogPSBnZXRJbmRpY2F0b3JDbGFzcyhuYW1lKTtcbiAgICAgICAgdmFyIGluZGljYXRvciA9IG5ldyBJbmRpY2F0b3JDbGF6eigpO1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6ZUluZGljYXRvclNlcmllc1ByZWNpc2lvbihpbmRpY2F0b3IpO1xuICAgICAgICBpbmRpY2F0b3IucGFuZUlkID0gcGFuZUlkO1xuICAgICAgICBpbmRpY2F0b3Iub3ZlcnJpZGUoY3JlYXRlKTtcbiAgICAgICAgaWYgKCFpc1N0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluZGljYXRvcih7IHBhbmVJZDogcGFuZUlkIH0pO1xuICAgICAgICAgICAgcGFuZUluZGljYXRvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwYW5lSW5kaWNhdG9ycy5wdXNoKGluZGljYXRvcik7XG4gICAgICAgIHRoaXMuX2luZGljYXRvcnMuc2V0KHBhbmVJZCwgcGFuZUluZGljYXRvcnMpO1xuICAgICAgICB0aGlzLl9zb3J0SW5kaWNhdG9ycyhwYW5lSWQpO1xuICAgICAgICB0aGlzLl9hZGRJbmRpY2F0b3JDYWxjVGFzayhpbmRpY2F0b3IsIExvYWREYXRhVHlwZS5Jbml0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkID0gZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9pbmRpY2F0b3JzLmdldChwYW5lSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRJbmRpY2F0b3JzQnlGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBwYW5lSWQgPSBmaWx0ZXIucGFuZUlkLCBuYW1lID0gZmlsdGVyLm5hbWUsIGlkID0gZmlsdGVyLmlkO1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kaWNhdG9yLmlkID09PSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNWYWxpZChuYW1lKSB8fCBpbmRpY2F0b3IubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGluZGljYXRvcnMgPSBbXTtcbiAgICAgICAgaWYgKGlzVmFsaWQocGFuZUlkKSkge1xuICAgICAgICAgICAgaW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkKHBhbmVJZCkuZmlsdGVyKG1hdGNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVJbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHBhbmVJbmRpY2F0b3JzLmZpbHRlcihtYXRjaCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljYXRvcnM7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUucmVtb3ZlSW5kaWNhdG9yID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZmlsdGVySW5kaWNhdG9ycyA9IHRoaXMuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIGZpbHRlckluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB2YXIgcGFuZUluZGljYXRvcnMgPSBfdGhpcy5nZXRJbmRpY2F0b3JzQnlQYW5lSWQoaW5kaWNhdG9yLnBhbmVJZCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYW5lSW5kaWNhdG9ycy5maW5kSW5kZXgoZnVuY3Rpb24gKGlucykgeyByZXR1cm4gaW5zLmlkID09PSBpbmRpY2F0b3IuaWQ7IH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFza1NjaGVkdWxlci5yZW1vdmVUYXNrKGdlbmVyYXRlVGFza0lkKGluZGljYXRvci5pZCkpO1xuICAgICAgICAgICAgICAgIHBhbmVJbmRpY2F0b3JzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZUluZGljYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2luZGljYXRvcnMuZGVsZXRlKGluZGljYXRvci5wYW5lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuaGFzSW5kaWNhdG9ycyA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvcnMuaGFzKHBhbmVJZCk7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuX3N5bmNocm9uaXplSW5kaWNhdG9yU2VyaWVzUHJlY2lzaW9uID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9wcmVjaXNpb24sIHByaWNlUHJlY2lzaW9uID0gX2EucHJpY2UsIHZvbHVtZVByZWNpc2lvbiA9IF9hLnZvbHVtZTtcbiAgICAgICAgdmFyIHN5bmNocm9uaXplID0gZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRpY2F0b3Iuc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBJbmRpY2F0b3JTZXJpZXMuUHJpY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yLnNldFNlcmllc1ByZWNpc2lvbihwcmljZVByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIEluZGljYXRvclNlcmllcy5Wb2x1bWU6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yLnNldFNlcmllc1ByZWNpc2lvbih2b2x1bWVQcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1ZhbGlkKGluZGljYXRvcikpIHtcbiAgICAgICAgICAgIHN5bmNocm9uaXplKGluZGljYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVJbmRpY2F0b3JzKSB7XG4gICAgICAgICAgICAgICAgcGFuZUluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNocm9uaXplKGluZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLm92ZXJyaWRlSW5kaWNhdG9yID0gZnVuY3Rpb24gKG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVGbGFnID0gZmFsc2U7XG4gICAgICAgIHZhciBzb3J0RmxhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZmlsdGVySW5kaWNhdG9ycyA9IHRoaXMuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyKG92ZXJyaWRlKTtcbiAgICAgICAgZmlsdGVySW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIGluZGljYXRvci5vdmVycmlkZShvdmVycmlkZSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBpbmRpY2F0b3Iuc2hvdWxkVXBkYXRlSW1wKCksIGNhbGMgPSBfYS5jYWxjLCBkcmF3ID0gX2EuZHJhdywgc29ydCA9IF9hLnNvcnQ7XG4gICAgICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgICAgIHNvcnRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZEluZGljYXRvckNhbGNUYXNrKGluZGljYXRvciwgTG9hZERhdGFUeXBlLlVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhdykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgaWYgKHNvcnRGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3J0SW5kaWNhdG9ycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICBpZiAodXBkYXRlRmxhZykge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQubGF5b3V0KHsgdXBkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldE92ZXJsYXlzQnlGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGlkID0gZmlsdGVyLmlkLCBncm91cElkID0gZmlsdGVyLmdyb3VwSWQsIHBhbmVJZCA9IGZpbHRlci5wYW5lSWQsIG5hbWUgPSBmaWx0ZXIubmFtZTtcbiAgICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdmVybGF5LmlkID09PSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdmVybGF5Lmdyb3VwSWQgPT09IGdyb3VwSWQgJiYgKCFpc1ZhbGlkKG5hbWUpIHx8IG92ZXJsYXkubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFpc1ZhbGlkKG5hbWUpIHx8IG92ZXJsYXkubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gW107XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIG92ZXJsYXlzID0gb3ZlcmxheXMuY29uY2F0KHRoaXMuZ2V0T3ZlcmxheXNCeVBhbmVJZChwYW5lSWQpLmZpbHRlcihtYXRjaCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheXMgPSBvdmVybGF5cy5jb25jYXQocGFuZU92ZXJsYXlzLmZpbHRlcihtYXRjaCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheSA9IChfYSA9IHRoaXMuX3Byb2dyZXNzT3ZlcmxheUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdmVybGF5O1xuICAgICAgICBpZiAoaXNWYWxpZChwcm9ncmVzc092ZXJsYXkpICYmIG1hdGNoKHByb2dyZXNzT3ZlcmxheSkpIHtcbiAgICAgICAgICAgIG92ZXJsYXlzLnB1c2gocHJvZ3Jlc3NPdmVybGF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmxheXM7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuZ2V0T3ZlcmxheXNCeVBhbmVJZCA9IGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIHZhciBvdmVybGF5c18xID0gW107XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5cy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lT3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5c18xID0gb3ZlcmxheXNfMS5jb25jYXQocGFuZU92ZXJsYXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXlzXzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX292ZXJsYXlzLmdldChwYW5lSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5fc29ydE92ZXJsYXlzID0gZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc1N0cmluZyhwYW5lSWQpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9vdmVybGF5cy5nZXQocGFuZUlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvcnQoZnVuY3Rpb24gKG8xLCBvMikgeyByZXR1cm4gbzEuekxldmVsIC0gbzIuekxldmVsOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVPdmVybGF5cykge1xuICAgICAgICAgICAgICAgIHBhbmVPdmVybGF5cy5zb3J0KGZ1bmN0aW9uIChvMSwgbzIpIHsgcmV0dXJuIG8xLnpMZXZlbCAtIG8yLnpMZXZlbDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmFkZE92ZXJsYXlzID0gZnVuY3Rpb24gKG9zLCBhcHBvaW50UGFuZUZsYWdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVQYW5lSWRzID0gW107XG4gICAgICAgIHZhciBpZHMgPSBvcy5tYXAoZnVuY3Rpb24gKGNyZWF0ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdmFyIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChjcmVhdGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmRPdmVybGF5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaCA9IF9fdmFsdWVzKF90aGlzLl9vdmVybGF5cyksIF9qID0gX2gubmV4dCgpOyAhX2ouZG9uZTsgX2ogPSBfaC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfayA9IF9fcmVhZChfai52YWx1ZSwgMiksIG92ZXJsYXlzID0gX2tbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IG92ZXJsYXlzLmZpbmQoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8uaWQgPT09IGNyZWF0ZS5pZDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChvdmVybGF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRPdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9qICYmICFfai5kb25lICYmIChfYSA9IF9oLnJldHVybikpIF9hLmNhbGwoX2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoZmluZE92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIE92ZXJsYXlDbGF6eiA9IGdldE92ZXJsYXlJbm5lckNsYXNzKGNyZWF0ZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKE92ZXJsYXlDbGF6eikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSAoX2IgPSBjcmVhdGUuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNyZWF0ZUlkKE9WRVJMQVlfSURfUFJFRklYKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhenooKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZUlkID0gKF9jID0gY3JlYXRlLnBhbmVJZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogUGFuZUlkQ29uc3RhbnRzLkNBTkRMRTtcbiAgICAgICAgICAgICAgICBjcmVhdGUuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICAoX2QgPSBjcmVhdGUuZ3JvdXBJZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGNyZWF0ZS5ncm91cElkID0gaWQpO1xuICAgICAgICAgICAgICAgIHZhciB6TGV2ZWwgPSBfdGhpcy5nZXRPdmVybGF5c0J5UGFuZUlkKHBhbmVJZCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIChfZSA9IGNyZWF0ZS56TGV2ZWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IChjcmVhdGUuekxldmVsID0gekxldmVsKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5Lm92ZXJyaWRlKGNyZWF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVQYW5lSWRzLmluY2x1ZGVzKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFuZUlkcy5wdXNoKHBhbmVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvID0geyBwYW5lSWQ6IHBhbmVJZCwgb3ZlcmxheTogb3ZlcmxheSwgYXBwb2ludFBhbmVGbGFnOiBhcHBvaW50UGFuZUZsYWdzW2luZGV4XSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fb3ZlcmxheXMuaGFzKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vdmVybGF5cy5zZXQocGFuZUlkLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9mID0gX3RoaXMuX292ZXJsYXlzLmdldChwYW5lSWQpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucHVzaChvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZyA9IG92ZXJsYXkub25EcmF3U3RhcnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jYWxsKG92ZXJsYXksICh7IG92ZXJsYXk6IG92ZXJsYXksIGNoYXJ0OiBfdGhpcy5fY2hhcnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGVQYW5lSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRPdmVybGF5cygpO1xuICAgICAgICAgICAgdXBkYXRlUGFuZUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lSWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8sIHBhbmVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBQYW5lSWRDb25zdGFudHMuWF9BWElTKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldFByb2dyZXNzT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnByb2dyZXNzT3ZlcmxheUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvLCBvdmVybGF5ID0gX2Iub3ZlcmxheSwgcGFuZUlkID0gX2IucGFuZUlkO1xuICAgICAgICAgICAgaWYgKCFvdmVybGF5LmlzRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5cy5oYXMocGFuZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdmVybGF5cy5zZXQocGFuZUlkLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX292ZXJsYXlzLmdldChwYW5lSWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3J0T3ZlcmxheXMocGFuZUlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnVwZGF0ZVByb2dyZXNzT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAocGFuZUlkLCBhcHBvaW50UGFuZUZsYWcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzT3ZlcmxheUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4oYXBwb2ludFBhbmVGbGFnKSAmJiBhcHBvaW50UGFuZUZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvLmFwcG9pbnRQYW5lRmxhZyA9IGFwcG9pbnRQYW5lRmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT3ZlcmxheUluZm8ucGFuZUlkID0gcGFuZUlkO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mby5vdmVybGF5Lm92ZXJyaWRlKHsgcGFuZUlkOiBwYW5lSWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5vdmVycmlkZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvcnRGbGFnID0gZmFsc2U7XG4gICAgICAgIHZhciB1cGRhdGVQYW5lSWRzID0gW107XG4gICAgICAgIHZhciBmaWx0ZXJPdmVybGF5cyA9IHRoaXMuZ2V0T3ZlcmxheXNCeUZpbHRlcihvdmVycmlkZSk7XG4gICAgICAgIGZpbHRlck92ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIG92ZXJsYXkub3ZlcnJpZGUob3ZlcnJpZGUpO1xuICAgICAgICAgICAgdmFyIF9hID0gb3ZlcmxheS5zaG91bGRVcGRhdGUoKSwgc29ydCA9IF9hLnNvcnQsIGRyYXcgPSBfYS5kcmF3O1xuICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgICBzb3J0RmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc29ydCB8fCBkcmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVQYW5lSWRzLmluY2x1ZGVzKG92ZXJsYXkucGFuZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQYW5lSWRzLnB1c2gob3ZlcmxheS5wYW5lSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICBpZiAoc29ydEZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRPdmVybGF5cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVQYW5lSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVwZGF0ZVBhbmVJZHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBwYW5lSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUucmVtb3ZlT3ZlcmxheSA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZVBhbmVJZHMgPSBbXTtcbiAgICAgICAgdmFyIGZpbHRlck92ZXJsYXlzID0gdGhpcy5nZXRPdmVybGF5c0J5RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIGZpbHRlck92ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBwYW5lSWQgPSBvdmVybGF5LnBhbmVJZDtcbiAgICAgICAgICAgIHZhciBwYW5lT3ZlcmxheXMgPSBfdGhpcy5nZXRPdmVybGF5c0J5UGFuZUlkKG92ZXJsYXkucGFuZUlkKTtcbiAgICAgICAgICAgIChfYSA9IG92ZXJsYXkub25SZW1vdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCB7IG92ZXJsYXk6IG92ZXJsYXksIGNoYXJ0OiBfdGhpcy5fY2hhcnQgfSk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZVBhbmVJZHMuaW5jbHVkZXMocGFuZUlkKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVBhbmVJZHMucHVzaChwYW5lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYW5lT3ZlcmxheXMuZmluZEluZGV4KGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLmlkID09PSBvdmVybGF5LmlkOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lT3ZlcmxheXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZU92ZXJsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vdmVybGF5cy5kZWxldGUocGFuZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGVQYW5lSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVwZGF0ZVBhbmVJZHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBwYW5lSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLywgUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0UHJlc3NlZE92ZXJsYXlJbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgdGhpcy5fcHJlc3NlZE92ZXJsYXlJbmZvID0gaW5mbztcbiAgICB9O1xuICAgIFN0b3JlSW1wLnByb3RvdHlwZS5nZXRQcmVzc2VkT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVzc2VkT3ZlcmxheUluZm87XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuc2V0SG92ZXJPdmVybGF5SW5mbyA9IGZ1bmN0aW9uIChpbmZvLCBldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuX2hvdmVyT3ZlcmxheUluZm8sIG92ZXJsYXkgPSBfYi5vdmVybGF5LCBmaWd1cmVUeXBlID0gX2IuZmlndXJlVHlwZSwgZmlndXJlSW5kZXggPSBfYi5maWd1cmVJbmRleCwgZmlndXJlID0gX2IuZmlndXJlO1xuICAgICAgICB2YXIgaW5mb092ZXJsYXkgPSBpbmZvLm92ZXJsYXk7XG4gICAgICAgIGlmICgob3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVybGF5LmlkKSAhPT0gKGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5pZCkgfHxcbiAgICAgICAgICAgIGZpZ3VyZVR5cGUgIT09IGluZm8uZmlndXJlVHlwZSB8fFxuICAgICAgICAgICAgZmlndXJlSW5kZXggIT09IGluZm8uZmlndXJlSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyT3ZlcmxheUluZm8gPSBpbmZvO1xuICAgICAgICAgICAgaWYgKChvdmVybGF5ID09PSBudWxsIHx8IG92ZXJsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJsYXkuaWQpICE9PSAoaW5mb092ZXJsYXkgPT09IG51bGwgfHwgaW5mb092ZXJsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9PdmVybGF5LmlkKSkge1xuICAgICAgICAgICAgICAgIHZhciBpZ25vcmVVcGRhdGVGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5vdmVycmlkZSh7IHpMZXZlbDogb3ZlcmxheS5nZXRQcmV2WkxldmVsKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3ZlcmxheS5vbk1vdXNlTGVhdmUpICYmIGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvbk1vdXNlTGVhdmUnLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5Lm9uTW91c2VMZWF2ZShfX2Fzc2lnbih7IGNoYXJ0OiB0aGlzLl9jaGFydCwgb3ZlcmxheTogb3ZlcmxheSwgZmlndXJlOiBmaWd1cmUgIT09IG51bGwgJiYgZmlndXJlICE9PSB2b2lkIDAgPyBmaWd1cmUgOiB1bmRlZmluZWQgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVVwZGF0ZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvT3ZlcmxheS5zZXRQcmV2WkxldmVsKGluZm9PdmVybGF5LnpMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIGluZm9PdmVybGF5Lm92ZXJyaWRlKHsgekxldmVsOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9KTtcbiAgICAgICAgICAgICAgICAgICAgc29ydEZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihpbmZvT3ZlcmxheS5vbk1vdXNlRW50ZXIpICYmIGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvbk1vdXNlRW50ZXInLCBpbmZvLmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9PdmVybGF5Lm9uTW91c2VFbnRlcihfX2Fzc2lnbih7IGNoYXJ0OiB0aGlzLl9jaGFydCwgb3ZlcmxheTogaW5mb092ZXJsYXksIGZpZ3VyZTogKF9hID0gaW5mby5maWd1cmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlVXBkYXRlRmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRPdmVybGF5cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZVVwZGF0ZUZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldEhvdmVyT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Zlck92ZXJsYXlJbmZvO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLnNldENsaWNrT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoaW5mbywgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHZhciBfZyA9IHRoaXMuX2NsaWNrT3ZlcmxheUluZm8sIHBhbmVJZCA9IF9nLnBhbmVJZCwgb3ZlcmxheSA9IF9nLm92ZXJsYXksIGZpZ3VyZVR5cGUgPSBfZy5maWd1cmVUeXBlLCBmaWd1cmUgPSBfZy5maWd1cmUsIGZpZ3VyZUluZGV4ID0gX2cuZmlndXJlSW5kZXg7XG4gICAgICAgIHZhciBpbmZvT3ZlcmxheSA9IGluZm8ub3ZlcmxheTtcbiAgICAgICAgaWYgKCghKChfYSA9IGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5pc0RyYXdpbmcoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpKSAmJiBjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25DbGljaycsIGluZm8uZmlndXJlKSkge1xuICAgICAgICAgICAgKF9iID0gaW5mb092ZXJsYXkgPT09IG51bGwgfHwgaW5mb092ZXJsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9PdmVybGF5Lm9uQ2xpY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGluZm9PdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiB0aGlzLl9jaGFydCwgb3ZlcmxheTogaW5mb092ZXJsYXksIGZpZ3VyZTogKF9jID0gaW5mby5maWd1cmUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCB9LCBldmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVybGF5LmlkKSAhPT0gKGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5pZCkgfHwgZmlndXJlVHlwZSAhPT0gaW5mby5maWd1cmVUeXBlIHx8IGZpZ3VyZUluZGV4ICE9PSBpbmZvLmZpZ3VyZUluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja092ZXJsYXlJbmZvID0gaW5mbztcbiAgICAgICAgICAgIGlmICgob3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVybGF5LmlkKSAhPT0gKGluZm9PdmVybGF5ID09PSBudWxsIHx8IGluZm9PdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvT3ZlcmxheS5pZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uRGVzZWxlY3RlZCcsIGZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gb3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVybGF5Lm9uRGVzZWxlY3RlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogdGhpcy5fY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZTogZmlndXJlICE9PSBudWxsICYmIGZpZ3VyZSAhPT0gdm9pZCAwID8gZmlndXJlIDogdW5kZWZpbmVkIH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25TZWxlY3RlZCcsIGluZm8uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2UgPSBpbmZvT3ZlcmxheSA9PT0gbnVsbCB8fCBpbmZvT3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mb092ZXJsYXkub25TZWxlY3RlZCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoaW5mb092ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IHRoaXMuX2NoYXJ0LCBvdmVybGF5OiBpbmZvT3ZlcmxheSwgZmlndXJlOiAoX2YgPSBpbmZvLmZpZ3VyZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdW5kZWZpbmVkIH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBpbmZvLnBhbmVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVJZCAhPT0gaW5mby5wYW5lSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8sIHBhbmVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovLCBQYW5lSWRDb25zdGFudHMuWF9BWElTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldENsaWNrT3ZlcmxheUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlja092ZXJsYXlJbmZvO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmlzT3ZlcmxheUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheXMuc2l6ZSA9PT0gMCAmJiB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvID09PSBudWxsO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmlzT3ZlcmxheURyYXdpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wcm9ncmVzc092ZXJsYXlJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3ZlcmxheS5pc0RyYXdpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfTtcbiAgICBTdG9yZUltcC5wcm90b3R5cGUuY2xlYXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2FkRGF0YU1vcmUuYmFja3dhcmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbG9hZERhdGFNb3JlLmZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZURhdGFMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZUhpZ2hMb3dQcmljZSA9IFtcbiAgICAgICAgICAgIHsgeDogMCwgcHJpY2U6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIH0sXG4gICAgICAgICAgICB7IHg6IDAsIHByaWNlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9XG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3Zpc2libGVSYW5nZSA9IGdldERlZmF1bHRWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5fdGltZVdlaWdodFRpY2tNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdGltZVdlaWdodFRpY2tMaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2Nyb3NzaGFpciA9IHt9O1xuICAgICAgICB0aGlzLl9hY3RpdmVUb29sdGlwRmVhdHVyZUluZm8gPSBudWxsO1xuICAgIH07XG4gICAgU3RvcmVJbXAucHJvdG90eXBlLmdldENoYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnQ7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVJbXA7XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBXaWRnZXROYW1lQ29uc3RhbnRzID0ge1xuICAgIE1BSU46ICdtYWluJyxcbiAgICBYX0FYSVM6ICd4QXhpcycsXG4gICAgWV9BWElTOiAneUF4aXMnLFxuICAgIFNFUEFSQVRPUjogJ3NlcGFyYXRvcidcbn07XG52YXIgUkVBTF9TRVBBUkFUT1JfSEVJR0hUID0gNztcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc1N1cHBvcnRlZERldmljZVBpeGVsQ29udGVudEJveCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVudHJpZXMuZXZlcnkoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiAnZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZScgaW4gZW50cnk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvYXZvaWQtbmV3IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBDYW52YXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FudmFzKHN0eWxlLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zdXBwb3J0ZWREZXZpY2VQaXhlbENvbnRlbnRCb3ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9waXhlbFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fcGl4ZWxIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9uZXh0UGl4ZWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX25leHRQaXhlbEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RBbmltYXRpb25JZCA9IERFRkFVTFRfUkVRVUVTVF9JRDtcbiAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKF90aGlzLl9lbGVtZW50KTtcbiAgICAgICAgICAgIF90aGlzLl9uZXh0UGl4ZWxXaWR0aCA9IE1hdGgucm91bmQoX3RoaXMuX2VsZW1lbnQuY2xpZW50V2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIF90aGlzLl9uZXh0UGl4ZWxIZWlnaHQgPSBNYXRoLnJvdW5kKF90aGlzLl9lbGVtZW50LmNsaWVudEhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gY3JlYXRlRG9tKCdjYW52YXMnLCBzdHlsZSk7XG4gICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaXNTdXBwb3J0ZWREZXZpY2VQaXhlbENvbnRlbnRCb3goKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdXBwb3J0ZWREZXZpY2VQaXhlbENvbnRlbnRCb3ggPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnRhcmdldCA9PT0gX3RoaXMuX2VsZW1lbnQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5kZXZpY2VQaXhlbENvbnRlbnRCb3hTaXplWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25leHRQaXhlbFdpZHRoID0gc2l6ZS5pbmxpbmVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25leHRQaXhlbEhlaWdodCA9IHNpemUuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9waXhlbFdpZHRoICE9PSBfdGhpcy5fbmV4dFBpeGVsV2lkdGggfHwgX3RoaXMuX3BpeGVsSGVpZ2h0ICE9PSBfdGhpcy5fbmV4dFBpeGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoX3RoaXMuX2VsZW1lbnQsIHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9tZWRpYVF1ZXJ5TGlzdCA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHJlc29sdXRpb246IFwiLmNvbmNhdChnZXRQaXhlbFJhdGlvKF90aGlzLl9lbGVtZW50KSwgXCJkcHB4KVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1kZXByZWNhdGVkIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIF90aGlzLl9tZWRpYVF1ZXJ5TGlzdC5hZGRMaXN0ZW5lcihfdGhpcy5fbWVkaWFRdWVyeUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKF8pIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICB9XG4gICAgQ2FudmFzLnByb3RvdHlwZS5fcmVzZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9leGVjdXRlTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gX3RoaXMuX2VsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX3RoaXMuX2VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgX3RoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBfdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgX3RoaXMuX3BpeGVsV2lkdGggPSBfdGhpcy5fbmV4dFBpeGVsV2lkdGg7XG4gICAgICAgICAgICBfdGhpcy5fcGl4ZWxIZWlnaHQgPSBfdGhpcy5fbmV4dFBpeGVsSGVpZ2h0O1xuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnQud2lkdGggPSBfdGhpcy5fbmV4dFBpeGVsV2lkdGg7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudC5oZWlnaHQgPSBfdGhpcy5fbmV4dFBpeGVsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGhvcml6b250YWxQaXhlbFJhdGlvID0gX3RoaXMuX25leHRQaXhlbFdpZHRoIC8gd2lkdGg7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxQaXhlbFJhdGlvID0gX3RoaXMuX25leHRQaXhlbEhlaWdodCAvIGhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLl9jdHguc2NhbGUoaG9yaXpvbnRhbFBpeGVsUmF0aW8sIHZlcnRpY2FsUGl4ZWxSYXRpbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS5fZXhlY3V0ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0QW5pbWF0aW9uSWQgPT09IERFRkFVTFRfUkVRVUVTVF9JRCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCBfdGhpcy5fd2lkdGgsIF90aGlzLl9oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9saXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0QW5pbWF0aW9uSWQgPSBERUZBVUxUX1JFUVVFU1RfSUQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodywgaCkge1xuICAgICAgICBpZiAodGhpcy5fd2lkdGggIT09IHcgfHwgdGhpcy5faGVpZ2h0ICE9PSBoKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodywgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoaCwgXCJweFwiKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3VwcG9ydGVkRGV2aWNlUGl4ZWxDb250ZW50Qm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRQaXhlbFdpZHRoID0gTWF0aC5yb3VuZCh3ICogcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFBpeGVsSGVpZ2h0ID0gTWF0aC5yb3VuZChoICogcGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzLnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICB9O1xuICAgIENhbnZhcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzVmFsaWQodGhpcy5fcmVzaXplT2JzZXJ2ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWQodGhpcy5fbWVkaWFRdWVyeUxpc3QpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWRlcHJlY2F0ZWQgLS0gaWdub3JlXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVF1ZXJ5TGlzdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tZWRpYVF1ZXJ5TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FudmFzO1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KHJvb3RDb250YWluZXIsIHBhbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2JvdW5kaW5nID0gY3JlYXRlRGVmYXVsdEJvdW5kaW5nKCk7XG4gICAgICAgIF90aGlzLl9wYW5lID0gcGFuZTtcbiAgICAgICAgX3RoaXMuX3Jvb3RDb250YWluZXIgPSByb290Q29udGFpbmVyO1xuICAgICAgICBfdGhpcy5fY29udGFpbmVyID0gX3RoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHJvb3RDb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2lkZ2V0LnByb3RvdHlwZS5zZXRCb3VuZGluZyA9IGZ1bmN0aW9uIChib3VuZGluZykge1xuICAgICAgICBtZXJnZSh0aGlzLl9ib3VuZGluZywgYm91bmRpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdpZGdldC5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGFpbmVyOyB9O1xuICAgIFdpZGdldC5wcm90b3R5cGUuZ2V0Qm91bmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZGluZztcbiAgICB9O1xuICAgIFdpZGdldC5wcm90b3R5cGUuZ2V0UGFuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmU7XG4gICAgfTtcbiAgICBXaWRnZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUltcCh0aGlzLl9jb250YWluZXIsIHRoaXMuX2JvdW5kaW5nLCBsZXZlbCAhPT0gbnVsbCAmJiBsZXZlbCAhPT0gdm9pZCAwID8gbGV2ZWwgOiAzIC8qIFVwZGF0ZUxldmVsLkRyYXdlciAqLyk7XG4gICAgfTtcbiAgICBXaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBXaWRnZXQ7XG59KEV2ZW50ZnVsKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERyYXdXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYXdXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJhd1dpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RDb250YWluZXIsIHBhbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9tYWluQ2FudmFzID0gbmV3IENhbnZhcyh7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICAgICAgekluZGV4OiAnMicsXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVNYWluKF90aGlzLl9tYWluQ2FudmFzLmdldENvbnRleHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fb3ZlcmxheUNhbnZhcyA9IG5ldyBDYW52YXMoe1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgIHpJbmRleDogJzInLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlT3ZlcmxheShfdGhpcy5fb3ZlcmxheUNhbnZhcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLmdldENvbnRhaW5lcigpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoX3RoaXMuX21haW5DYW52YXMuZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKF90aGlzLl9vdmVybGF5Q2FudmFzLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJhd1dpZGdldC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRG9tKCdkaXYnLCB7XG4gICAgICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgIHpJbmRleDogJzEnXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRHJhd1dpZGdldC5wcm90b3R5cGUudXBkYXRlSW1wID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgYm91bmRpbmcsIGxldmVsKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGJvdW5kaW5nLndpZHRoLCBoZWlnaHQgPSBib3VuZGluZy5oZWlnaHQsIGxlZnQgPSBib3VuZGluZy5sZWZ0O1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KGxlZnQsIFwicHhcIik7XG4gICAgICAgIHZhciBsID0gbGV2ZWw7XG4gICAgICAgIHZhciB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gdyB8fCBoZWlnaHQgIT09IGgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICAgIGwgPSAzIC8qIFVwZGF0ZUxldmVsLkRyYXdlciAqLztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGwpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBVcGRhdGVMZXZlbC5NYWluICovOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFpbkNhbnZhcy51cGRhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX292ZXJsYXlDYW52YXMudXBkYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAzIC8qIFVwZGF0ZUxldmVsLkRyYXdlciAqLzpcbiAgICAgICAgICAgIGNhc2UgNCAvKiBVcGRhdGVMZXZlbC5BbGwgKi86IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWluQ2FudmFzLnVwZGF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdmVybGF5Q2FudmFzLnVwZGF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd1dpZGdldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFpbkNhbnZhcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDYW52YXMuZGVzdHJveSgpO1xuICAgIH07XG4gICAgRHJhd1dpZGdldC5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoaW5jbHVkZU92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRCb3VuZGluZygpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVEb20oJ2NhbnZhcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9tYWluQ2FudmFzLmdldEVsZW1lbnQoKSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmIChpbmNsdWRlT3ZlcmxheSkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9vdmVybGF5Q2FudmFzLmdldEVsZW1lbnQoKSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuICAgIHJldHVybiBEcmF3V2lkZ2V0O1xufShXaWRnZXQpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPbkNpcmNsZShjb29yZGluYXRlLCBhdHRycykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBjaXJjbGVzID0gW107XG4gICAgY2lyY2xlcyA9IGNpcmNsZXMuY29uY2F0KGF0dHJzKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBjaXJjbGVzXzEgPSBfX3ZhbHVlcyhjaXJjbGVzKSwgY2lyY2xlc18xXzEgPSBjaXJjbGVzXzEubmV4dCgpOyAhY2lyY2xlc18xXzEuZG9uZTsgY2lyY2xlc18xXzEgPSBjaXJjbGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlXzEgPSBjaXJjbGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB4ID0gY2lyY2xlXzEueCwgeSA9IGNpcmNsZV8xLnksIHIgPSBjaXJjbGVfMS5yO1xuICAgICAgICAgICAgdmFyIGRpZlggPSBjb29yZGluYXRlLnggLSB4O1xuICAgICAgICAgICAgdmFyIGRpZlkgPSBjb29yZGluYXRlLnkgLSB5O1xuICAgICAgICAgICAgaWYgKCEoZGlmWCAqIGRpZlggKyBkaWZZICogZGlmWSA+IHIgKiByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2lyY2xlc18xXzEgJiYgIWNpcmNsZXNfMV8xLmRvbmUgJiYgKF9hID0gY2lyY2xlc18xLnJldHVybikpIF9hLmNhbGwoY2lyY2xlc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdDaXJjbGUoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIGNpcmNsZXMgPSBbXTtcbiAgICBjaXJjbGVzID0gY2lyY2xlcy5jb25jYXQoYXR0cnMpO1xuICAgIHZhciBfYSA9IHN0eWxlcy5zdHlsZSwgc3R5bGUgPSBfYSA9PT0gdm9pZCAwID8gUG9seWdvblR5cGUuRmlsbCA6IF9hLCBfYiA9IHN0eWxlcy5jb2xvciwgY29sb3IgPSBfYiA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfYiwgX2MgPSBzdHlsZXMuYm9yZGVyU2l6ZSwgYm9yZGVyU2l6ZSA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gc3R5bGVzLmJvcmRlckNvbG9yLCBib3JkZXJDb2xvciA9IF9kID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9kLCBfZSA9IHN0eWxlcy5ib3JkZXJTdHlsZSwgYm9yZGVyU3R5bGUgPSBfZSA9PT0gdm9pZCAwID8gTGluZVR5cGUuU29saWQgOiBfZSwgX2YgPSBzdHlsZXMuYm9yZGVyRGFzaGVkVmFsdWUsIGJvcmRlckRhc2hlZFZhbHVlID0gX2YgPT09IHZvaWQgMCA/IFsyLCAyXSA6IF9mO1xuICAgIHZhciBzb2xpZCA9IChzdHlsZSA9PT0gUG9seWdvblR5cGUuRmlsbCB8fCBzdHlsZXMuc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwpICYmICghaXNTdHJpbmcoY29sb3IpIHx8ICFpc1RyYW5zcGFyZW50KGNvbG9yKSk7XG4gICAgaWYgKHNvbGlkKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY2lyY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgciA9IF9hLnI7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKHN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2UgfHwgc3R5bGVzLnN0eWxlID09PSBQb2x5Z29uVHlwZS5TdHJva2VGaWxsKSAmJiBib3JkZXJTaXplID4gMCAmJiAhaXNUcmFuc3BhcmVudChib3JkZXJDb2xvcikpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJTaXplO1xuICAgICAgICBpZiAoYm9yZGVyU3R5bGUgPT09IExpbmVUeXBlLkRhc2hlZCkge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2hlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2lyY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgciA9IF9hLnI7XG4gICAgICAgICAgICBpZiAoIXNvbGlkIHx8IHIgPiBib3JkZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbnZhciBjaXJjbGUgPSB7XG4gICAgbmFtZTogJ2NpcmNsZScsXG4gICAgY2hlY2tFdmVudE9uOiBjaGVja0Nvb3JkaW5hdGVPbkNpcmNsZSxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdDaXJjbGUoY3R4LCBhdHRycywgc3R5bGVzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9uUG9seWdvbihjb29yZGluYXRlLCBhdHRycykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIHBvbHlnb25zID0gcG9seWdvbnMuY29uY2F0KGF0dHJzKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBwb2x5Z29uc18xID0gX192YWx1ZXMocG9seWdvbnMpLCBwb2x5Z29uc18xXzEgPSBwb2x5Z29uc18xLm5leHQoKTsgIXBvbHlnb25zXzFfMS5kb25lOyBwb2x5Z29uc18xXzEgPSBwb2x5Z29uc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHBvbHlnb25fMSA9IHBvbHlnb25zXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcG9seWdvbl8xLmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjb29yZGluYXRlc1tpXS55ID4gY29vcmRpbmF0ZS55KSAhPT0gKGNvb3JkaW5hdGVzW2pdLnkgPiBjb29yZGluYXRlLnkpICYmXG4gICAgICAgICAgICAgICAgICAgIChjb29yZGluYXRlLnggPCAoY29vcmRpbmF0ZXNbal0ueCAtIGNvb3JkaW5hdGVzW2ldLngpICogKGNvb3JkaW5hdGUueSAtIGNvb3JkaW5hdGVzW2ldLnkpIC8gKGNvb3JkaW5hdGVzW2pdLnkgLSBjb29yZGluYXRlc1tpXS55KSArIGNvb3JkaW5hdGVzW2ldLngpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uID0gIW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocG9seWdvbnNfMV8xICYmICFwb2x5Z29uc18xXzEuZG9uZSAmJiAoX2EgPSBwb2x5Z29uc18xLnJldHVybikpIF9hLmNhbGwocG9seWdvbnNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3UG9seWdvbihjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLmNvbmNhdChhdHRycyk7XG4gICAgdmFyIF9hID0gc3R5bGVzLnN0eWxlLCBzdHlsZSA9IF9hID09PSB2b2lkIDAgPyBQb2x5Z29uVHlwZS5GaWxsIDogX2EsIF9iID0gc3R5bGVzLmNvbG9yLCBjb2xvciA9IF9iID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9iLCBfYyA9IHN0eWxlcy5ib3JkZXJTaXplLCBib3JkZXJTaXplID0gX2MgPT09IHZvaWQgMCA/IDEgOiBfYywgX2QgPSBzdHlsZXMuYm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yID0gX2QgPT09IHZvaWQgMCA/ICdjdXJyZW50Q29sb3InIDogX2QsIF9lID0gc3R5bGVzLmJvcmRlclN0eWxlLCBib3JkZXJTdHlsZSA9IF9lID09PSB2b2lkIDAgPyBMaW5lVHlwZS5Tb2xpZCA6IF9lLCBfZiA9IHN0eWxlcy5ib3JkZXJEYXNoZWRWYWx1ZSwgYm9yZGVyRGFzaGVkVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gWzIsIDJdIDogX2Y7XG4gICAgaWYgKChzdHlsZSA9PT0gUG9seWdvblR5cGUuRmlsbCB8fCBzdHlsZXMuc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwpICYmXG4gICAgICAgICghaXNTdHJpbmcoY29sb3IpIHx8ICFpc1RyYW5zcGFyZW50KGNvbG9yKSkpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNvb3JkaW5hdGVzWzBdLngsIGNvb3JkaW5hdGVzWzBdLnkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY29vcmRpbmF0ZXNbaV0ueCwgY29vcmRpbmF0ZXNbaV0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChzdHlsZSA9PT0gUG9seWdvblR5cGUuU3Ryb2tlIHx8IHN0eWxlcy5zdHlsZSA9PT0gUG9seWdvblR5cGUuU3Ryb2tlRmlsbCkgJiYgYm9yZGVyU2l6ZSA+IDAgJiYgIWlzVHJhbnNwYXJlbnQoYm9yZGVyQ29sb3IpKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyU2l6ZTtcbiAgICAgICAgaWYgKGJvcmRlclN0eWxlID09PSBMaW5lVHlwZS5EYXNoZWQpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBfYS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29vcmRpbmF0ZXNbMF0ueCwgY29vcmRpbmF0ZXNbMF0ueSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1tpXS54LCBjb29yZGluYXRlc1tpXS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIHBvbHlnb24gPSB7XG4gICAgbmFtZTogJ3BvbHlnb24nLFxuICAgIGNoZWNrRXZlbnRPbjogY2hlY2tDb29yZGluYXRlT25Qb2x5Z29uLFxuICAgIGRyYXc6IGZ1bmN0aW9uIChjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICAgICAgZHJhd1BvbHlnb24oY3R4LCBhdHRycywgc3R5bGVzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29vcmRpbmF0ZU9uUmVjdChjb29yZGluYXRlLCBhdHRycykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciByZWN0cyA9IFtdO1xuICAgIHJlY3RzID0gcmVjdHMuY29uY2F0KGF0dHJzKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciByZWN0c18xID0gX192YWx1ZXMocmVjdHMpLCByZWN0c18xXzEgPSByZWN0c18xLm5leHQoKTsgIXJlY3RzXzFfMS5kb25lOyByZWN0c18xXzEgPSByZWN0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHJlY3RfMSA9IHJlY3RzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB4ID0gcmVjdF8xLng7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0XzEud2lkdGg7XG4gICAgICAgICAgICBpZiAod2lkdGggPCBERVZJQVRJT04gKiAyKSB7XG4gICAgICAgICAgICAgICAgeCAtPSBERVZJQVRJT047XG4gICAgICAgICAgICAgICAgd2lkdGggPSBERVZJQVRJT04gKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSByZWN0XzEueTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0XzEuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IERFVklBVElPTiAqIDIpIHtcbiAgICAgICAgICAgICAgICB5IC09IERFVklBVElPTjtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBERVZJQVRJT04gKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUueCA+PSB4ICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54IDw9IHggKyB3aWR0aCAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA+PSB5ICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS55IDw9IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlY3RzXzFfMSAmJiAhcmVjdHNfMV8xLmRvbmUgJiYgKF9hID0gcmVjdHNfMS5yZXR1cm4pKSBfYS5jYWxsKHJlY3RzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd1JlY3QoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciByZWN0cyA9IFtdO1xuICAgIHJlY3RzID0gcmVjdHMuY29uY2F0KGF0dHJzKTtcbiAgICB2YXIgX2IgPSBzdHlsZXMuc3R5bGUsIHN0eWxlID0gX2IgPT09IHZvaWQgMCA/IFBvbHlnb25UeXBlLkZpbGwgOiBfYiwgX2MgPSBzdHlsZXMuY29sb3IsIGNvbG9yID0gX2MgPT09IHZvaWQgMCA/ICd0cmFuc3BhcmVudCcgOiBfYywgX2QgPSBzdHlsZXMuYm9yZGVyU2l6ZSwgYm9yZGVyU2l6ZSA9IF9kID09PSB2b2lkIDAgPyAxIDogX2QsIF9lID0gc3R5bGVzLmJvcmRlckNvbG9yLCBib3JkZXJDb2xvciA9IF9lID09PSB2b2lkIDAgPyAndHJhbnNwYXJlbnQnIDogX2UsIF9mID0gc3R5bGVzLmJvcmRlclN0eWxlLCBib3JkZXJTdHlsZSA9IF9mID09PSB2b2lkIDAgPyBMaW5lVHlwZS5Tb2xpZCA6IF9mLCBfZyA9IHN0eWxlcy5ib3JkZXJSYWRpdXMsIHIgPSBfZyA9PT0gdm9pZCAwID8gMCA6IF9nLCBfaCA9IHN0eWxlcy5ib3JkZXJEYXNoZWRWYWx1ZSwgYm9yZGVyRGFzaGVkVmFsdWUgPSBfaCA9PT0gdm9pZCAwID8gWzIsIDJdIDogX2g7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICB2YXIgZHJhdyA9IChfYSA9IGN0eC5yb3VuZFJlY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5yZWN0O1xuICAgIHZhciBzb2xpZCA9IChzdHlsZSA9PT0gUG9seWdvblR5cGUuRmlsbCB8fCBzdHlsZXMuc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwpICYmICghaXNTdHJpbmcoY29sb3IpIHx8ICFpc1RyYW5zcGFyZW50KGNvbG9yKSk7XG4gICAgaWYgKHNvbGlkKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgcmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnksIHcgPSBfYS53aWR0aCwgaCA9IF9hLmhlaWdodDtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGRyYXcuY2FsbChjdHgsIHgsIHksIHcsIGgsIHIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZSB8fCBzdHlsZXMuc3R5bGUgPT09IFBvbHlnb25UeXBlLlN0cm9rZUZpbGwpICYmIGJvcmRlclNpemUgPiAwICYmICFpc1RyYW5zcGFyZW50KGJvcmRlckNvbG9yKSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyU2l6ZTtcbiAgICAgICAgaWYgKGJvcmRlclN0eWxlID09PSBMaW5lVHlwZS5EYXNoZWQpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChib3JkZXJEYXNoZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JyZWN0aW9uXzEgPSBib3JkZXJTaXplICUgMiA9PT0gMSA/IDAuNSA6IDA7XG4gICAgICAgIHZhciBkb3VibGVDb3JyZWN0aW9uXzEgPSBNYXRoLnJvdW5kKGNvcnJlY3Rpb25fMSAqIDIpO1xuICAgICAgICByZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgdyA9IF9hLndpZHRoLCBoID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHcgPiBib3JkZXJTaXplICogMiAmJiBoID4gYm9yZGVyU2l6ZSAqIDIpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZHJhdy5jYWxsKGN0eCwgeCArIGNvcnJlY3Rpb25fMSwgeSArIGNvcnJlY3Rpb25fMSwgdyAtIGRvdWJsZUNvcnJlY3Rpb25fMSwgaCAtIGRvdWJsZUNvcnJlY3Rpb25fMSwgcik7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc29saWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIHJlY3QgPSB7XG4gICAgbmFtZTogJ3JlY3QnLFxuICAgIGNoZWNrRXZlbnRPbjogY2hlY2tDb29yZGluYXRlT25SZWN0LFxuICAgIGRyYXc6IGZ1bmN0aW9uIChjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICAgICAgZHJhd1JlY3QoY3R4LCBhdHRycywgc3R5bGVzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRSZWN0KGF0dHJzLCBzdHlsZXMpIHtcbiAgICB2YXIgX2EgPSBzdHlsZXMuc2l6ZSwgc2l6ZSA9IF9hID09PSB2b2lkIDAgPyAxMiA6IF9hLCBfYiA9IHN0eWxlcy5wYWRkaW5nTGVmdCwgcGFkZGluZ0xlZnQgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IHN0eWxlcy5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBzdHlsZXMucGFkZGluZ1JpZ2h0LCBwYWRkaW5nUmlnaHQgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBfZSA9IHN0eWxlcy5wYWRkaW5nQm90dG9tLCBwYWRkaW5nQm90dG9tID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZSwgX2YgPSBzdHlsZXMud2VpZ2h0LCB3ZWlnaHQgPSBfZiA9PT0gdm9pZCAwID8gJ25vcm1hbCcgOiBfZiwgZmFtaWx5ID0gc3R5bGVzLmZhbWlseTtcbiAgICB2YXIgeCA9IGF0dHJzLngsIHkgPSBhdHRycy55LCB0ZXh0ID0gYXR0cnMudGV4dCwgX2cgPSBhdHRycy5hbGlnbiwgYWxpZ24gPSBfZyA9PT0gdm9pZCAwID8gJ2xlZnQnIDogX2csIF9oID0gYXR0cnMuYmFzZWxpbmUsIGJhc2VsaW5lID0gX2ggPT09IHZvaWQgMCA/ICd0b3AnIDogX2gsIHcgPSBhdHRycy53aWR0aCwgaCA9IGF0dHJzLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSB3ICE9PSBudWxsICYmIHcgIT09IHZvaWQgMCA/IHcgOiAocGFkZGluZ0xlZnQgKyBjYWxjVGV4dFdpZHRoKHRleHQsIHNpemUsIHdlaWdodCwgZmFtaWx5KSArIHBhZGRpbmdSaWdodCk7XG4gICAgdmFyIGhlaWdodCA9IGggIT09IG51bGwgJiYgaCAhPT0gdm9pZCAwID8gaCA6IChwYWRkaW5nVG9wICsgc2l6ZSArIHBhZGRpbmdCb3R0b20pO1xuICAgIHZhciBzdGFydFggPSAwO1xuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNhc2UgJ3N0YXJ0Jzoge1xuICAgICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgY2FzZSAnZW5kJzoge1xuICAgICAgICAgICAgc3RhcnRYID0geCAtIHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhcnRYID0geCAtIHdpZHRoIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydFkgPSAwO1xuICAgIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnaGFuZ2luZyc6IHtcbiAgICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOiB7XG4gICAgICAgICAgICBzdGFydFkgPSB5IC0gaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhcnRZID0geSAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xufVxuZnVuY3Rpb24gY2hlY2tDb29yZGluYXRlT25UZXh0KGNvb3JkaW5hdGUsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgdGV4dHMgPSBbXTtcbiAgICB0ZXh0cyA9IHRleHRzLmNvbmNhdChhdHRycyk7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgdGV4dHNfMSA9IF9fdmFsdWVzKHRleHRzKSwgdGV4dHNfMV8xID0gdGV4dHNfMS5uZXh0KCk7ICF0ZXh0c18xXzEuZG9uZTsgdGV4dHNfMV8xID0gdGV4dHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0XzEgPSB0ZXh0c18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRUZXh0UmVjdCh0ZXh0XzEsIHN0eWxlcyksIHggPSBfYi54LCB5ID0gX2IueSwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUueCA+PSB4ICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54IDw9IHggKyB3aWR0aCAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA+PSB5ICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZS55IDw9IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRleHRzXzFfMSAmJiAhdGV4dHNfMV8xLmRvbmUgJiYgKF9hID0gdGV4dHNfMS5yZXR1cm4pKSBfYS5jYWxsKHRleHRzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd1RleHQoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgdmFyIHRleHRzID0gW107XG4gICAgdGV4dHMgPSB0ZXh0cy5jb25jYXQoYXR0cnMpO1xuICAgIHZhciBfYSA9IHN0eWxlcy5jb2xvciwgY29sb3IgPSBfYSA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfYSwgX2IgPSBzdHlsZXMuc2l6ZSwgc2l6ZSA9IF9iID09PSB2b2lkIDAgPyAxMiA6IF9iLCBmYW1pbHkgPSBzdHlsZXMuZmFtaWx5LCB3ZWlnaHQgPSBzdHlsZXMud2VpZ2h0LCBfYyA9IHN0eWxlcy5wYWRkaW5nTGVmdCwgcGFkZGluZ0xlZnQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLCBfZCA9IHN0eWxlcy5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBzdHlsZXMucGFkZGluZ1JpZ2h0LCBwYWRkaW5nUmlnaHQgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lO1xuICAgIHZhciByZWN0cyA9IHRleHRzLm1hcChmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gZ2V0VGV4dFJlY3QodGV4dCwgc3R5bGVzKTsgfSk7XG4gICAgZHJhd1JlY3QoY3R4LCByZWN0cywgX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlcyksIHsgY29sb3I6IHN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IgfSkpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgIGN0eC5mb250ID0gY3JlYXRlRm9udChzaXplLCB3ZWlnaHQsIGZhbWlseSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIHRleHRzLmZvckVhY2goZnVuY3Rpb24gKHRleHQsIGluZGV4KSB7XG4gICAgICAgIHZhciByZWN0ID0gcmVjdHNbaW5kZXhdO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dC50ZXh0LCByZWN0LnggKyBwYWRkaW5nTGVmdCwgcmVjdC55ICsgcGFkZGluZ1RvcCwgcmVjdC53aWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0KTtcbiAgICB9KTtcbn1cbnZhciB0ZXh0ID0ge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uVGV4dCxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdUZXh0KGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZShjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIpIHtcbiAgICB2YXIgeERpZiA9IGNvb3JkaW5hdGUxLnggLSBjb29yZGluYXRlMi54O1xuICAgIHZhciB5RGlmID0gY29vcmRpbmF0ZTEueSAtIGNvb3JkaW5hdGUyLnk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGlmICogeERpZiArIHlEaWYgKiB5RGlmKTtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPbkFyYyhjb29yZGluYXRlLCBhdHRycykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBhcmNzID0gW107XG4gICAgYXJjcyA9IGFyY3MuY29uY2F0KGF0dHJzKTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBhcmNzXzEgPSBfX3ZhbHVlcyhhcmNzKSwgYXJjc18xXzEgPSBhcmNzXzEubmV4dCgpOyAhYXJjc18xXzEuZG9uZTsgYXJjc18xXzEgPSBhcmNzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgYXJjXzEgPSBhcmNzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhnZXREaXN0YW5jZShjb29yZGluYXRlLCBhcmNfMSkgLSBhcmNfMS5yKSA8IERFVklBVElPTikge1xuICAgICAgICAgICAgICAgIHZhciByID0gYXJjXzEuciwgc3RhcnRBbmdsZSA9IGFyY18xLnN0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gYXJjXzEuZW5kQW5nbGU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29vcmRpbmF0ZVggPSByICogTWF0aC5jb3Moc3RhcnRBbmdsZSkgKyBhcmNfMS54O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENvb3JkaW5hdGVZID0gciAqIE1hdGguc2luKHN0YXJ0QW5nbGUpICsgYXJjXzEueTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29vcmRpbmF0ZVggPSByICogTWF0aC5jb3MoZW5kQW5nbGUpICsgYXJjXzEueDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29vcmRpbmF0ZVkgPSByICogTWF0aC5zaW4oZW5kQW5nbGUpICsgYXJjXzEueTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZS54IDw9IE1hdGgubWF4KHN0YXJ0Q29vcmRpbmF0ZVgsIGVuZENvb3JkaW5hdGVYKSArIERFVklBVElPTiAmJlxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlLnggPj0gTWF0aC5taW4oc3RhcnRDb29yZGluYXRlWCwgZW5kQ29vcmRpbmF0ZVgpIC0gREVWSUFUSU9OICYmXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA8PSBNYXRoLm1heChzdGFydENvb3JkaW5hdGVZLCBlbmRDb29yZGluYXRlWSkgKyBERVZJQVRJT04gJiZcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS55ID49IE1hdGgubWluKHN0YXJ0Q29vcmRpbmF0ZVksIGVuZENvb3JkaW5hdGVZKSAtIERFVklBVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChhcmNzXzFfMSAmJiAhYXJjc18xXzEuZG9uZSAmJiAoX2EgPSBhcmNzXzEucmV0dXJuKSkgX2EuY2FsbChhcmNzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICB2YXIgYXJjcyA9IFtdO1xuICAgIGFyY3MgPSBhcmNzLmNvbmNhdChhdHRycyk7XG4gICAgdmFyIF9hID0gc3R5bGVzLnN0eWxlLCBzdHlsZSA9IF9hID09PSB2b2lkIDAgPyBMaW5lVHlwZS5Tb2xpZCA6IF9hLCBfYiA9IHN0eWxlcy5zaXplLCBzaXplID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYiwgX2MgPSBzdHlsZXMuY29sb3IsIGNvbG9yID0gX2MgPT09IHZvaWQgMCA/ICdjdXJyZW50Q29sb3InIDogX2MsIF9kID0gc3R5bGVzLmRhc2hlZFZhbHVlLCBkYXNoZWRWYWx1ZSA9IF9kID09PSB2b2lkIDAgPyBbMiwgMl0gOiBfZDtcbiAgICBjdHgubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBpZiAoc3R5bGUgPT09IExpbmVUeXBlLkRhc2hlZCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVkVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCByID0gX2Euciwgc3RhcnRBbmdsZSA9IF9hLnN0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gX2EuZW5kQW5nbGU7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0pO1xufVxudmFyIGFyYyA9IHtcbiAgICBuYW1lOiAnYXJjJyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uQXJjLFxuICAgIGRyYXc6IGZ1bmN0aW9uIChjdHgsIGF0dHJzLCBzdHlsZXMpIHtcbiAgICAgICAgZHJhd0FyYyhjdHgsIGF0dHJzLCBzdHlsZXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZHJhd0VsbGlwdGljYWxBcmMoY3R4LCB4MSwgeTEsIGFyZ3MsIG9mZnNldFgsIG9mZnNldFksIGlzUmVsYXRpdmUpIHtcbiAgICB2YXIgX2EgPSBfX3JlYWQoYXJncywgNyksIHJ4ID0gX2FbMF0sIHJ5ID0gX2FbMV0sIHJvdGF0aW9uID0gX2FbMl0sIGxhcmdlQXJjRmxhZyA9IF9hWzNdLCBzd2VlcEZsYWcgPSBfYVs0XSwgeDIgPSBfYVs1XSwgeTIgPSBfYVs2XTtcbiAgICB2YXIgdGFyZ2V0WCA9IGlzUmVsYXRpdmUgPyB4MSArIHgyIDogeDIgKyBvZmZzZXRYO1xuICAgIHZhciB0YXJnZXRZID0gaXNSZWxhdGl2ZSA/IHkxICsgeTIgOiB5MiArIG9mZnNldFk7XG4gICAgdmFyIHNlZ21lbnRzID0gZWxsaXB0aWNhbEFyY1RvQmV6aWVycyh4MSwgeTEsIHJ4LCByeSwgcm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB0YXJnZXRYLCB0YXJnZXRZKTtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0sIHNlZ21lbnRbMl0sIHNlZ21lbnRbM10sIHNlZ21lbnRbNF0sIHNlZ21lbnRbNV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZWxsaXB0aWNhbEFyY1RvQmV6aWVycyh4MSwgeTEsIHJ4LCByeSwgcm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4MiwgeTIpIHtcbiAgICB2YXIgX2EgPSBjb21wdXRlRWxsaXB0aWNhbEFyY1BhcmFtZXRlcnMoeDEsIHkxLCByeCwgcnksIHJvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeDIsIHkyKSwgY3ggPSBfYS5jeCwgY3kgPSBfYS5jeSwgc3RhcnRBbmdsZSA9IF9hLnN0YXJ0QW5nbGUsIGRlbHRhQW5nbGUgPSBfYS5kZWx0YUFuZ2xlO1xuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHZhciBudW1TZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkZWx0YUFuZ2xlKSAvIChNYXRoLlBJIC8gMikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGFydEFuZ2xlICsgKGkgKiBkZWx0YUFuZ2xlKSAvIG51bVNlZ21lbnRzO1xuICAgICAgICB2YXIgZW5kID0gc3RhcnRBbmdsZSArICgoaSArIDEpICogZGVsdGFBbmdsZSkgLyBudW1TZWdtZW50cztcbiAgICAgICAgdmFyIGJlemllciA9IGVsbGlwdGljYWxBcmNUb0JlemllcihjeCwgY3ksIHJ4LCByeSwgcm90YXRpb24sIHN0YXJ0LCBlbmQpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJlemllcik7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFbGxpcHRpY2FsQXJjUGFyYW1ldGVycyh4MSwgeTEsIHJ4LCByeSwgcm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4MiwgeTIpIHtcbiAgICB2YXIgcGhpID0gKHJvdGF0aW9uICogTWF0aC5QSSkgLyAxODA7XG4gICAgdmFyIGR4ID0gKHgxIC0geDIpIC8gMjtcbiAgICB2YXIgZHkgPSAoeTEgLSB5MikgLyAyO1xuICAgIHZhciB4MXAgPSBNYXRoLmNvcyhwaGkpICogZHggKyBNYXRoLnNpbihwaGkpICogZHk7XG4gICAgdmFyIHkxcCA9IC1NYXRoLnNpbihwaGkpICogZHggKyBNYXRoLmNvcyhwaGkpICogZHk7XG4gICAgdmFyIGxhbWJkYSA9IChNYXRoLnBvdyh4MXAsIDIpKSAvIChNYXRoLnBvdyhyeCwgMikpICsgKE1hdGgucG93KHkxcCwgMikpIC8gKE1hdGgucG93KHJ5LCAyKSk7XG4gICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgIH1cbiAgICB2YXIgc2lnbiA9IGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxO1xuICAgIHZhciBudW1lcmF0b3IgPSAoTWF0aC5wb3cocngsIDIpKSAqIChNYXRoLnBvdyhyeSwgMikpIC0gKE1hdGgucG93KHJ4LCAyKSkgKiAoTWF0aC5wb3coeTFwLCAyKSkgLSAoTWF0aC5wb3cocnksIDIpKSAqIChNYXRoLnBvdyh4MXAsIDIpKTtcbiAgICB2YXIgZGVub21pbmF0b3IgPSAoTWF0aC5wb3cocngsIDIpKSAqIChNYXRoLnBvdyh5MXAsIDIpKSArIChNYXRoLnBvdyhyeSwgMikpICogKE1hdGgucG93KHgxcCwgMikpO1xuICAgIHZhciBjeHAgPSBzaWduICogTWF0aC5zcXJ0KE1hdGguYWJzKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKSkgKiAocnggKiB5MXAgLyByeSk7XG4gICAgdmFyIGN5cCA9IHNpZ24gKiBNYXRoLnNxcnQoTWF0aC5hYnMobnVtZXJhdG9yIC8gZGVub21pbmF0b3IpKSAqICgtcnkgKiB4MXAgLyByeCk7XG4gICAgdmFyIGN4ID0gTWF0aC5jb3MocGhpKSAqIGN4cCAtIE1hdGguc2luKHBoaSkgKiBjeXAgKyAoeDEgKyB4MikgLyAyO1xuICAgIHZhciBjeSA9IE1hdGguc2luKHBoaSkgKiBjeHAgKyBNYXRoLmNvcyhwaGkpICogY3lwICsgKHkxICsgeTIpIC8gMjtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIoKHkxcCAtIGN5cCkgLyByeSwgKHgxcCAtIGN4cCkgLyByeCk7XG4gICAgdmFyIGRlbHRhQW5nbGUgPSBNYXRoLmF0YW4yKCgteTFwIC0gY3lwKSAvIHJ5LCAoLXgxcCAtIGN4cCkgLyByeCkgLSBzdGFydEFuZ2xlO1xuICAgIGlmIChkZWx0YUFuZ2xlIDwgMCAmJiBzd2VlcEZsYWcgPT09IDEpIHtcbiAgICAgICAgZGVsdGFBbmdsZSArPSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVsdGFBbmdsZSA+IDAgJiYgc3dlZXBGbGFnID09PSAwKSB7XG4gICAgICAgIGRlbHRhQW5nbGUgLT0gMiAqIE1hdGguUEk7XG4gICAgfVxuICAgIHJldHVybiB7IGN4OiBjeCwgY3k6IGN5LCBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLCBkZWx0YUFuZ2xlOiBkZWx0YUFuZ2xlIH07XG59XG4vKipcbiAqIEVsbGlwc2UgYXJjIHNlZ21lbnQgdG8gQmV6aWVyIGN1cnZlXG4gKiBAcGFyYW0gY3hcbiAqIEBwYXJhbSBjeVxuICogQHBhcmFtIHJ4XG4gKiBAcGFyYW0gcnlcbiAqIEBwYXJhbSByb3RhdGlvblxuICogQHBhcmFtIHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSBlbmRBbmdsZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZWxsaXB0aWNhbEFyY1RvQmV6aWVyKGN4LCBjeSwgcngsIHJ5LCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAvLyDorqHnrpfmjqfliLbngrlcbiAgICB2YXIgYWxwaGEgPSBNYXRoLnNpbihlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICogKE1hdGguc3FydCg0ICsgMyAqIE1hdGgucG93KE1hdGgudGFuKChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gMiksIDIpKSAtIDEpIC8gMztcbiAgICB2YXIgY29zUGhpID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgIHZhciBzaW5QaGkgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgdmFyIHgxID0gY3ggKyByeCAqIE1hdGguY29zKHN0YXJ0QW5nbGUpICogY29zUGhpIC0gcnkgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHNpblBoaTtcbiAgICB2YXIgeTEgPSBjeSArIHJ4ICogTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiBzaW5QaGkgKyByeSAqIE1hdGguc2luKHN0YXJ0QW5nbGUpICogY29zUGhpO1xuICAgIHZhciB4MiA9IGN4ICsgcnggKiBNYXRoLmNvcyhlbmRBbmdsZSkgKiBjb3NQaGkgLSByeSAqIE1hdGguc2luKGVuZEFuZ2xlKSAqIHNpblBoaTtcbiAgICB2YXIgeTIgPSBjeSArIHJ4ICogTWF0aC5jb3MoZW5kQW5nbGUpICogc2luUGhpICsgcnkgKiBNYXRoLnNpbihlbmRBbmdsZSkgKiBjb3NQaGk7XG4gICAgdmFyIGNwMXggPSB4MSArIGFscGhhICogKC1yeCAqIE1hdGguc2luKHN0YXJ0QW5nbGUpICogY29zUGhpIC0gcnkgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHNpblBoaSk7XG4gICAgdmFyIGNwMXkgPSB5MSArIGFscGhhICogKC1yeCAqIE1hdGguc2luKHN0YXJ0QW5nbGUpICogc2luUGhpICsgcnkgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIGNvc1BoaSk7XG4gICAgdmFyIGNwMnggPSB4MiAtIGFscGhhICogKC1yeCAqIE1hdGguc2luKGVuZEFuZ2xlKSAqIGNvc1BoaSAtIHJ5ICogTWF0aC5jb3MoZW5kQW5nbGUpICogc2luUGhpKTtcbiAgICB2YXIgY3AyeSA9IHkyIC0gYWxwaGEgKiAoLXJ4ICogTWF0aC5zaW4oZW5kQW5nbGUpICogc2luUGhpICsgcnkgKiBNYXRoLmNvcyhlbmRBbmdsZSkgKiBjb3NQaGkpO1xuICAgIHJldHVybiBbY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeDIsIHkyXTtcbn1cbmZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgYXR0cnMsIHN0eWxlcykge1xuICAgIHZhciBwYXRocyA9IFtdO1xuICAgIHBhdGhzID0gcGF0aHMuY29uY2F0KGF0dHJzKTtcbiAgICB2YXIgX2EgPSBzdHlsZXMubGluZVdpZHRoLCBsaW5lV2lkdGggPSBfYSA9PT0gdm9pZCAwID8gMSA6IF9hLCBfYiA9IHN0eWxlcy5jb2xvciwgY29sb3IgPSBfYiA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfYjtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgcGF0aCA9IF9hLnBhdGg7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHBhdGgubWF0Y2goL1tNTEhWQ1NRVEFaXVteTUxIVkNTUVRBWl0qL2dpKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoY29tbWFuZHMpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WF8xID0geDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZXzEgPSB5O1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50WCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRZID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNvbW1hbmRbMF07XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjb21tYW5kLnNsaWNlKDEpLnRyaW0oKS5zcGxpdCgvW1xccyxdKy8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gYXJnc1swXSArIG9mZnNldFhfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZID0gYXJnc1sxXSArIG9mZnNldFlfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WCA9IGN1cnJlbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gY3VycmVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WCA9IGN1cnJlbnRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gY3VycmVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbMF0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbMV0gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gYXJnc1swXSArIG9mZnNldFhfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY3VycmVudFgsIGN1cnJlbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbMF0gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1cnJlbnRYLCBjdXJyZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSArPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjdXJyZW50WCwgY3VycmVudFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1swXSArIG9mZnNldFhfMSwgYXJnc1sxXSArIG9mZnNldFlfMSwgYXJnc1syXSArIG9mZnNldFhfMSwgYXJnc1szXSArIG9mZnNldFlfMSwgYXJnc1s0XSArIG9mZnNldFhfMSwgYXJnc1s1XSArIG9mZnNldFlfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbNF0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbNV0gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjdXJyZW50WCArIGFyZ3NbMF0sIGN1cnJlbnRZICsgYXJnc1sxXSwgY3VycmVudFggKyBhcmdzWzJdLCBjdXJyZW50WSArIGFyZ3NbM10sIGN1cnJlbnRYICsgYXJnc1s0XSwgY3VycmVudFkgKyBhcmdzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGFyZ3NbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSArPSBhcmdzWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3VycmVudFgsIGN1cnJlbnRZLCBhcmdzWzBdICsgb2Zmc2V0WF8xLCBhcmdzWzFdICsgb2Zmc2V0WV8xLCBhcmdzWzJdICsgb2Zmc2V0WF8xLCBhcmdzWzNdICsgb2Zmc2V0WV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gYXJnc1syXSArIG9mZnNldFhfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZID0gYXJnc1szXSArIG9mZnNldFlfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRYLCBjdXJyZW50WSwgY3VycmVudFggKyBhcmdzWzBdLCBjdXJyZW50WSArIGFyZ3NbMV0sIGN1cnJlbnRYICsgYXJnc1syXSwgY3VycmVudFkgKyBhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSArPSBhcmdzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oYXJnc1swXSArIG9mZnNldFhfMSwgYXJnc1sxXSArIG9mZnNldFlfMSwgYXJnc1syXSArIG9mZnNldFhfMSwgYXJnc1szXSArIG9mZnNldFlfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGFyZ3NbMl0gKyBvZmZzZXRYXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IGFyZ3NbM10gKyBvZmZzZXRZXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50WCArIGFyZ3NbMF0sIGN1cnJlbnRZICsgYXJnc1sxXSwgY3VycmVudFggKyBhcmdzWzJdLCBjdXJyZW50WSArIGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gYXJnc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZICs9IGFyZ3NbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50WCwgY3VycmVudFksIGFyZ3NbMF0gKyBvZmZzZXRYXzEsIGFyZ3NbMV0gKyBvZmZzZXRZXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggPSBhcmdzWzBdICsgb2Zmc2V0WF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgPSBhcmdzWzFdICsgb2Zmc2V0WV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudFgsIGN1cnJlbnRZLCBjdXJyZW50WCArIGFyZ3NbMF0sIGN1cnJlbnRZICsgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCArPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RWxsaXB0aWNhbEFyYyhjdHgsIGN1cnJlbnRYLCBjdXJyZW50WSwgYXJncywgb2Zmc2V0WF8xLCBvZmZzZXRZXzEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYID0gYXJnc1s1XSArIG9mZnNldFhfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZID0gYXJnc1s2XSArIG9mZnNldFlfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RWxsaXB0aWNhbEFyYyhjdHgsIGN1cnJlbnRYLCBjdXJyZW50WSwgYXJncywgb2Zmc2V0WF8xLCBvZmZzZXRZXzEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gYXJnc1s1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRZICs9IGFyZ3NbNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFggPSBzdGFydFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WSA9IHN0YXJ0WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0eWxlcy5zdHlsZSA9PT0gUGF0aFR5cGUuRmlsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciBwYXRoID0ge1xuICAgIG5hbWU6ICdwYXRoJyxcbiAgICBjaGVja0V2ZW50T246IGNoZWNrQ29vcmRpbmF0ZU9uUmVjdCxcbiAgICBkcmF3OiBmdW5jdGlvbiAoY3R4LCBhdHRycywgc3R5bGVzKSB7XG4gICAgICAgIGRyYXdQYXRoKGN0eCwgYXR0cnMsIHN0eWxlcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgZmlndXJlcyA9IHt9O1xudmFyIGV4dGVuc2lvbnMgPSBbY2lyY2xlLCBsaW5lLCBwb2x5Z29uLCByZWN0LCB0ZXh0LCBhcmMsIHBhdGhdO1xuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChmaWd1cmUpIHtcbiAgICBmaWd1cmVzW2ZpZ3VyZS5uYW1lXSA9IEZpZ3VyZUltcC5leHRlbmQoZmlndXJlKTtcbn0pO1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkRmlndXJlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlndXJlcyk7XG59XG5mdW5jdGlvbiByZWdpc3RlckZpZ3VyZShmaWd1cmUpIHtcbiAgICBmaWd1cmVzW2ZpZ3VyZS5uYW1lXSA9IEZpZ3VyZUltcC5leHRlbmQoZmlndXJlKTtcbn1cbmZ1bmN0aW9uIGdldElubmVyRmlndXJlQ2xhc3MobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gZmlndXJlc1tuYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEZpZ3VyZUNsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IGZpZ3VyZXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG59XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlldyh3aWRnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3dpZGdldCA9IHdpZGdldDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3LnByb3RvdHlwZS5nZXRXaWRnZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl93aWRnZXQ7IH07XG4gICAgVmlldy5wcm90b3R5cGUuY3JlYXRlRmlndXJlID0gZnVuY3Rpb24gKGNyZWF0ZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHZhciBGaWd1cmVDbGF6eiA9IGdldElubmVyRmlndXJlQ2xhc3MoY3JlYXRlLm5hbWUpO1xuICAgICAgICBpZiAoRmlndXJlQ2xhenogIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmaWd1cmUgPSBuZXcgRmlndXJlQ2xhenooY3JlYXRlKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGV2ZW50SGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWd1cmUucmVnaXN0ZXJFdmVudChrZXksIGV2ZW50SGFuZGxlcltrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGZpZ3VyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlndXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGV4dGVuZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZXh0ZW5kW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kcmF3SW1wKGN0eCwgZXh0ZW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3O1xufShFdmVudGZ1bCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBHcmlkVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JpZFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JpZFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgR3JpZFZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnQuZ2V0U3R5bGVzKCkuZ3JpZDtcbiAgICAgICAgdmFyIHNob3cgPSBzdHlsZXMuc2hvdztcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICAgICAgdmFyIGhvcml6b250YWxTdHlsZXMgPSBzdHlsZXMuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsU2hvdyA9IGhvcml6b250YWxTdHlsZXMuc2hvdztcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsU2hvdykge1xuICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHlBeGlzLmdldFRpY2tzKCkubWFwKGZ1bmN0aW9uICh0aWNrKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiAwLCB5OiB0aWNrLmNvb3JkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiB0aWNrLmNvb3JkIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGhvcml6b250YWxTdHlsZXNcbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbFN0eWxlcyA9IHN0eWxlcy52ZXJ0aWNhbDtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbFNob3cgPSB2ZXJ0aWNhbFN0eWxlcy5zaG93O1xuICAgICAgICAgICAgaWYgKHZlcnRpY2FsU2hvdykge1xuICAgICAgICAgICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB4QXhpcy5nZXRUaWNrcygpLm1hcChmdW5jdGlvbiAodGljaykgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogdGljay5jb29yZCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiB0aWNrLmNvb3JkLCB5OiBib3VuZGluZy5oZWlnaHQgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogdmVydGljYWxTdHlsZXNcbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHcmlkVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDaGlsZHJlblZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoaWxkcmVuVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGlsZHJlblZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2hpbGRyZW5WaWV3LnByb3RvdHlwZS5lYWNoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGRDYWxsYmFjaykge1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciB2aXNpYmxlUmFuZ2VEYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0VmlzaWJsZVJhbmdlRGF0YUxpc3QoKTtcbiAgICAgICAgdmFyIGJhclNwYWNlID0gY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHZpc2libGVSYW5nZURhdGFMaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGRDYWxsYmFjayh2aXNpYmxlUmFuZ2VEYXRhTGlzdFtpbmRleF0sIGJhclNwYWNlLCBpbmRleCk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2hpbGRyZW5WaWV3O1xufShWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENhbmRsZUJhclZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhbmRsZUJhclZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlQmFyVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmd1bWVudHMpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ib3VuZENhbmRsZUJhckNsaWNrRXZlbnQgPSBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmV4ZWN1dGVBY3Rpb24oQWN0aW9uVHlwZS5PbkNhbmRsZUJhckNsaWNrLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYW5kbGVCYXJWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgaXNNYWluID0gcGFuZS5nZXRJZCgpID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBjYW5kbGVCYXJPcHRpb25zID0gdGhpcy5nZXRDYW5kbGVCYXJPcHRpb25zKCk7XG4gICAgICAgIGlmIChjYW5kbGVCYXJPcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdHlwZV8xID0gY2FuZGxlQmFyT3B0aW9ucy50eXBlLCBzdHlsZXNfMSA9IGNhbmRsZUJhck9wdGlvbnMuc3R5bGVzO1xuICAgICAgICAgICAgdmFyIG9obGNTaXplXzEgPSAwO1xuICAgICAgICAgICAgdmFyIGhhbGZPaGxjU2l6ZV8xID0gMDtcbiAgICAgICAgICAgIGlmIChjYW5kbGVCYXJPcHRpb25zLnR5cGUgPT09IENhbmRsZVR5cGUuT2hsYykge1xuICAgICAgICAgICAgICAgIHZhciBnYXBCYXIgPSBjaGFydFN0b3JlLmdldEJhclNwYWNlKCkuZ2FwQmFyO1xuICAgICAgICAgICAgICAgIG9obGNTaXplXzEgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLnJvdW5kKGdhcEJhciAqIDAuMiksIDEpLCA4KTtcbiAgICAgICAgICAgICAgICBpZiAob2hsY1NpemVfMSA+IDIgJiYgb2hsY1NpemVfMSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2hsY1NpemVfMS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYWxmT2hsY1NpemVfMSA9IE1hdGguZmxvb3IoaGFsZk9obGNTaXplXzEgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5QXhpc18xID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZHJlbihmdW5jdGlvbiAodmlzaWJsZURhdGEsIGJhclNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdmlzaWJsZURhdGEueCwgX2IgPSB2aXNpYmxlRGF0YS5kYXRhLCBjdXJyZW50ID0gX2IuY3VycmVudCwgcHJldiA9IF9iLnByZXY7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5fMSA9IGN1cnJlbnQub3BlbiwgaGlnaCA9IGN1cnJlbnQuaGlnaCwgbG93ID0gY3VycmVudC5sb3csIGNsb3NlXzEgPSBjdXJyZW50LmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVByaWNlID0gc3R5bGVzXzEuY29tcGFyZVJ1bGUgPT09IENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUuQ3VycmVudE9wZW4gPyBvcGVuXzEgOiAoKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LmNsb3NlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbG9zZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VfMSA+IGNvbXBhcmVQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzBdID0gc3R5bGVzXzEudXBDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yc1sxXSA9IHN0eWxlc18xLnVwQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMl0gPSBzdHlsZXNfMS51cFdpY2tDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZV8xIDwgY29tcGFyZVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMF0gPSBzdHlsZXNfMS5kb3duQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMV0gPSBzdHlsZXNfMS5kb3duQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMl0gPSBzdHlsZXNfMS5kb3duV2lja0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzWzBdID0gc3R5bGVzXzEubm9DaGFuZ2VDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yc1sxXSA9IHN0eWxlc18xLm5vQ2hhbmdlQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMl0gPSBzdHlsZXNfMS5ub0NoYW5nZVdpY2tDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblkgPSB5QXhpc18xLmNvbnZlcnRUb1BpeGVsKG9wZW5fMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVkgPSB5QXhpc18xLmNvbnZlcnRUb1BpeGVsKGNsb3NlXzEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpY2VZID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblksIGNsb3NlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzXzEuY29udmVydFRvUGl4ZWwoaGlnaCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhpc18xLmNvbnZlcnRUb1BpeGVsKGxvdylcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcHJpY2VZLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcnJlY3Rpb24gPSBiYXJTcGFjZS5nYXBCYXIgJSAyID09PSAwID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYW5kbGVUeXBlLkNhbmRsZVNvbGlkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMgPSBfdGhpcy5fY3JlYXRlU29saWRCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2FuZGxlVHlwZS5DYW5kbGVTdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0cyA9IF90aGlzLl9jcmVhdGVTdHJva2VCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2FuZGxlVHlwZS5DYW5kbGVVcFN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZV8xID4gb3Blbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gX3RoaXMuX2NyZWF0ZVN0cm9rZUJhcih4LCBwcmljZVksIGJhclNwYWNlLCBjb2xvcnMsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMgPSBfdGhpcy5fY3JlYXRlU29saWRCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhbmRsZVR5cGUuQ2FuZGxlRG93blN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuXzEgPiBjbG9zZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gX3RoaXMuX2NyZWF0ZVN0cm9rZUJhcih4LCBwcmljZVksIGJhclNwYWNlLCBjb2xvcnMsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdHMgPSBfdGhpcy5fY3JlYXRlU29saWRCYXIoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhbmRsZVR5cGUuT2hsYzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCAtIGhhbGZPaGxjU2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVlbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvaGxjU2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByaWNlWVszXSAtIHByaWNlWVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4IC0gYmFyU3BhY2UuaGFsZkdhcEJhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogb3BlblkgKyBvaGxjU2l6ZV8xID4gcHJpY2VZWzNdID8gcHJpY2VZWzNdIC0gb2hsY1NpemVfMSA6IG9wZW5ZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYmFyU3BhY2UuaGFsZkdhcEJhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBvaGxjU2l6ZV8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKyBoYWxmT2hsY1NpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2xvc2VZICsgb2hsY1NpemVfMSA+IHByaWNlWVszXSA/IHByaWNlWVszXSAtIG9obGNTaXplXzEgOiBjbG9zZVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYXJTcGFjZS5oYWxmR2FwQmFyIC0gaGFsZk9obGNTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogb2hsY1NpemVfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGNvbG9yc1swXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3RzLmZvckVhY2goZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZUNsaWNrRXZlbnQ6IF90aGlzLl9ib3VuZENhbmRsZUJhckNsaWNrRXZlbnQodmlzaWJsZURhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZShyZWN0LCBoYW5kbGVyICE9PSBudWxsICYmIGhhbmRsZXIgIT09IHZvaWQgMCA/IGhhbmRsZXIgOiB1bmRlZmluZWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FuZGxlQmFyVmlldy5wcm90b3R5cGUuZ2V0Q2FuZGxlQmFyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbmRsZVN0eWxlcyA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkuY2FuZGxlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogY2FuZGxlU3R5bGVzLnR5cGUsXG4gICAgICAgICAgICBzdHlsZXM6IGNhbmRsZVN0eWxlcy5iYXJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENhbmRsZUJhclZpZXcucHJvdG90eXBlLl9jcmVhdGVTb2xpZEJhciA9IGZ1bmN0aW9uICh4LCBwcmljZVksIGJhclNwYWNlLCBjb2xvcnMsIGNvcnJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogcHJpY2VZWzBdLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmljZVlbM10gLSBwcmljZVlbMF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogY29sb3JzWzJdIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHggLSBiYXJTcGFjZS5oYWxmR2FwQmFyLFxuICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVlbMV0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYXJTcGFjZS5nYXBCYXIgKyBjb3JyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIHByaWNlWVsyXSAtIHByaWNlWVsxXSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuU3Ryb2tlRmlsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1swXSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIENhbmRsZUJhclZpZXcucHJvdG90eXBlLl9jcmVhdGVTdHJva2VCYXIgPSBmdW5jdGlvbiAoeCwgcHJpY2VZLCBiYXJTcGFjZSwgY29sb3JzLCBjb3JyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVlbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJpY2VZWzFdIC0gcHJpY2VZWzBdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVlbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJpY2VZWzNdIC0gcHJpY2VZWzJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogY29sb3JzWzJdIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHggLSBiYXJTcGFjZS5oYWxmR2FwQmFyLFxuICAgICAgICAgICAgICAgICAgICB5OiBwcmljZVlbMV0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYXJTcGFjZS5nYXBCYXIgKyBjb3JyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIHByaWNlWVsyXSAtIHByaWNlWVsxXSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogUG9seWdvblR5cGUuU3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3JzWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZUJhclZpZXc7XG59KENoaWxkcmVuVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBJbmRpY2F0b3JWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmRpY2F0b3JWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZGljYXRvclZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5kaWNhdG9yVmlldy5wcm90b3R5cGUuZ2V0Q2FuZGxlQmFyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICBpZiAoIXlBeGlzLmlzSW5DYW5kbGUoKSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRpY2F0b3JzXzEgPSBfX3ZhbHVlcyhpbmRpY2F0b3JzKSwgaW5kaWNhdG9yc18xXzEgPSBpbmRpY2F0b3JzXzEubmV4dCgpOyAhaW5kaWNhdG9yc18xXzEuZG9uZTsgaW5kaWNhdG9yc18xXzEgPSBpbmRpY2F0b3JzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3IgPSBpbmRpY2F0b3JzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci5zaG91bGRPaGxjICYmIGluZGljYXRvci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNhdG9yU3R5bGVzID0gaW5kaWNhdG9yLnN0eWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5pbmRpY2F0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVJ1bGUgPSBmb3JtYXRWYWx1ZShpbmRpY2F0b3JTdHlsZXMsICdvaGxjLmNvbXBhcmVSdWxlJywgZGVmYXVsdFN0eWxlcy5vaGxjLmNvbXBhcmVSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cENvbG9yID0gZm9ybWF0VmFsdWUoaW5kaWNhdG9yU3R5bGVzLCAnb2hsYy51cENvbG9yJywgZGVmYXVsdFN0eWxlcy5vaGxjLnVwQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvd25Db2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvclN0eWxlcywgJ29obGMuZG93bkNvbG9yJywgZGVmYXVsdFN0eWxlcy5vaGxjLmRvd25Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9DaGFuZ2VDb2xvciA9IGZvcm1hdFZhbHVlKGluZGljYXRvclN0eWxlcywgJ29obGMubm9DaGFuZ2VDb2xvcicsIGRlZmF1bHRTdHlsZXMub2hsYy5ub0NoYW5nZUNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FuZGxlVHlwZS5PaGxjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlUnVsZTogY29tcGFyZVJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwQ29sb3I6IHVwQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25Db2xvcjogZG93bkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub0NoYW5nZUNvbG9yOiBub0NoYW5nZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cEJvcmRlckNvbG9yOiB1cENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3duQm9yZGVyQ29sb3I6IGRvd25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9DaGFuZ2VCb3JkZXJDb2xvcjogbm9DaGFuZ2VDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBXaWNrQ29sb3I6IHVwQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25XaWNrQ29sb3I6IGRvd25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9DaGFuZ2VXaWNrQ29sb3I6IG5vQ2hhbmdlQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3JzXzFfMSAmJiAhaW5kaWNhdG9yc18xXzEuZG9uZSAmJiAoX2EgPSBpbmRpY2F0b3JzXzEucmV0dXJuKSkgX2EuY2FsbChpbmRpY2F0b3JzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRyYXdJbXAuY2FsbCh0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgeEF4aXMgPSBjaGFydC5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IGNoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICB2YXIgZGVmYXVsdFN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuaW5kaWNhdG9yO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgaWYgKGluZGljYXRvci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGljYXRvci56TGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlzQ292ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yLmRyYXcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaXNDb3ZlciA9IGluZGljYXRvci5kcmF3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQ6IGNoYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yOiBpbmRpY2F0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZzogYm91bmRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB4QXhpczogeEF4aXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhpczogeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNDb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBpbmRpY2F0b3IucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lYWNoQ2hpbGRyZW4oZnVuY3Rpb24gKGRhdGEsIGJhclNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWxmR2FwQmFyID0gYmFyU3BhY2UuaGFsZkdhcEJhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBkYXRhLmRhdGFJbmRleCwgeCA9IGRhdGEueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2WCA9IHhBeGlzLmNvbnZlcnRUb1BpeGVsKGRhdGFJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRYID0geEF4aXMuY29udmVydFRvUGl4ZWwoZGF0YUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkRhdGEgPSAoX2EgPSByZXN1bHRfMVtkYXRhSW5kZXggLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RGF0YSA9IChfYiA9IHJlc3VsdF8xW2RhdGFJbmRleF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dERhdGEgPSAoX2MgPSByZXN1bHRfMVtkYXRhSW5kZXggKyAxXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2Q29vcmRpbmF0ZSA9IHsgeDogcHJldlggfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q29vcmRpbmF0ZSA9IHsgeDogeCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDb29yZGluYXRlID0geyB4OiBuZXh0WCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yLmZpZ3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2Eua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHByZXZEYXRhID09PSBudWxsIHx8IHByZXZEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2RGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihwcmV2VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDb29yZGluYXRlW2tleV0gPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBjdXJyZW50RGF0YSA9PT0gbnVsbCB8fCBjdXJyZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29vcmRpbmF0ZVtrZXldID0geUF4aXMuY29udmVydFRvUGl4ZWwoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dERhdGEgPT09IG51bGwgfHwgbmV4dERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvb3JkaW5hdGVba2V5XSA9IHlBeGlzLmNvbnZlcnRUb1BpeGVsKG5leHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoRmlndXJlcyhpbmRpY2F0b3IsIGRhdGFJbmRleCwgZGVmYXVsdFN0eWxlcywgZnVuY3Rpb24gKGZpZ3VyZSwgZmlndXJlU3R5bGVzLCBmaWd1cmVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGN1cnJlbnREYXRhID09PSBudWxsIHx8IGN1cnJlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RGF0YVtmaWd1cmUua2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlWSA9IGN1cnJlbnRDb29yZGluYXRlW2ZpZ3VyZS5rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSAoX2EgPSBmaWd1cmUuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGZpZ3VyZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBwcmV2OiBwcmV2RGF0YSwgY3VycmVudDogY3VycmVudERhdGEsIG5leHQ6IG5leHREYXRhIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlOiB7IHByZXY6IHByZXZDb29yZGluYXRlLCBjdXJyZW50OiBjdXJyZW50Q29vcmRpbmF0ZSwgbmV4dDogbmV4dENvb3JkaW5hdGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nOiBib3VuZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhclNwYWNlOiBiYXJTcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhBeGlzOiB4QXhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzOiB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGF0dHJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NpcmNsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSB7IHg6IHgsIHk6IHZhbHVlWSwgcjogTWF0aC5tYXgoMSwgaGFsZkdhcEJhcikgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSA9IChfYiA9IGZpZ3VyZS5iYXNlVmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHlBeGlzLmdldFJhbmdlKCkuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZVkgPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoYmFzZVZhbHVlWSAtIHZhbHVlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWUgIT09IChjdXJyZW50RGF0YSA9PT0gbnVsbCB8fCBjdXJyZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERhdGFbZmlndXJlLmtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWSA+IGJhc2VWYWx1ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBiYXNlVmFsdWVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB2YWx1ZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB4IC0gaGFsZkdhcEJhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoMSwgaGFsZkdhcEJhciAqIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChsaW5lc18xW2ZpZ3VyZUluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzXzFbZmlndXJlSW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGN1cnJlbnRDb29yZGluYXRlW2ZpZ3VyZS5rZXldKSAmJiBpc051bWJlcihuZXh0Q29vcmRpbmF0ZVtmaWd1cmUua2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzXzFbZmlndXJlSW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogY3VycmVudENvb3JkaW5hdGUueCwgeTogY3VycmVudENvb3JkaW5hdGVbZmlndXJlLmtleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiBuZXh0Q29vcmRpbmF0ZS54LCB5OiBuZXh0Q29vcmRpbmF0ZVtmaWd1cmUua2V5XSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGZpZ3VyZVN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlndXJlLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGF0dHJzKSAmJiB0eXBlICE9PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYyA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdHlwZSA9PT0gJ2JhcicgPyAncmVjdCcgOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGZpZ3VyZVN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGxpbmUgYW5kIHJlbmRlclxuICAgICAgICAgICAgICAgICAgICBsaW5lc18xLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZUxpbmVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW2l0ZW1zWzBdLmNvb3JkaW5hdGVzWzBdLCBpdGVtc1swXS5jb29yZGluYXRlc1sxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGl0ZW1zWzBdLnN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0TWVyZ2VMaW5lID0gbWVyZ2VMaW5lc1ttZXJnZUxpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE1lcmdlTGluZUxhc3RDb29yZGluYXRlID0gbGFzdE1lcmdlTGluZS5jb29yZGluYXRlc1tsYXN0TWVyZ2VMaW5lLmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE1lcmdlTGluZUxhc3RDb29yZGluYXRlLnggPT09IGN1cnJlbnQuY29vcmRpbmF0ZXNbMF0ueCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lcmdlTGluZUxhc3RDb29yZGluYXRlLnkgPT09IGN1cnJlbnQuY29vcmRpbmF0ZXNbMF0ueSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lcmdlTGluZS5zdHlsZXMuc3R5bGUgPT09IGN1cnJlbnQuc3R5bGVzLnN0eWxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVyZ2VMaW5lLnN0eWxlcy5jb2xvciA9PT0gY3VycmVudC5zdHlsZXMuY29sb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXJnZUxpbmUuc3R5bGVzLnNpemUgPT09IGN1cnJlbnQuc3R5bGVzLnNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXJnZUxpbmUuc3R5bGVzLnNtb290aCA9PT0gY3VycmVudC5zdHlsZXMuc21vb3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gbGFzdE1lcmdlTGluZS5zdHlsZXMuZGFzaGVkVmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09ICgoX2IgPSBjdXJyZW50LnN0eWxlcy5kYXNoZWRWYWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IGxhc3RNZXJnZUxpbmUuc3R5bGVzLmRhc2hlZFZhbHVlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMV0pID09PSAoKF9kID0gY3VycmVudC5zdHlsZXMuZGFzaGVkVmFsdWUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXJnZUxpbmUuY29vcmRpbmF0ZXMucHVzaChjdXJyZW50LmNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlTGluZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtjdXJyZW50LmNvb3JkaW5hdGVzWzBdLCBjdXJyZW50LmNvb3JkaW5hdGVzWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGN1cnJlbnQuc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUxpbmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gX2EuY29vcmRpbmF0ZXMsIHN0eWxlcyA9IF9hLnN0eWxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5kaWNhdG9yVmlldztcbn0oQ2FuZGxlQmFyVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDcm9zc2hhaXJMaW5lVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3Jvc3NoYWlyTGluZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3Jvc3NoYWlyTGluZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ3Jvc3NoYWlyTGluZVZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHdpZGdldC5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBjcm9zc2hhaXIgPSBjaGFydFN0b3JlLmdldENyb3NzaGFpcigpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5jcm9zc2hhaXI7XG4gICAgICAgIGlmIChpc1N0cmluZyhjcm9zc2hhaXIucGFuZUlkKSAmJiBzdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgaWYgKGNyb3NzaGFpci5wYW5lSWQgPT09IHBhbmUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0gY3Jvc3NoYWlyLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogMCwgeTogeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiB5IH1cbiAgICAgICAgICAgICAgICBdLCBzdHlsZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IGNyb3NzaGFpci5yZWFsWDtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgW1xuICAgICAgICAgICAgICAgIHsgeDogeCwgeTogMCB9LFxuICAgICAgICAgICAgICAgIHsgeDogeCwgeTogYm91bmRpbmcuaGVpZ2h0IH1cbiAgICAgICAgICAgIF0sIHN0eWxlcy52ZXJ0aWNhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENyb3NzaGFpckxpbmVWaWV3LnByb3RvdHlwZS5fZHJhd0xpbmUgPSBmdW5jdGlvbiAoY3R4LCBjb29yZGluYXRlcywgc3R5bGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlcyA9IHN0eWxlcy5saW5lO1xuICAgICAgICAgICAgaWYgKGxpbmVTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBsaW5lU3R5bGVzXG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDcm9zc2hhaXJMaW5lVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBJbmRpY2F0b3JUb29sdGlwVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5kaWNhdG9yVG9vbHRpcFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5kaWNhdG9yVG9vbHRpcFZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJndW1lbnRzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fYm91bmRGZWF0dXJlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZUluZm8pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBwYW5lID0gX3RoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvciA9IGN1cnJlbnRGZWF0dXJlSW5mby5pbmRpY2F0b3IsIG90aGVycyA9IF9fcmVzdChjdXJyZW50RmVhdHVyZUluZm8sIFtcImluZGljYXRvclwiXSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChpbmRpY2F0b3IpKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gaW5kaWNhdG9yLm9uQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGluZGljYXRvciwgX19hc3NpZ24oeyB0YXJnZXQ6IEluZGljYXRvckV2ZW50VGFyZ2V0LkZlYXR1cmUsIGNoYXJ0OiBwYW5lLmdldENoYXJ0KCksIGluZGljYXRvcjogaW5kaWNhdG9yIH0sIG90aGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5leGVjdXRlQWN0aW9uKEFjdGlvblR5cGUuT25DYW5kbGVUb29sdGlwRmVhdHVyZUNsaWNrLCBjdXJyZW50RmVhdHVyZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgICAgIF90aGlzLl9ib3VuZEZlYXR1cmVNb3VzZU1vdmVFdmVudCA9IGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZUluZm8pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5zZXRBY3RpdmVUb29sdGlwRmVhdHVyZUluZm8oY3VycmVudEZlYXR1cmVJbmZvKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBjcm9zc2hhaXIgPSBjaGFydFN0b3JlLmdldENyb3NzaGFpcigpO1xuICAgICAgICBpZiAoaXNWYWxpZChjcm9zc2hhaXIua0xpbmVEYXRhKSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmluZGljYXRvci50b29sdGlwLCBvZmZzZXRMZWZ0ID0gX2Eub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Eub2Zmc2V0VG9wLCBvZmZzZXRSaWdodCA9IF9hLm9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kcmF3SW5kaWNhdG9yVG9vbHRpcChjdHgsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgYm91bmRpbmcud2lkdGggLSBvZmZzZXRSaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5kcmF3SW5kaWNhdG9yVG9vbHRpcCA9IGZ1bmN0aW9uIChjdHgsIGxlZnQsIHRvcCwgbWF4V2lkdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5pbmRpY2F0b3I7XG4gICAgICAgIHZhciB0b29sdGlwU3R5bGVzID0gc3R5bGVzLnRvb2x0aXA7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhd1Rvb2x0aXAoY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKSwgdG9vbHRpcFN0eWxlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3JzID0gY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQocGFuZS5nZXRJZCgpKTtcbiAgICAgICAgICAgIHZhciB0b29sdGlwVGV4dFN0eWxlc18xID0gdG9vbHRpcFN0eWxlcy50ZXh0O1xuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlJvd0hlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IGxlZnQsIHk6IHRvcCB9O1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmdldEluZGljYXRvclRvb2x0aXBEYXRhKGluZGljYXRvciksIG5hbWUgPSBfYS5uYW1lLCBjYWxjUGFyYW1zVGV4dCA9IF9hLmNhbGNQYXJhbXNUZXh0LCBsZWdlbmRzID0gX2EubGVnZW5kcywgZmVhdHVyZXMgPSBfYS5mZWF0dXJlcztcbiAgICAgICAgICAgICAgICB2YXIgbmFtZVZhbGlkID0gbmFtZS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRWYWxpZCA9IGxlZ2VuZHMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVZhbGlkIHx8IGxlZ2VuZFZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfdGhpcy5jbGFzc2lmeVRvb2x0aXBGZWF0dXJlcyhmZWF0dXJlcyksIDMpLCBsZWZ0RmVhdHVyZXMgPSBfYlswXSwgbWlkZGxlRmVhdHVyZXMgPSBfYlsxXSwgcmlnaHRGZWF0dXJlcyA9IF9iWzJdO1xuICAgICAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gX3RoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzKGN0eCwgbGVmdEZlYXR1cmVzLCBjb29yZGluYXRlLCBpbmRpY2F0b3IsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGNQYXJhbXNUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gXCJcIi5jb25jYXQodGV4dCkuY29uY2F0KGNhbGNQYXJhbXNUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBfdGhpcy5kcmF3U3RhbmRhcmRUb29sdGlwTGVnZW5kcyhjdHgsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7IHRleHQ6ICcnLCBjb2xvcjogdG9vbHRpcFRleHRTdHlsZXNfMS5jb2xvciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyB0ZXh0OiB0ZXh0LCBjb2xvcjogdG9vbHRpcFRleHRTdHlsZXNfMS5jb2xvciB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgY29vcmRpbmF0ZSwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgsIHRvb2x0aXBUZXh0U3R5bGVzXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBfdGhpcy5kcmF3U3RhbmRhcmRUb29sdGlwRmVhdHVyZXMoY3R4LCBtaWRkbGVGZWF0dXJlcywgY29vcmRpbmF0ZSwgaW5kaWNhdG9yLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWdlbmRWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IF90aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBMZWdlbmRzKGN0eCwgbGVnZW5kcywgY29vcmRpbmF0ZSwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgsIHRvb2x0aXBTdHlsZXMudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyByaWdodCBpY29uc1xuICAgICAgICAgICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gX3RoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzKGN0eCwgcmlnaHRGZWF0dXJlcywgY29vcmRpbmF0ZSwgaW5kaWNhdG9yLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGNvb3JkaW5hdGUueSArIHByZXZSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9O1xuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5kcmF3U3RhbmRhcmRUb29sdGlwRmVhdHVyZXMgPSBmdW5jdGlvbiAoY3R4LCBmZWF0dXJlcywgY29vcmRpbmF0ZSwgaW5kaWNhdG9yLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoXzEgPSAwO1xuICAgICAgICAgICAgdmFyIGhlaWdodF8xID0gMDtcbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBmZWF0dXJlLm1hcmdpbkxlZnQsIG1hcmdpbkxlZnQgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLCBfYiA9IGZlYXR1cmUubWFyZ2luVG9wLCBtYXJnaW5Ub3AgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IGZlYXR1cmUubWFyZ2luUmlnaHQsIG1hcmdpblJpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBmZWF0dXJlLm1hcmdpbkJvdHRvbSwgbWFyZ2luQm90dG9tID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBmZWF0dXJlLnBhZGRpbmdMZWZ0LCBwYWRkaW5nTGVmdCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gZmVhdHVyZS5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2YgPT09IHZvaWQgMCA/IDAgOiBfZiwgX2cgPSBmZWF0dXJlLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZywgX2ggPSBmZWF0dXJlLnBhZGRpbmdCb3R0b20sIHBhZGRpbmdCb3R0b20gPSBfaCA9PT0gdm9pZCAwID8gMCA6IF9oLCBfaiA9IGZlYXR1cmUuc2l6ZSwgc2l6ZSA9IF9qID09PSB2b2lkIDAgPyAwIDogX2osIHR5cGUgPSBmZWF0dXJlLnR5cGUsIGljb25Gb250ID0gZmVhdHVyZS5pY29uRm9udDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gVG9vbHRpcEZlYXR1cmVUeXBlLkljb25Gb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY3JlYXRlRm9udChzaXplLCAnbm9ybWFsJywgaWNvbkZvbnQuZmFtaWx5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGljb25Gb250LmNvbnRlbnQpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFdpZHRoID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2lkdGhfMSArPSAobWFyZ2luTGVmdCArIHBhZGRpbmdMZWZ0ICsgY29udGVudFdpZHRoICsgcGFkZGluZ1JpZ2h0ICsgbWFyZ2luUmlnaHQpO1xuICAgICAgICAgICAgICAgIGhlaWdodF8xID0gTWF0aC5tYXgoaGVpZ2h0XzEsIG1hcmdpblRvcCArIHBhZGRpbmdUb3AgKyBzaXplICsgcGFkZGluZ0JvdHRvbSArIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlLnggKyB3aWR0aF8xID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnggPSBsZWZ0O1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSArPSBwcmV2Um93SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBoZWlnaHRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBNYXRoLm1heChwcmV2Um93SGVpZ2h0LCBoZWlnaHRfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICAgICAgdmFyIHBhbmVJZF8xID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUZlYXR1cmVJbmZvXzEgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmdldEFjdGl2ZVRvb2x0aXBGZWF0dXJlSW5mbygpO1xuICAgICAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICB2YXIgX2UgPSBmZWF0dXJlLm1hcmdpbkxlZnQsIG1hcmdpbkxlZnQgPSBfZSA9PT0gdm9pZCAwID8gMCA6IF9lLCBfZiA9IGZlYXR1cmUubWFyZ2luVG9wLCBtYXJnaW5Ub3AgPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mLCBfZyA9IGZlYXR1cmUubWFyZ2luUmlnaHQsIG1hcmdpblJpZ2h0ID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZywgX2ggPSBmZWF0dXJlLnBhZGRpbmdMZWZ0LCBwYWRkaW5nTGVmdCA9IF9oID09PSB2b2lkIDAgPyAwIDogX2gsIF9qID0gZmVhdHVyZS5wYWRkaW5nVG9wLCBwYWRkaW5nVG9wID0gX2ogPT09IHZvaWQgMCA/IDAgOiBfaiwgX2sgPSBmZWF0dXJlLnBhZGRpbmdSaWdodCwgcGFkZGluZ1JpZ2h0ID0gX2sgPT09IHZvaWQgMCA/IDAgOiBfaywgX2wgPSBmZWF0dXJlLnBhZGRpbmdCb3R0b20sIHBhZGRpbmdCb3R0b20gPSBfbCA9PT0gdm9pZCAwID8gMCA6IF9sLCBiYWNrZ3JvdW5kQ29sb3IgPSBmZWF0dXJlLmJhY2tncm91bmRDb2xvciwgYWN0aXZlQmFja2dyb3VuZENvbG9yID0gZmVhdHVyZS5hY3RpdmVCYWNrZ3JvdW5kQ29sb3IsIGJvcmRlclJhZGl1cyA9IGZlYXR1cmUuYm9yZGVyUmFkaXVzLCBfbSA9IGZlYXR1cmUuc2l6ZSwgc2l6ZSA9IF9tID09PSB2b2lkIDAgPyAwIDogX20sIGNvbG9yID0gZmVhdHVyZS5jb2xvciwgYWN0aXZlQ29sb3IgPSBmZWF0dXJlLmFjdGl2ZUNvbG9yLCB0eXBlID0gZmVhdHVyZS50eXBlLCBpY29uRm9udCA9IGZlYXR1cmUuaWNvbkZvbnQsIHBhdGggPSBmZWF0dXJlLnBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IChhY3RpdmVGZWF0dXJlSW5mb18xID09PSBudWxsIHx8IGFjdGl2ZUZlYXR1cmVJbmZvXzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUZlYXR1cmVJbmZvXzEucGFuZUlkKSA9PT0gcGFuZUlkXzEgJiYgKChfYSA9IGFjdGl2ZUZlYXR1cmVJbmZvXzEuaW5kaWNhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpID09PSAoaW5kaWNhdG9yID09PSBudWxsIHx8IGluZGljYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5kaWNhdG9yLmlkKSAmJiBhY3RpdmVGZWF0dXJlSW5mb18xLmZlYXR1cmUuaWQgPT09IGZlYXR1cmUuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VDbGlja0V2ZW50OiBfdGhpcy5fYm91bmRGZWF0dXJlQ2xpY2tFdmVudCh7IHBhbmVJZDogcGFuZUlkXzEsIGluZGljYXRvcjogaW5kaWNhdG9yLCBmZWF0dXJlOiBmZWF0dXJlIH0pLFxuICAgICAgICAgICAgICAgICAgICBtb3VzZU1vdmVFdmVudDogX3RoaXMuX2JvdW5kRmVhdHVyZU1vdXNlTW92ZUV2ZW50KHsgcGFuZUlkOiBwYW5lSWRfMSwgaW5kaWNhdG9yOiBpbmRpY2F0b3IsIGZlYXR1cmU6IGZlYXR1cmUgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBmaW5hbENvbG9yID0gYWN0aXZlID8gKGFjdGl2ZUNvbG9yICE9PSBudWxsICYmIGFjdGl2ZUNvbG9yICE9PSB2b2lkIDAgPyBhY3RpdmVDb2xvciA6IGNvbG9yKSA6IGNvbG9yO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBmaW5hbEJhY2tncm91bmRDb2xvciA9IGFjdGl2ZSA/IChhY3RpdmVCYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwgJiYgYWN0aXZlQmFja2dyb3VuZENvbG9yICE9PSB2b2lkIDAgPyBhY3RpdmVCYWNrZ3JvdW5kQ29sb3IgOiBiYWNrZ3JvdW5kQ29sb3IpIDogYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBUb29sdGlwRmVhdHVyZVR5cGUuSWNvbkZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHRleHQ6IGljb25Gb250LmNvbnRlbnQsIHg6IGNvb3JkaW5hdGUueCArIG1hcmdpbkxlZnQsIHk6IGNvb3JkaW5hdGUueSArIG1hcmdpblRvcCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IHBhZGRpbmdMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IHBhZGRpbmdUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogcGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseTogaWNvbkZvbnQuZmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBmaW5hbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZmluYWxCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZXZlbnRIYW5kbGVyKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGljb25Gb250LmNvbnRlbnQpLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHg6IGNvb3JkaW5hdGUueCArIG1hcmdpbkxlZnQsIHk6IGNvb3JkaW5hdGUueSArIG1hcmdpblRvcCwgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IHBhZGRpbmdMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IHBhZGRpbmdUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogcGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZmluYWxCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZXZlbnRIYW5kbGVyKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKF9kID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHBhdGg6IHBhdGgucGF0aCwgeDogY29vcmRpbmF0ZS54ICsgbWFyZ2luTGVmdCArIHBhZGRpbmdMZWZ0LCB5OiBjb29yZGluYXRlLnkgKyBtYXJnaW5Ub3AgKyBwYWRkaW5nVG9wLCB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogcGF0aC5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHBhdGgubGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBmaW5hbENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50V2lkdGggPSBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnggKz0gKG1hcmdpbkxlZnQgKyBwYWRkaW5nTGVmdCArIGNvbnRlbnRXaWR0aCArIHBhZGRpbmdSaWdodCArIG1hcmdpblJpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2Um93SGVpZ2h0O1xuICAgIH07XG4gICAgSW5kaWNhdG9yVG9vbHRpcFZpZXcucHJvdG90eXBlLmRyYXdTdGFuZGFyZFRvb2x0aXBMZWdlbmRzID0gZnVuY3Rpb24gKGN0eCwgbGVnZW5kcywgY29vcmRpbmF0ZSwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgsIHN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGVnZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbWFyZ2luTGVmdF8xID0gc3R5bGVzLm1hcmdpbkxlZnQsIG1hcmdpblRvcF8xID0gc3R5bGVzLm1hcmdpblRvcCwgbWFyZ2luUmlnaHRfMSA9IHN0eWxlcy5tYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tXzEgPSBzdHlsZXMubWFyZ2luQm90dG9tLCBzaXplXzEgPSBzdHlsZXMuc2l6ZSwgZmFtaWx5XzEgPSBzdHlsZXMuZmFtaWx5LCB3ZWlnaHRfMSA9IHN0eWxlcy53ZWlnaHQ7XG4gICAgICAgICAgICBjdHguZm9udCA9IGNyZWF0ZUZvbnQoc2l6ZV8xLCB3ZWlnaHRfMSwgZmFtaWx5XzEpO1xuICAgICAgICAgICAgbGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlVGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRpdGxlLnRleHQpLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh2YWx1ZS50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxUZXh0V2lkdGggPSB0aXRsZVRleHRXaWR0aCArIHZhbHVlVGV4dFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoID0gbWFyZ2luVG9wXzEgKyBzaXplXzEgKyBtYXJnaW5Cb3R0b21fMTtcbiAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZS54ICsgbWFyZ2luTGVmdF8xICsgdG90YWxUZXh0V2lkdGggKyBtYXJnaW5SaWdodF8xID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS55ICs9IHByZXZSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IE1hdGgubWF4KHByZXZSb3dIZWlnaHQsIGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGl0bGUudGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB4OiBjb29yZGluYXRlLnggKyBtYXJnaW5MZWZ0XzEsIHk6IGNvb3JkaW5hdGUueSArIG1hcmdpblRvcF8xLCB0ZXh0OiB0aXRsZS50ZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IHRpdGxlLmNvbG9yLCBzaXplOiBzaXplXzEsIGZhbWlseTogZmFtaWx5XzEsIHdlaWdodDogd2VpZ2h0XzEgfVxuICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB4OiBjb29yZGluYXRlLnggKyBtYXJnaW5MZWZ0XzEgKyB0aXRsZVRleHRXaWR0aCwgeTogY29vcmRpbmF0ZS55ICsgbWFyZ2luVG9wXzEsIHRleHQ6IHZhbHVlLnRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7IGNvbG9yOiB2YWx1ZS5jb2xvciwgc2l6ZTogc2l6ZV8xLCBmYW1pbHk6IGZhbWlseV8xLCB3ZWlnaHQ6IHdlaWdodF8xIH1cbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnggKz0gKG1hcmdpbkxlZnRfMSArIHRvdGFsVGV4dFdpZHRoICsgbWFyZ2luUmlnaHRfMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldlJvd0hlaWdodDtcbiAgICB9O1xuICAgIEluZGljYXRvclRvb2x0aXBWaWV3LnByb3RvdHlwZS5pc0RyYXdUb29sdGlwID0gZnVuY3Rpb24gKGNyb3NzaGFpciwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBzaG93UnVsZSA9IHN0eWxlcy5zaG93UnVsZTtcbiAgICAgICAgcmV0dXJuIHNob3dSdWxlID09PSBUb29sdGlwU2hvd1J1bGUuQWx3YXlzIHx8XG4gICAgICAgICAgICAoc2hvd1J1bGUgPT09IFRvb2x0aXBTaG93UnVsZS5Gb2xsb3dDcm9zcyAmJiBpc1N0cmluZyhjcm9zc2hhaXIucGFuZUlkKSk7XG4gICAgfTtcbiAgICBJbmRpY2F0b3JUb29sdGlwVmlldy5wcm90b3R5cGUuZ2V0SW5kaWNhdG9yVG9vbHRpcERhdGEgPSBmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmluZGljYXRvcjtcbiAgICAgICAgdmFyIHRvb2x0aXBTdHlsZXMgPSBzdHlsZXMudG9vbHRpcDtcbiAgICAgICAgdmFyIG5hbWUgPSB0b29sdGlwU3R5bGVzLnNob3dOYW1lID8gaW5kaWNhdG9yLnNob3J0TmFtZSA6ICcnO1xuICAgICAgICB2YXIgY2FsY1BhcmFtc1RleHQgPSAnJztcbiAgICAgICAgaWYgKHRvb2x0aXBTdHlsZXMuc2hvd1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNhbGNQYXJhbXMgPSBpbmRpY2F0b3IuY2FsY1BhcmFtcztcbiAgICAgICAgICAgIGlmIChjYWxjUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWxjUGFyYW1zVGV4dCA9IFwiKFwiLmNvbmNhdChjYWxjUGFyYW1zLmpvaW4oJywnKSwgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b29sdGlwRGF0YSA9IHsgbmFtZTogbmFtZSwgY2FsY1BhcmFtc1RleHQ6IGNhbGNQYXJhbXNUZXh0LCBsZWdlbmRzOiBbXSwgZmVhdHVyZXM6IHRvb2x0aXBTdHlsZXMuZmVhdHVyZXMgfTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCkuZGF0YUluZGV4O1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5kaWNhdG9yLnJlc3VsdDtcbiAgICAgICAgdmFyIGN1c3RvbUFwaSA9IGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCk7XG4gICAgICAgIHZhciBkZWNpbWFsRm9sZCA9IGNoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1NlcGFyYXRvciA9IGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7XG4gICAgICAgIHZhciBsZWdlbmRzID0gW107XG4gICAgICAgIGlmIChpbmRpY2F0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgdmFyIGRhdGFfMSA9IChfYiA9IChfYSA9IHJlc3VsdFtkYXRhSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXN1bHRbZGF0YUluZGV4IC0gMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICAgICAgZWFjaEZpZ3VyZXMoaW5kaWNhdG9yLCBkYXRhSW5kZXgsIHN0eWxlcywgZnVuY3Rpb24gKGZpZ3VyZSwgZmlndXJlU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGZpZ3VyZS50aXRsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gZmlndXJlU3R5bGVzLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50ICAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YV8xW2ZpZ3VyZS5rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZvcm1hdFByZWNpc2lvbih2YWx1ZSwgaW5kaWNhdG9yLnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yLnNob3VsZEZvcm1hdEJpZ051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3VzdG9tQXBpLmZvcm1hdEJpZ051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kcy5wdXNoKHsgdGl0bGU6IHsgdGV4dDogZmlndXJlLnRpdGxlLCBjb2xvcjogY29sb3IgfSwgdmFsdWU6IHsgdGV4dDogKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHRvb2x0aXBTdHlsZXMuZGVmYXVsdFZhbHVlKSwgY29sb3I6IGNvbG9yIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b29sdGlwRGF0YS5sZWdlbmRzID0gbGVnZW5kcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihpbmRpY2F0b3IuY3JlYXRlVG9vbHRpcERhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgICAgIHZhciBfYyA9IGluZGljYXRvci5jcmVhdGVUb29sdGlwRGF0YVNvdXJjZSh7XG4gICAgICAgICAgICAgICAgY2hhcnQ6IGNoYXJ0LFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogaW5kaWNhdG9yLFxuICAgICAgICAgICAgICAgIGNyb3NzaGFpcjogY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKSxcbiAgICAgICAgICAgICAgICBib3VuZGluZzogd2lkZ2V0LmdldEJvdW5kaW5nKCksXG4gICAgICAgICAgICAgICAgeEF4aXM6IHBhbmUuZ2V0Q2hhcnQoKS5nZXRYQXhpc1BhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCksXG4gICAgICAgICAgICAgICAgeUF4aXM6IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpXG4gICAgICAgICAgICB9KSwgY3VzdG9tTmFtZSA9IF9jLm5hbWUsIGN1c3RvbUNhbGNQYXJhbXNUZXh0ID0gX2MuY2FsY1BhcmFtc1RleHQsIGN1c3RvbUxlZ2VuZHMgPSBfYy5sZWdlbmRzLCBjdXN0b21GZWF0dXJlcyA9IF9jLmZlYXR1cmVzO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGN1c3RvbU5hbWUpICYmIHRvb2x0aXBTdHlsZXMuc2hvd05hbWUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwRGF0YS5uYW1lID0gY3VzdG9tTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhjdXN0b21DYWxjUGFyYW1zVGV4dCkgJiYgdG9vbHRpcFN0eWxlcy5zaG93UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcERhdGEuY2FsY1BhcmFtc1RleHQgPSBjdXN0b21DYWxjUGFyYW1zVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGN1c3RvbUZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLmZlYXR1cmVzID0gY3VzdG9tRmVhdHVyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChjdXN0b21MZWdlbmRzKSAmJiBpbmRpY2F0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRMZWdlbmRzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JfMSA9IHN0eWxlcy50b29sdGlwLnRleHQuY29sb3I7XG4gICAgICAgICAgICAgICAgY3VzdG9tTGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHsgdGV4dDogJycsIGNvbG9yOiBjb2xvcl8xIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkYXRhLnRpdGxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUudGV4dCA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geyB0ZXh0OiAnJywgY29sb3I6IGNvbG9yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0ID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoTnVtYmVyKHZhbHVlLnRleHQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGV4dCA9IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KHZhbHVlLnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpbWl6ZWRMZWdlbmRzXzEucHVzaCh7IHRpdGxlOiB0aXRsZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBEYXRhLmxlZ2VuZHMgPSBvcHRpbWl6ZWRMZWdlbmRzXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2x0aXBEYXRhO1xuICAgIH07XG4gICAgSW5kaWNhdG9yVG9vbHRpcFZpZXcucHJvdG90eXBlLmNsYXNzaWZ5VG9vbHRpcEZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBsZWZ0RmVhdHVyZXMgPSBbXTtcbiAgICAgICAgdmFyIG1pZGRsZUZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciByaWdodEZlYXR1cmVzID0gW107XG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmVhdHVyZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgVG9vbHRpcEZlYXR1cmVQb3NpdGlvbi5MZWZ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBUb29sdGlwRmVhdHVyZVBvc2l0aW9uLk1pZGRsZToge1xuICAgICAgICAgICAgICAgICAgICBtaWRkbGVGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBUb29sdGlwRmVhdHVyZVBvc2l0aW9uLlJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtsZWZ0RmVhdHVyZXMsIG1pZGRsZUZlYXR1cmVzLCByaWdodEZlYXR1cmVzXTtcbiAgICB9O1xuICAgIHJldHVybiBJbmRpY2F0b3JUb29sdGlwVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBPdmVybGF5VmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3ZlcmxheVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVZpZXcod2lkZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHdpZGdldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2luaXRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5faW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYW5lLmdldENoYXJ0KCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoJ21vdXNlTW92ZUV2ZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NPdmVybGF5SW5mbyA9IGNoYXJ0U3RvcmUuZ2V0UHJvZ3Jlc3NPdmVybGF5SW5mbygpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzT3ZlcmxheUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheSA9IHByb2dyZXNzT3ZlcmxheUluZm8ub3ZlcmxheTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NPdmVybGF5UGFuZUlkID0gcHJvZ3Jlc3NPdmVybGF5SW5mby5wYW5lSWQ7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUudXBkYXRlUHJvZ3Jlc3NPdmVybGF5SW5mbyhwYW5lSWQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPSBwYW5lSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG92ZXJsYXkucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNEcmF3aW5nKCkgJiYgcHJvZ3Jlc3NPdmVybGF5UGFuZUlkID09PSBwYW5lSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5ldmVudE1vdmVGb3JEcmF3aW5nKF90aGlzLl9jb29yZGluYXRlVG9Qb2ludChvdmVybGF5LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uRHJhd2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXkgfSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9maWd1cmVNb3VzZU1vdmVFdmVudChvdmVybGF5LCAxIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLlBvaW50ICovLCBpbmRleCwgeyBrZXk6IFwiXCIuY29uY2F0KE9WRVJMQVlfRklHVVJFX0tFWV9QUkVGSVgsIFwicG9pbnRfXCIpLmNvbmNhdChpbmRleCksIHR5cGU6ICdjaXJjbGUnLCBhdHRyczoge30gfSkoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRIb3Zlck92ZXJsYXlJbmZvKHtcbiAgICAgICAgICAgICAgICBwYW5lSWQ6IHBhbmVJZCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgICAgIGZpZ3VyZVR5cGU6IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLyxcbiAgICAgICAgICAgICAgICBmaWd1cmVJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgICAgICB9LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLnJlZ2lzdGVyRXZlbnQoJ21vdXNlQ2xpY2tFdmVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXlJbmZvID0gY2hhcnRTdG9yZS5nZXRQcm9ncmVzc092ZXJsYXlJbmZvKCk7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NPdmVybGF5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGF5ID0gcHJvZ3Jlc3NPdmVybGF5SW5mby5vdmVybGF5O1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPSBwcm9ncmVzc092ZXJsYXlJbmZvLnBhbmVJZDtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheS5pc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS51cGRhdGVQcm9ncmVzc092ZXJsYXlJbmZvKHBhbmVJZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzT3ZlcmxheVBhbmVJZCA9IHBhbmVJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb3ZlcmxheS5wb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheS5pc0RyYXdpbmcoKSAmJiBwcm9ncmVzc092ZXJsYXlQYW5lSWQgPT09IHBhbmVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmV2ZW50TW92ZUZvckRyYXdpbmcoX3RoaXMuX2Nvb3JkaW5hdGVUb1BvaW50KG92ZXJsYXksIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IG92ZXJsYXkub25EcmF3aW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiBjaGFydCwgb3ZlcmxheTogb3ZlcmxheSB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5Lm5leHRTdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3ZlcmxheS5pc0RyYXdpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS5wcm9ncmVzc092ZXJsYXlDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gb3ZlcmxheS5vbkRyYXdFbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG92ZXJsYXksIF9fYXNzaWduKHsgY2hhcnQ6IGNoYXJ0LCBvdmVybGF5OiBvdmVybGF5IH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9maWd1cmVNb3VzZUNsaWNrRXZlbnQob3ZlcmxheSwgMSAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Qb2ludCAqLywgaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYLCBcInBvaW50X1wiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHt9XG4gICAgICAgICAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRDbGlja092ZXJsYXlJbmZvKHtcbiAgICAgICAgICAgICAgICBwYW5lSWQ6IHBhbmVJZCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgICAgIGZpZ3VyZVR5cGU6IDAgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuTm9uZSAqLyxcbiAgICAgICAgICAgICAgICBmaWd1cmVJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgZmlndXJlOiBudWxsXG4gICAgICAgICAgICB9LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLnJlZ2lzdGVyRXZlbnQoJ21vdXNlRG91YmxlQ2xpY2tFdmVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheUluZm8gPSBjaGFydFN0b3JlLmdldFByb2dyZXNzT3ZlcmxheUluZm8oKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc092ZXJsYXlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBwcm9ncmVzc092ZXJsYXlJbmZvLm92ZXJsYXk7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheVBhbmVJZCA9IHByb2dyZXNzT3ZlcmxheUluZm8ucGFuZUlkO1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5LmlzRHJhd2luZygpICYmIHByb2dyZXNzT3ZlcmxheVBhbmVJZCA9PT0gcGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZm9yY2VDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJsYXkuaXNEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUucHJvZ3Jlc3NPdmVybGF5Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG92ZXJsYXkub25EcmF3RW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiBjaGFydCwgb3ZlcmxheTogb3ZlcmxheSB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG92ZXJsYXkucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9maWd1cmVNb3VzZUNsaWNrRXZlbnQob3ZlcmxheSwgMSAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Qb2ludCAqLywgaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYLCBcInBvaW50X1wiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHt9XG4gICAgICAgICAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5yZWdpc3RlckV2ZW50KCdtb3VzZVJpZ2h0Q2xpY2tFdmVudCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzT3ZlcmxheUluZm8gPSBjaGFydFN0b3JlLmdldFByb2dyZXNzT3ZlcmxheUluZm8oKTtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc092ZXJsYXlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBwcm9ncmVzc092ZXJsYXlJbmZvLm92ZXJsYXk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaXNEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb3ZlcmxheS5wb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9maWd1cmVNb3VzZVJpZ2h0Q2xpY2tFdmVudChvdmVybGF5LCAxIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLlBvaW50ICovLCBpbmRleCwge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChPVkVSTEFZX0ZJR1VSRV9LRVlfUFJFRklYLCBcInBvaW50X1wiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge31cbiAgICAgICAgICAgICAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkucmVnaXN0ZXJFdmVudCgnbW91c2VVcEV2ZW50JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBjaGFydFN0b3JlLmdldFByZXNzZWRPdmVybGF5SW5mbygpLCBvdmVybGF5ID0gX2Iub3ZlcmxheSwgZmlndXJlID0gX2IuZmlndXJlO1xuICAgICAgICAgICAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uUHJlc3NlZE1vdmVFbmQnLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IG92ZXJsYXkub25QcmVzc2VkTW92ZUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZTogZmlndXJlICE9PSBudWxsICYmIGZpZ3VyZSAhPT0gdm9pZCAwID8gZmlndXJlIDogdW5kZWZpbmVkIH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRQcmVzc2VkT3ZlcmxheUluZm8oe1xuICAgICAgICAgICAgICAgIHBhbmVJZDogcGFuZUlkLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICAgICAgZmlndXJlVHlwZTogMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovLFxuICAgICAgICAgICAgICAgIGZpZ3VyZUluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICBmaWd1cmU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5yZWdpc3RlckV2ZW50KCdwcmVzc2VkTW91c2VNb3ZlRXZlbnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgX2MgPSBjaGFydFN0b3JlLmdldFByZXNzZWRPdmVybGF5SW5mbygpLCBvdmVybGF5ID0gX2Mub3ZlcmxheSwgZmlndXJlVHlwZSA9IF9jLmZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4ID0gX2MuZmlndXJlSW5kZXgsIGZpZ3VyZSA9IF9jLmZpZ3VyZTtcbiAgICAgICAgICAgIGlmIChvdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrT3ZlcmxheUZpZ3VyZUV2ZW50KCdvblByZXNzZWRNb3ZpbmcnLCBmaWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3ZlcmxheS5sb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSBvdmVybGF5Lm9uUHJlc3NlZE1vdmluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZTogZmlndXJlICE9PSBudWxsICYmIGZpZ3VyZSAhPT0gdm9pZCAwID8gZmlndXJlIDogdW5kZWZpbmVkIH0sIGV2ZW50KSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IF90aGlzLl9jb29yZGluYXRlVG9Qb2ludChvdmVybGF5LCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZ3VyZVR5cGUgPT09IDEgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuUG9pbnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5ldmVudFByZXNzZWRQb2ludE1vdmUocG9pbnQsIGZpZ3VyZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkuZXZlbnRQcmVzc2VkT3RoZXJNb3ZlKHBvaW50LCBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLl9jcmVhdGVGaWd1cmVFdmVudHMgPSBmdW5jdGlvbiAob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSkge1xuICAgICAgICBpZiAob3ZlcmxheS5pc0RyYXdpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdXNlTW92ZUV2ZW50OiB0aGlzLl9maWd1cmVNb3VzZU1vdmVFdmVudChvdmVybGF5LCBmaWd1cmVUeXBlLCBmaWd1cmVJbmRleCwgZmlndXJlKSxcbiAgICAgICAgICAgIG1vdXNlRG93bkV2ZW50OiB0aGlzLl9maWd1cmVNb3VzZURvd25FdmVudChvdmVybGF5LCBmaWd1cmVUeXBlLCBmaWd1cmVJbmRleCwgZmlndXJlKSxcbiAgICAgICAgICAgIG1vdXNlQ2xpY2tFdmVudDogdGhpcy5fZmlndXJlTW91c2VDbGlja0V2ZW50KG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpLFxuICAgICAgICAgICAgbW91c2VSaWdodENsaWNrRXZlbnQ6IHRoaXMuX2ZpZ3VyZU1vdXNlUmlnaHRDbGlja0V2ZW50KG92ZXJsYXksIGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4LCBmaWd1cmUpLFxuICAgICAgICAgICAgbW91c2VEb3VibGVDbGlja0V2ZW50OiB0aGlzLl9maWd1cmVNb3VzZURvdWJsZUNsaWNrRXZlbnQob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZmlndXJlTW91c2VNb3ZlRXZlbnQgPSBmdW5jdGlvbiAob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgICAgIHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuc2V0SG92ZXJPdmVybGF5SW5mbyh7IHBhbmVJZDogcGFuZS5nZXRJZCgpLCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmVUeXBlOiBmaWd1cmVUeXBlLCBmaWd1cmU6IGZpZ3VyZSwgZmlndXJlSW5kZXg6IGZpZ3VyZUluZGV4IH0sIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25Nb3VzZUVudGVyJywgZmlndXJlKSAmJiAhb3ZlcmxheS5pc0RyYXdpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZmlndXJlTW91c2VEb3duRXZlbnQgPSBmdW5jdGlvbiAob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgICAgIHZhciBwYW5lSWQgPSBwYW5lLmdldElkKCk7XG4gICAgICAgICAgICBvdmVybGF5LnN0YXJ0UHJlc3NlZE1vdmUoX3RoaXMuX2Nvb3JkaW5hdGVUb1BvaW50KG92ZXJsYXksIGV2ZW50KSk7XG4gICAgICAgICAgICBpZiAoY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uUHJlc3NlZE1vdmVTdGFydCcsIGZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uUHJlc3NlZE1vdmVTdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3ZlcmxheSwgX19hc3NpZ24oeyBjaGFydDogcGFuZS5nZXRDaGFydCgpLCBvdmVybGF5OiBvdmVybGF5LCBmaWd1cmU6IGZpZ3VyZSB9LCBldmVudCkpO1xuICAgICAgICAgICAgICAgIHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuc2V0UHJlc3NlZE92ZXJsYXlJbmZvKHsgcGFuZUlkOiBwYW5lSWQsIG92ZXJsYXk6IG92ZXJsYXksIGZpZ3VyZVR5cGU6IGZpZ3VyZVR5cGUsIGZpZ3VyZUluZGV4OiBmaWd1cmVJbmRleCwgZmlndXJlOiBmaWd1cmUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdmVybGF5LmlzRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLl9maWd1cmVNb3VzZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAob3ZlcmxheSwgZmlndXJlVHlwZSwgZmlndXJlSW5kZXgsIGZpZ3VyZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgICAgIHZhciBwYW5lSWQgPSBwYW5lLmdldElkKCk7XG4gICAgICAgICAgICBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLnNldENsaWNrT3ZlcmxheUluZm8oeyBwYW5lSWQ6IHBhbmVJZCwgb3ZlcmxheTogb3ZlcmxheSwgZmlndXJlVHlwZTogZmlndXJlVHlwZSwgZmlndXJlSW5kZXg6IGZpZ3VyZUluZGV4LCBmaWd1cmU6IGZpZ3VyZSB9LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tPdmVybGF5RmlndXJlRXZlbnQoJ29uQ2xpY2snLCBmaWd1cmUpICYmICFvdmVybGF5LmlzRHJhd2luZygpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLl9maWd1cmVNb3VzZURvdWJsZUNsaWNrRXZlbnQgPSBmdW5jdGlvbiAob3ZlcmxheSwgX2ZpZ3VyZVR5cGUsIF9maWd1cmVJbmRleCwgZmlndXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25Eb3VibGVDbGljaycsIGZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBvdmVybGF5Lm9uRG91YmxlQ2xpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG92ZXJsYXksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudCksIHsgY2hhcnQ6IF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLCBmaWd1cmU6IGZpZ3VyZSwgb3ZlcmxheTogb3ZlcmxheSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdmVybGF5LmlzRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLl9maWd1cmVNb3VzZVJpZ2h0Q2xpY2tFdmVudCA9IGZ1bmN0aW9uIChvdmVybGF5LCBfZmlndXJlVHlwZSwgX2ZpZ3VyZUluZGV4LCBmaWd1cmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChjaGVja092ZXJsYXlGaWd1cmVFdmVudCgnb25SaWdodENsaWNrJywgZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmICghKChfYiA9IChfYSA9IG92ZXJsYXkub25SaWdodENsaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCBfX2Fzc2lnbih7IGNoYXJ0OiBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKSwgb3ZlcmxheTogb3ZlcmxheSwgZmlndXJlOiBmaWd1cmUgfSwgZXZlbnQpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIW92ZXJsYXkuaXNEcmF3aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuX2Nvb3JkaW5hdGVUb1BvaW50ID0gZnVuY3Rpb24gKG8sIGNvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcG9pbnQgPSB7fTtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IGNoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29vcmRpbmF0ZVRvUG9pbnRUaW1lc3RhbXBEYXRhSW5kZXhGbGFnKCkpIHtcbiAgICAgICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSB4QXhpcy5jb252ZXJ0RnJvbVBpeGVsKGNvb3JkaW5hdGUueCk7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gKF9hID0gY2hhcnRTdG9yZS5kYXRhSW5kZXhUb1RpbWVzdGFtcChkYXRhSW5kZXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwb2ludC50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICBwb2ludC5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29vcmRpbmF0ZVRvUG9pbnRWYWx1ZUZsYWcoKSkge1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB5QXhpcy5jb252ZXJ0RnJvbVBpeGVsKGNvb3JkaW5hdGUueSk7XG4gICAgICAgICAgICBpZiAoby5tb2RlICE9PSBPdmVybGF5TW9kZS5Ob3JtYWwgJiYgcGFuZUlkID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFICYmIGlzTnVtYmVyKHBvaW50LmRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga0xpbmVEYXRhID0gY2hhcnRTdG9yZS5nZXREYXRhQnlEYXRhSW5kZXgocG9pbnQuZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoa0xpbmVEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlU2Vuc2l0aXZpdHkgPSBvLm1vZGVTZW5zaXRpdml0eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4ga0xpbmVEYXRhLmhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm1vZGUgPT09IE92ZXJsYXlNb2RlLldlYWtNYWduZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaFkgPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChrTGluZURhdGEuaGlnaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZWYWx1ZSA9IHlBeGlzLmNvbnZlcnRGcm9tUGl4ZWwoaGlnaFkgLSBtb2RlU2Vuc2l0aXZpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IGJ1ZmZWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ga0xpbmVEYXRhLmhpZ2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBrTGluZURhdGEubG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tb2RlID09PSBPdmVybGF5TW9kZS5XZWFrTWFnbmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd1kgPSB5QXhpcy5jb252ZXJ0VG9QaXhlbChrTGluZURhdGEubG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZlZhbHVlID0geUF4aXMuY29udmVydEZyb21QaXhlbChsb3dZIC0gbW9kZVNlbnNpdGl2aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBidWZmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBrTGluZURhdGEubG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChrTGluZURhdGEub3Blbiwga0xpbmVEYXRhLmNsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihrTGluZURhdGEub3Blbiwga0xpbmVEYXRhLmNsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIG1heCA8IGtMaW5lRGF0YS5oaWdoIC0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtMaW5lRGF0YS5oaWdoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0ga0xpbmVEYXRhLmxvdyA8IG1pbiAtIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ga0xpbmVEYXRhLmxvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heCAtIHZhbHVlIDwgdmFsdWUgLSBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZVRvUG9pbnRWYWx1ZUZsYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVUb1BvaW50VGltZXN0YW1wRGF0YUluZGV4RmxhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBldmVudCwgb3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmlzT3ZlcmxheURyYXdpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FdmVudChuYW1lLCBldmVudCwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBuYW1lLCBldmVudCwgb3RoZXIpO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmNoZWNrRXZlbnRPbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5nZXRDb21wbGV0ZU92ZXJsYXlzKCk7XG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIGlmIChvdmVybGF5LnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZHJhd092ZXJsYXkoY3R4LCBvdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcm9ncmVzc092ZXJsYXkgPSB0aGlzLmdldFByb2dyZXNzT3ZlcmxheSgpO1xuICAgICAgICBpZiAoaXNWYWxpZChwcm9ncmVzc092ZXJsYXkpICYmIHByb2dyZXNzT3ZlcmxheS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3T3ZlcmxheShjdHgsIHByb2dyZXNzT3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5fZHJhd092ZXJsYXkgPSBmdW5jdGlvbiAoY3R4LCBvdmVybGF5KSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBvdmVybGF5LnBvaW50cztcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IGNoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhSW5kZXggPSBjaGFydFN0b3JlLnRpbWVzdGFtcFRvRGF0YUluZGV4KHBvaW50LnRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGFJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlLnggPSB4QXhpcy5jb252ZXJ0VG9QaXhlbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUueSA9IChfYSA9IHlBeGlzID09PSBudWxsIHx8IHlBeGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5QXhpcy5jb252ZXJ0VG9QaXhlbChwb2ludC52YWx1ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdmFyIGZpZ3VyZXMgPSBbXS5jb25jYXQodGhpcy5nZXRGaWd1cmVzKG92ZXJsYXksIGNvb3JkaW5hdGVzKSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdGaWd1cmVzKGN0eCwgb3ZlcmxheSwgZmlndXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3RGVmYXVsdEZpZ3VyZXMoY3R4LCBvdmVybGF5LCBjb29yZGluYXRlcyk7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZHJhd0ZpZ3VyZXMgPSBmdW5jdGlvbiAoY3R4LCBvdmVybGF5LCBmaWd1cmVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZhdWx0U3R5bGVzID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRTdHlsZXMoKS5vdmVybGF5O1xuICAgICAgICBmaWd1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZpZ3VyZSwgZmlndXJlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmlndXJlLnR5cGUsIHN0eWxlcyA9IGZpZ3VyZS5zdHlsZXMsIGF0dHJzID0gZmlndXJlLmF0dHJzO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHZhciBhdHRyc0FycmF5ID0gW10uY29uY2F0KGF0dHJzKTtcbiAgICAgICAgICAgIGF0dHJzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gX3RoaXMuX2NyZWF0ZUZpZ3VyZUV2ZW50cyhvdmVybGF5LCAyIC8qIEV2ZW50T3ZlcmxheUluZm9GaWd1cmVUeXBlLk90aGVyICovLCBmaWd1cmVJbmRleCwgZmlndXJlKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBzcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0U3R5bGVzW3R5cGVdKSwgKF9hID0gb3ZlcmxheS5zdHlsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0eXBlXSksIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHlwZSwgYXR0cnM6IGF0cywgc3R5bGVzOiBzc1xuICAgICAgICAgICAgICAgIH0sIGV2ZW50cyAhPT0gbnVsbCAmJiBldmVudHMgIT09IHZvaWQgMCA/IGV2ZW50cyA6IHVuZGVmaW5lZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZ2V0Q29tcGxldGVPdmVybGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgcmV0dXJuIHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuZ2V0T3ZlcmxheXNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLmdldFByb2dyZXNzT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGluZm8gPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmdldFByb2dyZXNzT3ZlcmxheUluZm8oKTtcbiAgICAgICAgaWYgKGlzVmFsaWQoaW5mbykgJiYgaW5mby5wYW5lSWQgPT09IHBhbmUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZm8ub3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5nZXRGaWd1cmVzID0gZnVuY3Rpb24gKG8sIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBvLmNyZWF0ZVBvaW50RmlndXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobywgeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG8sIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcywgYm91bmRpbmc6IGJvdW5kaW5nLCB4QXhpczogeEF4aXMsIHlBeGlzOiB5QXhpcyB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuZHJhd0RlZmF1bHRGaWd1cmVzID0gZnVuY3Rpb24gKGN0eCwgb3ZlcmxheSwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG92ZXJsYXkubmVlZERlZmF1bHRQb2ludEZpZ3VyZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgIHZhciBob3Zlck92ZXJsYXlJbmZvXzEgPSBjaGFydFN0b3JlLmdldEhvdmVyT3ZlcmxheUluZm8oKTtcbiAgICAgICAgICAgIHZhciBjbGlja092ZXJsYXlJbmZvID0gY2hhcnRTdG9yZS5nZXRDbGlja092ZXJsYXlJbmZvKCk7XG4gICAgICAgICAgICBpZiAoKCgoX2EgPSBob3Zlck92ZXJsYXlJbmZvXzEub3ZlcmxheSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSA9PT0gb3ZlcmxheS5pZCAmJiBob3Zlck92ZXJsYXlJbmZvXzEuZmlndXJlVHlwZSAhPT0gMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovKSB8fFxuICAgICAgICAgICAgICAgICgoKF9iID0gY2xpY2tPdmVybGF5SW5mby5vdmVybGF5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpID09PSBvdmVybGF5LmlkICYmIGNsaWNrT3ZlcmxheUluZm8uZmlndXJlVHlwZSAhPT0gMCAvKiBFdmVudE92ZXJsYXlJbmZvRmlndXJlVHlwZS5Ob25lICovKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKS5vdmVybGF5O1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSBvdmVybGF5LnN0eWxlcztcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRTdHlsZXNfMSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0U3R5bGVzLnBvaW50KSwgc3R5bGVzID09PSBudWxsIHx8IHN0eWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVzLnBvaW50KTtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IHBvaW50U3R5bGVzXzEucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBwb2ludFN0eWxlc18xLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSBwb2ludFN0eWxlc18xLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyU2l6ZSA9IHBvaW50U3R5bGVzXzEuYm9yZGVyU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2IgPSBob3Zlck92ZXJsYXlJbmZvXzEub3ZlcmxheSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSA9PT0gb3ZlcmxheS5pZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJPdmVybGF5SW5mb18xLmZpZ3VyZVR5cGUgPT09IDEgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuUG9pbnQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBob3Zlck92ZXJsYXlJbmZvXzEuZmlndXJlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mua2V5KSA9PT0gXCJcIi5jb25jYXQoT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCwgXCJwb2ludF9cIikuY29uY2F0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gcG9pbnRTdHlsZXNfMS5hY3RpdmVSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHBvaW50U3R5bGVzXzEuYWN0aXZlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IHBvaW50U3R5bGVzXzEuYWN0aXZlQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJTaXplID0gcG9pbnRTdHlsZXNfMS5hY3RpdmVCb3JkZXJTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfZSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHg6IHgsIHk6IHksIHI6IHJhZGl1cyArIGJvcmRlclNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogYm9yZGVyQ29sb3IgfVxuICAgICAgICAgICAgICAgICAgICB9LCAoX2QgPSBfdGhpcy5fY3JlYXRlRmlndXJlRXZlbnRzKG92ZXJsYXksIDEgLyogRXZlbnRPdmVybGF5SW5mb0ZpZ3VyZVR5cGUuUG9pbnQgKi8sIGluZGV4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KE9WRVJMQVlfRklHVVJFX0tFWV9QUkVGSVgsIFwicG9pbnRfXCIpLmNvbmNhdChpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHg6IHgsIHk6IHksIHI6IHJhZGl1cyArIGJvcmRlclNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogYm9yZGVyQ29sb3IgfVxuICAgICAgICAgICAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgKF9mID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgeDogeCwgeTogeSwgcjogcmFkaXVzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IGNvbG9yIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5Vmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBJbmRpY2F0b3JXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZGljYXRvcldpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmRpY2F0b3JXaWRnZXQocm9vdENvbnRhaW5lciwgcGFuZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290Q29udGFpbmVyLCBwYW5lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZ3JpZFZpZXcgPSBuZXcgR3JpZFZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5faW5kaWNhdG9yVmlldyA9IG5ldyBJbmRpY2F0b3JWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2Nyb3NzaGFpckxpbmVWaWV3ID0gbmV3IENyb3NzaGFpckxpbmVWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX3Rvb2x0aXBWaWV3ID0gX3RoaXMuY3JlYXRlVG9vbHRpcFZpZXcoKTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlWaWV3ID0gbmV3IE92ZXJsYXlWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuX3Rvb2x0aXBWaWV3KTtcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuX292ZXJsYXlWaWV3KTtcbiAgICAgICAgX3RoaXMuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5kaWNhdG9yV2lkZ2V0LnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOO1xuICAgIH07XG4gICAgSW5kaWNhdG9yV2lkZ2V0LnByb3RvdHlwZS51cGRhdGVNYWluID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5nZXRQYW5lKCkuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1haW5Db250ZW50KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5kaWNhdG9yV2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVUb29sdGlwVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRpY2F0b3JUb29sdGlwVmlldyh0aGlzKTtcbiAgICB9O1xuICAgIEluZGljYXRvcldpZGdldC5wcm90b3R5cGUudXBkYXRlTWFpbkNvbnRlbnQgPSBmdW5jdGlvbiAoX2N0eCkge1xuICAgICAgICAvLyB0byBkbyBpdFxuICAgIH07XG4gICAgSW5kaWNhdG9yV2lkZ2V0LnByb3RvdHlwZS51cGRhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5nZXRQYW5lKCkuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5Vmlldy5kcmF3KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9jcm9zc2hhaXJMaW5lVmlldy5kcmF3KGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9vbHRpcFZpZXcuZHJhdyhjdHgpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZGljYXRvcldpZGdldDtcbn0oRHJhd1dpZGdldCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDYW5kbGVBcmVhVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlQXJlYVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlQXJlYVZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJndW1lbnRzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmlwcGxlUG9pbnQgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgbmFtZTogJ2NpcmNsZScsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICByOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmaWxsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuX2FuaW1hdGlvbkZyYW1lVGltZSA9IDA7XG4gICAgICAgIF90aGlzLl9hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHsgaXRlcmF0aW9uQ291bnQ6IEluZmluaXR5IH0pLmRvRnJhbWUoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9hbmltYXRpb25GcmFtZVRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCk7XG4gICAgICAgICAgICBwYW5lLmdldENoYXJ0KCkudXBkYXRlUGFuZSgwIC8qIFVwZGF0ZUxldmVsLk1haW4gKi8sIHBhbmUuZ2V0SWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhbmRsZUFyZWFWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgZGF0YUxpc3QgPSBjaGFydC5nZXREYXRhTGlzdCgpO1xuICAgICAgICB2YXIgbGFzdERhdGFJbmRleCA9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0LmdldFN0eWxlcygpLmNhbmRsZS5hcmVhO1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgdmFyIGFyZWFTdGFydFggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgdmFyIHJpcHBsZVBvaW50Q29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWFjaENoaWxkcmVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGRhdGEueDtcbiAgICAgICAgICAgIHZhciBrTGluZURhdGEgPSBkYXRhLmRhdGEuY3VycmVudDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtMaW5lRGF0YSA9PT0gbnVsbCB8fCBrTGluZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtMaW5lRGF0YVtzdHlsZXMudmFsdWVdO1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciB5ID0geUF4aXMuY29udmVydFRvUGl4ZWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChhcmVhU3RhcnRYID09PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICBhcmVhU3RhcnRYID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMucHVzaCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmRhdGFJbmRleCA9PT0gbGFzdERhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByaXBwbGVQb2ludENvb3JkaW5hdGUgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHN0eWxlcy5saW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlcy5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBzdHlsZXMuc21vb3RoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAvLyByZW5kZXIgYXJlYVxuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSAnJztcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRfMSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBib3VuZGluZy5oZWlnaHQsIDAsIG1pblkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvci5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IF9hLm9mZnNldCwgY29sb3IgPSBfYS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50XzEuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sb3IgPSBncmFkaWVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGFyZWFTdGFydFgsIGJvdW5kaW5nLmhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNvb3JkaW5hdGVzWzBdLngsIGNvb3JkaW5hdGVzWzBdLnkpO1xuICAgICAgICAgICAgbGluZVRvKGN0eCwgY29vcmRpbmF0ZXMsIHN0eWxlcy5zbW9vdGgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXS54LCBib3VuZGluZy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnRTdHlsZXMgPSBzdHlsZXMucG9pbnQ7XG4gICAgICAgIGlmIChwb2ludFN0eWxlcy5zaG93ICYmIGlzVmFsaWQocmlwcGxlUG9pbnRDb29yZGluYXRlKSkge1xuICAgICAgICAgICAgKF9iID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJpcHBsZVBvaW50Q29vcmRpbmF0ZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiByaXBwbGVQb2ludENvb3JkaW5hdGUueSxcbiAgICAgICAgICAgICAgICAgICAgcjogcG9pbnRTdHlsZXMucmFkaXVzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHBvaW50U3R5bGVzLmNvbG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICB2YXIgcmlwcGxlUmFkaXVzID0gcG9pbnRTdHlsZXMucmlwcGxlUmFkaXVzO1xuICAgICAgICAgICAgaWYgKHBvaW50U3R5bGVzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJpcHBsZVJhZGl1cyA9IHBvaW50U3R5bGVzLnJhZGl1cyArIHRoaXMuX2FuaW1hdGlvbkZyYW1lVGltZSAvIHBvaW50U3R5bGVzLmFuaW1hdGlvbkR1cmF0aW9uICogKHBvaW50U3R5bGVzLnJpcHBsZVJhZGl1cyAtIHBvaW50U3R5bGVzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uLnNldER1cmF0aW9uKHBvaW50U3R5bGVzLmFuaW1hdGlvbkR1cmF0aW9uKS5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9jID0gdGhpcy5fcmlwcGxlUG9pbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXRBdHRycyh7XG4gICAgICAgICAgICAgICAgeDogcmlwcGxlUG9pbnRDb29yZGluYXRlLngsXG4gICAgICAgICAgICAgICAgeTogcmlwcGxlUG9pbnRDb29yZGluYXRlLnksXG4gICAgICAgICAgICAgICAgcjogcmlwcGxlUmFkaXVzXG4gICAgICAgICAgICB9KS5zZXRTdHlsZXMoeyBzdHlsZTogJ2ZpbGwnLCBjb2xvcjogcG9pbnRTdHlsZXMucmlwcGxlQ29sb3IgfSkuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmRsZUFyZWFWaWV3LnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hbmltYXRpb24uc3RvcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZUFyZWFWaWV3O1xufShDaGlsZHJlblZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlSGlnaExvd1ByaWNlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlSGlnaExvd1ByaWNlVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYW5kbGVIaWdoTG93UHJpY2VWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhbmRsZUhpZ2hMb3dQcmljZVZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIHByaWNlTWFya1N0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuY2FuZGxlLnByaWNlTWFyaztcbiAgICAgICAgdmFyIGhpZ2hQcmljZU1hcmtTdHlsZXMgPSBwcmljZU1hcmtTdHlsZXMuaGlnaDtcbiAgICAgICAgdmFyIGxvd1ByaWNlTWFya1N0eWxlcyA9IHByaWNlTWFya1N0eWxlcy5sb3c7XG4gICAgICAgIGlmIChwcmljZU1hcmtTdHlsZXMuc2hvdyAmJiAoaGlnaFByaWNlTWFya1N0eWxlcy5zaG93IHx8IGxvd1ByaWNlTWFya1N0eWxlcy5zaG93KSkge1xuICAgICAgICAgICAgdmFyIGhpZ2hlc3RMb3dlc3RQcmljZSA9IGNoYXJ0U3RvcmUuZ2V0VmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlKCk7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdmFyIF9hID0gaGlnaGVzdExvd2VzdFByaWNlWzBdLCBoaWdoID0gX2EucHJpY2UsIGhpZ2hYID0gX2EueDtcbiAgICAgICAgICAgIHZhciBfYiA9IGhpZ2hlc3RMb3dlc3RQcmljZVsxXSwgbG93ID0gX2IucHJpY2UsIGxvd1ggPSBfYi54O1xuICAgICAgICAgICAgdmFyIGhpZ2hZID0geUF4aXMuY29udmVydFRvUGl4ZWwoaGlnaCk7XG4gICAgICAgICAgICB2YXIgbG93WSA9IHlBeGlzLmNvbnZlcnRUb1BpeGVsKGxvdyk7XG4gICAgICAgICAgICB2YXIgZGVjaW1hbEZvbGQgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7XG4gICAgICAgICAgICB2YXIgdGhvdXNhbmRzU2VwYXJhdG9yID0gY2hhcnRTdG9yZS5nZXRUaG91c2FuZHNTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIGlmIChoaWdoUHJpY2VNYXJrU3R5bGVzLnNob3cgJiYgaGlnaCAhPT0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3TWFyayhjdHgsIGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KGZvcm1hdFByZWNpc2lvbihoaWdoLCBwcmVjaXNpb24ucHJpY2UpKSksIHsgeDogaGlnaFgsIHk6IGhpZ2hZIH0sIGhpZ2hZIDwgbG93WSA/IFstMiwgLTVdIDogWzIsIDVdLCBoaWdoUHJpY2VNYXJrU3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb3dQcmljZU1hcmtTdHlsZXMuc2hvdyAmJiBsb3cgIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd01hcmsoY3R4LCBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24obG93LCBwcmVjaXNpb24ucHJpY2UpKSksIHsgeDogbG93WCwgeTogbG93WSB9LCBoaWdoWSA8IGxvd1kgPyBbMiwgNV0gOiBbLTIsIC01XSwgbG93UHJpY2VNYXJrU3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FuZGxlSGlnaExvd1ByaWNlVmlldy5wcm90b3R5cGUuX2RyYXdNYXJrID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgY29vcmRpbmF0ZSwgb2Zmc2V0cywgc3R5bGVzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB2YXIgc3RhcnRYID0gY29vcmRpbmF0ZS54O1xuICAgICAgICB2YXIgc3RhcnRZID0gY29vcmRpbmF0ZS55ICsgb2Zmc2V0c1swXTtcbiAgICAgICAgKF9hID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHN0YXJ0WCAtIDIsIHk6IHN0YXJ0WSArIG9mZnNldHNbMF0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHN0YXJ0WCArIDIsIHk6IHN0YXJ0WSArIG9mZnNldHNbMF0gfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZXM6IHsgY29sb3I6IHN0eWxlcy5jb2xvciB9XG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICB2YXIgbGluZUVuZFggPSAwO1xuICAgICAgICB2YXIgdGV4dFN0YXJ0WCA9IDA7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkZ2V0KCkuZ2V0Qm91bmRpbmcoKS53aWR0aDtcbiAgICAgICAgaWYgKHN0YXJ0WCA+IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgbGluZUVuZFggPSBzdGFydFggLSA1O1xuICAgICAgICAgICAgdGV4dFN0YXJ0WCA9IGxpbmVFbmRYIC0gc3R5bGVzLnRleHRPZmZzZXQ7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZUVuZFggPSBzdGFydFggKyA1O1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgdGV4dFN0YXJ0WCA9IGxpbmVFbmRYICsgc3R5bGVzLnRleHRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSBzdGFydFkgKyBvZmZzZXRzWzFdO1xuICAgICAgICAoX2IgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICBuYW1lOiAnbGluZScsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc3RhcnRYLCB5OiBzdGFydFkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzdGFydFgsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBsaW5lRW5kWCwgeTogeSB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogc3R5bGVzLmNvbG9yIH1cbiAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgIChfYyA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgeDogdGV4dFN0YXJ0WCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgYWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICBiYXNlbGluZTogJ21pZGRsZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3R5bGVzLmNvbG9yLFxuICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlcy50ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgICBmYW1pbHk6IHN0eWxlcy50ZXh0RmFtaWx5LFxuICAgICAgICAgICAgICAgIHdlaWdodDogc3R5bGVzLnRleHRXZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kcmF3KGN0eCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuZGxlSGlnaExvd1ByaWNlVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDYW5kbGVMYXN0UHJpY2VWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYW5kbGVMYXN0UHJpY2VWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZUxhc3RQcmljZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2FuZGxlTGFzdFByaWNlVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBwcmljZU1hcmtTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNhbmRsZS5wcmljZU1hcms7XG4gICAgICAgIHZhciBsYXN0UHJpY2VNYXJrU3R5bGVzID0gcHJpY2VNYXJrU3R5bGVzLmxhc3Q7XG4gICAgICAgIHZhciBsYXN0UHJpY2VNYXJrTGluZVN0eWxlcyA9IGxhc3RQcmljZU1hcmtTdHlsZXMubGluZTtcbiAgICAgICAgaWYgKHByaWNlTWFya1N0eWxlcy5zaG93ICYmIGxhc3RQcmljZU1hcmtTdHlsZXMuc2hvdyAmJiBsYXN0UHJpY2VNYXJrTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YUxpc3RbZGF0YUxpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZGF0YS5jbG9zZSwgb3Blbl8xID0gZGF0YS5vcGVuO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlUHJpY2UgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLmNvbXBhcmVSdWxlID09PSBDYW5kbGVDb2xvckNvbXBhcmVSdWxlLkN1cnJlbnRPcGVuID8gb3Blbl8xIDogKChfYiA9IChfYSA9IGRhdGFMaXN0W2RhdGFMaXN0Lmxlbmd0aCAtIDJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNsb3NlXzEpO1xuICAgICAgICAgICAgICAgIHZhciBwcmljZVkgPSB5QXhpcy5jb252ZXJ0VG9OaWNlUGl4ZWwoY2xvc2VfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlXzEgPiBjb21wYXJlUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLnVwQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlXzEgPCBjb21wYXJlUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBsYXN0UHJpY2VNYXJrU3R5bGVzLmRvd25Db2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gbGFzdFByaWNlTWFya1N0eWxlcy5ub0NoYW5nZUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiAwLCB5OiBwcmljZVkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiBwcmljZVkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBsYXN0UHJpY2VNYXJrTGluZVN0eWxlcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGxhc3RQcmljZU1hcmtMaW5lU3R5bGVzLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNoZWRWYWx1ZTogbGFzdFByaWNlTWFya0xpbmVTdHlsZXMuZGFzaGVkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuZGxlTGFzdFByaWNlVmlldztcbn0oVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBBeGlzUG9zaXRpb247XG4oZnVuY3Rpb24gKEF4aXNQb3NpdGlvbikge1xuICAgIEF4aXNQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBBeGlzUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbn0pKEF4aXNQb3NpdGlvbiB8fCAoQXhpc1Bvc2l0aW9uID0ge30pKTtcbmZ1bmN0aW9uIGdldERlZmF1bHRBeGlzUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDAsXG4gICAgICAgIHJhbmdlOiAwLFxuICAgICAgICByZWFsRnJvbTogMCxcbiAgICAgICAgcmVhbFRvOiAwLFxuICAgICAgICByZWFsUmFuZ2U6IDAsXG4gICAgICAgIGRpc3BsYXlGcm9tOiAwLFxuICAgICAgICBkaXNwbGF5VG86IDAsXG4gICAgICAgIGRpc3BsYXlSYW5nZTogMFxuICAgIH07XG59XG52YXIgQXhpc0ltcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBeGlzSW1wKHBhcmVudCkge1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSBnZXREZWZhdWx0QXhpc1JhbmdlKCk7XG4gICAgICAgIHRoaXMuX3ByZXZSYW5nZSA9IGdldERlZmF1bHRBeGlzUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5fdGlja3MgPSBbXTtcbiAgICAgICAgdGhpcy5fYXV0b0NhbGNUaWNrRmxhZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgQXhpc0ltcC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLmJ1aWxkVGlja3MgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9DYWxjVGlja0ZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhbmdlID0gdGhpcy5jcmVhdGVSYW5nZUltcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcmV2UmFuZ2UuZnJvbSAhPT0gdGhpcy5fcmFuZ2UuZnJvbSB8fCB0aGlzLl9wcmV2UmFuZ2UudG8gIT09IHRoaXMuX3JhbmdlLnRvIHx8IGZvcmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2UmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tzID0gdGhpcy5jcmVhdGVUaWNrc0ltcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQXhpc0ltcC5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrcztcbiAgICB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuX2F1dG9DYWxjVGlja0ZsYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcbiAgICB9O1xuICAgIEF4aXNJbXAucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmFuZ2U7IH07XG4gICAgQXhpc0ltcC5wcm90b3R5cGUuc2V0QXV0b0NhbGNUaWNrRmxhZyA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHRoaXMuX2F1dG9DYWxjVGlja0ZsYWcgPSBmbGFnO1xuICAgIH07XG4gICAgQXhpc0ltcC5wcm90b3R5cGUuZ2V0QXV0b0NhbGNUaWNrRmxhZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2F1dG9DYWxjVGlja0ZsYWc7IH07XG4gICAgcmV0dXJuIEF4aXNJbXA7XG59KCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB6aENOID0ge1xuICAgIHRpbWU6ICfml7bpl7TvvJonLFxuICAgIG9wZW46ICflvIDvvJonLFxuICAgIGhpZ2g6ICfpq5jvvJonLFxuICAgIGxvdzogJ+S9ju+8micsXG4gICAgY2xvc2U6ICfmlLbvvJonLFxuICAgIHZvbHVtZTogJ+aIkOS6pOmHj++8micsXG4gICAgdHVybm92ZXI6ICfmiJDkuqTpop3vvJonLFxuICAgIGNoYW5nZTogJ+a2qOW5he+8midcbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGVuVVMgPSB7XG4gICAgdGltZTogJ1RpbWU6ICcsXG4gICAgb3BlbjogJ09wZW46ICcsXG4gICAgaGlnaDogJ0hpZ2g6ICcsXG4gICAgbG93OiAnTG93OiAnLFxuICAgIGNsb3NlOiAnQ2xvc2U6ICcsXG4gICAgdm9sdW1lOiAnVm9sdW1lOiAnLFxuICAgIHR1cm5vdmVyOiAnVHVybm92ZXI6ICcsXG4gICAgY2hhbmdlOiAnQ2hhbmdlOiAnXG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBsb2NhbGVzID0ge1xuICAgICd6aC1DTic6IHpoQ04sXG4gICAgJ2VuLVVTJzogZW5VU1xufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9jYWxlKGxvY2FsZSwgbHMpIHtcbiAgICBsb2NhbGVzW2xvY2FsZV0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbG9jYWxlc1tsb2NhbGVdKSwgbHMpO1xufVxuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTG9jYWxlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobG9jYWxlcyk7XG59XG5mdW5jdGlvbiBpMThuKGtleSwgbG9jYWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBsb2NhbGVzW2xvY2FsZV1ba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoga2V5O1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDYW5kbGVUb29sdGlwVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlVG9vbHRpcFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlVG9vbHRpcFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2FuZGxlVG9vbHRpcFZpZXcucHJvdG90eXBlLmRyYXdJbXAgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHdpZGdldC5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBjcm9zc2hhaXIgPSBjaGFydFN0b3JlLmdldENyb3NzaGFpcigpO1xuICAgICAgICBpZiAoaXNWYWxpZChjcm9zc2hhaXIua0xpbmVEYXRhKSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKTtcbiAgICAgICAgICAgIHZhciBjYW5kbGVTdHlsZXMgPSBzdHlsZXMuY2FuZGxlO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvclN0eWxlcyA9IHN0eWxlcy5pbmRpY2F0b3I7XG4gICAgICAgICAgICBpZiAoY2FuZGxlU3R5bGVzLnRvb2x0aXAuc2hvd1R5cGUgPT09IFRvb2x0aXBTaG93VHlwZS5SZWN0ICYmXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yU3R5bGVzLnRvb2x0aXAuc2hvd1R5cGUgPT09IFRvb2x0aXBTaG93VHlwZS5SZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHJhd0NhbmRsZVRvb2x0aXAgPSB0aGlzLmlzRHJhd1Rvb2x0aXAoY3Jvc3NoYWlyLCBjYW5kbGVTdHlsZXMudG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHJhd0luZGljYXRvclRvb2x0aXAgPSB0aGlzLmlzRHJhd1Rvb2x0aXAoY3Jvc3NoYWlyLCBpbmRpY2F0b3JTdHlsZXMudG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd1JlY3RUb29sdGlwKGN0eCwgaXNEcmF3Q2FuZGxlVG9vbHRpcCwgaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCwgY2FuZGxlU3R5bGVzLnRvb2x0aXAub2Zmc2V0VG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRsZVN0eWxlcy50b29sdGlwLnNob3dUeXBlID09PSBUb29sdGlwU2hvd1R5cGUuU3RhbmRhcmQgJiZcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JTdHlsZXMudG9vbHRpcC5zaG93VHlwZSA9PT0gVG9vbHRpcFNob3dUeXBlLlN0YW5kYXJkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY2FuZGxlU3R5bGVzLnRvb2x0aXAsIG9mZnNldExlZnQgPSBfYS5vZmZzZXRMZWZ0LCBvZmZzZXRUb3AgPSBfYS5vZmZzZXRUb3AsIG9mZnNldFJpZ2h0ID0gX2Eub2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gYm91bmRpbmcud2lkdGggLSBvZmZzZXRSaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSB0aGlzLl9kcmF3Q2FuZGxlU3RhbmRhcmRUb29sdGlwKGN0eCwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaWNhdG9yVG9vbHRpcChjdHgsIG9mZnNldExlZnQsIHRvcF8xLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYW5kbGVTdHlsZXMudG9vbHRpcC5zaG93VHlwZSA9PT0gVG9vbHRpcFNob3dUeXBlLlJlY3QgJiZcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JTdHlsZXMudG9vbHRpcC5zaG93VHlwZSA9PT0gVG9vbHRpcFNob3dUeXBlLlN0YW5kYXJkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gY2FuZGxlU3R5bGVzLnRvb2x0aXAsIG9mZnNldExlZnQgPSBfYi5vZmZzZXRMZWZ0LCBvZmZzZXRUb3AgPSBfYi5vZmZzZXRUb3AsIG9mZnNldFJpZ2h0ID0gX2Iub2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gYm91bmRpbmcud2lkdGggLSBvZmZzZXRSaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgdG9wXzIgPSB0aGlzLmRyYXdJbmRpY2F0b3JUb29sdGlwKGN0eCwgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wLCBtYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHJhd0NhbmRsZVRvb2x0aXAgPSB0aGlzLmlzRHJhd1Rvb2x0aXAoY3Jvc3NoYWlyLCBjYW5kbGVTdHlsZXMudG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd1JlY3RUb29sdGlwKGN0eCwgaXNEcmF3Q2FuZGxlVG9vbHRpcCwgZmFsc2UsIHRvcF8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IGNhbmRsZVN0eWxlcy50b29sdGlwLCBvZmZzZXRMZWZ0ID0gX2Mub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Mub2Zmc2V0VG9wLCBvZmZzZXRSaWdodCA9IF9jLm9mZnNldFJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IGJvdW5kaW5nLndpZHRoIC0gb2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvcF8zID0gdGhpcy5fZHJhd0NhbmRsZVN0YW5kYXJkVG9vbHRpcChjdHgsIG9mZnNldExlZnQsIG9mZnNldFRvcCwgbWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYXdJbmRpY2F0b3JUb29sdGlwID0gdGhpcy5pc0RyYXdUb29sdGlwKGNyb3NzaGFpciwgaW5kaWNhdG9yU3R5bGVzLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdSZWN0VG9vbHRpcChjdHgsIGZhbHNlLCBpc0RyYXdJbmRpY2F0b3JUb29sdGlwLCB0b3BfMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbmRsZVRvb2x0aXBWaWV3LnByb3RvdHlwZS5fZHJhd0NhbmRsZVN0YW5kYXJkVG9vbHRpcCA9IGZ1bmN0aW9uIChjdHgsIGxlZnQsIHRvcCwgbWF4V2lkdGgpIHtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuY2FuZGxlO1xuICAgICAgICB2YXIgdG9vbHRpcFN0eWxlcyA9IHN0eWxlcy50b29sdGlwO1xuICAgICAgICB2YXIgdG9vbHRpcFRleHRTdHlsZXMgPSB0b29sdGlwU3R5bGVzLnRleHQ7XG4gICAgICAgIHZhciBwcmV2Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB7IHg6IGxlZnQsIHk6IHRvcCB9O1xuICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmF3VG9vbHRpcChjcm9zc2hhaXIsIHRvb2x0aXBTdHlsZXMpKSB7XG4gICAgICAgICAgICB2YXIgbGVnZW5kcyA9IHRoaXMuX2dldENhbmRsZVRvb2x0aXBMZWdlbmRzKCk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5jbGFzc2lmeVRvb2x0aXBGZWF0dXJlcyh0b29sdGlwU3R5bGVzLmZlYXR1cmVzKSwgMyksIGxlZnRGZWF0dXJlcyA9IF9hWzBdLCBtaWRkbGVGZWF0dXJlcyA9IF9hWzFdLCByaWdodEZlYXR1cmVzID0gX2FbMl07XG4gICAgICAgICAgICBwcmV2Um93SGVpZ2h0ID0gdGhpcy5kcmF3U3RhbmRhcmRUb29sdGlwRmVhdHVyZXMoY3R4LCBsZWZ0RmVhdHVyZXMsIGNvb3JkaW5hdGUsIG51bGwsIGxlZnQsIHByZXZSb3dIZWlnaHQsIG1heFdpZHRoKTtcbiAgICAgICAgICAgIHByZXZSb3dIZWlnaHQgPSB0aGlzLmRyYXdTdGFuZGFyZFRvb2x0aXBGZWF0dXJlcyhjdHgsIG1pZGRsZUZlYXR1cmVzLCBjb29yZGluYXRlLCBudWxsLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCk7XG4gICAgICAgICAgICBpZiAobGVnZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IHRoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcExlZ2VuZHMoY3R4LCBsZWdlbmRzLCBjb29yZGluYXRlLCBsZWZ0LCBwcmV2Um93SGVpZ2h0LCBtYXhXaWR0aCwgdG9vbHRpcFRleHRTdHlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlJvd0hlaWdodCA9IHRoaXMuZHJhd1N0YW5kYXJkVG9vbHRpcEZlYXR1cmVzKGN0eCwgcmlnaHRGZWF0dXJlcywgY29vcmRpbmF0ZSwgbnVsbCwgbGVmdCwgcHJldlJvd0hlaWdodCwgbWF4V2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlLnkgKyBwcmV2Um93SGVpZ2h0O1xuICAgIH07XG4gICAgQ2FuZGxlVG9vbHRpcFZpZXcucHJvdG90eXBlLl9kcmF3UmVjdFRvb2x0aXAgPSBmdW5jdGlvbiAoY3R4LCBpc0RyYXdDYW5kbGVUb29sdGlwLCBpc0RyYXdJbmRpY2F0b3JUb29sdGlwLCB0b3ApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKTtcbiAgICAgICAgdmFyIGNhbmRsZVN0eWxlcyA9IHN0eWxlcy5jYW5kbGU7XG4gICAgICAgIHZhciBpbmRpY2F0b3JTdHlsZXMgPSBzdHlsZXMuaW5kaWNhdG9yO1xuICAgICAgICB2YXIgY2FuZGxlVG9vbHRpcFN0eWxlcyA9IGNhbmRsZVN0eWxlcy50b29sdGlwO1xuICAgICAgICB2YXIgaW5kaWNhdG9yVG9vbHRpcFN0eWxlcyA9IGluZGljYXRvclN0eWxlcy50b29sdGlwO1xuICAgICAgICBpZiAoaXNEcmF3Q2FuZGxlVG9vbHRpcCB8fCBpc0RyYXdJbmRpY2F0b3JUb29sdGlwKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGxlTGVnZW5kcyA9IHRoaXMuX2dldENhbmRsZVRvb2x0aXBMZWdlbmRzKCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IGNhbmRsZVRvb2x0aXBTdHlsZXMub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gY2FuZGxlVG9vbHRpcFN0eWxlcy5vZmZzZXRUb3AsIG9mZnNldFJpZ2h0ID0gY2FuZGxlVG9vbHRpcFN0eWxlcy5vZmZzZXRSaWdodCwgb2Zmc2V0Qm90dG9tID0gY2FuZGxlVG9vbHRpcFN0eWxlcy5vZmZzZXRCb3R0b207XG4gICAgICAgICAgICB2YXIgX2MgPSBjYW5kbGVUb29sdGlwU3R5bGVzLnRleHQsIGJhc2VUZXh0TWFyZ2luTGVmdF8xID0gX2MubWFyZ2luTGVmdCwgYmFzZVRleHRNYXJnaW5SaWdodF8xID0gX2MubWFyZ2luUmlnaHQsIGJhc2VUZXh0TWFyZ2luVG9wXzEgPSBfYy5tYXJnaW5Ub3AsIGJhc2VUZXh0TWFyZ2luQm90dG9tXzEgPSBfYy5tYXJnaW5Cb3R0b20sIGJhc2VUZXh0U2l6ZV8xID0gX2Muc2l6ZSwgYmFzZVRleHRXZWlnaHRfMSA9IF9jLndlaWdodCwgYmFzZVRleHRGYW1pbHlfMSA9IF9jLmZhbWlseTtcbiAgICAgICAgICAgIHZhciBfZCA9IGNhbmRsZVRvb2x0aXBTdHlsZXMucmVjdCwgcmVjdFBvc2l0aW9uID0gX2QucG9zaXRpb24sIHJlY3RQYWRkaW5nTGVmdCA9IF9kLnBhZGRpbmdMZWZ0LCByZWN0UGFkZGluZ1JpZ2h0XzEgPSBfZC5wYWRkaW5nUmlnaHQsIHJlY3RQYWRkaW5nVG9wID0gX2QucGFkZGluZ1RvcCwgcmVjdFBhZGRpbmdCb3R0b20gPSBfZC5wYWRkaW5nQm90dG9tLCByZWN0T2Zmc2V0TGVmdCA9IF9kLm9mZnNldExlZnQsIHJlY3RPZmZzZXRSaWdodCA9IF9kLm9mZnNldFJpZ2h0LCByZWN0T2Zmc2V0VG9wID0gX2Qub2Zmc2V0VG9wLCByZWN0T2Zmc2V0Qm90dG9tID0gX2Qub2Zmc2V0Qm90dG9tLCByZWN0Qm9yZGVyU2l6ZV8xID0gX2QuYm9yZGVyU2l6ZSwgcmVjdEJvcmRlclJhZGl1cyA9IF9kLmJvcmRlclJhZGl1cywgcmVjdEJvcmRlckNvbG9yID0gX2QuYm9yZGVyQ29sb3IsIHJlY3RCYWNrZ3JvdW5kQ29sb3IgPSBfZC5jb2xvcjtcbiAgICAgICAgICAgIHZhciBtYXhUZXh0V2lkdGhfMSA9IDA7XG4gICAgICAgICAgICB2YXIgcmVjdFdpZHRoXzEgPSAwO1xuICAgICAgICAgICAgdmFyIHJlY3RIZWlnaHRfMSA9IDA7XG4gICAgICAgICAgICBpZiAoaXNEcmF3Q2FuZGxlVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY3JlYXRlRm9udChiYXNlVGV4dFNpemVfMSwgYmFzZVRleHRXZWlnaHRfMSwgYmFzZVRleHRGYW1pbHlfMSk7XG4gICAgICAgICAgICAgICAgY2FuZGxlTGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gXCJcIi5jb25jYXQodGl0bGUudGV4dCkuY29uY2F0KHZhbHVlLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArIGJhc2VUZXh0TWFyZ2luTGVmdF8xICsgYmFzZVRleHRNYXJnaW5SaWdodF8xO1xuICAgICAgICAgICAgICAgICAgICBtYXhUZXh0V2lkdGhfMSA9IE1hdGgubWF4KG1heFRleHRXaWR0aF8xLCBsYWJlbFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWN0SGVpZ2h0XzEgKz0gKChiYXNlVGV4dE1hcmdpbkJvdHRvbV8xICsgYmFzZVRleHRNYXJnaW5Ub3BfMSArIGJhc2VUZXh0U2l6ZV8xKSAqIGNhbmRsZUxlZ2VuZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZSA9IGluZGljYXRvclRvb2x0aXBTdHlsZXMudGV4dCwgaW5kaWNhdG9yVGV4dE1hcmdpbkxlZnRfMSA9IF9lLm1hcmdpbkxlZnQsIGluZGljYXRvclRleHRNYXJnaW5SaWdodF8xID0gX2UubWFyZ2luUmlnaHQsIGluZGljYXRvclRleHRNYXJnaW5Ub3BfMSA9IF9lLm1hcmdpblRvcCwgaW5kaWNhdG9yVGV4dE1hcmdpbkJvdHRvbV8xID0gX2UubWFyZ2luQm90dG9tLCBpbmRpY2F0b3JUZXh0U2l6ZV8xID0gX2Uuc2l6ZSwgaW5kaWNhdG9yVGV4dFdlaWdodF8xID0gX2Uud2VpZ2h0LCBpbmRpY2F0b3JUZXh0RmFtaWx5XzEgPSBfZS5mYW1pbHk7XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9yTGVnZW5kc0FycmF5XzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChpc0RyYXdJbmRpY2F0b3JUb29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY3JlYXRlRm9udChpbmRpY2F0b3JUZXh0U2l6ZV8xLCBpbmRpY2F0b3JUZXh0V2VpZ2h0XzEsIGluZGljYXRvclRleHRGYW1pbHlfMSk7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBEYXRhTGVnZW5kcyA9IF90aGlzLmdldEluZGljYXRvclRvb2x0aXBEYXRhKGluZGljYXRvcikubGVnZW5kcztcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yTGVnZW5kc0FycmF5XzEucHVzaCh0b29sdGlwRGF0YUxlZ2VuZHMpO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwRGF0YUxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCIuY29uY2F0KHRpdGxlLnRleHQpLmNvbmNhdCh2YWx1ZS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGggKyBpbmRpY2F0b3JUZXh0TWFyZ2luTGVmdF8xICsgaW5kaWNhdG9yVGV4dE1hcmdpblJpZ2h0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUZXh0V2lkdGhfMSA9IE1hdGgubWF4KG1heFRleHRXaWR0aF8xLCB0ZXh0V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdEhlaWdodF8xICs9IChpbmRpY2F0b3JUZXh0TWFyZ2luVG9wXzEgKyBpbmRpY2F0b3JUZXh0TWFyZ2luQm90dG9tXzEgKyBpbmRpY2F0b3JUZXh0U2l6ZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWN0V2lkdGhfMSArPSBtYXhUZXh0V2lkdGhfMTtcbiAgICAgICAgICAgIGlmIChyZWN0V2lkdGhfMSAhPT0gMCAmJiByZWN0SGVpZ2h0XzEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNCb3VuZGluZyA9IHBhbmUuZ2V0WUF4aXNXaWRnZXQoKS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgIHJlY3RXaWR0aF8xICs9IChyZWN0Qm9yZGVyU2l6ZV8xICogMiArIHJlY3RQYWRkaW5nTGVmdCArIHJlY3RQYWRkaW5nUmlnaHRfMSk7XG4gICAgICAgICAgICAgICAgcmVjdEhlaWdodF8xICs9IChyZWN0Qm9yZGVyU2l6ZV8xICogMiArIHJlY3RQYWRkaW5nVG9wICsgcmVjdFBhZGRpbmdCb3R0b20pO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJYID0gYm91bmRpbmcud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHZhciBpc1BvaW50ZXIgPSByZWN0UG9zaXRpb24gPT09IENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24uUG9pbnRlciAmJiBjcm9zc2hhaXIucGFuZUlkID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFO1xuICAgICAgICAgICAgICAgIHZhciBpc0xlZnQgPSAoKF9hID0gY3Jvc3NoYWlyLnJlYWxYKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA+IGNlbnRlclg7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RYXzEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxYID0gY3Jvc3NoYWlyLnJlYWxYO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xID0gcmVhbFggLSByZWN0T2Zmc2V0UmlnaHQgLSByZWN0V2lkdGhfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RYXzEgPSByZWFsWCArIHJlY3RPZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RYXzEgPSByZWN0T2Zmc2V0TGVmdCArIG9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeUF4aXMuaW5zaWRlICYmIHlBeGlzLnBvc2l0aW9uID09PSBBeGlzUG9zaXRpb24uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RYXzEgKz0geUF4aXNCb3VuZGluZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RYXzEgPSBib3VuZGluZy53aWR0aCAtIHJlY3RPZmZzZXRSaWdodCAtIHJlY3RXaWR0aF8xIC0gb2Zmc2V0UmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeUF4aXMuaW5zaWRlICYmIHlBeGlzLnBvc2l0aW9uID09PSBBeGlzUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0WF8xIC09IHlBeGlzQm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RZID0gdG9wICsgcmVjdE9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICBpZiAoaXNQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gY3Jvc3NoYWlyLnk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RZID0geSAtIHJlY3RIZWlnaHRfMSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0WSArIHJlY3RIZWlnaHRfMSA+IGJvdW5kaW5nLmhlaWdodCAtIHJlY3RPZmZzZXRCb3R0b20gLSBvZmZzZXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RZID0gYm91bmRpbmcuaGVpZ2h0IC0gcmVjdE9mZnNldEJvdHRvbSAtIHJlY3RIZWlnaHRfMSAtIG9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdFkgPCB0b3AgKyByZWN0T2Zmc2V0VG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0WSA9IHRvcCArIHJlY3RPZmZzZXRUb3AgKyBvZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiByZWN0WF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcmVjdFksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdFdpZHRoXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3RIZWlnaHRfMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBQb2x5Z29uVHlwZS5TdHJva2VGaWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJlY3RCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVjdEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyU2l6ZTogcmVjdEJvcmRlclNpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogcmVjdEJvcmRlclJhZGl1c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRsZVRleHRYXzEgPSByZWN0WF8xICsgcmVjdEJvcmRlclNpemVfMSArIHJlY3RQYWRkaW5nTGVmdCArIGJhc2VUZXh0TWFyZ2luTGVmdF8xO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0WV8xID0gcmVjdFkgKyByZWN0Qm9yZGVyU2l6ZV8xICsgcmVjdFBhZGRpbmdUb3A7XG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhd0NhbmRsZVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGNhbmRsZSB0ZXh0c1xuICAgICAgICAgICAgICAgICAgICBjYW5kbGVMZWdlbmRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0WV8xICs9IGJhc2VUZXh0TWFyZ2luVG9wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2FuZGxlVGV4dFhfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGV4dFlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGl0bGUudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogYmFzZVRleHRTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseTogYmFzZVRleHRGYW1pbHlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBiYXNlVGV4dFdlaWdodF8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFhfMSArIHJlY3RXaWR0aF8xIC0gcmVjdEJvcmRlclNpemVfMSAtIGJhc2VUZXh0TWFyZ2luUmlnaHRfMSAtIHJlY3RQYWRkaW5nUmlnaHRfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdGV4dFlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFsdWUudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdyaWdodCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdmFsdWUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGJhc2VUZXh0U2l6ZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk6IGJhc2VUZXh0RmFtaWx5XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogYmFzZVRleHRXZWlnaHRfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFlfMSArPSAoYmFzZVRleHRTaXplXzEgKyBiYXNlVGV4dE1hcmdpbkJvdHRvbV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RyYXdJbmRpY2F0b3JUb29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciBpbmRpY2F0b3IgdGV4dHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljYXRvclRleHRYXzEgPSByZWN0WF8xICsgcmVjdEJvcmRlclNpemVfMSArIHJlY3RQYWRkaW5nTGVmdCArIGluZGljYXRvclRleHRNYXJnaW5MZWZ0XzE7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvckxlZ2VuZHNBcnJheV8xLmZvckVhY2goZnVuY3Rpb24gKGxlZ2VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFlfMSArPSBpbmRpY2F0b3JUZXh0TWFyZ2luVG9wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZGljYXRvclRleHRYXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0ZXh0WV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGl0bGUudGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGluZGljYXRvclRleHRTaXplXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHk6IGluZGljYXRvclRleHRGYW1pbHlfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogaW5kaWNhdG9yVGV4dFdlaWdodF8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBfdGhpcy5jcmVhdGVGaWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiByZWN0WF8xICsgcmVjdFdpZHRoXzEgLSByZWN0Qm9yZGVyU2l6ZV8xIC0gaW5kaWNhdG9yVGV4dE1hcmdpblJpZ2h0XzEgLSByZWN0UGFkZGluZ1JpZ2h0XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0ZXh0WV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFsdWUudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHZhbHVlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogaW5kaWNhdG9yVGV4dFNpemVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbWlseTogaW5kaWNhdG9yVGV4dEZhbWlseV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBpbmRpY2F0b3JUZXh0V2VpZ2h0XzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRZXzEgKz0gKGluZGljYXRvclRleHRTaXplXzEgKyBpbmRpY2F0b3JUZXh0TWFyZ2luQm90dG9tXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FuZGxlVG9vbHRpcFZpZXcucHJvdG90eXBlLl9nZXRDYW5kbGVUb29sdGlwTGVnZW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNhbmRsZTtcbiAgICAgICAgdmFyIGRhdGFMaXN0ID0gY2hhcnRTdG9yZS5nZXREYXRhTGlzdCgpO1xuICAgICAgICB2YXIgY3VzdG9tQXBpID0gY2hhcnRTdG9yZS5nZXRDdXN0b21BcGkoKTtcbiAgICAgICAgdmFyIGRlY2ltYWxGb2xkID0gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpO1xuICAgICAgICB2YXIgdGhvdXNhbmRzU2VwYXJhdG9yID0gY2hhcnRTdG9yZS5nZXRUaG91c2FuZHNTZXBhcmF0b3IoKTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGNoYXJ0U3RvcmUuZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciBfZyA9IGNoYXJ0U3RvcmUuZ2V0UHJlY2lzaW9uKCksIHByaWNlUHJlY2lzaW9uID0gX2cucHJpY2UsIHZvbHVtZVByZWNpc2lvbiA9IF9nLnZvbHVtZTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IChfYSA9IGNoYXJ0U3RvcmUuZ2V0Q3Jvc3NoYWlyKCkuZGF0YUluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICB2YXIgdG9vbHRpcFN0eWxlcyA9IHN0eWxlcy50b29sdGlwO1xuICAgICAgICB2YXIgdGV4dENvbG9yID0gdG9vbHRpcFN0eWxlcy50ZXh0LmNvbG9yO1xuICAgICAgICB2YXIgcHJldiA9IChfYiA9IGRhdGFMaXN0W2RhdGFJbmRleCAtIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICB2YXIgY3VycmVudCA9IGRhdGFMaXN0W2RhdGFJbmRleF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIGlnbm9yZVxuICAgICAgICB2YXIgcHJldkNsb3NlID0gKF9jID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LmNsb3NlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdXJyZW50LmNsb3NlO1xuICAgICAgICB2YXIgY2hhbmdlVmFsdWUgPSBjdXJyZW50LmNsb3NlIC0gcHJldkNsb3NlO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICd7dGltZX0nOiBjdXN0b21BcGkuZm9ybWF0RGF0ZShjdXJyZW50LnRpbWVzdGFtcCwgJ1lZWVktTU0tREQgSEg6bW0nLCBGb3JtYXREYXRlVHlwZS5Ub29sdGlwKSxcbiAgICAgICAgICAgICd7b3Blbn0nOiBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oY3VycmVudC5vcGVuLCBwcmljZVByZWNpc2lvbikpKSxcbiAgICAgICAgICAgICd7aGlnaH0nOiBkZWNpbWFsRm9sZC5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oY3VycmVudC5oaWdoLCBwcmljZVByZWNpc2lvbikpKSxcbiAgICAgICAgICAgICd7bG93fSc6IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KGZvcm1hdFByZWNpc2lvbihjdXJyZW50LmxvdywgcHJpY2VQcmVjaXNpb24pKSksXG4gICAgICAgICAgICAne2Nsb3NlfSc6IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KGZvcm1hdFByZWNpc2lvbihjdXJyZW50LmNsb3NlLCBwcmljZVByZWNpc2lvbikpKSxcbiAgICAgICAgICAgICd7dm9sdW1lfSc6IGRlY2ltYWxGb2xkLmZvcm1hdCh0aG91c2FuZHNTZXBhcmF0b3IuZm9ybWF0KGN1c3RvbUFwaS5mb3JtYXRCaWdOdW1iZXIoZm9ybWF0UHJlY2lzaW9uKChfZCA9IGN1cnJlbnQudm9sdW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSwgdm9sdW1lUHJlY2lzaW9uKSkpKSxcbiAgICAgICAgICAgICd7dHVybm92ZXJ9JzogZGVjaW1hbEZvbGQuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQoZm9ybWF0UHJlY2lzaW9uKChfZSA9IGN1cnJlbnQudHVybm92ZXIpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRvb2x0aXBTdHlsZXMuZGVmYXVsdFZhbHVlLCBwcmljZVByZWNpc2lvbikpKSxcbiAgICAgICAgICAgICd7Y2hhbmdlfSc6IHByZXZDbG9zZSA9PT0gMCA/IHRvb2x0aXBTdHlsZXMuZGVmYXVsdFZhbHVlIDogXCJcIi5jb25jYXQodGhvdXNhbmRzU2VwYXJhdG9yLmZvcm1hdChmb3JtYXRQcmVjaXNpb24oY2hhbmdlVmFsdWUgLyBwcmV2Q2xvc2UgKiAxMDApKSwgXCIlXCIpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBsZWdlbmRzID0gKGlzRnVuY3Rpb24odG9vbHRpcFN0eWxlcy5jdXN0b20pXG4gICAgICAgICAgICA/IHRvb2x0aXBTdHlsZXMuY3VzdG9tKHsgcHJldjogcHJldiwgY3VycmVudDogY3VycmVudCwgbmV4dDogKF9mID0gZGF0YUxpc3RbZGF0YUluZGV4ICsgMV0pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG51bGwgfSwgc3R5bGVzKVxuICAgICAgICAgICAgOiB0b29sdGlwU3R5bGVzLmN1c3RvbSk7XG4gICAgICAgIHJldHVybiBsZWdlbmRzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IF9hLnRpdGxlLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHQgPSB7IHRleHQ6ICcnLCBjb2xvcjogdGV4dENvbG9yIH07XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgdCA9IF9fYXNzaWduKHt9LCB0aXRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0LnRleHQgPSB0aXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQudGV4dCA9IGkxOG4odC50ZXh0LCBsb2NhbGUpO1xuICAgICAgICAgICAgdmFyIHYgPSB7IHRleHQ6IHRvb2x0aXBTdHlsZXMuZGVmYXVsdFZhbHVlLCBjb2xvcjogdGV4dENvbG9yIH07XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdiA9IF9fYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2LnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IC97KFxcUyopfS8uZXhlYyh2LnRleHQpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJ7XCIuY29uY2F0KG1hdGNoWzFdLCBcIn1cIik7XG4gICAgICAgICAgICAgICAgdi50ZXh0ID0gdi50ZXh0LnJlcGxhY2Uoa2V5LCAoKF9iID0gbWFwcGluZ1trZXldKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0b29sdGlwU3R5bGVzLmRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd7Y2hhbmdlfScpIHtcbiAgICAgICAgICAgICAgICAgICAgdi5jb2xvciA9IGNoYW5nZVZhbHVlID09PSAwID8gc3R5bGVzLnByaWNlTWFyay5sYXN0Lm5vQ2hhbmdlQ29sb3IgOiAoY2hhbmdlVmFsdWUgPiAwID8gc3R5bGVzLnByaWNlTWFyay5sYXN0LnVwQ29sb3IgOiBzdHlsZXMucHJpY2VNYXJrLmxhc3QuZG93bkNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0aXRsZTogdCwgdmFsdWU6IHYgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuZGxlVG9vbHRpcFZpZXc7XG59KEluZGljYXRvclRvb2x0aXBWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIENhbmRsZVdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlV2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbmRsZVdpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RDb250YWluZXIsIHBhbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jYW5kbGVCYXJWaWV3ID0gbmV3IENhbmRsZUJhclZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fY2FuZGxlQXJlYVZpZXcgPSBuZXcgQ2FuZGxlQXJlYVZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fY2FuZGxlSGlnaExvd1ByaWNlVmlldyA9IG5ldyBDYW5kbGVIaWdoTG93UHJpY2VWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2NhbmRsZUxhc3RQcmljZUxpbmVWaWV3ID0gbmV3IENhbmRsZUxhc3RQcmljZVZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5fY2FuZGxlQmFyVmlldyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FuZGxlV2lkZ2V0LnByb3RvdHlwZS51cGRhdGVNYWluQ29udGVudCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIGNhbmRsZVN0eWxlcyA9IHRoaXMuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkuY2FuZGxlO1xuICAgICAgICBpZiAoY2FuZGxlU3R5bGVzLnR5cGUgIT09IENhbmRsZVR5cGUuQXJlYSkge1xuICAgICAgICAgICAgdGhpcy5fY2FuZGxlQmFyVmlldy5kcmF3KGN0eCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5kbGVIaWdoTG93UHJpY2VWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmRsZUFyZWFWaWV3LnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmRsZUFyZWFWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW5kbGVMYXN0UHJpY2VMaW5lVmlldy5kcmF3KGN0eCk7XG4gICAgfTtcbiAgICBDYW5kbGVXaWRnZXQucHJvdG90eXBlLmNyZWF0ZVRvb2x0aXBWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENhbmRsZVRvb2x0aXBWaWV3KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbmRsZVdpZGdldDtcbn0oSW5kaWNhdG9yV2lkZ2V0KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEF4aXNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBeGlzVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBeGlzVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgsIGV4dGVuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0QXhpc1N0eWxlcyhwYW5lLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkpO1xuICAgICAgICBpZiAoc3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuYXhpc0xpbmUuc2hvdykge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogdGhpcy5jcmVhdGVBeGlzTGluZShib3VuZGluZywgc3R5bGVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXMuYXhpc0xpbmVcbiAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXh0ZW5kWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5nZXRUaWNrcygpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZXMudGlja0xpbmUuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmNyZWF0ZVRpY2tMaW5lcyh0aWNrcywgYm91bmRpbmcsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLmNyZWF0ZUZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLnRpY2tMaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZXMudGlja1RleHQuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dHMgPSB0aGlzLmNyZWF0ZVRpY2tUZXh0cyh0aWNrcywgYm91bmRpbmcsIHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB0ZXh0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLnRpY2tUZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEF4aXNWaWV3O1xufShWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFlBeGlzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWUF4aXNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFlBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBZQXhpc1ZpZXcucHJvdG90eXBlLmdldEF4aXNTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzdHlsZXMueUF4aXM7XG4gICAgfTtcbiAgICBZQXhpc1ZpZXcucHJvdG90eXBlLmNyZWF0ZUF4aXNMaW5lID0gZnVuY3Rpb24gKGJvdW5kaW5nLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgc2l6ZSA9IHN0eWxlcy5heGlzTGluZS5zaXplO1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIGlmICh5QXhpcy5pc0Zyb21aZXJvKCkpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IGJvdW5kaW5nLndpZHRoIC0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IGJvdW5kaW5nLmhlaWdodCB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBZQXhpc1ZpZXcucHJvdG90eXBlLmNyZWF0ZVRpY2tMaW5lcyA9IGZ1bmN0aW9uICh0aWNrcywgYm91bmRpbmcsIHN0eWxlcykge1xuICAgICAgICB2YXIgeUF4aXMgPSB0aGlzLmdldFdpZGdldCgpLmdldFBhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciBheGlzTGluZVN0eWxlcyA9IHN0eWxlcy5heGlzTGluZTtcbiAgICAgICAgdmFyIHRpY2tMaW5lU3R5bGVzID0gc3R5bGVzLnRpY2tMaW5lO1xuICAgICAgICB2YXIgc3RhcnRYID0gMDtcbiAgICAgICAgdmFyIGVuZFggPSAwO1xuICAgICAgICBpZiAoeUF4aXMuaXNGcm9tWmVybygpKSB7XG4gICAgICAgICAgICBzdGFydFggPSAwO1xuICAgICAgICAgICAgaWYgKGF4aXNMaW5lU3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgICAgICBzdGFydFggKz0gYXhpc0xpbmVTdHlsZXMuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZFggPSBzdGFydFggKyB0aWNrTGluZVN0eWxlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFggPSBib3VuZGluZy53aWR0aDtcbiAgICAgICAgICAgIGlmIChheGlzTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgc3RhcnRYIC09IGF4aXNMaW5lU3R5bGVzLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRYID0gc3RhcnRYIC0gdGlja0xpbmVTdHlsZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcy5tYXAoZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgIHsgeDogc3RhcnRYLCB5OiB0aWNrLmNvb3JkIH0sXG4gICAgICAgICAgICAgICAgeyB4OiBlbmRYLCB5OiB0aWNrLmNvb3JkIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgWUF4aXNWaWV3LnByb3RvdHlwZS5jcmVhdGVUaWNrVGV4dHMgPSBmdW5jdGlvbiAodGlja3MsIGJvdW5kaW5nLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHlBeGlzID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgYXhpc0xpbmVTdHlsZXMgPSBzdHlsZXMuYXhpc0xpbmU7XG4gICAgICAgIHZhciB0aWNrTGluZVN0eWxlcyA9IHN0eWxlcy50aWNrTGluZTtcbiAgICAgICAgdmFyIHRpY2tUZXh0U3R5bGVzID0gc3R5bGVzLnRpY2tUZXh0O1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIGlmICh5QXhpcy5pc0Zyb21aZXJvKCkpIHtcbiAgICAgICAgICAgIHggPSB0aWNrVGV4dFN0eWxlcy5tYXJnaW5TdGFydDtcbiAgICAgICAgICAgIGlmIChheGlzTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgeCArPSBheGlzTGluZVN0eWxlcy5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpY2tMaW5lU3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgICAgICB4ICs9IHRpY2tMaW5lU3R5bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSBib3VuZGluZy53aWR0aCAtIHRpY2tUZXh0U3R5bGVzLm1hcmdpbkVuZDtcbiAgICAgICAgICAgIGlmIChheGlzTGluZVN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgeCAtPSBheGlzTGluZVN0eWxlcy5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpY2tMaW5lU3R5bGVzLnNob3cpIHtcbiAgICAgICAgICAgICAgICB4IC09IHRpY2tMaW5lU3R5bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dEFsaWduID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpLmlzRnJvbVplcm8oKSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHJldHVybiB0aWNrcy5tYXAoZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogdGljay5jb29yZCxcbiAgICAgICAgICAgIHRleHQ6IHRpY2sudGV4dCxcbiAgICAgICAgICAgIGFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICBiYXNlbGluZTogJ21pZGRsZSdcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFlBeGlzVmlldztcbn0oQXhpc1ZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYW5kbGVMYXN0UHJpY2VMYWJlbFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhbmRsZUxhc3RQcmljZUxhYmVsVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBib3VuZGluZyA9IHdpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBwcmljZU1hcmtTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLmNhbmRsZS5wcmljZU1hcms7XG4gICAgICAgIHZhciBsYXN0UHJpY2VNYXJrU3R5bGVzID0gcHJpY2VNYXJrU3R5bGVzLmxhc3Q7XG4gICAgICAgIHZhciBsYXN0UHJpY2VNYXJrVGV4dFN0eWxlcyA9IGxhc3RQcmljZU1hcmtTdHlsZXMudGV4dDtcbiAgICAgICAgaWYgKHByaWNlTWFya1N0eWxlcy5zaG93ICYmIGxhc3RQcmljZU1hcmtTdHlsZXMuc2hvdyAmJiBsYXN0UHJpY2VNYXJrVGV4dFN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdmFyIGRhdGFMaXN0ID0gY2hhcnRTdG9yZS5nZXREYXRhTGlzdCgpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtkYXRhTGlzdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBkYXRhLmNsb3NlLCBvcGVuXzEgPSBkYXRhLm9wZW47XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVQcmljZSA9IGxhc3RQcmljZU1hcmtTdHlsZXMuY29tcGFyZVJ1bGUgPT09IENhbmRsZUNvbG9yQ29tcGFyZVJ1bGUuQ3VycmVudE9wZW4gPyBvcGVuXzEgOiAoKF9iID0gKF9hID0gZGF0YUxpc3RbZGF0YUxpc3QubGVuZ3RoIC0gMl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY2xvc2VfMSk7XG4gICAgICAgICAgICAgICAgdmFyIHByaWNlWSA9IHlBeGlzLmNvbnZlcnRUb05pY2VQaXhlbChjbG9zZV8xKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlXzEgPiBjb21wYXJlUHJpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gbGFzdFByaWNlTWFya1N0eWxlcy51cENvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZV8xIDwgY29tcGFyZVByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGxhc3RQcmljZU1hcmtTdHlsZXMuZG93bkNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gbGFzdFByaWNlTWFya1N0eWxlcy5ub0NoYW5nZUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNSYW5nZSA9IHlBeGlzLmdldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB5QXhpcy5kaXNwbGF5VmFsdWVUb1RleHQoeUF4aXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUoeUF4aXMudmFsdWVUb1JlYWxWYWx1ZShjbG9zZV8xLCB7IHJhbmdlOiB5QXhpc1JhbmdlIH0pLCB7IHJhbmdlOiB5QXhpc1JhbmdlIH0pLCBwcmVjaXNpb24ucHJpY2UpO1xuICAgICAgICAgICAgICAgIHRleHQgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCkuZm9ybWF0KGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkuZm9ybWF0KHRleHQpKTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGdpbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBpZiAoeUF4aXMuaXNGcm9tWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxnaW4gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGdpbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHByaWNlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogdGV4dEFsZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogX19hc3NpZ24oX19hc3NpZ24oe30sIGxhc3RQcmljZU1hcmtUZXh0U3R5bGVzKSwgeyBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvciB9KVxuICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuZGxlTGFzdFByaWNlTGFiZWxWaWV3O1xufShWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIEluZGljYXRvckxhc3RWYWx1ZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZGljYXRvckxhc3RWYWx1ZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5kaWNhdG9yTGFzdFZhbHVlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmRpY2F0b3JMYXN0VmFsdWVWaWV3LnByb3RvdHlwZS5kcmF3SW1wID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgZGVmYXVsdFN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuaW5kaWNhdG9yO1xuICAgICAgICB2YXIgbGFzdFZhbHVlTWFya1N0eWxlcyA9IGRlZmF1bHRTdHlsZXMubGFzdFZhbHVlTWFyaztcbiAgICAgICAgdmFyIGxhc3RWYWx1ZU1hcmtUZXh0U3R5bGVzID0gbGFzdFZhbHVlTWFya1N0eWxlcy50ZXh0O1xuICAgICAgICBpZiAobGFzdFZhbHVlTWFya1N0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICB2YXIgeUF4aXNfMSA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgdmFyIHlBeGlzUmFuZ2VfMSA9IHlBeGlzXzEuZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBkYXRhTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0RGF0YUxpc3QoKTtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXhfMSA9IGRhdGFMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgaW5kaWNhdG9ycyA9IGNoYXJ0U3RvcmUuZ2V0SW5kaWNhdG9yc0J5UGFuZUlkKHBhbmUuZ2V0SWQoKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQXBpXzEgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpO1xuICAgICAgICAgICAgdmFyIGRlY2ltYWxGb2xkXzEgPSBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCk7XG4gICAgICAgICAgICB2YXIgdGhvdXNhbmRzU2VwYXJhdG9yXzEgPSBjaGFydFN0b3JlLmdldFRob3VzYW5kc1NlcGFyYXRvcigpO1xuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmRpY2F0b3IucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gKF9iID0gKF9hID0gcmVzdWx0W2RhdGFJbmRleF8xXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzdWx0W2RhdGFJbmRleF8xIC0gMV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpICYmIGluZGljYXRvci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVjaXNpb25fMSA9IGluZGljYXRvci5wcmVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgIGVhY2hGaWd1cmVzKGluZGljYXRvciwgZGF0YUluZGV4XzEsIGRlZmF1bHRTdHlsZXMsIGZ1bmN0aW9uIChmaWd1cmUsIGZpZ3VyZVN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbZmlndXJlLmtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSB5QXhpc18xLmNvbnZlcnRUb05pY2VQaXhlbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB5QXhpc18xLmRpc3BsYXlWYWx1ZVRvVGV4dCh5QXhpc18xLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKHlBeGlzXzEudmFsdWVUb1JlYWxWYWx1ZSh2YWx1ZSwgeyByYW5nZTogeUF4aXNSYW5nZV8xIH0pLCB7IHJhbmdlOiB5QXhpc1JhbmdlXzEgfSksIHByZWNpc2lvbl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yLnNob3VsZEZvcm1hdEJpZ051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gY3VzdG9tQXBpXzEuZm9ybWF0QmlnTnVtYmVyKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjaW1hbEZvbGRfMS5mb3JtYXQodGhvdXNhbmRzU2VwYXJhdG9yXzEuZm9ybWF0KHRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeUF4aXNfMS5pc0Zyb21aZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBib3VuZGluZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsYXN0VmFsdWVNYXJrVGV4dFN0eWxlcyksIHsgYmFja2dyb3VuZENvbG9yOiBmaWd1cmVTdHlsZXMuY29sb3IgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmRpY2F0b3JMYXN0VmFsdWVWaWV3O1xufShWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIE92ZXJsYXlZQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE92ZXJsYXlZQXhpc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVlBeGlzVmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPdmVybGF5WUF4aXNWaWV3LnByb3RvdHlwZS5jb29yZGluYXRlVG9Qb2ludFRpbWVzdGFtcERhdGFJbmRleEZsYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE92ZXJsYXlZQXhpc1ZpZXcucHJvdG90eXBlLmRyYXdEZWZhdWx0RmlndXJlcyA9IGZ1bmN0aW9uIChjdHgsIG92ZXJsYXksIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuZHJhd0ZpZ3VyZXMoY3R4LCBvdmVybGF5LCB0aGlzLmdldERlZmF1bHRGaWd1cmVzKG92ZXJsYXksIGNvb3JkaW5hdGVzKSk7XG4gICAgfTtcbiAgICBPdmVybGF5WUF4aXNWaWV3LnByb3RvdHlwZS5nZXREZWZhdWx0RmlndXJlcyA9IGZ1bmN0aW9uIChvdmVybGF5LCBjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gcGFuZS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGNsaWNrT3ZlcmxheUluZm8gPSBjaGFydFN0b3JlLmdldENsaWNrT3ZlcmxheUluZm8oKTtcbiAgICAgICAgdmFyIGZpZ3VyZXMgPSBbXTtcbiAgICAgICAgaWYgKG92ZXJsYXkubmVlZERlZmF1bHRZQXhpc0ZpZ3VyZSAmJlxuICAgICAgICAgICAgb3ZlcmxheS5pZCA9PT0gKChfYSA9IGNsaWNrT3ZlcmxheUluZm8ub3ZlcmxheSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSAmJlxuICAgICAgICAgICAgY2xpY2tPdmVybGF5SW5mby5wYW5lSWQgPT09IHBhbmUuZ2V0SWQoKSkge1xuICAgICAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgIHZhciB0b3BZXzEgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIHZhciBib3R0b21ZXzEgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIHZhciBpc0Zyb21aZXJvID0geUF4aXMuaXNGcm9tWmVybygpO1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbl8xID0gJ2xlZnQnO1xuICAgICAgICAgICAgdmFyIHhfMSA9IDA7XG4gICAgICAgICAgICBpZiAoaXNGcm9tWmVybykge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbl8xID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIHhfMSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ25fMSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgeF8xID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVjaW1hbEZvbGRfMSA9IGNoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKTtcbiAgICAgICAgICAgIHZhciB0aG91c2FuZHNTZXBhcmF0b3JfMSA9IGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7XG4gICAgICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZGluYXRlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IG92ZXJsYXkucG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcFlfMSA9IE1hdGgubWluKHRvcFlfMSwgY29vcmRpbmF0ZS55KTtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tWV8xID0gTWF0aC5tYXgoYm90dG9tWV8xLCBjb29yZGluYXRlLnkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRlY2ltYWxGb2xkXzEuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvcl8xLmZvcm1hdChmb3JtYXRQcmVjaXNpb24ocG9pbnQudmFsdWUsIGNoYXJ0U3RvcmUuZ2V0UHJlY2lzaW9uKCkucHJpY2UpKSk7XG4gICAgICAgICAgICAgICAgICAgIGZpZ3VyZXMucHVzaCh7IHR5cGU6ICd0ZXh0JywgYXR0cnM6IHsgeDogeF8xLCB5OiBjb29yZGluYXRlLnksIHRleHQ6IHRleHQsIGFsaWduOiB0ZXh0QWxpZ25fMSwgYmFzZWxpbmU6ICdtaWRkbGUnIH0sIGlnbm9yZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmaWd1cmVzLnVuc2hpZnQoeyB0eXBlOiAncmVjdCcsIGF0dHJzOiB7IHg6IDAsIHk6IHRvcFlfMSwgd2lkdGg6IGJvdW5kaW5nLndpZHRoLCBoZWlnaHQ6IGJvdHRvbVlfMSAtIHRvcFlfMSB9LCBpZ25vcmVFdmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlndXJlcztcbiAgICB9O1xuICAgIE92ZXJsYXlZQXhpc1ZpZXcucHJvdG90eXBlLmdldEZpZ3VyZXMgPSBmdW5jdGlvbiAob3ZlcmxheSwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0ID0gcGFuZS5nZXRDaGFydCgpO1xuICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIHhBeGlzID0gY2hhcnQuZ2V0WEF4aXNQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IG92ZXJsYXkuY3JlYXRlWUF4aXNGaWd1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvdmVybGF5LCB7IGNoYXJ0OiBjaGFydCwgb3ZlcmxheTogb3ZlcmxheSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLCBib3VuZGluZzogYm91bmRpbmcsIHhBeGlzOiB4QXhpcywgeUF4aXM6IHlBeGlzIH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5WUF4aXNWaWV3O1xufShPdmVybGF5VmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldy5wcm90b3R5cGUuZHJhd0ltcCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5nZXRXaWRnZXQoKTtcbiAgICAgICAgdmFyIHBhbmUgPSB3aWRnZXQuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyID0gY2hhcnRTdG9yZS5nZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNoYXJ0U3RvcmUuZ2V0U3R5bGVzKCkuY3Jvc3NoYWlyO1xuICAgICAgICBpZiAoaXNTdHJpbmcoY3Jvc3NoYWlyLnBhbmVJZCkgJiYgdGhpcy5jb21wYXJlKGNyb3NzaGFpciwgcGFuZS5nZXRJZCgpKSkge1xuICAgICAgICAgICAgaWYgKHN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblN0eWxlcyA9IHRoaXMuZ2V0RGlyZWN0aW9uU3R5bGVzKHN0eWxlcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRTdHlsZXMgPSBkaXJlY3Rpb25TdHlsZXMudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uU3R5bGVzLnNob3cgJiYgdGV4dFN0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KGNyb3NzaGFpciwgY2hhcnRTdG9yZSwgYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY3JlYXRlRm9udCh0ZXh0U3R5bGVzLnNpemUsIHRleHRTdHlsZXMud2VpZ2h0LCB0ZXh0U3R5bGVzLmZhbWlseSk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY3JlYXRlRmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB0aGlzLmdldFRleHRBdHRycyh0ZXh0LCBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGgsIGNyb3NzaGFpciwgYm91bmRpbmcsIGF4aXMsIHRleHRTdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB0ZXh0U3R5bGVzXG4gICAgICAgICAgICAgICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChjcm9zc2hhaXIsIHBhbmVJZCkge1xuICAgICAgICByZXR1cm4gY3Jvc3NoYWlyLnBhbmVJZCA9PT0gcGFuZUlkO1xuICAgIH07XG4gICAgQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldy5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLmhvcml6b250YWw7XG4gICAgfTtcbiAgICBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGNyb3NzaGFpciwgY2hhcnRTdG9yZSwgYXhpcykge1xuICAgICAgICB2YXIgeUF4aXMgPSBheGlzO1xuICAgICAgICB2YXIgdmFsdWUgPSBheGlzLmNvbnZlcnRGcm9tUGl4ZWwoY3Jvc3NoYWlyLnkpO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgdmFyIHNob3VsZEZvcm1hdEJpZ051bWJlciA9IGZhbHNlO1xuICAgICAgICBpZiAoeUF4aXMuaXNJbkNhbmRsZSgpKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChjcm9zc2hhaXIucGFuZUlkKTtcbiAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoaW5kaWNhdG9yLnByZWNpc2lvbiwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICBzaG91bGRGb3JtYXRCaWdOdW1iZXIgfHwgKHNob3VsZEZvcm1hdEJpZ051bWJlciA9IGluZGljYXRvci5zaG91bGRGb3JtYXRCaWdOdW1iZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlBeGlzUmFuZ2UgPSB5QXhpcy5nZXRSYW5nZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IHlBeGlzLmRpc3BsYXlWYWx1ZVRvVGV4dCh5QXhpcy5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZSh5QXhpcy52YWx1ZVRvUmVhbFZhbHVlKHZhbHVlLCB7IHJhbmdlOiB5QXhpc1JhbmdlIH0pLCB7IHJhbmdlOiB5QXhpc1JhbmdlIH0pLCBwcmVjaXNpb24pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgaWYgKHNob3VsZEZvcm1hdEJpZ051bWJlcikge1xuICAgICAgICAgICAgdGV4dCA9IGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCkuZm9ybWF0QmlnTnVtYmVyKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFydFN0b3JlLmdldERlY2ltYWxGb2xkKCkuZm9ybWF0KGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCkuZm9ybWF0KHRleHQpKTtcbiAgICB9O1xuICAgIENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcucHJvdG90eXBlLmdldFRleHRBdHRycyA9IGZ1bmN0aW9uICh0ZXh0LCBfdGV4dFdpZHRoLCBjcm9zc2hhaXIsIGJvdW5kaW5nLCBheGlzLCBfc3R5bGVzKSB7XG4gICAgICAgIHZhciB5QXhpcyA9IGF4aXM7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgaWYgKHlBeGlzLmlzRnJvbVplcm8oKSkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IGNyb3NzaGFpci55LCB0ZXh0OiB0ZXh0LCBhbGlnbjogdGV4dEFsaWduLCBiYXNlbGluZTogJ21pZGRsZScgfTtcbiAgICB9O1xuICAgIHJldHVybiBDcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3O1xufShWaWV3KSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFlBeGlzV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhZQXhpc1dpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBZQXhpc1dpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RDb250YWluZXIsIHBhbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl95QXhpc1ZpZXcgPSBuZXcgWUF4aXNWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2NhbmRsZUxhc3RQcmljZUxhYmVsVmlldyA9IG5ldyBDYW5kbGVMYXN0UHJpY2VMYWJlbFZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5faW5kaWNhdG9yTGFzdFZhbHVlVmlldyA9IG5ldyBJbmRpY2F0b3JMYXN0VmFsdWVWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX292ZXJsYXlZQXhpc1ZpZXcgPSBuZXcgT3ZlcmxheVlBeGlzVmlldyhfdGhpcyk7XG4gICAgICAgIF90aGlzLl9jcm9zc2hhaXJIb3Jpem9udGFsTGFiZWxWaWV3ID0gbmV3IENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5nZXRDb250YWluZXIoKS5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJztcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuX292ZXJsYXlZQXhpc1ZpZXcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFlBeGlzV2lkZ2V0LnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gV2lkZ2V0TmFtZUNvbnN0YW50cy5ZX0FYSVM7XG4gICAgfTtcbiAgICBZQXhpc1dpZGdldC5wcm90b3R5cGUudXBkYXRlTWFpbiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG1pbmltaXplID0gdGhpcy5nZXRQYW5lKCkuZ2V0T3B0aW9ucygpLnN0YXRlID09PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovO1xuICAgICAgICB0aGlzLl95QXhpc1ZpZXcuZHJhdyhjdHgsIG1pbmltaXplKTtcbiAgICAgICAgaWYgKCFtaW5pbWl6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKS5pc0luQ2FuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5kbGVMYXN0UHJpY2VMYWJlbFZpZXcuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yTGFzdFZhbHVlVmlldy5kcmF3KGN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFlBeGlzV2lkZ2V0LnByb3RvdHlwZS51cGRhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5nZXRQYW5lKCkuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5WUF4aXNWaWV3LmRyYXcoY3R4KTtcbiAgICAgICAgICAgIHRoaXMuX2Nyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gWUF4aXNXaWRnZXQ7XG59KERyYXdXaWRnZXQpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgVElDS19DT1VOVCA9IDg7XG52YXIgWUF4aXNJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFlBeGlzSW1wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFlBeGlzSW1wKHBhcmVudCwgeUF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmluc2lkZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IEF4aXNQb3NpdGlvbi5SaWdodDtcbiAgICAgICAgX3RoaXMuZ2FwID0ge1xuICAgICAgICAgICAgdG9wOiAwLjIsXG4gICAgICAgICAgICBib3R0b206IDAuMVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHBhcmFtcy5kZWZhdWx0UmFuZ2U7IH07XG4gICAgICAgIF90aGlzLm1pblNwYW4gPSBmdW5jdGlvbiAocHJlY2lzaW9uKSB7IHJldHVybiBpbmRleDEwKC1wcmVjaXNpb24pOyB9O1xuICAgICAgICBfdGhpcy52YWx1ZVRvUmVhbFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgICAgX3RoaXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgICBfdGhpcy5kaXNwbGF5VmFsdWVUb1JlYWxWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgICAgIF90aGlzLnJlYWxWYWx1ZVRvVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgICBfdGhpcy5kaXNwbGF5VmFsdWVUb1RleHQgPSBmdW5jdGlvbiAodmFsdWUsIHByZWNpc2lvbikgeyByZXR1cm4gZm9ybWF0UHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pOyB9O1xuICAgICAgICBfdGhpcy5vdmVycmlkZSh5QXhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICAgIHZhciBuYW1lID0geUF4aXMubmFtZSwgZ2FwID0geUF4aXMuZ2FwLCBvdGhlcnMgPSBfX3Jlc3QoeUF4aXMsIFtcIm5hbWVcIiwgXCJnYXBcIl0pO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcy5nYXAsIGdhcCk7XG4gICAgICAgIG1lcmdlKHRoaXMsIG90aGVycyk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuY3JlYXRlUmFuZ2VJbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB2YXIgY2hhcnQgPSBwYXJlbnQuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBjaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBwYW5lSWQgPSBwYXJlbnQuZ2V0SWQoKTtcbiAgICAgICAgdmFyIG1pbiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB2YXIgbWF4ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciBzaG91bGRPaGxjID0gZmFsc2U7XG4gICAgICAgIHZhciBzcGVjaWZ5TWluID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciBzcGVjaWZ5TWF4ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgIHZhciBpbmRpY2F0b3JQcmVjaXNpb24gPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lSWQpO1xuICAgICAgICBpbmRpY2F0b3JzLmZvckVhY2goZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgc2hvdWxkT2hsYyB8fCAoc2hvdWxkT2hsYyA9IGluZGljYXRvci5zaG91bGRPaGxjKTtcbiAgICAgICAgICAgIGluZGljYXRvclByZWNpc2lvbiA9IE1hdGgubWluKGluZGljYXRvclByZWNpc2lvbiwgaW5kaWNhdG9yLnByZWNpc2lvbik7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoaW5kaWNhdG9yLm1pblZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNwZWNpZnlNaW4gPSBNYXRoLm1pbihzcGVjaWZ5TWluLCBpbmRpY2F0b3IubWluVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGluZGljYXRvci5tYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZ5TWF4ID0gTWF0aC5tYXgoc3BlY2lmeU1heCwgaW5kaWNhdG9yLm1heFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSA0O1xuICAgICAgICB2YXIgaW5DYW5kbGUgPSB0aGlzLmlzSW5DYW5kbGUoKTtcbiAgICAgICAgaWYgKGluQ2FuZGxlKSB7XG4gICAgICAgICAgICB2YXIgcHJpY2VQcmVjaXNpb24gPSBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICAgICAgaWYgKGluZGljYXRvclByZWNpc2lvbiAhPT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1pbihpbmRpY2F0b3JQcmVjaXNpb24sIHByaWNlUHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByaWNlUHJlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGljYXRvclByZWNpc2lvbiAhPT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBpbmRpY2F0b3JQcmVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpc2libGVSYW5nZURhdGFMaXN0ID0gY2hhcnRTdG9yZS5nZXRWaXNpYmxlUmFuZ2VEYXRhTGlzdCgpO1xuICAgICAgICB2YXIgY2FuZGxlU3R5bGVzID0gY2hhcnQuZ2V0U3R5bGVzKCkuY2FuZGxlO1xuICAgICAgICB2YXIgaXNBcmVhID0gY2FuZGxlU3R5bGVzLnR5cGUgPT09IENhbmRsZVR5cGUuQXJlYTtcbiAgICAgICAgdmFyIGFyZWFWYWx1ZUtleSA9IGNhbmRsZVN0eWxlcy5hcmVhLnZhbHVlO1xuICAgICAgICB2YXIgc2hvdWxkQ29tcGFyZUhpZ2hMb3cgPSAoaW5DYW5kbGUgJiYgIWlzQXJlYSkgfHwgKCFpbkNhbmRsZSAmJiBzaG91bGRPaGxjKTtcbiAgICAgICAgdmlzaWJsZVJhbmdlRGF0YUxpc3QuZm9yRWFjaChmdW5jdGlvbiAodmlzaWJsZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSB2aXNpYmxlRGF0YS5kYXRhSW5kZXg7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZpc2libGVEYXRhLmRhdGEuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZENvbXBhcmVIaWdoTG93KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZGF0YS5sb3cpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGEuaGlnaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbkNhbmRsZSAmJiBpc0FyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVthcmVhVmFsdWVLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2EucmVzdWx0LCBmaWd1cmVzID0gX2EuZmlndXJlcztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IChfYiA9IHJlc3VsdFtkYXRhSW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgICAgICAgICBmaWd1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZpZ3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ZpZ3VyZS5rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaW4gIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIG1heCAhPT0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHNwZWNpZnlNaW4sIG1pbik7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChzcGVjaWZ5TWF4LCBtYXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluID0gMDtcbiAgICAgICAgICAgIG1heCA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0RGlmZiA9IG1heCAtIG1pbjtcbiAgICAgICAgdmFyIGRlZmF1bHRSYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IG1pbixcbiAgICAgICAgICAgIHRvOiBtYXgsXG4gICAgICAgICAgICByYW5nZTogZGVmYXVsdERpZmYsXG4gICAgICAgICAgICByZWFsRnJvbTogbWluLFxuICAgICAgICAgICAgcmVhbFRvOiBtYXgsXG4gICAgICAgICAgICByZWFsUmFuZ2U6IGRlZmF1bHREaWZmLFxuICAgICAgICAgICAgZGlzcGxheUZyb206IG1pbixcbiAgICAgICAgICAgIGRpc3BsYXlUbzogbWF4LFxuICAgICAgICAgICAgZGlzcGxheVJhbmdlOiBkZWZhdWx0RGlmZlxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmNyZWF0ZVJhbmdlKHtcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgIHBhbmVJZDogcGFuZUlkLFxuICAgICAgICAgICAgZGVmYXVsdFJhbmdlOiBkZWZhdWx0UmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZWFsRnJvbSA9IHJhbmdlLnJlYWxGcm9tO1xuICAgICAgICB2YXIgcmVhbFRvID0gcmFuZ2UucmVhbFRvO1xuICAgICAgICB2YXIgcmVhbFJhbmdlID0gcmFuZ2UucmVhbFJhbmdlO1xuICAgICAgICB2YXIgbWluU3BhbiA9IHRoaXMubWluU3BhbihwcmVjaXNpb24pO1xuICAgICAgICBpZiAocmVhbEZyb20gPT09IHJlYWxUbyB8fCByZWFsUmFuZ2UgPCBtaW5TcGFuKSB7XG4gICAgICAgICAgICB2YXIgbWluQ2hlY2sgPSBzcGVjaWZ5TWluID09PSByZWFsRnJvbTtcbiAgICAgICAgICAgIHZhciBtYXhDaGVjayA9IHNwZWNpZnlNYXggPT09IHJlYWxUbztcbiAgICAgICAgICAgIHZhciBoYWxmVGlja0NvdW50ID0gVElDS19DT1VOVCAvIDI7XG4gICAgICAgICAgICByZWFsRnJvbSA9IG1pbkNoZWNrID8gcmVhbEZyb20gOiAobWF4Q2hlY2sgPyByZWFsRnJvbSAtIFRJQ0tfQ09VTlQgKiBtaW5TcGFuIDogcmVhbEZyb20gLSBoYWxmVGlja0NvdW50ICogbWluU3Bhbik7XG4gICAgICAgICAgICByZWFsVG8gPSBtYXhDaGVjayA/IHJlYWxUbyA6IChtaW5DaGVjayA/IHJlYWxUbyArIFRJQ0tfQ09VTlQgKiBtaW5TcGFuIDogcmVhbFRvICsgaGFsZlRpY2tDb3VudCAqIG1pblNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdhcCwgdG9wID0gX2EudG9wLCBib3R0b20gPSBfYS5ib3R0b207XG4gICAgICAgIHZhciB0b3BSYXRlID0gdG9wO1xuICAgICAgICBpZiAodG9wUmF0ZSA+PSAxKSB7XG4gICAgICAgICAgICB0b3BSYXRlID0gdG9wUmF0ZSAvIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm90dG9tUmF0ZSA9IGJvdHRvbTtcbiAgICAgICAgaWYgKGJvdHRvbVJhdGUgPj0gMSkge1xuICAgICAgICAgICAgYm90dG9tUmF0ZSA9IGJvdHRvbVJhdGUgLyBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVhbFJhbmdlID0gcmVhbFRvIC0gcmVhbEZyb207XG4gICAgICAgIHJlYWxGcm9tID0gcmVhbEZyb20gLSByZWFsUmFuZ2UgKiBib3R0b21SYXRlO1xuICAgICAgICByZWFsVG8gPSByZWFsVG8gKyByZWFsUmFuZ2UgKiB0b3BSYXRlO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMucmVhbFZhbHVlVG9WYWx1ZShyZWFsRnJvbSwgeyByYW5nZTogcmFuZ2UgfSk7XG4gICAgICAgIHZhciB0byA9IHRoaXMucmVhbFZhbHVlVG9WYWx1ZShyZWFsVG8sIHsgcmFuZ2U6IHJhbmdlIH0pO1xuICAgICAgICB2YXIgZGlzcGxheUZyb20gPSB0aGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKHJlYWxGcm9tLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICAgICAgdmFyIGRpc3BsYXlUbyA9IHRoaXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUocmVhbFRvLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICByYW5nZTogdG8gLSBmcm9tLFxuICAgICAgICAgICAgcmVhbEZyb206IHJlYWxGcm9tLFxuICAgICAgICAgICAgcmVhbFRvOiByZWFsVG8sXG4gICAgICAgICAgICByZWFsUmFuZ2U6IHJlYWxUbyAtIHJlYWxGcm9tLFxuICAgICAgICAgICAgZGlzcGxheUZyb206IGRpc3BsYXlGcm9tLFxuICAgICAgICAgICAgZGlzcGxheVRvOiBkaXNwbGF5VG8sXG4gICAgICAgICAgICBkaXNwbGF5UmFuZ2U6IGRpc3BsYXlUbyAtIGRpc3BsYXlGcm9tXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDmmK/lkKbmmK/onKHng5vlm77ovbRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5pc0luQ2FuZGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKS5nZXRJZCgpID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5piv5ZCm5LuOeei9tDDlvIDlp4tcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5pc0Zyb21aZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnBvc2l0aW9uID09PSBBeGlzUG9zaXRpb24uTGVmdCAmJiB0aGlzLmluc2lkZSkgfHxcbiAgICAgICAgICAgICh0aGlzLnBvc2l0aW9uID09PSBBeGlzUG9zaXRpb24uUmlnaHQgJiYgIXRoaXMuaW5zaWRlKSk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuY3JlYXRlVGlja3NJbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIGRpc3BsYXlGcm9tID0gcmFuZ2UuZGlzcGxheUZyb20sIGRpc3BsYXlUbyA9IHJhbmdlLmRpc3BsYXlUbywgZGlzcGxheVJhbmdlID0gcmFuZ2UuZGlzcGxheVJhbmdlO1xuICAgICAgICB2YXIgdGlja3MgPSBbXTtcbiAgICAgICAgaWYgKGRpc3BsYXlSYW5nZSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuaWNlKGRpc3BsYXlSYW5nZSAvIFRJQ0tfQ09VTlQpO1xuICAgICAgICAgICAgdmFyIHByZWNpc2lvbl8xID0gZ2V0UHJlY2lzaW9uKGludGVydmFsKTtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHJvdW5kKE1hdGguY2VpbChkaXNwbGF5RnJvbSAvIGludGVydmFsKSAqIGludGVydmFsLCBwcmVjaXNpb25fMSk7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHJvdW5kKE1hdGguZmxvb3IoZGlzcGxheVRvIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwsIHByZWNpc2lvbl8xKTtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHZhciBmID0gZmlyc3Q7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZiA8PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZi50b0ZpeGVkKHByZWNpc2lvbl8xKTtcbiAgICAgICAgICAgICAgICAgICAgdGlja3Nbbl0gPSB7IHRleHQ6IHYsIGNvb3JkOiAwLCB2YWx1ZTogdiB9O1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGYgKz0gaW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IChfYiA9IChfYSA9IHBhbmUuZ2V0WUF4aXNXaWRnZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nKCkuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHBhbmUuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBvcHRpbWFsVGlja3MgPSBbXTtcbiAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICB2YXIgc3R5bGVzID0gY2hhcnRTdG9yZS5nZXRTdHlsZXMoKTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIHZhciBzaG91bGRGb3JtYXRCaWdOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbkNhbmRsZSgpKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heChwcmVjaXNpb24sIGluZGljYXRvci5wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIHNob3VsZEZvcm1hdEJpZ051bWJlciB8fCAoc2hvdWxkRm9ybWF0QmlnTnVtYmVyID0gaW5kaWNhdG9yLnNob3VsZEZvcm1hdEJpZ051bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VzdG9tQXBpID0gY2hhcnRTdG9yZS5nZXRDdXN0b21BcGkoKTtcbiAgICAgICAgdmFyIHRob3VzYW5kc1NlcGFyYXRvciA9IGNoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7XG4gICAgICAgIHZhciBkZWNpbWFsRm9sZCA9IGNoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKTtcbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSBzdHlsZXMueEF4aXMudGlja1RleHQuc2l6ZTtcbiAgICAgICAgdmFyIHZhbGlkWSA9IE5hTjtcbiAgICAgICAgdGlja3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHYgPSBfdGhpcy5kaXNwbGF5VmFsdWVUb1RleHQoK3ZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgdmFyIHkgPSBfdGhpcy5jb252ZXJ0VG9QaXhlbChfdGhpcy5yZWFsVmFsdWVUb1ZhbHVlKF90aGlzLmRpc3BsYXlWYWx1ZVRvUmVhbFZhbHVlKCt2YWx1ZSwgeyByYW5nZTogcmFuZ2UgfSksIHsgcmFuZ2U6IHJhbmdlIH0pKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRGb3JtYXRCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB2ID0gY3VzdG9tQXBpLmZvcm1hdEJpZ051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ID0gZGVjaW1hbEZvbGQuZm9ybWF0KHRob3VzYW5kc1NlcGFyYXRvci5mb3JtYXQodikpO1xuICAgICAgICAgICAgdmFyIHZhbGlkWU51bWJlciA9IGlzTnVtYmVyKHZhbGlkWSk7XG4gICAgICAgICAgICBpZiAoeSA+IHRleHRIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICB5IDwgaGVpZ2h0IC0gdGV4dEhlaWdodCAmJlxuICAgICAgICAgICAgICAgICgodmFsaWRZTnVtYmVyICYmIChNYXRoLmFicyh2YWxpZFkgLSB5KSA+IHRleHRIZWlnaHQgKiAyKSkgfHwgIXZhbGlkWU51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWFsVGlja3MucHVzaCh7IHRleHQ6IHYsIGNvb3JkOiB5LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdmFsaWRZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuY3JlYXRlVGlja3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaWNrcyh7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICAgICAgICBib3VuZGluZzogdGhpcy5nZXRCb3VuZGluZygpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUaWNrczogb3B0aW1hbFRpY2tzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW1hbFRpY2tzO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmdldEF1dG9TaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBjaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpO1xuICAgICAgICB2YXIgeUF4aXNTdHlsZXMgPSBzdHlsZXMueUF4aXM7XG4gICAgICAgIHZhciB3aWR0aCA9IHlBeGlzU3R5bGVzLnNpemU7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlBeGlzV2lkdGggPSAwO1xuICAgICAgICBpZiAoeUF4aXNTdHlsZXMuc2hvdykge1xuICAgICAgICAgICAgaWYgKHlBeGlzU3R5bGVzLmF4aXNMaW5lLnNob3cpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1dpZHRoICs9IHlBeGlzU3R5bGVzLmF4aXNMaW5lLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeUF4aXNTdHlsZXMudGlja0xpbmUuc2hvdykge1xuICAgICAgICAgICAgICAgIHlBeGlzV2lkdGggKz0geUF4aXNTdHlsZXMudGlja0xpbmUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlBeGlzU3R5bGVzLnRpY2tUZXh0LnNob3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFdpZHRoXzEgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGlja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aF8xID0gTWF0aC5tYXgodGV4dFdpZHRoXzEsIGNhbGNUZXh0V2lkdGgodGljay50ZXh0LCB5QXhpc1N0eWxlcy50aWNrVGV4dC5zaXplLCB5QXhpc1N0eWxlcy50aWNrVGV4dC53ZWlnaHQsIHlBeGlzU3R5bGVzLnRpY2tUZXh0LmZhbWlseSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlBeGlzV2lkdGggKz0gKHlBeGlzU3R5bGVzLnRpY2tUZXh0Lm1hcmdpblN0YXJ0ICsgeUF4aXNTdHlsZXMudGlja1RleHQubWFyZ2luRW5kICsgdGV4dFdpZHRoXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjcm9zc2hhaXJTdHlsZXMgPSBzdHlsZXMuY3Jvc3NoYWlyO1xuICAgICAgICB2YXIgY3Jvc3NoYWlyVmVydGljYWxUZXh0V2lkdGggPSAwO1xuICAgICAgICBpZiAoY3Jvc3NoYWlyU3R5bGVzLnNob3cgJiZcbiAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnNob3cgJiZcbiAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnRleHQuc2hvdykge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBjaGFydFN0b3JlLmdldEluZGljYXRvcnNCeVBhbmVJZChwYW5lLmdldElkKCkpO1xuICAgICAgICAgICAgdmFyIGluZGljYXRvclByZWNpc2lvbl8xID0gMDtcbiAgICAgICAgICAgIHZhciBzaG91bGRGb3JtYXRCaWdOdW1iZXJfMSA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kaWNhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3JQcmVjaXNpb25fMSA9IE1hdGgubWF4KGluZGljYXRvci5wcmVjaXNpb24sIGluZGljYXRvclByZWNpc2lvbl8xKTtcbiAgICAgICAgICAgICAgICBzaG91bGRGb3JtYXRCaWdOdW1iZXJfMSB8fCAoc2hvdWxkRm9ybWF0QmlnTnVtYmVyXzEgPSBpbmRpY2F0b3Iuc2hvdWxkRm9ybWF0QmlnTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IDI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luQ2FuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJpY2VQcmVjaXNpb24gPSBjaGFydFN0b3JlLmdldFByZWNpc2lvbigpLnByaWNlO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0VmFsdWVNYXJrU3R5bGVzID0gc3R5bGVzLmluZGljYXRvci5sYXN0VmFsdWVNYXJrO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VmFsdWVNYXJrU3R5bGVzLnNob3cgJiYgbGFzdFZhbHVlTWFya1N0eWxlcy50ZXh0LnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoaW5kaWNhdG9yUHJlY2lzaW9uXzEsIHByaWNlUHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByaWNlUHJlY2lzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IGluZGljYXRvclByZWNpc2lvbl8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlVGV4dCA9IGZvcm1hdFByZWNpc2lvbih0aGlzLmdldFJhbmdlKCkuZGlzcGxheVRvLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gaWdub3JlXG4gICAgICAgICAgICBpZiAoc2hvdWxkRm9ybWF0QmlnTnVtYmVyXzEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVRleHQgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpLmZvcm1hdEJpZ051bWJlcih2YWx1ZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVUZXh0ID0gY2hhcnRTdG9yZS5nZXREZWNpbWFsRm9sZCgpLmZvcm1hdCh2YWx1ZVRleHQpO1xuICAgICAgICAgICAgY3Jvc3NoYWlyVmVydGljYWxUZXh0V2lkdGggKz0gKGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnRleHQucGFkZGluZ0xlZnQgK1xuICAgICAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy5ob3Jpem9udGFsLnRleHQucGFkZGluZ1JpZ2h0ICtcbiAgICAgICAgICAgICAgICBjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC50ZXh0LmJvcmRlclNpemUgKiAyICtcbiAgICAgICAgICAgICAgICBjYWxjVGV4dFdpZHRoKHZhbHVlVGV4dCwgY3Jvc3NoYWlyU3R5bGVzLmhvcml6b250YWwudGV4dC5zaXplLCBjcm9zc2hhaXJTdHlsZXMuaG9yaXpvbnRhbC50ZXh0LndlaWdodCwgY3Jvc3NoYWlyU3R5bGVzLmhvcml6b250YWwudGV4dC5mYW1pbHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoeUF4aXNXaWR0aCwgY3Jvc3NoYWlyVmVydGljYWxUZXh0V2lkdGgpO1xuICAgIH07XG4gICAgWUF4aXNJbXAucHJvdG90eXBlLmdldEJvdW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKS5nZXRZQXhpc1dpZGdldCgpLmdldEJvdW5kaW5nKCk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChwaXhlbCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgICB2YXIgcmVhbEZyb20gPSByYW5nZS5yZWFsRnJvbSwgcmVhbFJhbmdlID0gcmFuZ2UucmVhbFJhbmdlO1xuICAgICAgICB2YXIgcmF0ZSA9IHRoaXMucmV2ZXJzZSA/IHBpeGVsIC8gaGVpZ2h0IDogMSAtIHBpeGVsIC8gaGVpZ2h0O1xuICAgICAgICB2YXIgcmVhbFZhbHVlID0gcmF0ZSAqIHJlYWxSYW5nZSArIHJlYWxGcm9tO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsVmFsdWVUb1ZhbHVlKHJlYWxWYWx1ZSwgeyByYW5nZTogcmFuZ2UgfSk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgICB2YXIgcmVhbFZhbHVlID0gdGhpcy52YWx1ZVRvUmVhbFZhbHVlKHZhbHVlLCB7IHJhbmdlOiByYW5nZSB9KTtcbiAgICAgICAgdmFyIGhlaWdodCA9IChfYiA9IChfYSA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0WUF4aXNXaWRnZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nKCkuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICB2YXIgcmVhbEZyb20gPSByYW5nZS5yZWFsRnJvbSwgcmVhbFJhbmdlID0gcmFuZ2UucmVhbFJhbmdlO1xuICAgICAgICB2YXIgcmF0ZSA9IChyZWFsVmFsdWUgLSByZWFsRnJvbSkgLyByZWFsUmFuZ2U7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UgPyBNYXRoLnJvdW5kKHJhdGUgKiBoZWlnaHQpIDogTWF0aC5yb3VuZCgoMSAtIHJhdGUpICogaGVpZ2h0KTtcbiAgICB9O1xuICAgIFlBeGlzSW1wLnByb3RvdHlwZS5jb252ZXJ0VG9OaWNlUGl4ZWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGhlaWdodCA9IChfYiA9IChfYSA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0WUF4aXNXaWRnZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nKCkuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmNvbnZlcnRUb1BpeGVsKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5tYXgoaGVpZ2h0ICogMC4wNSwgTWF0aC5taW4ocGl4ZWwsIGhlaWdodCAqIDAuOTgpKSk7XG4gICAgfTtcbiAgICBZQXhpc0ltcC5leHRlbmQgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIEN1c3RvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDdXN0b20sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b20ocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgdGVtcGxhdGUpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgICAgICB9KFlBeGlzSW1wKSk7XG4gICAgICAgIHJldHVybiBDdXN0b207XG4gICAgfTtcbiAgICByZXR1cm4gWUF4aXNJbXA7XG59KEF4aXNJbXApKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbm9ybWFsJDEgPSB7XG4gICAgbmFtZTogJ25vcm1hbCdcbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHBlcmNlbnRhZ2UgPSB7XG4gICAgbmFtZTogJ3BlcmNlbnRhZ2UnLFxuICAgIG1pblNwYW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgucG93KDEwLCAtMik7IH0sXG4gICAgZGlzcGxheVZhbHVlVG9UZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGZvcm1hdFByZWNpc2lvbih2YWx1ZSwgMiksIFwiJVwiKTsgfSxcbiAgICB2YWx1ZVRvUmVhbFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICByZXR1cm4gKHZhbHVlIC0gcmFuZ2UuZnJvbSkgLyByYW5nZS5yYW5nZSAqIHJhbmdlLnJlYWxSYW5nZSArIHJhbmdlLnJlYWxGcm9tO1xuICAgIH0sXG4gICAgcmVhbFZhbHVlVG9WYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHJhbmdlLnJlYWxGcm9tKSAvIHJhbmdlLnJlYWxSYW5nZSAqIHJhbmdlLnJhbmdlICsgcmFuZ2UuZnJvbTtcbiAgICB9LFxuICAgIGNyZWF0ZVJhbmdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNoYXJ0ID0gX2EuY2hhcnQsIGRlZmF1bHRSYW5nZSA9IF9hLmRlZmF1bHRSYW5nZTtcbiAgICAgICAgdmFyIGtMaW5lRGF0YUxpc3QgPSBjaGFydC5nZXREYXRhTGlzdCgpO1xuICAgICAgICB2YXIgdmlzaWJsZVJhbmdlID0gY2hhcnQuZ2V0VmlzaWJsZVJhbmdlKCk7XG4gICAgICAgIHZhciBrTGluZURhdGEgPSBrTGluZURhdGFMaXN0W3Zpc2libGVSYW5nZS5mcm9tXTtcbiAgICAgICAgaWYgKGlzVmFsaWQoa0xpbmVEYXRhKSkge1xuICAgICAgICAgICAgdmFyIGZyb20gPSBkZWZhdWx0UmFuZ2UuZnJvbSwgdG8gPSBkZWZhdWx0UmFuZ2UudG8sIHJhbmdlID0gZGVmYXVsdFJhbmdlLnJhbmdlO1xuICAgICAgICAgICAgdmFyIHJlYWxGcm9tID0gKGRlZmF1bHRSYW5nZS5mcm9tIC0ga0xpbmVEYXRhLmNsb3NlKSAvIGtMaW5lRGF0YS5jbG9zZSAqIDEwMDtcbiAgICAgICAgICAgIHZhciByZWFsVG8gPSAoZGVmYXVsdFJhbmdlLnRvIC0ga0xpbmVEYXRhLmNsb3NlKSAvIGtMaW5lRGF0YS5jbG9zZSAqIDEwMDtcbiAgICAgICAgICAgIHZhciByZWFsUmFuZ2UgPSByZWFsVG8gLSByZWFsRnJvbTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIHJlYWxGcm9tOiByZWFsRnJvbSxcbiAgICAgICAgICAgICAgICByZWFsVG86IHJlYWxUbyxcbiAgICAgICAgICAgICAgICByZWFsUmFuZ2U6IHJlYWxSYW5nZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5RnJvbTogcmVhbEZyb20sXG4gICAgICAgICAgICAgICAgZGlzcGxheVRvOiByZWFsVG8sXG4gICAgICAgICAgICAgICAgZGlzcGxheVJhbmdlOiByZWFsUmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSYW5nZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBsb2dhcml0aG0gPSB7XG4gICAgbmFtZTogJ2xvZ2FyaXRobScsXG4gICAgbWluU3BhbjogZnVuY3Rpb24gKHByZWNpc2lvbikgeyByZXR1cm4gMC4wNSAqIGluZGV4MTAoLXByZWNpc2lvbik7IH0sXG4gICAgdmFsdWVUb1JlYWxWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA8IDAgPyAtbG9nMTAoTWF0aC5hYnModmFsdWUpKSA6IGxvZzEwKHZhbHVlKTsgfSxcbiAgICByZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA8IDAgPyAtaW5kZXgxMChNYXRoLmFicyh2YWx1ZSkpIDogaW5kZXgxMCh2YWx1ZSk7IH0sXG4gICAgZGlzcGxheVZhbHVlVG9SZWFsVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPCAwID8gLWxvZzEwKE1hdGguYWJzKHZhbHVlKSkgOiBsb2cxMCh2YWx1ZSk7IH0sXG4gICAgcmVhbFZhbHVlVG9WYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA8IDAgPyAtaW5kZXgxMChNYXRoLmFicyh2YWx1ZSkpIDogaW5kZXgxMCh2YWx1ZSk7IH0sXG4gICAgY3JlYXRlUmFuZ2U6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGVmYXVsdFJhbmdlID0gX2EuZGVmYXVsdFJhbmdlO1xuICAgICAgICB2YXIgZnJvbSA9IGRlZmF1bHRSYW5nZS5mcm9tLCB0byA9IGRlZmF1bHRSYW5nZS50bywgcmFuZ2UgPSBkZWZhdWx0UmFuZ2UucmFuZ2U7XG4gICAgICAgIHZhciByZWFsRnJvbSA9IGZyb20gPCAwID8gLWxvZzEwKE1hdGguYWJzKGZyb20pKSA6IGxvZzEwKGZyb20pO1xuICAgICAgICB2YXIgcmVhbFRvID0gdG8gPCAwID8gLWxvZzEwKE1hdGguYWJzKHRvKSkgOiBsb2cxMCh0byk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgcmVhbEZyb206IHJlYWxGcm9tLFxuICAgICAgICAgICAgcmVhbFRvOiByZWFsVG8sXG4gICAgICAgICAgICByZWFsUmFuZ2U6IHJlYWxUbyAtIHJlYWxGcm9tLFxuICAgICAgICAgICAgZGlzcGxheUZyb206IGZyb20sXG4gICAgICAgICAgICBkaXNwbGF5VG86IHRvLFxuICAgICAgICAgICAgZGlzcGxheVJhbmdlOiByYW5nZVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIHlBeGlzZXMgPSB7XG4gICAgbm9ybWFsOiBZQXhpc0ltcC5leHRlbmQobm9ybWFsJDEpLFxuICAgIHBlcmNlbnRhZ2U6IFlBeGlzSW1wLmV4dGVuZChwZXJjZW50YWdlKSxcbiAgICBsb2dhcml0aG06IFlBeGlzSW1wLmV4dGVuZChsb2dhcml0aG0pXG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJZQXhpcyhheGlzKSB7XG4gICAgeUF4aXNlc1theGlzLm5hbWVdID0gWUF4aXNJbXAuZXh0ZW5kKGF4aXMpO1xufVxuZnVuY3Rpb24gZ2V0WUF4aXNDbGFzcyhuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB5QXhpc2VzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB5QXhpc2VzLm5vcm1hbDtcbn1cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgUGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYW5lKGNoYXJ0LCBpZCkge1xuICAgICAgICB0aGlzLl9ib3VuZGluZyA9IGNyZWF0ZURlZmF1bHRCb3VuZGluZygpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEJvdW5kaW5nID0gY3JlYXRlRGVmYXVsdEJvdW5kaW5nKCk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjcmVhdGVEb20oJ2RpdicsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFBhbmUucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9O1xuICAgIFBhbmUucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS5nZXRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIFBhbmUucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS5nZXRDaGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0O1xuICAgIH07XG4gICAgUGFuZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZGluZztcbiAgICB9O1xuICAgIFBhbmUucHJvdG90eXBlLnNldE9yaWdpbmFsQm91bmRpbmcgPSBmdW5jdGlvbiAoYm91bmRpbmcpIHtcbiAgICAgICAgbWVyZ2UodGhpcy5fb3JpZ2luYWxCb3VuZGluZywgYm91bmRpbmcpO1xuICAgIH07XG4gICAgUGFuZS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxCb3VuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsQm91bmRpbmc7XG4gICAgfTtcbiAgICBQYW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kaW5nLmhlaWdodCAhPT0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuX2JvdW5kaW5nLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUltcChsZXZlbCAhPT0gbnVsbCAmJiBsZXZlbCAhPT0gdm9pZCAwID8gbGV2ZWwgOiAzIC8qIFVwZGF0ZUxldmVsLkRyYXdlciAqLywgdGhpcy5fY29udGFpbmVyLCB0aGlzLl9ib3VuZGluZyk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFuZTtcbn0oKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIERyYXdQYW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3UGFuZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcmF3UGFuZShjaGFydCwgaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2hhcnQsIGlkKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5feUF4aXNXaWRnZXQgPSBudWxsO1xuICAgICAgICBfdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiAnJyxcbiAgICAgICAgICAgIG1pbkhlaWdodDogUEFORV9NSU5fSEVJR0hULFxuICAgICAgICAgICAgZHJhZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBvcmRlcjogMCxcbiAgICAgICAgICAgIGhlaWdodDogUEFORV9ERUZBVUxUX0hFSUdIVCxcbiAgICAgICAgICAgIHN0YXRlOiBcIm5vcm1hbFwiIC8qIFBhbmVTdGF0ZS5Ob3JtYWwgKi8sXG4gICAgICAgICAgICBheGlzOiB7IG5hbWU6ICdub3JtYWwnLCBzY3JvbGxab29tRW5hYmxlZDogdHJ1ZSB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICAgICAgX3RoaXMuX21haW5XaWRnZXQgPSBfdGhpcy5jcmVhdGVNYWluV2lkZ2V0KGNvbnRhaW5lcik7XG4gICAgICAgIF90aGlzLl95QXhpc1dpZGdldCA9IF90aGlzLmNyZWF0ZVlBeGlzV2lkZ2V0KGNvbnRhaW5lcik7XG4gICAgICAgIF90aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB2YXIgcGFuZUlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICBpZiAocGFuZUlkID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFIHx8IHBhbmVJZCA9PT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgdmFyIGF4aXNOYW1lID0gKF9hID0gb3B0aW9ucy5heGlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0aGlzLl9heGlzKSB8fFxuICAgICAgICAgICAgICAgIChpc1ZhbGlkKGF4aXNOYW1lKSAmJiB0aGlzLl9vcHRpb25zLmF4aXMubmFtZSAhPT0gYXhpc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpcyA9IHRoaXMuY3JlYXRlQXhpc0NvbXBvbmVudChheGlzTmFtZSAhPT0gbnVsbCAmJiBheGlzTmFtZSAhPT0gdm9pZCAwID8gYXhpc05hbWUgOiAnbm9ybWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5fYXhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGlzID0gdGhpcy5jcmVhdGVBeGlzQ29tcG9uZW50KCdub3JtYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXhpcyBpbnN0YW5jZW9mIFlBeGlzSW1wKSB7XG4gICAgICAgICAgICB0aGlzLl9heGlzLnNldEF1dG9DYWxjVGlja0ZsYWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UodGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2F4aXMub3ZlcnJpZGUoX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMuYXhpcyksIHsgbmFtZTogKF9jID0gKF9iID0gb3B0aW9ucy5heGlzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ25vcm1hbCcgfSkpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKHRoaXMuZ2V0SWQoKSA9PT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5nZXRNYWluV2lkZ2V0KCkuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuZ2V0WUF4aXNXaWRnZXQoKS5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGN1cnNvciA9ICducy1yZXNpemUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2UgPSAoX2QgPSBvcHRpb25zLmF4aXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zY3JvbGxab29tRW5hYmxlZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdHJ1ZSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLmdldEF4aXNDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9heGlzO1xuICAgIH07XG4gICAgRHJhd1BhbmUucHJvdG90eXBlLnNldEJvdW5kaW5nID0gZnVuY3Rpb24gKHJvb3RCb3VuZGluZywgbWFpbkJvdW5kaW5nLCBsZWZ0WUF4aXNCb3VuZGluZywgcmlnaHRZQXhpc0JvdW5kaW5nKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbWVyZ2UodGhpcy5nZXRCb3VuZGluZygpLCByb290Qm91bmRpbmcpO1xuICAgICAgICB2YXIgY29udGVudEJvdW5kaW5nID0ge307XG4gICAgICAgIGlmIChpc1ZhbGlkKHJvb3RCb3VuZGluZy5oZWlnaHQpKSB7XG4gICAgICAgICAgICBjb250ZW50Qm91bmRpbmcuaGVpZ2h0ID0gcm9vdEJvdW5kaW5nLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZChyb290Qm91bmRpbmcudG9wKSkge1xuICAgICAgICAgICAgY29udGVudEJvdW5kaW5nLnRvcCA9IHJvb3RCb3VuZGluZy50b3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFpbldpZGdldC5zZXRCb3VuZGluZyhjb250ZW50Qm91bmRpbmcpO1xuICAgICAgICB2YXIgbWFpbkJvdW5kaW5nVmFsaWQgPSBpc1ZhbGlkKG1haW5Cb3VuZGluZyk7XG4gICAgICAgIGlmIChtYWluQm91bmRpbmdWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFpbldpZGdldC5zZXRCb3VuZGluZyhtYWluQm91bmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX3lBeGlzV2lkZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5feUF4aXNXaWRnZXQuc2V0Qm91bmRpbmcoY29udGVudEJvdW5kaW5nKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuX2F4aXM7XG4gICAgICAgICAgICBpZiAoeUF4aXMucG9zaXRpb24gPT09IEF4aXNQb3NpdGlvbi5MZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQobGVmdFlBeGlzQm91bmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3lBeGlzV2lkZ2V0LnNldEJvdW5kaW5nKF9fYXNzaWduKF9fYXNzaWduKHt9LCBsZWZ0WUF4aXNCb3VuZGluZyksIHsgbGVmdDogMCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQocmlnaHRZQXhpc0JvdW5kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl95QXhpc1dpZGdldC5zZXRCb3VuZGluZyhyaWdodFlBeGlzQm91bmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbkJvdW5kaW5nVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lBeGlzV2lkZ2V0LnNldEJvdW5kaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAoKF9hID0gbWFpbkJvdW5kaW5nLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IG1haW5Cb3VuZGluZy53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gbWFpbkJvdW5kaW5nLnJpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2QgPSByaWdodFlBeGlzQm91bmRpbmcud2lkdGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERyYXdQYW5lLnByb3RvdHlwZS5nZXRNYWluV2lkZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFpbldpZGdldDsgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuZ2V0WUF4aXNXaWRnZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl95QXhpc1dpZGdldDsgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUudXBkYXRlSW1wID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fbWFpbldpZGdldC51cGRhdGUobGV2ZWwpO1xuICAgICAgICAoX2EgPSB0aGlzLl95QXhpc1dpZGdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZShsZXZlbCk7XG4gICAgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9tYWluV2lkZ2V0LmRlc3Ryb3koKTtcbiAgICAgICAgKF9hID0gdGhpcy5feUF4aXNXaWRnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoaW5jbHVkZU92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRCb3VuZGluZygpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVEb20oJ2NhbnZhcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgdmFyIG1haW5Cb3VuZGluZyA9IHRoaXMuX21haW5XaWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9tYWluV2lkZ2V0LmdldEltYWdlKGluY2x1ZGVPdmVybGF5KSwgbWFpbkJvdW5kaW5nLmxlZnQsIDAsIG1haW5Cb3VuZGluZy53aWR0aCwgbWFpbkJvdW5kaW5nLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLl95QXhpc1dpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHlBeGlzQm91bmRpbmcgPSB0aGlzLl95QXhpc1dpZGdldC5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl95QXhpc1dpZGdldC5nZXRJbWFnZShpbmNsdWRlT3ZlcmxheSksIHlBeGlzQm91bmRpbmcubGVmdCwgMCwgeUF4aXNCb3VuZGluZy53aWR0aCwgeUF4aXNCb3VuZGluZy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcbiAgICBEcmF3UGFuZS5wcm90b3R5cGUuY3JlYXRlWUF4aXNXaWRnZXQgPSBmdW5jdGlvbiAoX2NvbnRhaW5lcikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gRHJhd1BhbmU7XG59KFBhbmUpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgSW5kaWNhdG9yUGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5kaWNhdG9yUGFuZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmRpY2F0b3JQYW5lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluZGljYXRvclBhbmUucHJvdG90eXBlLmNyZWF0ZUF4aXNDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgWUF4aXNDbGFzcyA9IGdldFlBeGlzQ2xhc3MobmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogJ2RlZmF1bHQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBZQXhpc0NsYXNzKHRoaXMpO1xuICAgIH07XG4gICAgSW5kaWNhdG9yUGFuZS5wcm90b3R5cGUuY3JlYXRlTWFpbldpZGdldCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRpY2F0b3JXaWRnZXQoY29udGFpbmVyLCB0aGlzKTtcbiAgICB9O1xuICAgIEluZGljYXRvclBhbmUucHJvdG90eXBlLmNyZWF0ZVlBeGlzV2lkZ2V0ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFlBeGlzV2lkZ2V0KGNvbnRhaW5lciwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5kaWNhdG9yUGFuZTtcbn0oRHJhd1BhbmUpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgQ2FuZGxlUGFuZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FuZGxlUGFuZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYW5kbGVQYW5lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhbmRsZVBhbmUucHJvdG90eXBlLmNyZWF0ZU1haW5XaWRnZXQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FuZGxlV2lkZ2V0KGNvbnRhaW5lciwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FuZGxlUGFuZTtcbn0oSW5kaWNhdG9yUGFuZSkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBYQXhpc1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhBeGlzVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWEF4aXNWaWV3LnByb3RvdHlwZS5nZXRBeGlzU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLnhBeGlzO1xuICAgIH07XG4gICAgWEF4aXNWaWV3LnByb3RvdHlwZS5jcmVhdGVBeGlzTGluZSA9IGZ1bmN0aW9uIChib3VuZGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGJvdW5kaW5nLndpZHRoLCB5OiAwIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhBeGlzVmlldy5wcm90b3R5cGUuY3JlYXRlVGlja0xpbmVzID0gZnVuY3Rpb24gKHRpY2tzLCBfYm91bmRpbmcsIHN0eWxlcykge1xuICAgICAgICB2YXIgdGlja0xpbmVTdHlsZXMgPSBzdHlsZXMudGlja0xpbmU7XG4gICAgICAgIHZhciBheGlzTGluZVNpemUgPSBzdHlsZXMuYXhpc0xpbmUuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRpY2tzLm1hcChmdW5jdGlvbiAodGljaykgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgeyB4OiB0aWNrLmNvb3JkLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0aWNrLmNvb3JkLCB5OiBheGlzTGluZVNpemUgKyB0aWNrTGluZVN0eWxlcy5sZW5ndGggfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBYQXhpc1ZpZXcucHJvdG90eXBlLmNyZWF0ZVRpY2tUZXh0cyA9IGZ1bmN0aW9uICh0aWNrcywgX2JvdW5kaW5nLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIHRpY2tUaWNrU3R5bGVzID0gc3R5bGVzLnRpY2tUZXh0O1xuICAgICAgICB2YXIgYXhpc0xpbmVTaXplID0gc3R5bGVzLmF4aXNMaW5lLnNpemU7XG4gICAgICAgIHZhciB0aWNrTGluZUxlbmd0aCA9IHN0eWxlcy50aWNrTGluZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aWNrcy5tYXAoZnVuY3Rpb24gKHRpY2spIHsgcmV0dXJuICh7XG4gICAgICAgICAgICB4OiB0aWNrLmNvb3JkLFxuICAgICAgICAgICAgeTogYXhpc0xpbmVTaXplICsgdGlja0xpbmVMZW5ndGggKyB0aWNrVGlja1N0eWxlcy5tYXJnaW5TdGFydCxcbiAgICAgICAgICAgIHRleHQ6IHRpY2sudGV4dCxcbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGJhc2VsaW5lOiAndG9wJ1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gWEF4aXNWaWV3O1xufShBeGlzVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBPdmVybGF5WEF4aXNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdmVybGF5WEF4aXNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlYQXhpc1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT3ZlcmxheVhBeGlzVmlldy5wcm90b3R5cGUuY29vcmRpbmF0ZVRvUG9pbnRUaW1lc3RhbXBEYXRhSW5kZXhGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE92ZXJsYXlYQXhpc1ZpZXcucHJvdG90eXBlLmNvb3JkaW5hdGVUb1BvaW50VmFsdWVGbGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBPdmVybGF5WEF4aXNWaWV3LnByb3RvdHlwZS5nZXRDb21wbGV0ZU92ZXJsYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuZ2V0T3ZlcmxheXNCeVBhbmVJZCgpO1xuICAgIH07XG4gICAgT3ZlcmxheVhBeGlzVmlldy5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3NPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5nZXRXaWRnZXQoKS5nZXRQYW5lKCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCkuZ2V0UHJvZ3Jlc3NPdmVybGF5SW5mbygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3ZlcmxheSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICB9O1xuICAgIE92ZXJsYXlYQXhpc1ZpZXcucHJvdG90eXBlLmdldERlZmF1bHRGaWd1cmVzID0gZnVuY3Rpb24gKG92ZXJsYXksIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGZpZ3VyZXMgPSBbXTtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuZ2V0V2lkZ2V0KCk7XG4gICAgICAgIHZhciBwYW5lID0gd2lkZ2V0LmdldFBhbmUoKTtcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSBwYW5lLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgY2xpY2tPdmVybGF5SW5mbyA9IGNoYXJ0U3RvcmUuZ2V0Q2xpY2tPdmVybGF5SW5mbygpO1xuICAgICAgICBpZiAob3ZlcmxheS5uZWVkRGVmYXVsdFhBeGlzRmlndXJlICYmIG92ZXJsYXkuaWQgPT09ICgoX2EgPSBjbGlja092ZXJsYXlJbmZvLm92ZXJsYXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0WF8xID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB2YXIgcmlnaHRYXzEgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkaW5hdGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGVmdFhfMSA9IE1hdGgubWluKGxlZnRYXzEsIGNvb3JkaW5hdGUueCk7XG4gICAgICAgICAgICAgICAgcmlnaHRYXzEgPSBNYXRoLm1heChyaWdodFhfMSwgY29vcmRpbmF0ZS54KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBvdmVybGF5LnBvaW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHBvaW50LnRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBjaGFydFN0b3JlLmdldEN1c3RvbUFwaSgpLmZvcm1hdERhdGUocG9pbnQudGltZXN0YW1wLCAnWVlZWS1NTS1ERCBISDptbScsIEZvcm1hdERhdGVUeXBlLkNyb3NzaGFpcik7XG4gICAgICAgICAgICAgICAgICAgIGZpZ3VyZXMucHVzaCh7IHR5cGU6ICd0ZXh0JywgYXR0cnM6IHsgeDogY29vcmRpbmF0ZS54LCB5OiAwLCB0ZXh0OiB0ZXh0LCBhbGlnbjogJ2NlbnRlcicgfSwgaWdub3JlRXZlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZpZ3VyZXMudW5zaGlmdCh7IHR5cGU6ICdyZWN0JywgYXR0cnM6IHsgeDogbGVmdFhfMSwgeTogMCwgd2lkdGg6IHJpZ2h0WF8xIC0gbGVmdFhfMSwgaGVpZ2h0OiB3aWRnZXQuZ2V0Qm91bmRpbmcoKS5oZWlnaHQgfSwgaWdub3JlRXZlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZ3VyZXM7XG4gICAgfTtcbiAgICBPdmVybGF5WEF4aXNWaWV3LnByb3RvdHlwZS5nZXRGaWd1cmVzID0gZnVuY3Rpb24gKG8sIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLmdldFdpZGdldCgpO1xuICAgICAgICB2YXIgcGFuZSA9IHdpZGdldC5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdmFyIHlBeGlzID0gcGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgIHZhciB4QXhpcyA9IGNoYXJ0LmdldFhBeGlzUGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgdmFyIGJvdW5kaW5nID0gd2lkZ2V0LmdldEJvdW5kaW5nKCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBvLmNyZWF0ZVhBeGlzRmlndXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobywgeyBjaGFydDogY2hhcnQsIG92ZXJsYXk6IG8sIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcywgYm91bmRpbmc6IGJvdW5kaW5nLCB4QXhpczogeEF4aXMsIHlBeGlzOiB5QXhpcyB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVhBeGlzVmlldztcbn0oT3ZlcmxheVlBeGlzVmlldykpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBDcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXcucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoY3Jvc3NoYWlyKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKGNyb3NzaGFpci50aW1lc3RhbXApO1xuICAgIH07XG4gICAgQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXcucHJvdG90eXBlLmdldERpcmVjdGlvblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy52ZXJ0aWNhbDtcbiAgICB9O1xuICAgIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGNyb3NzaGFpciwgY2hhcnRTdG9yZSkge1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gY3Jvc3NoYWlyLnRpbWVzdGFtcDtcbiAgICAgICAgcmV0dXJuIGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCkuZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdZWVlZLU1NLUREIEhIOm1tJywgRm9ybWF0RGF0ZVR5cGUuQ3Jvc3NoYWlyKTtcbiAgICB9O1xuICAgIENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LnByb3RvdHlwZS5nZXRUZXh0QXR0cnMgPSBmdW5jdGlvbiAodGV4dCwgdGV4dFdpZHRoLCBjcm9zc2hhaXIsIGJvdW5kaW5nLCBfYXhpcywgc3R5bGVzKSB7XG4gICAgICAgIHZhciB4ID0gY3Jvc3NoYWlyLnJlYWxYO1xuICAgICAgICB2YXIgb3B0aW1hbFggPSAwO1xuICAgICAgICB2YXIgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgaWYgKHggLSB0ZXh0V2lkdGggLyAyIC0gc3R5bGVzLnBhZGRpbmdMZWZ0IDwgMCkge1xuICAgICAgICAgICAgb3B0aW1hbFggPSAwO1xuICAgICAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCArIHRleHRXaWR0aCAvIDIgKyBzdHlsZXMucGFkZGluZ1JpZ2h0ID4gYm91bmRpbmcud2lkdGgpIHtcbiAgICAgICAgICAgIG9wdGltYWxYID0gYm91bmRpbmcud2lkdGg7XG4gICAgICAgICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpbWFsWCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogb3B0aW1hbFgsIHk6IDAsIHRleHQ6IHRleHQsIGFsaWduOiBhbGlnbiwgYmFzZWxpbmU6ICd0b3AnIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXc7XG59KENyb3NzaGFpckhvcml6b250YWxMYWJlbFZpZXcpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgWEF4aXNXaWRnZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhBeGlzV2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhBeGlzV2lkZ2V0KHJvb3RDb250YWluZXIsIHBhbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdENvbnRhaW5lciwgcGFuZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3hBeGlzVmlldyA9IG5ldyBYQXhpc1ZpZXcoX3RoaXMpO1xuICAgICAgICBfdGhpcy5fb3ZlcmxheVhBeGlzVmlldyA9IG5ldyBPdmVybGF5WEF4aXNWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2Nyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3ID0gbmV3IENyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3KF90aGlzKTtcbiAgICAgICAgX3RoaXMuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLl9vdmVybGF5WEF4aXNWaWV3KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYQXhpc1dpZGdldC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldE5hbWVDb25zdGFudHMuWF9BWElTO1xuICAgIH07XG4gICAgWEF4aXNXaWRnZXQucHJvdG90eXBlLnVwZGF0ZU1haW4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHRoaXMuX3hBeGlzVmlldy5kcmF3KGN0eCk7XG4gICAgfTtcbiAgICBYQXhpc1dpZGdldC5wcm90b3R5cGUudXBkYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVhBeGlzVmlldy5kcmF3KGN0eCk7XG4gICAgICAgIHRoaXMuX2Nyb3NzaGFpclZlcnRpY2FsTGFiZWxWaWV3LmRyYXcoY3R4KTtcbiAgICB9O1xuICAgIHJldHVybiBYQXhpc1dpZGdldDtcbn0oRHJhd1dpZGdldCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBYQXhpc0ltcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWEF4aXNJbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWEF4aXNJbXAocGFyZW50LCB4QXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm92ZXJyaWRlKHhBeGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYQXhpc0ltcC5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB4QXhpcy5uYW1lLCBzY3JvbGxab29tRW5hYmxlZCA9IHhBeGlzLnNjcm9sbFpvb21FbmFibGVkLCBjcmVhdGVUaWNrcyA9IHhBeGlzLmNyZWF0ZVRpY2tzO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxab29tRW5hYmxlZCA9IHNjcm9sbFpvb21FbmFibGVkICE9PSBudWxsICYmIHNjcm9sbFpvb21FbmFibGVkICE9PSB2b2lkIDAgPyBzY3JvbGxab29tRW5hYmxlZCA6IHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVGlja3MgPSBjcmVhdGVUaWNrcyAhPT0gbnVsbCAmJiBjcmVhdGVUaWNrcyAhPT0gdm9pZCAwID8gY3JlYXRlVGlja3MgOiB0aGlzLmNyZWF0ZVRpY2tzO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNyZWF0ZVJhbmdlSW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciB2aXNpYmxlRGF0YVJhbmdlID0gY2hhcnRTdG9yZS5nZXRWaXNpYmxlUmFuZ2UoKTtcbiAgICAgICAgdmFyIHJlYWxGcm9tID0gdmlzaWJsZURhdGFSYW5nZS5yZWFsRnJvbSwgcmVhbFRvID0gdmlzaWJsZURhdGFSYW5nZS5yZWFsVG87XG4gICAgICAgIHZhciBhZiA9IHJlYWxGcm9tO1xuICAgICAgICB2YXIgYXQgPSByZWFsVG87XG4gICAgICAgIHZhciBkaWZmID0gcmVhbFRvIC0gcmVhbEZyb20gKyAxO1xuICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBhZixcbiAgICAgICAgICAgIHRvOiBhdCxcbiAgICAgICAgICAgIHJhbmdlOiBkaWZmLFxuICAgICAgICAgICAgcmVhbEZyb206IGFmLFxuICAgICAgICAgICAgcmVhbFRvOiBhdCxcbiAgICAgICAgICAgIHJlYWxSYW5nZTogZGlmZixcbiAgICAgICAgICAgIGRpc3BsYXlGcm9tOiBhZixcbiAgICAgICAgICAgIGRpc3BsYXlUbzogYXQsXG4gICAgICAgICAgICBkaXNwbGF5UmFuZ2U6IGRpZmZcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNyZWF0ZVRpY2tzSW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFJhbmdlKCksIHJlYWxGcm9tID0gX2EucmVhbEZyb20sIHJlYWxUbyA9IF9hLnJlYWxUbztcbiAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLmdldFBhcmVudCgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICB2YXIgZm9ybWF0RGF0ZSA9IGNoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCkuZm9ybWF0RGF0ZTtcbiAgICAgICAgdmFyIHRpbWVXZWlnaHRUaWNrTGlzdCA9IGNoYXJ0U3RvcmUuZ2V0VGltZVdlaWdodFRpY2tMaXN0KCk7XG4gICAgICAgIHZhciB0aWNrcyA9IFtdO1xuICAgICAgICB2YXIgZml0VGlja3MgPSBmdW5jdGlvbiAobGlzdCwgc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsaXN0XzEgPSBfX3ZhbHVlcyhsaXN0KSwgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpOyAhbGlzdF8xXzEuZG9uZTsgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lV2VpZ2h0VGljayA9IGxpc3RfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZVdlaWdodFRpY2suZGF0YUluZGV4ID49IHN0YXJ0ICYmIHRpbWVXZWlnaHRUaWNrLmRhdGFJbmRleCA8IHJlYWxUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHRpbWVXZWlnaHRUaWNrLnRpbWVzdGFtcCwgd2VpZ2h0ID0gdGltZVdlaWdodFRpY2sud2VpZ2h0LCBkYXRhSW5kZXggPSB0aW1lV2VpZ2h0VGljay5kYXRhSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh3ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbWVXZWlnaHRDb25zdGFudHMuWWVhcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdZWVlZJywgRm9ybWF0RGF0ZVR5cGUuWEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaW1lV2VpZ2h0Q29uc3RhbnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXREYXRlKHRpbWVzdGFtcCwgJ1lZWVktTU0nLCBGb3JtYXREYXRlVHlwZS5YQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRpbWVXZWlnaHRDb25zdGFudHMuRGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXREYXRlKHRpbWVzdGFtcCwgJ01NLUREJywgRm9ybWF0RGF0ZVR5cGUuWEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaW1lV2VpZ2h0Q29uc3RhbnRzLkhvdXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUaW1lV2VpZ2h0Q29uc3RhbnRzLk1pbnV0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZm9ybWF0RGF0ZSh0aW1lc3RhbXAsICdISDptbScsIEZvcm1hdERhdGVUeXBlLlhBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVGltZVdlaWdodENvbnN0YW50cy5TZWNvbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGZvcm1hdERhdGUodGltZXN0YW1wLCAnSEg6bW06c3MnLCBGb3JtYXREYXRlVHlwZS5YQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBmb3JtYXREYXRlKHRpbWVzdGFtcCwgJ1lZWVktTU0tREQgSEg6bW0nLCBGb3JtYXREYXRlVHlwZS5YQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkOiBfdGhpcy5jb252ZXJ0VG9QaXhlbChkYXRhSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RfMV8xICYmICFsaXN0XzFfMS5kb25lICYmIChfYSA9IGxpc3RfMS5yZXR1cm4pKSBfYS5jYWxsKGxpc3RfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZml0VGlja3ModGltZVdlaWdodFRpY2tMaXN0LCByZWFsRnJvbSk7XG4gICAgICAgIC8vIEZ1dHVyZSB0aW1lIHRpY2tcbiAgICAgICAgaWYgKHRpbWVXZWlnaHRUaWNrTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgYmFyU3BhY2UgPSBjaGFydFN0b3JlLmdldEJhclNwYWNlKCkuYmFyO1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZXMgPSBjaGFydFN0b3JlLmdldFN0eWxlcygpLnhBeGlzLnRpY2tUZXh0O1xuICAgICAgICAgICAgdmFyIGJhckNvdW50ID0gY2FsY0JldHdlZW5UaW1lV2VpZ2h0VGlja0JhckNvdW50KGJhclNwYWNlLCB0ZXh0U3R5bGVzKTtcbiAgICAgICAgICAgIHZhciBzdGFydERhdGFJbmRleCA9IHRpbWVXZWlnaHRUaWNrTGlzdFt0aW1lV2VpZ2h0VGlja0xpc3QubGVuZ3RoIC0gMV0uZGF0YUluZGV4ICsgYmFyQ291bnQgLSAxO1xuICAgICAgICAgICAgdmFyIGRhdGFMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnREYXRhSW5kZXg7IGkgPCByZWFsVG87IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBjaGFydFN0b3JlLmRhdGFJbmRleFRvVGltZXN0YW1wKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFMaXN0LnB1c2goeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgY2xhc3NpZnlUaW1lV2VpZ2h0VGlja3MobWFwLCBkYXRhTGlzdCwgY2hhcnRTdG9yZS5nZXREYXRlVGltZUZvcm1hdCgpLCBzdGFydERhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgZml0VGlja3MoY3JlYXRlVGltZVdlaWdodFRpY2tMaXN0KG1hcCwgYmFyU3BhY2UsIHRleHRTdHlsZXMpLCBzdGFydERhdGFJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5jcmVhdGVUaWNrcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRpY2tzKHtcbiAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5nZXRSYW5nZSgpLFxuICAgICAgICAgICAgICAgIGJvdW5kaW5nOiB0aGlzLmdldEJvdW5kaW5nKCksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRpY2tzOiB0aWNrc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmdldEF1dG9TaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRQYXJlbnQoKS5nZXRDaGFydCgpLmdldFN0eWxlcygpO1xuICAgICAgICB2YXIgeEF4aXNTdHlsZXMgPSBzdHlsZXMueEF4aXM7XG4gICAgICAgIHZhciBoZWlnaHQgPSB4QXhpc1N0eWxlcy5zaXplO1xuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNyb3NzaGFpclN0eWxlcyA9IHN0eWxlcy5jcm9zc2hhaXI7XG4gICAgICAgIHZhciB4QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIGlmICh4QXhpc1N0eWxlcy5zaG93KSB7XG4gICAgICAgICAgICBpZiAoeEF4aXNTdHlsZXMuYXhpc0xpbmUuc2hvdykge1xuICAgICAgICAgICAgICAgIHhBeGlzSGVpZ2h0ICs9IHhBeGlzU3R5bGVzLmF4aXNMaW5lLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeEF4aXNTdHlsZXMudGlja0xpbmUuc2hvdykge1xuICAgICAgICAgICAgICAgIHhBeGlzSGVpZ2h0ICs9IHhBeGlzU3R5bGVzLnRpY2tMaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4QXhpc1N0eWxlcy50aWNrVGV4dC5zaG93KSB7XG4gICAgICAgICAgICAgICAgeEF4aXNIZWlnaHQgKz0gKHhBeGlzU3R5bGVzLnRpY2tUZXh0Lm1hcmdpblN0YXJ0ICsgeEF4aXNTdHlsZXMudGlja1RleHQubWFyZ2luRW5kICsgeEF4aXNTdHlsZXMudGlja1RleHQuc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNyb3NzaGFpclZlcnRpY2FsVGV4dEhlaWdodCA9IDA7XG4gICAgICAgIGlmIChjcm9zc2hhaXJTdHlsZXMuc2hvdyAmJlxuICAgICAgICAgICAgY3Jvc3NoYWlyU3R5bGVzLnZlcnRpY2FsLnNob3cgJiZcbiAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC50ZXh0LnNob3cpIHtcbiAgICAgICAgICAgIGNyb3NzaGFpclZlcnRpY2FsVGV4dEhlaWdodCArPSAoY3Jvc3NoYWlyU3R5bGVzLnZlcnRpY2FsLnRleHQucGFkZGluZ1RvcCArXG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyU3R5bGVzLnZlcnRpY2FsLnRleHQucGFkZGluZ0JvdHRvbSArXG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyU3R5bGVzLnZlcnRpY2FsLnRleHQuYm9yZGVyU2l6ZSAqIDIgK1xuICAgICAgICAgICAgICAgIGNyb3NzaGFpclN0eWxlcy52ZXJ0aWNhbC50ZXh0LnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh4QXhpc0hlaWdodCwgY3Jvc3NoYWlyVmVydGljYWxUZXh0SGVpZ2h0KTtcbiAgICB9O1xuICAgIFhBeGlzSW1wLnByb3RvdHlwZS5nZXRCb3VuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KCkuZ2V0TWFpbldpZGdldCgpLmdldEJvdW5kaW5nKCk7XG4gICAgfTtcbiAgICBYQXhpc0ltcC5wcm90b3R5cGUuY29udmVydFRpbWVzdGFtcEZyb21QaXhlbCA9IGZ1bmN0aW9uIChwaXhlbCkge1xuICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0Q2hhcnQoKS5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHZhciBkYXRhSW5kZXggPSBjaGFydFN0b3JlLmNvb3JkaW5hdGVUb0RhdGFJbmRleChwaXhlbCk7XG4gICAgICAgIHJldHVybiBjaGFydFN0b3JlLmRhdGFJbmRleFRvVGltZXN0YW1wKGRhdGFJbmRleCk7XG4gICAgfTtcbiAgICBYQXhpc0ltcC5wcm90b3R5cGUuY29udmVydFRpbWVzdGFtcFRvUGl4ZWwgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5nZXRQYXJlbnQoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGNoYXJ0U3RvcmUudGltZXN0YW1wVG9EYXRhSW5kZXgodGltZXN0YW1wKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0U3RvcmUuZGF0YUluZGV4VG9Db29yZGluYXRlKGRhdGFJbmRleCk7XG4gICAgfTtcbiAgICBYQXhpc0ltcC5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChwaXhlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKS5nZXRDaGFydCgpLmdldENoYXJ0U3RvcmUoKS5jb29yZGluYXRlVG9EYXRhSW5kZXgocGl4ZWwpO1xuICAgIH07XG4gICAgWEF4aXNJbXAucHJvdG90eXBlLmNvbnZlcnRUb1BpeGVsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpLmdldENoYXJ0KCkuZ2V0Q2hhcnRTdG9yZSgpLmRhdGFJbmRleFRvQ29vcmRpbmF0ZSh2YWx1ZSk7XG4gICAgfTtcbiAgICBYQXhpc0ltcC5leHRlbmQgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIEN1c3RvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDdXN0b20sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBDdXN0b20ocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgdGVtcGxhdGUpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tO1xuICAgICAgICB9KFhBeGlzSW1wKSk7XG4gICAgICAgIHJldHVybiBDdXN0b207XG4gICAgfTtcbiAgICByZXR1cm4gWEF4aXNJbXA7XG59KEF4aXNJbXApKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbm9ybWFsID0ge1xuICAgIG5hbWU6ICdub3JtYWwnXG59O1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB4QXhpc2VzID0ge1xuICAgIG5vcm1hbDogWEF4aXNJbXAuZXh0ZW5kKG5vcm1hbClcbn07XG5mdW5jdGlvbiByZWdpc3RlclhBeGlzKGF4aXMpIHtcbiAgICB4QXhpc2VzW2F4aXMubmFtZV0gPSBYQXhpc0ltcC5leHRlbmQoYXhpcyk7XG59XG5mdW5jdGlvbiBnZXRYQXhpc0NsYXNzKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHhBeGlzZXNbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHhBeGlzZXMubm9ybWFsO1xufVxuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBYQXhpc1BhbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhBeGlzUGFuZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYQXhpc1BhbmUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWEF4aXNQYW5lLnByb3RvdHlwZS5jcmVhdGVBeGlzQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIFhBeGlzQ2xhc3MgPSBnZXRYQXhpc0NsYXNzKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IFhBeGlzQ2xhc3ModGhpcyk7XG4gICAgfTtcbiAgICBYQXhpc1BhbmUucHJvdG90eXBlLmNyZWF0ZU1haW5XaWRnZXQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWEF4aXNXaWRnZXQoY29udGFpbmVyLCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBYQXhpc1BhbmU7XG59KERyYXdQYW5lKSk7XG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSBwcmV2aW91cyA+ICh3YWl0ICkpIHtcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIGV4cG9ydCBmdW5jdGlvbiBtZW1vaXplPFIxID0gYW55LCBSMiA9IGFueT4gKGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gUjEsIHJlc29sdmVyPzogKC4uLmFyZ3M6IGFueVtdKSA9PiBSMik6ICguLi5hcmdzOiBhbnlbXSkgPT4gUjEge1xuLy8gICBpZiAoIWlzRnVuY3Rpb24oZnVuYykgfHwgKGlzVmFsaWQocmVzb2x2ZXIpICYmICFpc0Z1bmN0aW9uKHJlc29sdmVyKSkpIHtcbi8vICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJylcbi8vICAgfVxuLy8gICBjb25zdCBtZW1vaXplZCA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSk6IGFueSB7XG4vLyAgICAgY29uc3Qga2V5ID0gaXNGdW5jdGlvbihyZXNvbHZlcikgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF1cbi8vICAgICBjb25zdCBjYWNoZSA9IG1lbW9pemVkLmNhY2hlXG4vLyAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4vLyAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSlcbi8vICAgICB9XG4vLyAgICAgY29uc3QgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKVxuLy8gICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbi8vICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGVcbi8vICAgICByZXR1cm4gcmVzdWx0XG4vLyAgIH1cbi8vICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuLy8gICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXApKClcbi8vICAgcmV0dXJuIG1lbW9pemVkXG4vLyB9XG4vLyBtZW1vaXplLkNhY2hlID0gTWFwXG5cbi8qKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIFNlcGFyYXRvcldpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VwYXJhdG9yV2lkZ2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcGFyYXRvcldpZGdldChyb290Q29udGFpbmVyLCBwYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RDb250YWluZXIsIHBhbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9kcmFnRmxhZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZHJhZ1N0YXJ0WSA9IDA7XG4gICAgICAgIF90aGlzLl90b3BQYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuX2JvdHRvbVBhbmVIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy5fdG9wUGFuZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9ib3R0b21QYW5lID0gbnVsbDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCAtLSBpZ25vcmVcbiAgICAgICAgX3RoaXMuX3ByZXNzZWRNb3VzZU1vdmVFdmVudCA9IHRocm90dGxlKF90aGlzLl9wcmVzc2VkVG91Y2hNb3VzZU1vdmVFdmVudCwgMjApO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJFdmVudCgndG91Y2hTdGFydEV2ZW50JywgX3RoaXMuX21vdXNlRG93bkV2ZW50LmJpbmQoX3RoaXMpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAucmVnaXN0ZXJFdmVudCgndG91Y2hNb3ZlRXZlbnQnLCBfdGhpcy5fcHJlc3NlZE1vdXNlTW92ZUV2ZW50LmJpbmQoX3RoaXMpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAucmVnaXN0ZXJFdmVudCgndG91Y2hFbmRFdmVudCcsIF90aGlzLl9tb3VzZVVwRXZlbnQuYmluZChfdGhpcykpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC5yZWdpc3RlckV2ZW50KCdtb3VzZURvd25FdmVudCcsIF90aGlzLl9tb3VzZURvd25FdmVudC5iaW5kKF90aGlzKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLnJlZ2lzdGVyRXZlbnQoJ21vdXNlVXBFdmVudCcsIF90aGlzLl9tb3VzZVVwRXZlbnQuYmluZChfdGhpcykpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC5yZWdpc3RlckV2ZW50KCdwcmVzc2VkTW91c2VNb3ZlRXZlbnQnLCBfdGhpcy5fcHJlc3NlZE1vdXNlTW92ZUV2ZW50LmJpbmQoX3RoaXMpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAucmVnaXN0ZXJFdmVudCgnbW91c2VFbnRlckV2ZW50JywgX3RoaXMuX21vdXNlRW50ZXJFdmVudC5iaW5kKF90aGlzKSlcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50IC0tIGlnbm9yZVxuICAgICAgICAgICAgLnJlZ2lzdGVyRXZlbnQoJ21vdXNlTGVhdmVFdmVudCcsIF90aGlzLl9tb3VzZUxlYXZlRXZlbnQuYmluZChfdGhpcykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFdpZGdldE5hbWVDb25zdGFudHMuU0VQQVJBVE9SO1xuICAgIH07XG4gICAgU2VwYXJhdG9yV2lkZ2V0LnByb3RvdHlwZS5jaGVja0V2ZW50T24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU2VwYXJhdG9yV2lkZ2V0LnByb3RvdHlwZS5fbW91c2VEb3duRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZHJhZ0ZsYWcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXRQYW5lKCk7XG4gICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgdGhpcy5fdG9wUGFuZSA9IHBhbmUuZ2V0VG9wUGFuZSgpO1xuICAgICAgICB0aGlzLl9ib3R0b21QYW5lID0gcGFuZS5nZXRCb3R0b21QYW5lKCk7XG4gICAgICAgIHZhciBkcmF3UGFuZXMgPSBjaGFydC5nZXREcmF3UGFuZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3RvcFBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlID09PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBkcmF3UGFuZXMuZmluZEluZGV4KGZ1bmN0aW9uIChwYW5lKSB7IHZhciBfYTsgcmV0dXJuIHBhbmUuZ2V0SWQoKSA9PT0gKChfYSA9IF90aGlzLl90b3BQYW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SWQoKSk7IH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4IC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZV8xID0gZHJhd1BhbmVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lXzEuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvcFBhbmUgPSBwYW5lXzE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYm90dG9tUGFuZS5nZXRPcHRpb25zKCkuc3RhdGUgPT09IFwibWluaW1pemVcIiAvKiBQYW5lU3RhdGUuTWluaW1pemUgKi8pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGRyYXdQYW5lcy5maW5kSW5kZXgoZnVuY3Rpb24gKHBhbmUpIHsgdmFyIF9hOyByZXR1cm4gcGFuZS5nZXRJZCgpID09PSAoKF9hID0gX3RoaXMuX2JvdHRvbVBhbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRJZCgpKTsgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxOyBpIDwgZHJhd1BhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVfMiA9IGRyYXdQYW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZV8yLmdldE9wdGlvbnMoKS5zdGF0ZSAhPT0gXCJtaW5pbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NaW5pbWl6ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib3R0b21QYW5lID0gcGFuZV8yO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdG9wUGFuZUhlaWdodCA9IHRoaXMuX3RvcFBhbmUuZ2V0Qm91bmRpbmcoKS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2JvdHRvbVBhbmVIZWlnaHQgPSB0aGlzLl9ib3R0b21QYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuX21vdXNlVXBFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJhZ0ZsYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG9wUGFuZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JvdHRvbVBhbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl90b3BQYW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fYm90dG9tUGFuZUhlaWdodCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb3VzZUxlYXZlRXZlbnQoKTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUuX3ByZXNzZWRUb3VjaE1vdXNlTW92ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBkcmFnRGlzdGFuY2UgPSBldmVudC5wYWdlWSAtIHRoaXMuX2RyYWdTdGFydFk7XG4gICAgICAgIHZhciBpc1VwRHJhZyA9IGRyYWdEaXN0YW5jZSA8IDA7XG4gICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX3RvcFBhbmUpICYmIGlzVmFsaWQodGhpcy5fYm90dG9tUGFuZSkpIHtcbiAgICAgICAgICAgIHZhciBib3R0b21QYW5lT3B0aW9ucyA9IHRoaXMuX2JvdHRvbVBhbmUuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RvcFBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovICYmXG4gICAgICAgICAgICAgICAgYm90dG9tUGFuZU9wdGlvbnMuc3RhdGUgIT09IFwibWluaW1pemVcIiAvKiBQYW5lU3RhdGUuTWluaW1pemUgKi8gJiZcbiAgICAgICAgICAgICAgICBib3R0b21QYW5lT3B0aW9ucy5kcmFnRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkUGFuZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGluY3JlYXNlZFBhbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydERyYWdSZWR1Y2VkUGFuZUhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RHJhZ0luY3JlYXNlZFBhbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpc1VwRHJhZykge1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2VkUGFuZSA9IHRoaXMuX3RvcFBhbmU7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZFBhbmUgPSB0aGlzLl9ib3R0b21QYW5lO1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWdSZWR1Y2VkUGFuZUhlaWdodCA9IHRoaXMuX3RvcFBhbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RHJhZ0luY3JlYXNlZFBhbmVIZWlnaHQgPSB0aGlzLl9ib3R0b21QYW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlZFBhbmUgPSB0aGlzLl9ib3R0b21QYW5lO1xuICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZWRQYW5lID0gdGhpcy5fdG9wUGFuZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgPSB0aGlzLl9ib3R0b21QYW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWdJbmNyZWFzZWRQYW5lSGVpZ2h0ID0gdGhpcy5fdG9wUGFuZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZWRQYW5lTWluSGVpZ2h0ID0gcmVkdWNlZFBhbmUuZ2V0T3B0aW9ucygpLm1pbkhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQgPiByZWR1Y2VkUGFuZU1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZFBhbmVIZWlnaHQgPSBNYXRoLm1heChzdGFydERyYWdSZWR1Y2VkUGFuZUhlaWdodCAtIE1hdGguYWJzKGRyYWdEaXN0YW5jZSksIHJlZHVjZWRQYW5lTWluSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZIZWlnaHQgPSBzdGFydERyYWdSZWR1Y2VkUGFuZUhlaWdodCAtIHJlZHVjZWRQYW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2VkUGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogcmVkdWNlZFBhbmVIZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlYXNlZFBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHN0YXJ0RHJhZ0luY3JlYXNlZFBhbmVIZWlnaHQgKyBkaWZmSGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBhbmUgPSB0aGlzLmdldFBhbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJ0ID0gY3VycmVudFBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLmV4ZWN1dGVBY3Rpb24oQWN0aW9uVHlwZS5PblBhbmVEcmFnLCB7IHBhbmVJZDogY3VycmVudFBhbmUuZ2V0SWQoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlQnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU2VwYXJhdG9yV2lkZ2V0LnByb3RvdHlwZS5fbW91c2VFbnRlckV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0UGFuZSgpO1xuICAgICAgICB2YXIgYm90dG9tUGFuZSA9IHBhbmUuZ2V0Qm90dG9tUGFuZSgpO1xuICAgICAgICBpZiAoYm90dG9tUGFuZS5nZXRPcHRpb25zKCkuZHJhZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFydCA9IHBhbmUuZ2V0Q2hhcnQoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBjaGFydC5nZXRTdHlsZXMoKS5zZXBhcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLnN0eWxlLmJhY2tncm91bmQgPSBzdHlsZXMuYWN0aXZlQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2VwYXJhdG9yV2lkZ2V0LnByb3RvdHlwZS5fbW91c2VMZWF2ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RyYWdGbGFnKSB7XG4gICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2VwYXJhdG9yV2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEb20oJ2RpdicsIHtcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KFJFQUxfU0VQQVJBVE9SX0hFSUdIVCwgXCJweFwiKSxcbiAgICAgICAgICAgIG1hcmdpbjogJzAnLFxuICAgICAgICAgICAgcGFkZGluZzogJzAnLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB0b3A6ICctM3B4JyxcbiAgICAgICAgICAgIHpJbmRleDogJzIwJyxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJ1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlcGFyYXRvcldpZGdldC5wcm90b3R5cGUudXBkYXRlSW1wID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgX2JvdW5kaW5nLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IDQgLyogVXBkYXRlTGV2ZWwuQWxsICovIHx8IGxldmVsID09PSAyIC8qIFVwZGF0ZUxldmVsLlNlcGFyYXRvciAqLykge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZ2V0UGFuZSgpLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkuc2VwYXJhdG9yO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KC1NYXRoLmZsb29yKChSRUFMX1NFUEFSQVRPUl9IRUlHSFQgLSBzdHlsZXMuc2l6ZSkgLyAyKSwgXCJweFwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChSRUFMX1NFUEFSQVRPUl9IRUlHSFQsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXBhcmF0b3JXaWRnZXQ7XG59KFdpZGdldCkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBTZXBhcmF0b3JQYW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZXBhcmF0b3JQYW5lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcGFyYXRvclBhbmUoY2hhcnQsIGlkLCB0b3BQYW5lLCBib3R0b21QYW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNoYXJ0LCBpZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZ2V0Q29udGFpbmVyKCkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgX3RoaXMuX3RvcFBhbmUgPSB0b3BQYW5lO1xuICAgICAgICBfdGhpcy5fYm90dG9tUGFuZSA9IGJvdHRvbVBhbmU7XG4gICAgICAgIF90aGlzLl9zZXBhcmF0b3JXaWRnZXQgPSBuZXcgU2VwYXJhdG9yV2lkZ2V0KF90aGlzLmdldENvbnRhaW5lcigpLCBfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUuc2V0Qm91bmRpbmcgPSBmdW5jdGlvbiAocm9vdEJvdW5kaW5nKSB7XG4gICAgICAgIG1lcmdlKHRoaXMuZ2V0Qm91bmRpbmcoKSwgcm9vdEJvdW5kaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS5nZXRUb3BQYW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9wUGFuZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvclBhbmUucHJvdG90eXBlLnNldFRvcFBhbmUgPSBmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICB0aGlzLl90b3BQYW5lID0gcGFuZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS5nZXRCb3R0b21QYW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm90dG9tUGFuZTtcbiAgICB9O1xuICAgIFNlcGFyYXRvclBhbmUucHJvdG90eXBlLnNldEJvdHRvbVBhbmUgPSBmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICB0aGlzLl9ib3R0b21QYW5lID0gcGFuZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS5nZXRXaWRnZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZXBhcmF0b3JXaWRnZXQ7IH07XG4gICAgU2VwYXJhdG9yUGFuZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoX2luY2x1ZGVPdmVybGF5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Qm91bmRpbmcoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRDaGFydCgpLmdldFN0eWxlcygpLnNlcGFyYXRvcjtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZURvbSgnY2FudmFzJywge1xuICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIiksXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oY2FudmFzKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVzLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfTtcbiAgICBTZXBhcmF0b3JQYW5lLnByb3RvdHlwZS51cGRhdGVJbXAgPSBmdW5jdGlvbiAobGV2ZWwsIGNvbnRhaW5lciwgYm91bmRpbmcpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSA0IC8qIFVwZGF0ZUxldmVsLkFsbCAqLyB8fCBsZXZlbCA9PT0gMiAvKiBVcGRhdGVMZXZlbC5TZXBhcmF0b3IgKi8pIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldENoYXJ0KCkuZ2V0U3R5bGVzKCkuc2VwYXJhdG9yO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHN0eWxlcy5jb2xvcjtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChib3VuZGluZy5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWFyZ2luTGVmdCA9IFwiXCIuY29uY2F0KGJvdW5kaW5nLmxlZnQsIFwicHhcIik7XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChib3VuZGluZy53aWR0aCwgXCJweFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NlcGFyYXRvcldpZGdldC51cGRhdGUobGV2ZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VwYXJhdG9yUGFuZTtcbn0oUGFuZSkpO1xuXG4vKipcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRkYoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2ZpcmVmb3gnKTtcbn1cbmZ1bmN0aW9uIGlzSU9TKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZHxpT1MvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBlc2xpbnQtY29tbWVudHMvcmVxdWlyZS1kZXNjcmlwdGlvbiAtLSBpZ25vcmUgKi9cbnZhciBNYW5oYXR0YW5EaXN0YW5jZSA9IHtcbiAgICBDYW5jZWxDbGljazogNSxcbiAgICBDYW5jZWxUYXA6IDUsXG4gICAgRG91YmxlQ2xpY2s6IDUsXG4gICAgRG91YmxlVGFwOiAzMFxufTtcbnZhciBNb3VzZUV2ZW50QnV0dG9uID0ge1xuICAgIExlZnQ6IDAsXG4gICAgTWlkZGxlOiAxLFxuICAgIFJpZ2h0OiAyXG59O1xudmFyIFRPVUNIX01JTl9SQURJVVMgPSAxMDtcbi8vIFRPRE86IGdldCByaWQgb2YgYSBsb3Qgb2YgYm9vbGVhbiBmbGFncywgcHJvYmFibHkgd2Ugc2hvdWxkIHJlcGxhY2UgaXQgd2l0aCBzb21lIGVudW1cbnZhciBTeW50aGV0aWNFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTeW50aGV0aWNFdmVudCh0YXJnZXQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xpY2tDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2NsaWNrVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xpY2tDb29yZGluYXRlID0geyB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIHk6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgICB0aGlzLl90YXBDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3RhcFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcENvb3JkaW5hdGUgPSB7IHg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICAgIHRoaXMuX2xvbmdUYXBUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb25nVGFwQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdXNlTW92ZVN0YXJ0Q29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RvdWNoTW92ZVN0YXJ0Q29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydFBpbmNoTWlkZGxlQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXJ0UGluY2hEaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuX3BpbmNoUHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdXNlUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCA9IDA7XG4gICAgICAgIC8vIGZvciB0b3VjaHN0YXJ0L3RvdWNobW92ZS90b3VjaGVuZCBldmVudHMgd2UgaGFuZGxlIG9ubHkgZmlyc3QgdG91Y2hcbiAgICAgICAgLy8gaS5lLiB3ZSBkb24ndCBzdXBwb3J0IHNldmVyYWwgYWN0aXZlIHRvdWNoZXMgYXQgdGhlIHNhbWUgdGltZSAoZXhjZXB0IHBpbmNoIGV2ZW50KVxuICAgICAgICB0aGlzLl9hY3RpdmVUb3VjaElkID0gbnVsbDtcbiAgICAgICAgLy8gYWNjZXB0IGFsbCBtb3VzZSBsZWF2ZSBldmVudHMgaWYgaXQncyBub3QgYW4gaU9TIGRldmljZVxuICAgICAgICAvLyBzZWUgX21vdXNlRW50ZXJIYW5kbGVyLCBfbW91c2VNb3ZlSGFuZGxlciwgX21vdXNlTGVhdmVIYW5kbGVyXG4gICAgICAgIHRoaXMuX2FjY2VwdE1vdXNlTGVhdmUgPSAhaXNJT1MoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIEZpcmVmb3ggbW91c2UgZXZlbnRzIGRvbnQndCBmaXJlIGlmIHRoZSBtb3VzZSBwb3NpdGlvbiBpcyBvdXRzaWRlIG9mIHRoZSBicm93c2VyJ3MgYm9yZGVyLlxuICAgICAgICAgKiBUbyBwcmV2ZW50IHRoZSBtb3VzZSBmcm9tIGhhbmdpbmcgd2hpbGUgcHJlc3NlZCB3ZSdyZSBzdWJzY3JpYmluZyBvbiB0aGUgbW91c2VsZWF2ZSBldmVudCBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC5cbiAgICAgICAgICogV2UncmUgc3Vic2NyaWJpbmcgb24gbW91c2VsZWF2ZSwgYnV0IHRoaXMgZXZlbnQgaXMgYWN0dWFsbHkgZmlyZWQgb24gbW91c2V1cCBvdXRzaWRlIG9mIHRoZSBicm93c2VyJ3MgYm9yZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25GaXJlZm94T3V0c2lkZU1vdXNlVXAgPSBmdW5jdGlvbiAobW91c2VVcEV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fbW91c2VVcEhhbmRsZXIobW91c2VVcEV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhZmFyaSBkb2Vzbid0IGZpcmUgdG91Y2hzdGFydC9tb3VzZWRvd24gZXZlbnRzIG9uIGRvdWJsZSB0YXAgc2luY2UgaU9TIDEzLlxuICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICogMSkgQ2FsbCBwcmV2ZW50RGVmYXVsdCBpbiB0b3VjaEVuZCBoYW5kbGVyLiBCdXQgaXQgYWxzbyBwcmV2ZW50cyBjbGljayBldmVudCBmcm9tIGZpcmluZy5cbiAgICAgICAgICogMikgQWRkIGxpc3RlbmVyIG9uIGRibGNsaWNrIGV2ZW50IHRoYXQgZmlyZXMgd2l0aCB0aGUgcHJlY2VkaW5nIG1vdXNlZG93bi9tb3VzZXVwLlxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC8xMjUwNzNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZGJsQ2xpY2tFdmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9maXJlc1RvdWNoRXZlbnRzKGRibENsaWNrRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgKytfdGhpcy5fdGFwQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl90YXBUaW1lb3V0SWQgIT09IG51bGwgJiYgX3RoaXMuX3RhcENvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFuaGF0dGFuRGlzdGFuY2UgPSBfdGhpcy5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8oX3RoaXMuX2dldENvb3JkaW5hdGUoZGJsQ2xpY2tFdmVudCksIF90aGlzLl90YXBDb29yZGluYXRlKS5tYW5oYXR0YW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgTWFuaGF0dGFuRGlzdGFuY2UuRG91YmxlVGFwICYmICFfdGhpcy5fY2FuY2VsVGFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc0V2ZW50KF90aGlzLl9tYWtlQ29tcGF0RXZlbnQoZGJsQ2xpY2tFdmVudCksIF90aGlzLl9oYW5kbGVyLmRvdWJsZVRhcEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytfdGhpcy5fY2xpY2tDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NsaWNrVGltZW91dElkICE9PSBudWxsICYmIF90aGlzLl9jbGlja0NvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFuaGF0dGFuRGlzdGFuY2UgPSBfdGhpcy5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8oX3RoaXMuX2dldENvb3JkaW5hdGUoZGJsQ2xpY2tFdmVudCksIF90aGlzLl9jbGlja0Nvb3JkaW5hdGUpLm1hbmhhdHRhbkRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCBNYW5oYXR0YW5EaXN0YW5jZS5Eb3VibGVDbGljayAmJiAhX3RoaXMuX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc0V2ZW50KF90aGlzLl9tYWtlQ29tcGF0RXZlbnQoZGJsQ2xpY2tFdmVudCksIF90aGlzLl9oYW5kbGVyLm1vdXNlRG91YmxlQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU91dHNpZGVNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlTW91c2VFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZU91dHNpZGVUb3VjaEV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVNb3VzZW1vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZU1vdXNlV2hlZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZUNvbnRleHRNZW51ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUNvbnRleHRNZW51ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZU1vYmlsZVNhZmFyaUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGVhckxvbmdUYXBUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX21vdXNlRW50ZXJIYW5kbGVyID0gZnVuY3Rpb24gKGVudGVyRXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIChfYSA9IHRoaXMuX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgICAgKF9iID0gdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzKTtcbiAgICAgICAgKF9jID0gdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgdmFyIGJvdW5kTW91c2VNb3ZlSGFuZGxlciA9IHRoaXMuX21vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgX3RoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBib3VuZE1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgYm91bmRNb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICB2YXIgYm91bmRNb3VzZVdoZWVsID0gdGhpcy5fbW91c2VXaGVlbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb3VzZVdoZWVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIF90aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBib3VuZE1vdXNlV2hlZWwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBib3VuZE1vdXNlV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgdmFyIGJvdW5kQ29udGV4dE1lbnUgPSB0aGlzLl9jb250ZXh0TWVudUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVDb250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgYm91bmRDb250ZXh0TWVudSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGJvdW5kQ29udGV4dE1lbnUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICh0aGlzLl9maXJlc1RvdWNoRXZlbnRzKGVudGVyRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChlbnRlckV2ZW50KSwgdGhpcy5faGFuZGxlci5tb3VzZUVudGVyRXZlbnQpO1xuICAgICAgICB0aGlzLl9hY2NlcHRNb3VzZUxlYXZlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fcmVzZXRDbGlja1RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlja1RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NsaWNrVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGlja0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGlja0Nvb3JkaW5hdGUgPSB7IHg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgeTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX3Jlc2V0VGFwVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhcFRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RhcFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl90YXBUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl90YXBDb29yZGluYXRlID0geyB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIHk6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZU1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKG1vdmVFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5fbW91c2VQcmVzc2VkIHx8IHRoaXMuX3RvdWNoTW92ZVN0YXJ0Q29vcmRpbmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9maXJlc1RvdWNoRXZlbnRzKG1vdmVFdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KG1vdmVFdmVudCksIHRoaXMuX2hhbmRsZXIubW91c2VNb3ZlRXZlbnQpO1xuICAgICAgICB0aGlzLl9hY2NlcHRNb3VzZUxlYXZlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VXaGVlbEhhbmRsZXIgPSBmdW5jdGlvbiAod2hlZWxFdmVudCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWxFdmVudC5kZWx0YVgpID4gTWF0aC5hYnMod2hlZWxFdmVudC5kZWx0YVkpKSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5faGFuZGxlci5tb3VzZVdoZWVsSG9ydEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KHdoZWVsRXZlbnQpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHdoZWVsRXZlbnQuZGVsdGFYKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIubW91c2VXaGVlbEhvcnRFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQod2hlZWxFdmVudCksIC13aGVlbEV2ZW50LmRlbHRhWCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5faGFuZGxlci5tb3VzZVdoZWVsVmVydEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSAtKHdoZWVsRXZlbnQuZGVsdGFZIC8gMTAwKTtcbiAgICAgICAgICAgIGlmIChkZWx0YVkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdCh3aGVlbEV2ZW50KTtcbiAgICAgICAgICAgIHN3aXRjaCAod2hlZWxFdmVudC5kZWx0YU1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0U6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZICo9IDEyMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2Ugd2hlZWxFdmVudC5ET01fREVMVEFfTElORToge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVkgKj0gMzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YVkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLnNpZ24oZGVsdGFZKSAqIE1hdGgubWluKDEsIE1hdGguYWJzKGRlbHRhWSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIubW91c2VXaGVlbFZlcnRFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQod2hlZWxFdmVudCksIHNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9jb250ZXh0TWVudUhhbmRsZXIgPSBmdW5jdGlvbiAobW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdChtb3VzZUV2ZW50KTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fdG91Y2hNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChtb3ZlRXZlbnQpIHtcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5fdG91Y2hXaXRoSWQobW92ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLCB0aGlzLl9hY3RpdmVUb3VjaElkKTtcbiAgICAgICAgaWYgKHRvdWNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSB0aGlzLl9ldmVudFRpbWVTdGFtcChtb3ZlRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJldmVudFRvdWNoRHJhZ1Byb2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IHBpbmNoIGlmIG1vdmUgZXZlbnQgY29tZXMgZmFzdGVyIHRoYW4gdGhlIHNlY29uZCB0b3VjaFxuICAgICAgICB0aGlzLl9waW5jaFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHZhciBtb3ZlSW5mbyA9IHRoaXMuX21vdXNlVG91Y2hNb3ZlV2l0aERvd25JbmZvKHRoaXMuX2dldENvb3JkaW5hdGUodG91Y2gpLCB0aGlzLl90b3VjaE1vdmVTdGFydENvb3JkaW5hdGUpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IG1vdmVJbmZvLnhPZmZzZXQsIHlPZmZzZXQgPSBtb3ZlSW5mby55T2Zmc2V0LCBtYW5oYXR0YW5EaXN0YW5jZSA9IG1vdmVJbmZvLm1hbmhhdHRhbkRpc3RhbmNlO1xuICAgICAgICBpZiAoIXRoaXMuX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UgJiYgbWFuaGF0dGFuRGlzdGFuY2UgPCBNYW5oYXR0YW5EaXN0YW5jZS5DYW5jZWxUYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgd2hlbiBjdXJyZW50IHBvc2l0aW9uIGV4Y2VlZGVkIG1hbmhhdHRhbiBkaXN0YW5jZVxuICAgICAgICAgICAgLy8gdmVydGljYWwgZHJhZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIGhvcml6b250YWwgZHJhZ1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBzY3JvbGwgdGhlIHBhZ2UgdmVydGljYWxseSBvZnRlbiB0aGFuIGhvcml6b250YWxseVxuICAgICAgICAgICAgdmFyIGNvcnJlY3RlZFhPZmZzZXQgPSB4T2Zmc2V0ICogMC41O1xuICAgICAgICAgICAgLy8gYSBkcmFnIGNhbiBiZSBvbmx5IGlmIHRvdWNoIHBhZ2Ugc2Nyb2xsIGlzbid0IGFsbG93ZWRcbiAgICAgICAgICAgIHZhciBpc1ZlcnREcmFnID0geU9mZnNldCA+PSBjb3JyZWN0ZWRYT2Zmc2V0ICYmICF0aGlzLl9vcHRpb25zLnRyZWF0VmVydERyYWdBc1BhZ2VTY3JvbGwoKTtcbiAgICAgICAgICAgIHZhciBpc0hvcnpEcmFnID0gY29ycmVjdGVkWE9mZnNldCA+IHlPZmZzZXQgJiYgIXRoaXMuX29wdGlvbnMudHJlYXRIb3J6RHJhZ0FzUGFnZVNjcm9sbCgpO1xuICAgICAgICAgICAgLy8gaWYgZHJhZyBldmVudCBoYXBwZW5lZCB0aGVuIHdlIHNob3VsZCByZXZlcnQgcHJldmVudERlZmF1bHQgc3RhdGUgdG8gb3JpZ2luYWwgb25lXG4gICAgICAgICAgICAvLyBhbmQgdHJ5IHRvIHByb2Nlc3MgdGhlIGRyYWcgZXZlbnRcbiAgICAgICAgICAgIC8vIGVsc2Ugd2Ugc2hvdWxkbid0IHByZXZlbnQgZGVmYXVsdCBvZiB0aGUgZXZlbnQgYW5kIGlnbm9yZSBwcm9jZXNzaW5nIHRoZSBkcmFnIGV2ZW50XG4gICAgICAgICAgICBpZiAoIWlzVmVydERyYWcgJiYgIWlzSG9yekRyYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGlmIG1hbmhhdHRhbiBkaXN0YW5jZSBpcyBtb3JlIHRoYXQgNSAtIHdlIHNob3VsZCBjYW5jZWwgdGFwIGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUYXAgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRUYXBUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50VG91Y2hEcmFnUHJvY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChtb3ZlRXZlbnQsIHRvdWNoKSwgdGhpcy5faGFuZGxlci50b3VjaE1vdmVFdmVudCk7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgcHJldmVudCBkZWZhdWx0IGluIGNhc2Ugb2YgdG91Y2ggb25seVxuICAgICAgICAgICAgLy8gdG8gcHJldmVudCBzY3JvbGwgb2YgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIHByZXZlbnREZWZhdWx0KG1vdmVFdmVudClcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZU1vdmVXaXRoRG93bkhhbmRsZXIgPSBmdW5jdGlvbiAobW92ZUV2ZW50KSB7XG4gICAgICAgIGlmIChtb3ZlRXZlbnQuYnV0dG9uICE9PSBNb3VzZUV2ZW50QnV0dG9uLkxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW92ZUluZm8gPSB0aGlzLl9tb3VzZVRvdWNoTW92ZVdpdGhEb3duSW5mbyh0aGlzLl9nZXRDb29yZGluYXRlKG1vdmVFdmVudCksIHRoaXMuX21vdXNlTW92ZVN0YXJ0Q29vcmRpbmF0ZSk7XG4gICAgICAgIHZhciBtYW5oYXR0YW5EaXN0YW5jZSA9IG1vdmVJbmZvLm1hbmhhdHRhbkRpc3RhbmNlO1xuICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPj0gTWFuaGF0dGFuRGlzdGFuY2UuQ2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgIC8vIGlmIG1hbmhhdHRhbiBkaXN0YW5jZSBpcyBtb3JlIHRoYXQgNSAtIHdlIHNob3VsZCBjYW5jZWwgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0Q2xpY2tUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9jYW5jZWxDbGljayBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoYXQgbWluaW11bSBtYW5oYXR0YW4gZGlzdGFuY2UgaXMgYWxyZWFkeSBleGNlZWRlZFxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KHRoaXMuX21ha2VDb21wYXRFdmVudChtb3ZlRXZlbnQpLCB0aGlzLl9oYW5kbGVyLnByZXNzZWRNb3VzZU1vdmVFdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8gPSBmdW5jdGlvbiAoY3VycmVudENvb3JkaW5hdGUsIHN0YXJ0Q29vcmRpbmF0ZSkge1xuICAgICAgICB2YXIgeE9mZnNldCA9IE1hdGguYWJzKHN0YXJ0Q29vcmRpbmF0ZS54IC0gY3VycmVudENvb3JkaW5hdGUueCk7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gTWF0aC5hYnMoc3RhcnRDb29yZGluYXRlLnkgLSBjdXJyZW50Q29vcmRpbmF0ZS55KTtcbiAgICAgICAgdmFyIG1hbmhhdHRhbkRpc3RhbmNlID0geE9mZnNldCArIHlPZmZzZXQ7XG4gICAgICAgIHJldHVybiB7IHhPZmZzZXQ6IHhPZmZzZXQsIHlPZmZzZXQ6IHlPZmZzZXQsIG1hbmhhdHRhbkRpc3RhbmNlOiBtYW5oYXR0YW5EaXN0YW5jZSB9O1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl90b3VjaEVuZEhhbmRsZXIgPSBmdW5jdGlvbiAodG91Y2hFbmRFdmVudCkge1xuICAgICAgICB2YXIgdG91Y2ggPSB0aGlzLl90b3VjaFdpdGhJZCh0b3VjaEVuZEV2ZW50LmNoYW5nZWRUb3VjaGVzLCB0aGlzLl9hY3RpdmVUb3VjaElkKTtcbiAgICAgICAgaWYgKHRvdWNoID09PSBudWxsICYmIHRvdWNoRW5kRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nLCBzb21laG93IHdlIG1pc3NlZCB0aGUgcmVxdWlyZWQgdG91Y2hlbmQgZXZlbnRcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IHRoZSBicm93c2VyIGhhcyBub3Qgc2VudCB0aGlzIGV2ZW50XG4gICAgICAgICAgICB0b3VjaCA9IHRvdWNoRW5kRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlVG91Y2hJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RUb3VjaEV2ZW50VGltZVN0YW1wID0gdGhpcy5fZXZlbnRUaW1lU3RhbXAodG91Y2hFbmRFdmVudCk7XG4gICAgICAgIHRoaXMuX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2hNb3ZlU3RhcnRDb29yZGluYXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXRFdmVudCA9IHRoaXMuX21ha2VDb21wYXRFdmVudCh0b3VjaEVuZEV2ZW50LCB0b3VjaCk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci50b3VjaEVuZEV2ZW50KTtcbiAgICAgICAgKyt0aGlzLl90YXBDb3VudDtcbiAgICAgICAgaWYgKHRoaXMuX3RhcFRpbWVvdXRJZCAhPT0gbnVsbCAmJiB0aGlzLl90YXBDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgYm90aCBjbGlja3MgYXJlIG5lYXIgZW5vdWdoXG4gICAgICAgICAgICB2YXIgbWFuaGF0dGFuRGlzdGFuY2UgPSB0aGlzLl9tb3VzZVRvdWNoTW92ZVdpdGhEb3duSW5mbyh0aGlzLl9nZXRDb29yZGluYXRlKHRvdWNoKSwgdGhpcy5fdGFwQ29vcmRpbmF0ZSkubWFuaGF0dGFuRGlzdGFuY2U7XG4gICAgICAgICAgICBpZiAobWFuaGF0dGFuRGlzdGFuY2UgPCBNYW5oYXR0YW5EaXN0YW5jZS5Eb3VibGVUYXAgJiYgIXRoaXMuX2NhbmNlbFRhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci5kb3VibGVUYXBFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXNldFRhcFRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuY2VsVGFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9oYW5kbGVyLnRhcEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgZmlyZSBtb3VzZSBldmVudHMgaWYgdGFwIGhhbmRsZXIgd2FzIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBjbGljayBldmVudCBvbiBuZXcgZG9tIGVsZW1lbnQgKHdobyBhcHBlYXJlZCBhZnRlciB0YXApXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQodGhpcy5faGFuZGxlci50YXBFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQodG91Y2hFbmRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQsIGZvciBleGFtcGxlLCBzYWZhcmkncyBkYmxjbGljay10by16b29tIG9yIGZhc3QtY2xpY2sgYWZ0ZXIgbG9uZy10YXBcbiAgICAgICAgLy8gd2UgaGFuZGxlIG1vdXNlRG91YmxlQ2xpY2tFdmVudCBoZXJlIG91cnNlbHZlc1xuICAgICAgICBpZiAodGhpcy5fdGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaEVuZEV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9uZ1RhcEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdUYXBBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IG5hdGl2ZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KHRvdWNoRW5kRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX21vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24gKG1vdXNlVXBFdmVudCkge1xuICAgICAgICBpZiAobW91c2VVcEV2ZW50LmJ1dHRvbiAhPT0gTW91c2VFdmVudEJ1dHRvbi5MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhdEV2ZW50ID0gdGhpcy5fbWFrZUNvbXBhdEV2ZW50KG1vdXNlVXBFdmVudCk7XG4gICAgICAgIHRoaXMuX21vdXNlTW92ZVN0YXJ0Q29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21vdXNlUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRkYoKSkge1xuICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uRmlyZWZveE91dHNpZGVNb3VzZVVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmlyZXNUb3VjaEV2ZW50cyhtb3VzZVVwRXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9oYW5kbGVyLm1vdXNlVXBFdmVudCk7XG4gICAgICAgICsrdGhpcy5fY2xpY2tDb3VudDtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrVGltZW91dElkICE9PSBudWxsICYmIHRoaXMuX2NsaWNrQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0aGF0IGJvdGggY2xpY2tzIGFyZSBuZWFyIGVub3VnaFxuICAgICAgICAgICAgdmFyIG1hbmhhdHRhbkRpc3RhbmNlID0gdGhpcy5fbW91c2VUb3VjaE1vdmVXaXRoRG93bkluZm8odGhpcy5fZ2V0Q29vcmRpbmF0ZShtb3VzZVVwRXZlbnQpLCB0aGlzLl9jbGlja0Nvb3JkaW5hdGUpLm1hbmhhdHRhbkRpc3RhbmNlO1xuICAgICAgICAgICAgaWYgKG1hbmhhdHRhbkRpc3RhbmNlIDwgTWFuaGF0dGFuRGlzdGFuY2UuRG91YmxlQ2xpY2sgJiYgIXRoaXMuX2NhbmNlbENsaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50KGNvbXBhdEV2ZW50LCB0aGlzLl9oYW5kbGVyLm1vdXNlRG91YmxlQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXNldENsaWNrVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChjb21wYXRFdmVudCwgdGhpcy5faGFuZGxlci5tb3VzZUNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2NsZWFyTG9uZ1RhcFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb25nVGFwVGltZW91dElkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvbmdUYXBUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLl9sb25nVGFwVGltZW91dElkID0gbnVsbDtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fdG91Y2hTdGFydEhhbmRsZXIgPSBmdW5jdGlvbiAoZG93bkV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUb3VjaElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoID0gZG93bkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0aGlzLl9hY3RpdmVUb3VjaElkID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAgPSB0aGlzLl9ldmVudFRpbWVTdGFtcChkb3duRXZlbnQpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl90YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90b3VjaE1vdmVFeGNlZWRlZE1hbmhhdHRhbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByZXZlbnRUb3VjaERyYWdQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RvdWNoTW92ZVN0YXJ0Q29vcmRpbmF0ZSA9IHRoaXMuX2dldENvb3JkaW5hdGUodG91Y2gpO1xuICAgICAgICBpZiAodGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RUb3VjaEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyIGJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyXzEgPSB0aGlzLl90b3VjaE1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB2YXIgYm91bmRUb3VjaEVuZEhhbmRsZXJfMSA9IHRoaXMuX3RvdWNoRW5kSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290VG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlcl8xKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgYm91bmRUb3VjaEVuZEhhbmRsZXJfMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGJvdW5kVG91Y2hNb3ZlV2l0aERvd25IYW5kbGVyXzEsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBib3VuZFRvdWNoRW5kSGFuZGxlcl8xLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJMb25nVGFwVGltZW91dCgpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHRoaXMuX2xvbmdUYXBUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX2xvbmdUYXBIYW5kbGVyLmJpbmQodGhpcywgZG93bkV2ZW50KSwgNTAwIC8qIERlbGF5LkxvbmdUYXAgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQoZG93bkV2ZW50LCB0b3VjaCksIHRoaXMuX2hhbmRsZXIudG91Y2hTdGFydEV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX3RhcFRpbWVvdXRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFwQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHRoaXMuX3RhcFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fcmVzZXRUYXBUaW1lb3V0LmJpbmQodGhpcyksIDUwMCAvKiBEZWxheS5SZXNldENsaWNrICovKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcENvb3JkaW5hdGUgPSB0aGlzLl9nZXRDb29yZGluYXRlKHRvdWNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZURvd25IYW5kbGVyID0gZnVuY3Rpb24gKGRvd25FdmVudCkge1xuICAgICAgICBpZiAoZG93bkV2ZW50LmJ1dHRvbiA9PT0gTW91c2VFdmVudEJ1dHRvbi5SaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQoZG93bkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQoZG93bkV2ZW50KSwgdGhpcy5faGFuZGxlci5tb3VzZVJpZ2h0Q2xpY2tFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvd25FdmVudC5idXR0b24gIT09IE1vdXNlRXZlbnRCdXR0b24uTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3RhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgaWYgKGlzRkYoKSkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uRmlyZWZveE91dHNpZGVNb3VzZVVwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW5jZWxDbGljayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmVTdGFydENvb3JkaW5hdGUgPSB0aGlzLl9nZXRDb29yZGluYXRlKGRvd25FdmVudCk7XG4gICAgICAgIGlmICh0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVSb290TW91c2VFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB2YXIgYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXJfMSA9IHRoaXMuX21vdXNlTW92ZVdpdGhEb3duSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyIGJvdW5kTW91c2VVcEhhbmRsZXJfMSA9IHRoaXMuX21vdXNlVXBIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVJvb3RNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW91c2VNb3ZlV2l0aERvd25IYW5kbGVyXzEpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGJvdW5kTW91c2VVcEhhbmRsZXJfMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW91c2VNb3ZlV2l0aERvd25IYW5kbGVyXzEpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZE1vdXNlVXBIYW5kbGVyXzEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdXNlUHJlc3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9maXJlc1RvdWNoRXZlbnRzKGRvd25FdmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KGRvd25FdmVudCksIHRoaXMuX2hhbmRsZXIubW91c2VEb3duRXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tUaW1lb3V0SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrVGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9yZXNldENsaWNrVGltZW91dC5iaW5kKHRoaXMpLCA1MDAgLyogRGVsYXkuUmVzZXRDbGljayAqLyk7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0Nvb3JkaW5hdGUgPSB0aGlzLl9nZXRDb29yZGluYXRlKGRvd25FdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9tb3VzZUVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gRG8gbm90IHNob3cgY29udGV4dCBtZW51IHdoZW4gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5fY2xlYXJMb25nVGFwVGltZW91dC5iaW5kKHRoaXMpKTtcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRvY18xID0gdGhpcy5fdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXJfMSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faGFuZGxlci5tb3VzZURvd25PdXRzaWRlRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb21wb3NlZCAmJiBfdGhpcy5fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZXZlbnQudGFyZ2V0ICE9PSBudWxsKSAmJiBfdGhpcy5fdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlci5tb3VzZURvd25PdXRzaWRlRXZlbnQoeyB4OiAwLCB5OiAwLCBwYWdlWDogMCwgcGFnZVk6IDAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVPdXRzaWRlVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jXzEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY18xLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG91dHNpZGVIYW5kbGVyXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY18xLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG91dHNpZGVIYW5kbGVyXzEpO1xuICAgICAgICAgICAgZG9jXzEuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG91dHNpZGVIYW5kbGVyXzEsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJT1MoKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVNb2JpbGVTYWZhcmlFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIF90aGlzLl9vbk1vYmlsZVNhZmFyaURvdWJsZUNsaWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLl9vbk1vYmlsZVNhZmFyaURvdWJsZUNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX21vdXNlTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGVyLmJpbmQodGhpcyksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IE1vdXNlRXZlbnRCdXR0b24uTWlkZGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBpbmNvcnJlY3Qgc2Nyb2xsaW5nIGV2ZW50XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5faW5pdFBpbmNoKCk7XG4gICAgICAgIC8vIEhleSBtb2JpbGUgU2FmYXJpLCB3aGF0J3MgdXA/XG4gICAgICAgIC8vIElmIG1vYmlsZSBTYWZhcmkgZG9lc24ndCBoYXZlIGFueSB0b3VjaG1vdmUgaGFuZGxlciB3aXRoIHBhc3NpdmU9ZmFsc2VcbiAgICAgICAgLy8gaXQgdHJlYXRzIGEgdG91Y2hzdGFydCBhbmQgdGhlIGZvbGxvd2luZyB0b3VjaG1vdmUgZXZlbnRzIGFzIGNhbmNlbGFibGU9ZmFsc2UsXG4gICAgICAgIC8vIHNvIHdlIGNhbid0IHByZXZlbnQgdGhlbSAoYXMgc29vbiB3ZSBzdWJzY3JpYmUgb24gdG91Y2htb3ZlIGluc2lkZSB0b3VjaHN0YXJ0J3MgaGFuZGxlcikuXG4gICAgICAgIC8vIEFuZCB3ZSdsbCBnZXQgc2Nyb2xsIG9mIHRoZSBwYWdlIGFsb25nIHdpdGggY2hhcnQncyBvbmUgaW5zdGVhZCBvZiBvbmx5IGNoYXJ0J3Mgc2Nyb2xsLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoKSB7IH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2luaXRQaW5jaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRoaXMuX2hhbmRsZXIucGluY2hTdGFydEV2ZW50KSAmJlxuICAgICAgICAgICAgIWlzVmFsaWQodGhpcy5faGFuZGxlci5waW5jaEV2ZW50KSAmJlxuICAgICAgICAgICAgIWlzVmFsaWQodGhpcy5faGFuZGxlci5waW5jaEVuZEV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9jaGVja1BpbmNoU3RhdGUoZXZlbnQudG91Y2hlcyk7IH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IF90aGlzLl9zdGFydFBpbmNoTWlkZGxlQ29vcmRpbmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKF90aGlzLl9oYW5kbGVyLnBpbmNoRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IF90aGlzLl9nZXRUb3VjaERpc3RhbmNlKGV2ZW50LnRvdWNoZXNbMF0sIGV2ZW50LnRvdWNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGN1cnJlbnREaXN0YW5jZSAvIF90aGlzLl9zdGFydFBpbmNoRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZXIucGluY2hFdmVudChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3RoaXMuX3N0YXJ0UGluY2hNaWRkbGVDb29yZGluYXRlKSwgeyBwYWdlWDogMCwgcGFnZVk6IDAgfSksIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9jaGVja1BpbmNoU3RhdGUoZXZlbnQudG91Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9jaGVja1BpbmNoU3RhdGUgPSBmdW5jdGlvbiAodG91Y2hlcykge1xuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpbmNoUHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuX3BpbmNoUHJldmVudGVkIHx8IHRoaXMuX2xvbmdUYXBBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BQaW5jaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRQaW5jaCh0b3VjaGVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9zdGFydFBpbmNoID0gZnVuY3Rpb24gKHRvdWNoZXMpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuX3RhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgPSB7XG4gICAgICAgICAgICB4OiAoKHRvdWNoZXNbMF0uY2xpZW50WCAtIGJveC5sZWZ0KSArICh0b3VjaGVzWzFdLmNsaWVudFggLSBib3gubGVmdCkpIC8gMixcbiAgICAgICAgICAgIHk6ICgodG91Y2hlc1swXS5jbGllbnRZIC0gYm94LnRvcCkgKyAodG91Y2hlc1sxXS5jbGllbnRZIC0gYm94LnRvcCkpIC8gMlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zdGFydFBpbmNoRGlzdGFuY2UgPSB0aGlzLl9nZXRUb3VjaERpc3RhbmNlKHRvdWNoZXNbMF0sIHRvdWNoZXNbMV0pO1xuICAgICAgICBpZiAoaXNWYWxpZCh0aGlzLl9oYW5kbGVyLnBpbmNoU3RhcnRFdmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIucGluY2hTdGFydEV2ZW50KHsgeDogMCwgeTogMCwgcGFnZVg6IDAsIHBhZ2VZOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyTG9uZ1RhcFRpbWVvdXQoKTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fc3RvcFBpbmNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhcnRQaW5jaE1pZGRsZUNvb3JkaW5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydFBpbmNoTWlkZGxlQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChpc1ZhbGlkKHRoaXMuX2hhbmRsZXIucGluY2hFbmRFdmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIucGluY2hFbmRFdmVudCh7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9tb3VzZUxlYXZlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgKF9hID0gdGhpcy5fdW5zdWJzY3JpYmVNb3VzZW1vdmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAoX2IgPSB0aGlzLl91bnN1YnNjcmliZU1vdXNlV2hlZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xuICAgICAgICAoX2MgPSB0aGlzLl91bnN1YnNjcmliZUNvbnRleHRNZW51KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcmVzVG91Y2hFdmVudHMoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9hY2NlcHRNb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICAvLyBtb2JpbGUgU2FmYXJpIHNvbWV0aW1lcyBlbWl0cyBtb3VzZSBsZWF2ZSBldmVudCBmb3Igbm8gcmVhc29uLCB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIGl0IGluIG90aGVyIHdheVxuICAgICAgICAgICAgLy8ganVzdCBpZ25vcmUgdGhpcyBldmVudCBpZiB0aGVyZSB3YXMgbm8gbW91c2UgbW92ZSBvciBtb3VzZSBlbnRlciBldmVudHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQodGhpcy5fbWFrZUNvbXBhdEV2ZW50KGV2ZW50KSwgdGhpcy5faGFuZGxlci5tb3VzZUxlYXZlRXZlbnQpO1xuICAgICAgICAvLyBhY2NlcHQgYWxsIG1vdXNlIGxlYXZlIGV2ZW50cyBpZiBpdCdzIG5vdCBhbiBpT1MgZGV2aWNlXG4gICAgICAgIHRoaXMuX2FjY2VwdE1vdXNlTGVhdmUgPSAhaXNJT1MoKTtcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fbG9uZ1RhcEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5fdG91Y2hXaXRoSWQoZXZlbnQudG91Y2hlcywgdGhpcy5fYWN0aXZlVG91Y2hJZCk7XG4gICAgICAgIGlmICh0b3VjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudCh0aGlzLl9tYWtlQ29tcGF0RXZlbnQoZXZlbnQsIHRvdWNoKSwgdGhpcy5faGFuZGxlci5sb25nVGFwRXZlbnQpO1xuICAgICAgICB0aGlzLl9jYW5jZWxUYXAgPSB0cnVlO1xuICAgICAgICAvLyBsb25nIHRhcCBpcyBhY3RpdmUgdW50aWwgdG91Y2hlbmQgZXZlbnQgd2l0aCAwIHRvdWNoZXMgb2NjdXJyZWRcbiAgICAgICAgdGhpcy5fbG9uZ1RhcEFjdGl2ZSA9IHRydWU7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2ZpcmVzVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIGlmIChpc1ZhbGlkKChfYSA9IGUuc291cmNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyZXNUb3VjaEV2ZW50cykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICByZXR1cm4gZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRUaW1lU3RhbXAoZSkgPCB0aGlzLl9sYXN0VG91Y2hFdmVudFRpbWVTdGFtcCArIDUwMCAvKiBEZWxheS5QcmV2ZW50RmlyZXNUb3VjaEV2ZW50cyAqLztcbiAgICB9O1xuICAgIFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZS5fcHJvY2Vzc0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suY2FsbCh0aGlzLl9oYW5kbGVyLCBldmVudCk7XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX21ha2VDb21wYXRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdG91Y2gpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVG91Y2hFdmVudCBoYXMgbm8gY2xpZW50WC9ZIGNvb3JkaW5hdGVzOlxuICAgICAgICAvLyBXZSBoYXZlIHRvIHVzZSB0aGUgbGFzdCBUb3VjaCBpbnN0ZWFkXG4gICAgICAgIHZhciBldmVudExpa2UgPSB0b3VjaCAhPT0gbnVsbCAmJiB0b3VjaCAhPT0gdm9pZCAwID8gdG91Y2ggOiBldmVudDtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuX3RhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGV2ZW50TGlrZS5jbGllbnRYIC0gYm94LmxlZnQsXG4gICAgICAgICAgICB5OiBldmVudExpa2UuY2xpZW50WSAtIGJveC50b3AsXG4gICAgICAgICAgICBwYWdlWDogZXZlbnRMaWtlLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50TGlrZS5wYWdlWSxcbiAgICAgICAgICAgIGlzVG91Y2g6ICFldmVudC50eXBlLnN0YXJ0c1dpdGgoJ21vdXNlJykgJiYgZXZlbnQudHlwZSAhPT0gJ2NvbnRleHRtZW51JyAmJiBldmVudC50eXBlICE9PSAnY2xpY2snICYmIGV2ZW50LnR5cGUgIT09ICd3aGVlbCcsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG91Y2hzdGFydCBpcyBwYXNzaXZlIGFuZCBjYW5ub3QgYmUgcHJldmVudGVkXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9nZXRUb3VjaERpc3RhbmNlID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICB2YXIgeERpZmYgPSBwMS5jbGllbnRYIC0gcDIuY2xpZW50WDtcbiAgICAgICAgdmFyIHlEaWZmID0gcDEuY2xpZW50WSAtIHAyLmNsaWVudFk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl9nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gKGV2ZW50TGlrZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZXZlbnRMaWtlLnBhZ2VYLFxuICAgICAgICAgICAgeTogZXZlbnRMaWtlLnBhZ2VZXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTeW50aGV0aWNFdmVudC5wcm90b3R5cGUuX2V2ZW50VGltZVN0YW1wID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBmb3Igc29tZSByZWFzb24gZS50aW1lc3RhbXAgaXMgYWx3YXlzIDAgb24gaVBhZCB3aXRoIG1hZ2ljIG1vdXNlLCBzbyB3ZSB1c2UgcGVyZm9ybWFuY2Uubm93KCkgYXMgYSBmYWxsYmFja1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICByZXR1cm4gKF9hID0gZS50aW1lU3RhbXApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gICAgU3ludGhldGljRXZlbnQucHJvdG90eXBlLl90b3VjaFdpdGhJZCA9IGZ1bmN0aW9uICh0b3VjaGVzLCBpZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodG91Y2hlc1tpXS5pZGVudGlmaWVyID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50O1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnQoY29udGFpbmVyLCBjaGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyDmg6/mgKfmu5rliqjlvIDlp4vml7bpl7RcbiAgICAgICAgdGhpcy5fZmxpbmdTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8g5oOv5oCn5rua5Yqo5a6a5pe25ZmoXG4gICAgICAgIHRoaXMuX2ZsaW5nU2Nyb2xsUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgLy8g5byA5aeL5rua5Yqo5pe25Z2Q5qCH54K5XG4gICAgICAgIHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIC8vIOW8gOWni+inpuaRuOaXtuWdkOagh1xuICAgICAgICB0aGlzLl90b3VjaENvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgICAvLyDmmK/lkKbmmK/lj5bmtojkuobljYHlrZflhYnmoIdcbiAgICAgICAgdGhpcy5fdG91Y2hDYW5jZWxDcm9zc2hhaXIgPSBmYWxzZTtcbiAgICAgICAgLy8g5piv5ZCm57yp5pS+6L+HXG4gICAgICAgIHRoaXMuX3RvdWNoWm9vbWVkID0gZmFsc2U7XG4gICAgICAgIC8vIOeUqOadpeiusOW9leaNj+WQiOe8qeaUvueahOWwuuWvuFxuICAgICAgICB0aGlzLl9waW5jaFNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5fbW91c2VEb3duV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJldllBeGlzUmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl94QXhpc1N0YXJ0U2NhbGVDb29yZGluYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5feEF4aXNTdGFydFNjYWxlRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl94QXhpc1NjYWxlID0gMTtcbiAgICAgICAgdGhpcy5feUF4aXNTdGFydFNjYWxlRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZU1vdmVUcmlnZ2VyV2lkZ2V0SW5mbyA9IHsgcGFuZTogbnVsbCwgd2lkZ2V0OiBudWxsIH07XG4gICAgICAgIHRoaXMuX2JvdW5kS2V5Qm9hcmREb3duRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFcXVhbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuem9vbSgwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTWludXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnpvb20oLTAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBfdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnNjcm9sbCgtMyAqIHN0b3JlLmdldEJhclNwYWNlKCkuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBfdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnNjcm9sbCgzICogc3RvcmUuZ2V0QmFyU3BhY2UoKS5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoY29udGFpbmVyLCB0aGlzLCB7XG4gICAgICAgICAgICB0cmVhdFZlcnREcmFnQXNQYWdlU2Nyb2xsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIHRyZWF0SG9yekRyYWdBc1BhZ2VTY3JvbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kS2V5Qm9hcmREb3duRXZlbnQpO1xuICAgIH1cbiAgICBFdmVudC5wcm90b3R5cGUucGluY2hTdGFydEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90b3VjaFpvb21lZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BpbmNoU2NhbGUgPSAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5waW5jaEV2ZW50ID0gZnVuY3Rpb24gKGUsIHNjYWxlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2EucGFuZSwgd2lkZ2V0ID0gX2Eud2lkZ2V0O1xuICAgICAgICBpZiAoKHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS5nZXRJZCgpKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyAmJiAod2lkZ2V0ID09PSBudWxsIHx8IHdpZGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2lkZ2V0LmdldE5hbWUoKSkgPT09IFdpZGdldE5hbWVDb25zdGFudHMuTUFJTikge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSAoc2NhbGUgLSB0aGlzLl9waW5jaFNjYWxlKSAqIDU7XG4gICAgICAgICAgICB0aGlzLl9waW5jaFNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuem9vbSh6b29tU2NhbGUsIHsgeDogZXZlbnRfMS54LCB5OiBldmVudF8xLnkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUubW91c2VXaGVlbEhvcnRFdmVudCA9IGZ1bmN0aW9uIChfLCBkaXN0YW5jZSkge1xuICAgICAgICB2YXIgc3RvcmUgPSB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgIHN0b3JlLnN0YXJ0U2Nyb2xsKCk7XG4gICAgICAgIHN0b3JlLnNjcm9sbChkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLm1vdXNlV2hlZWxWZXJ0RXZlbnQgPSBmdW5jdGlvbiAoZSwgc2NhbGUpIHtcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLndpZGdldDtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgIHZhciBuYW1lID0gd2lkZ2V0ID09PSBudWxsIHx8IHdpZGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IFdpZGdldE5hbWVDb25zdGFudHMuTUFJTikge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnpvb20oc2NhbGUsIHsgeDogZXZlbnQueCwgeTogZXZlbnQueSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZURvd25FdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2EucGFuZSwgd2lkZ2V0ID0gX2Eud2lkZ2V0O1xuICAgICAgICB0aGlzLl9tb3VzZURvd25XaWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8yID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZV8xKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLlNFUEFSQVRPUjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRG93bkV2ZW50JywgZXZlbnRfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXlBeGlzLmdldEF1dG9DYWxjVGlja0ZsYWcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0geUF4aXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZZQXhpc1JhbmdlID0gX19hc3NpZ24oe30sIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgPSB7IHg6IGV2ZW50XzIueCwgeTogZXZlbnRfMi55IH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS5zdGFydFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRG93bkV2ZW50JywgZXZlbnRfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NYQXhpc1Njcm9sbFN0YXJ0RXZlbnQod2lkZ2V0LCBldmVudF8yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1lBeGlzU2NhbGVTdGFydEV2ZW50KHdpZGdldCwgZXZlbnRfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZU1vdmVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9kLnBhbmUsIHdpZGdldCA9IF9kLndpZGdldDtcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5fbW91c2VNb3ZlVHJpZ2dlcldpZGdldEluZm8ucGFuZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldElkKCkpICE9PSAocGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkpIHx8XG4gICAgICAgICAgICAoKF9iID0gdGhpcy5fbW91c2VNb3ZlVHJpZ2dlcldpZGdldEluZm8ud2lkZ2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmFtZSgpKSAhPT0gKHdpZGdldCA9PT0gbnVsbCB8fCB3aWRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpZGdldC5nZXROYW1lKCkpKSB7XG4gICAgICAgICAgICB3aWRnZXQgPT09IG51bGwgfHwgd2lkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VFbnRlckV2ZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgKF9jID0gdGhpcy5fbW91c2VNb3ZlVHJpZ2dlcldpZGdldEluZm8ud2lkZ2V0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzcGF0Y2hFdmVudCgnbW91c2VMZWF2ZUV2ZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5fbW91c2VNb3ZlVHJpZ2dlcldpZGdldEluZm8gPSB7IHBhbmU6IHBhbmUsIHdpZGdldDogd2lkZ2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfMikge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdW1lZCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZU1vdmVFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3NzaGFpciA9IHsgeDogZXZlbnQueCwgeTogZXZlbnQueSwgcGFuZUlkOiBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzaGFpciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5nZXRDb250YWluZXIoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnNldENyb3NzaGFpcihjcm9zc2hhaXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5TRVBBUkFUT1I6XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLlhfQVhJUzpcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuWV9BWElTOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdW1lZCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZU1vdmVFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpLnNldENyb3NzaGFpcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5wcmVzc2VkTW91c2VNb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5fbW91c2VEb3duV2lkZ2V0ICE9PSBudWxsICYmIHRoaXMuX21vdXNlRG93bldpZGdldC5nZXROYW1lKCkgPT09IFdpZGdldE5hbWVDb25zdGFudHMuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW91c2VEb3duV2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ3ByZXNzZWRNb3VzZU1vdmVFdmVudCcsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYyA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2MucGFuZSwgd2lkZ2V0ID0gX2Mud2lkZ2V0O1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsICYmXG4gICAgICAgICAgICAoKF9hID0gdGhpcy5fbW91c2VEb3duV2lkZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGFuZSgpLmdldElkKCkpID09PSAocGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkpICYmXG4gICAgICAgICAgICAoKF9iID0gdGhpcy5fbW91c2VEb3duV2lkZ2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmFtZSgpKSA9PT0gd2lkZ2V0LmdldE5hbWUoKSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzMgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciBuYW1lXzMgPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2luaXQtZGVjbGFyYXRpb25zIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NoYWlyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgncHJlc3NlZE1vdXNlTW92ZUV2ZW50JywgZXZlbnRfMyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzaGFpciA9IHsgeDogZXZlbnRfMy54LCB5OiBldmVudF8zLnksIHBhbmVJZDogcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldElkKCkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNYWluU2Nyb2xsaW5nRXZlbnQod2lkZ2V0LCBldmVudF8zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuc2V0Q3Jvc3NoYWlyKGNyb3NzaGFpciwgeyBmb3JjZUludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLlhfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1hBeGlzU2Nyb2xsaW5nRXZlbnQod2lkZ2V0LCBldmVudF8zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1lBeGlzU2NhbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZVVwRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSkud2lkZ2V0O1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzQgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciBuYW1lXzQgPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuTUFJTjpcbiAgICAgICAgICAgICAgICBjYXNlIFdpZGdldE5hbWVDb25zdGFudHMuU0VQQVJBVE9SOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZVVwRXZlbnQnLCBldmVudF80KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN1bWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vdXNlRG93bldpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXZZQXhpc1JhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5feEF4aXNTdGFydFNjYWxlQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5feEF4aXNTY2FsZSA9IDE7XG4gICAgICAgIHRoaXMuX3lBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLm1vdXNlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKS53aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF81ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICByZXR1cm4gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlQ2xpY2tFdmVudCcsIGV2ZW50XzUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZVJpZ2h0Q2xpY2tFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKS53aWRnZXQ7XG4gICAgICAgIHZhciBjb25zdW1lZCA9IGZhbHNlO1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfNiA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgdmFyIG5hbWVfNSA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfNSkge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOlxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZVJpZ2h0Q2xpY2tFdmVudCcsIGV2ZW50XzYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLm1vdXNlRG91YmxlQ2xpY2tFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2EucGFuZSwgd2lkZ2V0ID0gX2Eud2lkZ2V0O1xuICAgICAgICBpZiAod2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV82ID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZV82KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU46IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzcgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZGdldC5kaXNwYXRjaEV2ZW50KCdtb3VzZURvdWJsZUNsaWNrRXZlbnQnLCBldmVudF83KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF5QXhpcy5nZXRBdXRvQ2FsY1RpY2tGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzLnNldEF1dG9DYWxjVGlja0ZsYWcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFydC5sYXlvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5tb3VzZUxlYXZlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS5zZXRDcm9zc2hhaXIoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUudG91Y2hTdGFydEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9iLnBhbmUsIHdpZGdldCA9IF9iLndpZGdldDtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzggPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIChfYSA9IGV2ZW50XzgucHJldmVudERlZmF1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGV2ZW50XzgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfNyA9IHdpZGdldC5nZXROYW1lKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfNykge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFydFN0b3JlID0gdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlRG93bkV2ZW50JywgZXZlbnRfOCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFN0b3JlLnNldENyb3NzaGFpcih1bmRlZmluZWQsIHsgbm90SW52YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mbGluZ1Njcm9sbFJlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZsaW5nU3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXlBeGlzLmdldEF1dG9DYWxjVGlja0ZsYWcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0geUF4aXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZZQXhpc1JhbmdlID0gX19hc3NpZ24oe30sIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgPSB7IHg6IGV2ZW50XzgueCwgeTogZXZlbnRfOC55IH07XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hab29tZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhEaWYgPSBldmVudF84LnggLSB0aGlzLl90b3VjaENvb3JkaW5hdGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5RGlmID0gZXZlbnRfOC55IC0gdGhpcy5fdG91Y2hDb29yZGluYXRlLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KHhEaWYgKiB4RGlmICsgeURpZiAqIHlEaWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGl1cyA8IFRPVUNIX01JTl9SQURJVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENvb3JkaW5hdGUgPSB7IHg6IGV2ZW50XzgueCwgeTogZXZlbnRfOC55IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRDcm9zc2hhaXIoeyB4OiBldmVudF84LngsIHk6IGV2ZW50XzgueSwgcGFuZUlkOiBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hDYW5jZWxDcm9zc2hhaXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NYQXhpc1Njcm9sbFN0YXJ0RXZlbnQod2lkZ2V0LCBldmVudF84KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1lBeGlzU2NhbGVTdGFydEV2ZW50KHdpZGdldCwgZXZlbnRfOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS50b3VjaE1vdmVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5fZmluZFdpZGdldEJ5RXZlbnQoZSksIHBhbmUgPSBfYi5wYW5lLCB3aWRnZXQgPSBfYi53aWRnZXQ7XG4gICAgICAgIGlmICh3aWRnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBldmVudF85ID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICAoX2EgPSBldmVudF85LnByZXZlbnREZWZhdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChldmVudF85KTtcbiAgICAgICAgICAgIHZhciBuYW1lXzggPSB3aWRnZXQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgdmFyIGNoYXJ0U3RvcmUgPSB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfOCkge1xuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5NQUlOOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWRnZXQuZGlzcGF0Y2hFdmVudCgncHJlc3NlZE1vdXNlTW92ZUV2ZW50JywgZXZlbnRfOSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKHVuZGVmaW5lZCwgeyBub3RJbnZhbGlkYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoQ29vcmRpbmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRDcm9zc2hhaXIoeyB4OiBldmVudF85LngsIHk6IGV2ZW50XzkueSwgcGFuZUlkOiBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNYWluU2Nyb2xsaW5nRXZlbnQod2lkZ2V0LCBldmVudF85KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLlhfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1hBeGlzU2Nyb2xsaW5nRXZlbnQod2lkZ2V0LCBldmVudF85KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1lBeGlzU2NhbGluZ0V2ZW50KHdpZGdldCwgZXZlbnRfOSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS50b3VjaEVuZEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdpZGdldCA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLndpZGdldDtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEwID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgbmFtZV85ID0gd2lkZ2V0LmdldE5hbWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZV85KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU46IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlVXBFdmVudCcsIGV2ZW50XzEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX2ZsaW5nU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gZXZlbnRfMTAueCAtIHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZfMSA9IGRpc3RhbmNlIC8gKHRpbWUgPiAwID8gdGltZSA6IDEpICogMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA8IDIwMCAmJiBNYXRoLmFicyh2XzEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZV8xID0gdGhpcy5fY2hhcnQuZ2V0Q2hhcnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbGluZ1Njcm9sbF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVfMS5zdGFydFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVfMS5zY3JvbGwodl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZfMSA9IHZfMSAqICgxIC0gMC4wMjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZfMSkgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9mbGluZ1Njcm9sbFJlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZmxpbmdTY3JvbGxSZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsaW5nU2Nyb2xsXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGluZ1Njcm9sbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgV2lkZ2V0TmFtZUNvbnN0YW50cy5YX0FYSVM6XG4gICAgICAgICAgICAgICAgY2FzZSBXaWRnZXROYW1lQ29uc3RhbnRzLllfQVhJUzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VVcEV2ZW50JywgZXZlbnRfMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LnVwZGF0ZVBhbmUoMSAvKiBVcGRhdGVMZXZlbC5PdmVybGF5ICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2WUF4aXNSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl94QXhpc1N0YXJ0U2NhbGVDb29yZGluYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZURpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3hBeGlzU2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5feUF4aXNTdGFydFNjYWxlRGlzdGFuY2UgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS50YXBFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ZpbmRXaWRnZXRCeUV2ZW50KGUpLCBwYW5lID0gX2EucGFuZSwgd2lkZ2V0ID0gX2Eud2lkZ2V0O1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzExID0gdGhpcy5fbWFrZVdpZGdldEV2ZW50KGUsIHdpZGdldCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ21vdXNlQ2xpY2tFdmVudCcsIGV2ZW50XzExKTtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuZ2V0TmFtZSgpID09PSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMTIgPSB0aGlzLl9tYWtlV2lkZ2V0RXZlbnQoZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnRTdG9yZSA9IHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hDb29yZGluYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRTdG9yZS5zZXRDcm9zc2hhaXIodW5kZWZpbmVkLCB7IG5vdEludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG91Y2hDYW5jZWxDcm9zc2hhaXIgJiYgIXRoaXMuX3RvdWNoWm9vbWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaENvb3JkaW5hdGUgPSB7IHg6IGV2ZW50XzEyLngsIHk6IGV2ZW50XzEyLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0U3RvcmUuc2V0Q3Jvc3NoYWlyKHsgeDogZXZlbnRfMTIueCwgeTogZXZlbnRfMTIueSwgcGFuZUlkOiBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSB9LCB7IG5vdEludmFsaWRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hDYW5jZWxDcm9zc2hhaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3VtZWQgfHwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdW1lZDtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5kb3VibGVUYXBFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG91YmxlQ2xpY2tFdmVudChlKTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5sb25nVGFwRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9maW5kV2lkZ2V0QnlFdmVudChlKSwgcGFuZSA9IF9hLnBhbmUsIHdpZGdldCA9IF9hLndpZGdldDtcbiAgICAgICAgaWYgKHdpZGdldCAhPT0gbnVsbCAmJiB3aWRnZXQuZ2V0TmFtZSgpID09PSBXaWRnZXROYW1lQ29uc3RhbnRzLk1BSU4pIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xMyA9IHRoaXMuX21ha2VXaWRnZXRFdmVudChlLCB3aWRnZXQpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hDb29yZGluYXRlID0geyB4OiBldmVudF8xMy54LCB5OiBldmVudF8xMy55IH07XG4gICAgICAgICAgICB0aGlzLl9jaGFydC5nZXRDaGFydFN0b3JlKCkuc2V0Q3Jvc3NoYWlyKHsgeDogZXZlbnRfMTMueCwgeTogZXZlbnRfMTMueSwgcGFuZUlkOiBwYW5lID09PSBudWxsIHx8IHBhbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmUuZ2V0SWQoKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV2ZW50LnByb3RvdHlwZS5fcHJvY2Vzc01haW5TY3JvbGxpbmdFdmVudCA9IGZ1bmN0aW9uICh3aWRnZXQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHdpZGdldC5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZZQXhpc1JhbmdlICE9PSBudWxsICYmICF5QXhpcy5nZXRBdXRvQ2FsY1RpY2tGbGFnKCkgJiYgeUF4aXMuc2Nyb2xsWm9vbUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9wcmV2WUF4aXNSYW5nZSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlXzEgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh5QXhpcy5yZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlXzEgPSB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUueSAtIGV2ZW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZV8xID0gZXZlbnQueSAtIHRoaXMuX3N0YXJ0U2Nyb2xsQ29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmcgPSB3aWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBkaXN0YW5jZV8xIC8gYm91bmRpbmcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBkaWZSYW5nZSA9IHJhbmdlICogc2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Zyb20gPSBmcm9tICsgZGlmUmFuZ2U7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RvID0gdG8gKyBkaWZSYW5nZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UmVhbEZyb20gPSB5QXhpcy52YWx1ZVRvUmVhbFZhbHVlKG5ld0Zyb20sIHsgcmFuZ2U6IHRoaXMuX3ByZXZZQXhpc1JhbmdlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSZWFsVG8gPSB5QXhpcy52YWx1ZVRvUmVhbFZhbHVlKG5ld1RvLCB7IHJhbmdlOiB0aGlzLl9wcmV2WUF4aXNSYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlzcGxheUZyb20gPSB5QXhpcy5yZWFsVmFsdWVUb0Rpc3BsYXlWYWx1ZShuZXdSZWFsRnJvbSwgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Rpc3BsYXlUbyA9IHlBeGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKG5ld1JlYWxUbywgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgeUF4aXMuc2V0UmFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBuZXdGcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3VG8sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBuZXdUbyAtIG5ld0Zyb20sXG4gICAgICAgICAgICAgICAgICAgIHJlYWxGcm9tOiBuZXdSZWFsRnJvbSxcbiAgICAgICAgICAgICAgICAgICAgcmVhbFRvOiBuZXdSZWFsVG8sXG4gICAgICAgICAgICAgICAgICAgIHJlYWxSYW5nZTogbmV3UmVhbFRvIC0gbmV3UmVhbEZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlGcm9tOiBuZXdEaXNwbGF5RnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheVRvOiBuZXdEaXNwbGF5VG8sXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlSYW5nZTogbmV3RGlzcGxheVRvIC0gbmV3RGlzcGxheUZyb21cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGV2ZW50LnggLSB0aGlzLl9zdGFydFNjcm9sbENvb3JkaW5hdGUueDtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS5zY3JvbGwoZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUuX3Byb2Nlc3NYQXhpc1Njcm9sbFN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAod2lkZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VEb3duRXZlbnQnLCBldmVudCk7XG4gICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3hBeGlzU3RhcnRTY2FsZUNvb3JkaW5hdGUgPSB7IHg6IGV2ZW50LngsIHk6IGV2ZW50LnkgfTtcbiAgICAgICAgdGhpcy5feEF4aXNTdGFydFNjYWxlRGlzdGFuY2UgPSBldmVudC5wYWdlWDtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9wcm9jZXNzWEF4aXNTY3JvbGxpbmdFdmVudCA9IGZ1bmN0aW9uICh3aWRnZXQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNvbnN1bWVkID0gd2lkZ2V0LmRpc3BhdGNoRXZlbnQoJ3ByZXNzZWRNb3VzZU1vdmVFdmVudCcsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFjb25zdW1lZCkge1xuICAgICAgICAgICAgdmFyIHhBeGlzID0gd2lkZ2V0LmdldFBhbmUoKS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICBpZiAoeEF4aXMuc2Nyb2xsWm9vbUVuYWJsZWQgJiYgdGhpcy5feEF4aXNTdGFydFNjYWxlRGlzdGFuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLl94QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSAvIGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSAoc2NhbGUgLSB0aGlzLl94QXhpc1NjYWxlKSAqIDEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94QXhpc1NjYWxlID0gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYXJ0LmdldENoYXJ0U3RvcmUoKS56b29tKHpvb21TY2FsZSwgKF9hID0gdGhpcy5feEF4aXNTdGFydFNjYWxlQ29vcmRpbmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9wcm9jZXNzWUF4aXNTY2FsZVN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAod2lkZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgnbW91c2VEb3duRXZlbnQnLCBldmVudCk7XG4gICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhcnQudXBkYXRlUGFuZSgxIC8qIFVwZGF0ZUxldmVsLk92ZXJsYXkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHdpZGdldC5nZXRQYW5lKCkuZ2V0QXhpc0NvbXBvbmVudCgpLmdldFJhbmdlKCk7XG4gICAgICAgIHRoaXMuX3ByZXZZQXhpc1JhbmdlID0gX19hc3NpZ24oe30sIHJhbmdlKTtcbiAgICAgICAgdGhpcy5feUF4aXNTdGFydFNjYWxlRGlzdGFuY2UgPSBldmVudC5wYWdlWTtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9wcm9jZXNzWUF4aXNTY2FsaW5nRXZlbnQgPSBmdW5jdGlvbiAod2lkZ2V0LCBldmVudCkge1xuICAgICAgICB2YXIgY29uc3VtZWQgPSB3aWRnZXQuZGlzcGF0Y2hFdmVudCgncHJlc3NlZE1vdXNlTW92ZUV2ZW50JywgZXZlbnQpO1xuICAgICAgICBpZiAoIWNvbnN1bWVkKSB7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSB3aWRnZXQuZ2V0UGFuZSgpLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2WUF4aXNSYW5nZSAhPT0gbnVsbCAmJiB5QXhpcy5zY3JvbGxab29tRW5hYmxlZCAmJiB0aGlzLl95QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuX3ByZXZZQXhpc1JhbmdlLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBldmVudC5wYWdlWSAvIHRoaXMuX3lBeGlzU3RhcnRTY2FsZURpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IHJhbmdlICogc2NhbGU7XG4gICAgICAgICAgICAgICAgdmFyIGRpZlJhbmdlID0gKG5ld1JhbmdlIC0gcmFuZ2UpIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RnJvbSA9IGZyb20gLSBkaWZSYW5nZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VG8gPSB0byArIGRpZlJhbmdlO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSZWFsRnJvbSA9IHlBeGlzLnZhbHVlVG9SZWFsVmFsdWUobmV3RnJvbSwgeyByYW5nZTogdGhpcy5fcHJldllBeGlzUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JlYWxUbyA9IHlBeGlzLnZhbHVlVG9SZWFsVmFsdWUobmV3VG8sIHsgcmFuZ2U6IHRoaXMuX3ByZXZZQXhpc1JhbmdlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdEaXNwbGF5RnJvbSA9IHlBeGlzLnJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlKG5ld1JlYWxGcm9tLCB7IHJhbmdlOiB0aGlzLl9wcmV2WUF4aXNSYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlzcGxheVRvID0geUF4aXMucmVhbFZhbHVlVG9EaXNwbGF5VmFsdWUobmV3UmVhbFRvLCB7IHJhbmdlOiB0aGlzLl9wcmV2WUF4aXNSYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB5QXhpcy5zZXRSYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG5ld0Zyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiBuZXdUbyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG5ld1JhbmdlLFxuICAgICAgICAgICAgICAgICAgICByZWFsRnJvbTogbmV3UmVhbEZyb20sXG4gICAgICAgICAgICAgICAgICAgIHJlYWxUbzogbmV3UmVhbFRvLFxuICAgICAgICAgICAgICAgICAgICByZWFsUmFuZ2U6IG5ld1JlYWxUbyAtIG5ld1JlYWxGcm9tLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RnJvbTogbmV3RGlzcGxheUZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlUbzogbmV3RGlzcGxheVRvLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5UmFuZ2U6IG5ld0Rpc3BsYXlUbyAtIG5ld0Rpc3BsYXlGcm9tXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnQubGF5b3V0KHtcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFydC51cGRhdGVQYW5lKDEgLyogVXBkYXRlTGV2ZWwuT3ZlcmxheSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkO1xuICAgIH07XG4gICAgRXZlbnQucHJvdG90eXBlLl9maW5kV2lkZ2V0QnlFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIHggPSBldmVudC54LCB5ID0gZXZlbnQueTtcbiAgICAgICAgdmFyIHNlcGFyYXRvclBhbmVzID0gdGhpcy5fY2hhcnQuZ2V0U2VwYXJhdG9yUGFuZXMoKTtcbiAgICAgICAgdmFyIHNlcGFyYXRvclNpemUgPSB0aGlzLl9jaGFydC5nZXRTdHlsZXMoKS5zZXBhcmF0b3Iuc2l6ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHNlcGFyYXRvclBhbmVzXzEgPSBfX3ZhbHVlcyhzZXBhcmF0b3JQYW5lcyksIHNlcGFyYXRvclBhbmVzXzFfMSA9IHNlcGFyYXRvclBhbmVzXzEubmV4dCgpOyAhc2VwYXJhdG9yUGFuZXNfMV8xLmRvbmU7IHNlcGFyYXRvclBhbmVzXzFfMSA9IHNlcGFyYXRvclBhbmVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKHNlcGFyYXRvclBhbmVzXzFfMS52YWx1ZSwgMiksIHBhbmVfMSA9IF9jWzFdO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZyA9IHBhbmVfMS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IGJvdW5kaW5nLnRvcCAtIE1hdGgucm91bmQoKFJFQUxfU0VQQVJBVE9SX0hFSUdIVCAtIHNlcGFyYXRvclNpemUpIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gYm91bmRpbmcubGVmdCAmJiB4IDw9IGJvdW5kaW5nLmxlZnQgKyBib3VuZGluZy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICB5ID49IHRvcF8xICYmIHkgPD0gdG9wXzEgKyBSRUFMX1NFUEFSQVRPUl9IRUlHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFuZTogcGFuZV8xLCB3aWRnZXQ6IHBhbmVfMS5nZXRXaWRnZXQoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvclBhbmVzXzFfMSAmJiAhc2VwYXJhdG9yUGFuZXNfMV8xLmRvbmUgJiYgKF9hID0gc2VwYXJhdG9yUGFuZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHNlcGFyYXRvclBhbmVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkcmF3UGFuZXMgPSB0aGlzLl9jaGFydC5nZXREcmF3UGFuZXMoKTtcbiAgICAgICAgdmFyIHBhbmUgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZHJhd1BhbmVzXzEgPSBfX3ZhbHVlcyhkcmF3UGFuZXMpLCBkcmF3UGFuZXNfMV8xID0gZHJhd1BhbmVzXzEubmV4dCgpOyAhZHJhd1BhbmVzXzFfMS5kb25lOyBkcmF3UGFuZXNfMV8xID0gZHJhd1BhbmVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBkcmF3UGFuZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZyA9IHAuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSBib3VuZGluZy5sZWZ0ICYmIHggPD0gYm91bmRpbmcubGVmdCArIGJvdW5kaW5nLndpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPj0gYm91bmRpbmcudG9wICYmIHkgPD0gYm91bmRpbmcudG9wICsgYm91bmRpbmcuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChkcmF3UGFuZXNfMV8xICYmICFkcmF3UGFuZXNfMV8xLmRvbmUgJiYgKF9iID0gZHJhd1BhbmVzXzEucmV0dXJuKSkgX2IuY2FsbChkcmF3UGFuZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZGdldCA9IG51bGw7XG4gICAgICAgIGlmIChwYW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQod2lkZ2V0KSkge1xuICAgICAgICAgICAgICAgIHZhciBtYWluV2lkZ2V0ID0gcGFuZS5nZXRNYWluV2lkZ2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG1haW5Cb3VuZGluZyA9IG1haW5XaWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSBtYWluQm91bmRpbmcubGVmdCAmJiB4IDw9IG1haW5Cb3VuZGluZy5sZWZ0ICsgbWFpbkJvdW5kaW5nLndpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPj0gbWFpbkJvdW5kaW5nLnRvcCAmJiB5IDw9IG1haW5Cb3VuZGluZy50b3AgKyBtYWluQm91bmRpbmcuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IG1haW5XaWRnZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHdpZGdldCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNXaWRnZXQgPSBwYW5lLmdldFlBeGlzV2lkZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHlBeGlzV2lkZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5QXhpc0JvdW5kaW5nID0geUF4aXNXaWRnZXQuZ2V0Qm91bmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0geUF4aXNCb3VuZGluZy5sZWZ0ICYmIHggPD0geUF4aXNCb3VuZGluZy5sZWZ0ICsgeUF4aXNCb3VuZGluZy53aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgeSA+PSB5QXhpc0JvdW5kaW5nLnRvcCAmJiB5IDw9IHlBeGlzQm91bmRpbmcudG9wICsgeUF4aXNCb3VuZGluZy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IHlBeGlzV2lkZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhbmU6IHBhbmUsIHdpZGdldDogd2lkZ2V0IH07XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUuX21ha2VXaWRnZXRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgd2lkZ2V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB2YXIgYm91bmRpbmcgPSAoX2EgPSB3aWRnZXQgPT09IG51bGwgfHwgd2lkZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aWRnZXQuZ2V0Qm91bmRpbmcoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudCksIHsgeDogZXZlbnQueCAtICgoX2IgPSBib3VuZGluZyA9PT0gbnVsbCB8fCBib3VuZGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm91bmRpbmcubGVmdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCksIHk6IGV2ZW50LnkgLSAoKF9jID0gYm91bmRpbmcgPT09IG51bGwgfHwgYm91bmRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kaW5nLnRvcCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgfSk7XG4gICAgfTtcbiAgICBFdmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleUJvYXJkRG93bkV2ZW50KTtcbiAgICAgICAgdGhpcy5fZXZlbnQuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50O1xufSgpKTtcblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgRG9tUG9zaXRpb247XG4oZnVuY3Rpb24gKERvbVBvc2l0aW9uKSB7XG4gICAgRG9tUG9zaXRpb25bXCJSb290XCJdID0gXCJyb290XCI7XG4gICAgRG9tUG9zaXRpb25bXCJNYWluXCJdID0gXCJtYWluXCI7XG4gICAgRG9tUG9zaXRpb25bXCJZQXhpc1wiXSA9IFwieUF4aXNcIjtcbn0pKERvbVBvc2l0aW9uIHx8IChEb21Qb3NpdGlvbiA9IHt9KSk7XG52YXIgQ2hhcnRJbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhcnRJbXAoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0Qm91bmRpbmcgPSBjcmVhdGVEZWZhdWx0Qm91bmRpbmcoKTtcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzID0gW107XG4gICAgICAgIHRoaXMuX3NlcGFyYXRvclBhbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zID0ge1xuICAgICAgICAgICAgc29ydDogdHJ1ZSxcbiAgICAgICAgICAgIG1lYXN1cmVIZWlnaHQ6IHRydWUsXG4gICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICBidWlsZFlBeGlzVGljazogZmFsc2UsXG4gICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sYXlvdXRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fY2hhcnRFdmVudCA9IG5ldyBFdmVudCh0aGlzLl9jaGFydENvbnRhaW5lciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUgPSBuZXcgU3RvcmVJbXAodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2luaXRQYW5lcyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfVxuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5faW5pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLl9jaGFydENvbnRhaW5lciA9IGNyZWF0ZURvbSgnZGl2Jywge1xuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgICAgICBib3JkZXJTdHlsZTogJ25vbmUnLFxuICAgICAgICAgICAgY3Vyc29yOiAnY3Jvc3NoYWlyJyxcbiAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgd2Via2l0VXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIG1zVXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgTW96VXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgd2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NoYXJ0Q29udGFpbmVyLnRhYkluZGV4ID0gMTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NoYXJ0Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fY2FjaGVDaGFydEJvdW5kaW5nKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX2NhY2hlQ2hhcnRCb3VuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRCb3VuZGluZy53aWR0aCA9IE1hdGguZmxvb3IodGhpcy5fY2hhcnRDb250YWluZXIuY2xpZW50V2lkdGgpO1xuICAgICAgICB0aGlzLl9jaGFydEJvdW5kaW5nLmhlaWdodCA9IE1hdGguZmxvb3IodGhpcy5fY2hhcnRDb250YWluZXIuY2xpZW50SGVpZ2h0KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5faW5pdFBhbmVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgbGF5b3V0ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxheW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW3sgdHlwZTogXCJjYW5kbGVcIiAvKiBMYXlvdXRDaGlsZFR5cGUuQ2FuZGxlICovIH1dO1xuICAgICAgICB2YXIgY3JlYXRlQ2FuZGxlUGFuZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZChfdGhpcy5fY2FuZGxlUGFuZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZU9wdGlvbnNfMSA9IChfYSA9IGNoaWxkLm9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgICAgIG1lcmdlKHBhbmVPcHRpb25zXzEsIHsgaWQ6IFBhbmVJZENvbnN0YW50cy5DQU5ETEUgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NhbmRsZVBhbmUgPSBfdGhpcy5fY3JlYXRlUGFuZShDYW5kbGVQYW5lLCBQYW5lSWRDb25zdGFudHMuQ0FORExFLCBwYW5lT3B0aW9uc18xKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IChfYiA9IGNoaWxkLmNvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVJbmRpY2F0b3IodiwgdHJ1ZSwgcGFuZU9wdGlvbnNfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjcmVhdGVYQXhpc1BhbmUgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoX3RoaXMuX3hBeGlzUGFuZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZSA9IF90aGlzLl9jcmVhdGVQYW5lKFhBeGlzUGFuZSwgUGFuZUlkQ29uc3RhbnRzLlhfQVhJUywgb3BzICE9PSBudWxsICYmIG9wcyAhPT0gdm9pZCAwID8gb3BzIDoge30pO1xuICAgICAgICAgICAgICAgIF90aGlzLl94QXhpc1BhbmUgPSBwYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsYXlvdXQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNhbmRsZVwiIC8qIExheW91dENoaWxkVHlwZS5DYW5kbGUgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FuZGxlUGFuZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5kaWNhdG9yXCIgLyogTGF5b3V0Q2hpbGRUeXBlLkluZGljYXRvciAqLzoge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IChfYSA9IGNoaWxkLmNvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFuZUlkID0gKF9jID0gKF9iID0gY2hpbGQub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQocGFuZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVJZCA9IGNyZWF0ZUlkKFBhbmVJZENvbnN0YW50cy5JTkRJQ0FUT1IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVPcHRpb25zXzIgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2hpbGQub3B0aW9ucyksIHsgaWQ6IHBhbmVJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUluZGljYXRvcih2LCB0cnVlLCBwYW5lT3B0aW9uc18yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwieEF4aXNcIiAvKiBMYXlvdXRDaGlsZFR5cGUuWEF4aXMgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlWEF4aXNQYW5lKGNoaWxkLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjcmVhdGVDYW5kbGVQYW5lKHsgfSk7XG4gICAgICAgIGNyZWF0ZVhBeGlzUGFuZSh7IG9yZGVyOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5fY3JlYXRlUGFuZSA9IGZ1bmN0aW9uIChEcmF3UGFuZUNsYXNzLCBpZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcGFuZSA9IG5ldyBEcmF3UGFuZUNsYXNzKHRoaXMsIGlkLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICAgIHRoaXMuX2RyYXdQYW5lcy5wdXNoKHBhbmUpO1xuICAgICAgICByZXR1cm4gcGFuZTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5fcmVjYWxjdWxhdGVQYW5lSGVpZ2h0ID0gZnVuY3Rpb24gKGN1cnJlbnRQYW5lLCBjdXJyZW50SGVpZ2h0LCBjaGFuZ2VIZWlnaHQpIHtcbiAgICAgICAgaWYgKGNoYW5nZUhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxTdGF0ZVBhbmVzID0gdGhpcy5fZHJhd1BhbmVzLmZpbHRlcihmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgIHJldHVybiAocGFuZS5nZXRPcHRpb25zKCkuc3RhdGUgPT09IFwibm9ybWFsXCIgLyogUGFuZVN0YXRlLk5vcm1hbCAqLyAmJlxuICAgICAgICAgICAgICAgIHBhbmVJZCAhPT0gY3VycmVudFBhbmUuZ2V0SWQoKSAmJlxuICAgICAgICAgICAgICAgIHBhbmVJZCAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY291bnQgPSBub3JtYWxTdGF0ZVBhbmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRQYW5lLmdldElkKCkgIT09IFBhbmVJZENvbnN0YW50cy5DQU5ETEUgJiZcbiAgICAgICAgICAgIGlzVmFsaWQodGhpcy5fY2FuZGxlUGFuZSkgJiZcbiAgICAgICAgICAgIHRoaXMuX2NhbmRsZVBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlID09PSBcIm5vcm1hbFwiIC8qIFBhbmVTdGF0ZS5Ob3JtYWwgKi8pIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9jYW5kbGVQYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gdGhpcy5fY2FuZGxlUGFuZS5nZXRPcHRpb25zKCkubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBoZWlnaHQgKyBjaGFuZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0hlaWdodCA8IG1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgLT0gKGhlaWdodCArIGNoYW5nZUhlaWdodCAtIG5ld0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmRsZVBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IG5ld0hlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdIZWlnaHRfMSA9IGNoYW5nZUhlaWdodDtcbiAgICAgICAgICAgIHZhciBub3JtYWxTdGF0ZVBhbmVDaGFuZ2VIZWlnaHRfMSA9IE1hdGguZmxvb3IoY2hhbmdlSGVpZ2h0IC8gY291bnQpO1xuICAgICAgICAgICAgbm9ybWFsU3RhdGVQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gY291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGhlaWdodCArIHJlbWFpbmluZ0hlaWdodF8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ICsgbm9ybWFsU3RhdGVQYW5lQ2hhbmdlSGVpZ2h0XzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPCBwYW5lLmdldE9wdGlvbnMoKS5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcGFuZS5nZXRPcHRpb25zKCkubWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nSGVpZ2h0XzEgLT0gKG5ld0hlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhyZW1haW5pbmdIZWlnaHRfMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCAtPSByZW1haW5pbmdIZWlnaHRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFuZS5zZXRCb3VuZGluZyh7IGhlaWdodDogY3VycmVudEhlaWdodCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0RHJhd1BhbmVCeUlkID0gZnVuY3Rpb24gKHBhbmVJZCkge1xuICAgICAgICBpZiAocGFuZUlkID09PSBQYW5lSWRDb25zdGFudHMuQ0FORExFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuZGxlUGFuZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFuZUlkID09PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feEF4aXNQYW5lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5fZHJhd1BhbmVzLmZpbmQoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZ2V0SWQoKSA9PT0gcGFuZUlkOyB9KTtcbiAgICAgICAgcmV0dXJuIHBhbmUgIT09IG51bGwgJiYgcGFuZSAhPT0gdm9pZCAwID8gcGFuZSA6IG51bGw7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGFpbmVyOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRDaGFydFN0b3JlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0WEF4aXNQYW5lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5feEF4aXNQYW5lOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXREcmF3UGFuZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kcmF3UGFuZXM7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFNlcGFyYXRvclBhbmVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VwYXJhdG9yUGFuZXM7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBpZiAoKF9hID0gb3B0aW9ucy5zb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5zb3J0ID0gb3B0aW9ucy5zb3J0O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSBvcHRpb25zLm1lYXN1cmVIZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLm1lYXN1cmVIZWlnaHQgPSBvcHRpb25zLm1lYXN1cmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYyA9IG9wdGlvbnMubWVhc3VyZVdpZHRoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5tZWFzdXJlV2lkdGggPSBvcHRpb25zLm1lYXN1cmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9kID0gb3B0aW9ucy51cGRhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLnVwZGF0ZSA9IG9wdGlvbnMudXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2UgPSBvcHRpb25zLmJ1aWxkWUF4aXNUaWNrKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucy5idWlsZFlBeGlzVGljayA9IG9wdGlvbnMuYnVpbGRZQXhpc1RpY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZiA9IG9wdGlvbnMuYnVpbGRZQXhpc1RpY2spICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zLmZvcmNlQnVpbGRZQXhpc1RpY2sgPSBvcHRpb25zLmZvcmNlQnVpbGRZQXhpc1RpY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXRQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbGF5b3V0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xheW91dFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5fbGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9sYXlvdXRPcHRpb25zLCBzb3J0ID0gX2Euc29ydCwgbWVhc3VyZUhlaWdodCA9IF9hLm1lYXN1cmVIZWlnaHQsIG1lYXN1cmVXaWR0aCA9IF9hLm1lYXN1cmVXaWR0aCwgdXBkYXRlID0gX2EudXBkYXRlLCBidWlsZFlBeGlzVGljayA9IF9hLmJ1aWxkWUF4aXNUaWNrLCBmb3JjZUJ1aWxkWUF4aXNUaWNrID0gX2EuZm9yY2VCdWlsZFlBeGlzVGljaztcbiAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChpc1ZhbGlkKHRoaXMuX2NoYXJ0Q29udGFpbmVyLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhcnRDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fY2hhcnRDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXBhcmF0b3JQYW5lcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0T3B0aW9ucygpLm9yZGVyIC0gYi5nZXRPcHRpb25zKCkub3JkZXI7IH0pO1xuICAgICAgICAgICAgdmFyIHByZXZQYW5lXzEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFuZS5nZXRJZCgpICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHByZXZQYW5lXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yUGFuZSA9IG5ldyBTZXBhcmF0b3JQYW5lKF90aGlzLCAnJywgcHJldlBhbmVfMSwgcGFuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnRDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yUGFuZS5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuc2V0KHBhbmUsIHNlcGFyYXRvclBhbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZQYW5lXzEgPSBwYW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnRDb250YWluZXIuYXBwZW5kQ2hpbGQocGFuZS5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUhlaWdodCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gdGhpcy5fY2hhcnRCb3VuZGluZy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yU2l6ZV8xID0gdGhpcy5nZXRTdHlsZXMoKS5zZXBhcmF0b3Iuc2l6ZTtcbiAgICAgICAgICAgIHZhciB4QXhpc0hlaWdodCA9IHRoaXMuX3hBeGlzUGFuZS5nZXRBeGlzQ29tcG9uZW50KCkuZ2V0QXV0b1NpemUoKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdIZWlnaHRfMiA9IHRvdGFsSGVpZ2h0IC0geEF4aXNIZWlnaHQ7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nSGVpZ2h0XzIgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nSGVpZ2h0XzIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKF90aGlzLl9zZXBhcmF0b3JQYW5lcy5nZXQocGFuZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0hlaWdodF8yIC09IHNlcGFyYXRvclNpemVfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVJZCAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUyAmJiBwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5DQU5ETEUgJiYgcGFuZS5nZXRWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVIZWlnaHQgPSBwYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZUhlaWdodCA+IHJlbWFpbmluZ0hlaWdodF8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lSGVpZ2h0ID0gcmVtYWluaW5nSGVpZ2h0XzI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdIZWlnaHRfMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdIZWlnaHRfMiAtPSBwYW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHBhbmVIZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jYW5kbGVQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBNYXRoLm1heChyZW1haW5pbmdIZWlnaHRfMiwgMCkgfSk7XG4gICAgICAgICAgICB0aGlzLl94QXhpc1BhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHhBeGlzSGVpZ2h0IH0pO1xuICAgICAgICAgICAgdmFyIHRvcF8xID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvclBhbmUgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHNlcGFyYXRvclBhbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvclBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHNlcGFyYXRvclNpemVfMSwgdG9wOiB0b3BfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9wXzEgKz0gc2VwYXJhdG9yU2l6ZV8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lLnNldEJvdW5kaW5nKHsgdG9wOiB0b3BfMSB9KTtcbiAgICAgICAgICAgICAgICB0b3BfMSArPSBwYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcmNlTWVhc3VyZVdpZHRoID0gbWVhc3VyZVdpZHRoO1xuICAgICAgICBpZiAoYnVpbGRZQXhpc1RpY2sgfHwgZm9yY2VCdWlsZFlBeGlzVGljaykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2VzcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpLmJ1aWxkVGlja3MoZm9yY2VCdWlsZFlBeGlzVGljayk7XG4gICAgICAgICAgICAgICAgZm9yY2VNZWFzdXJlV2lkdGggfHwgKGZvcmNlTWVhc3VyZVdpZHRoID0gc3VjY2Vzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VNZWFzdXJlV2lkdGgpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbFdpZHRoID0gdGhpcy5fY2hhcnRCb3VuZGluZy53aWR0aDtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldFN0eWxlcygpO1xuICAgICAgICAgICAgdmFyIGxlZnRZQXhpc1dpZHRoXzEgPSAwO1xuICAgICAgICAgICAgdmFyIGxlZnRZQXhpc091dHNpZGVfMSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmlnaHRZQXhpc1dpZHRoXzEgPSAwO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WUF4aXNPdXRzaWRlXzEgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFuZS5nZXRJZCgpICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zaWRlID0geUF4aXMuaW5zaWRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUF4aXNXaWR0aCA9IHlBeGlzLmdldEF1dG9TaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5QXhpcy5wb3NpdGlvbiA9PT0gQXhpc1Bvc2l0aW9uLkxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRZQXhpc1dpZHRoXzEgPSBNYXRoLm1heChsZWZ0WUF4aXNXaWR0aF8xLCB5QXhpc1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0WUF4aXNPdXRzaWRlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0WUF4aXNXaWR0aF8xID0gTWF0aC5tYXgocmlnaHRZQXhpc1dpZHRoXzEsIHlBeGlzV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0WUF4aXNPdXRzaWRlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1haW5XaWR0aCA9IHRvdGFsV2lkdGg7XG4gICAgICAgICAgICB2YXIgbWFpbkxlZnQgPSAwO1xuICAgICAgICAgICAgdmFyIG1haW5SaWdodCA9IDA7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgICAgIGlmIChsZWZ0WUF4aXNPdXRzaWRlXzEpIHtcbiAgICAgICAgICAgICAgICBtYWluV2lkdGggLT0gbGVmdFlBeGlzV2lkdGhfMTtcbiAgICAgICAgICAgICAgICBtYWluTGVmdCA9IGxlZnRZQXhpc1dpZHRoXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBpZ25vcmVcbiAgICAgICAgICAgIGlmIChyaWdodFlBeGlzT3V0c2lkZV8xKSB7XG4gICAgICAgICAgICAgICAgbWFpbldpZHRoIC09IHJpZ2h0WUF4aXNXaWR0aF8xO1xuICAgICAgICAgICAgICAgIG1haW5SaWdodCA9IHJpZ2h0WUF4aXNXaWR0aF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRUb3RhbEJhclNwYWNlKG1haW5XaWR0aCk7XG4gICAgICAgICAgICB2YXIgcGFuZUJvdW5kaW5nXzEgPSB7IHdpZHRoOiB0b3RhbFdpZHRoIH07XG4gICAgICAgICAgICB2YXIgbWFpbkJvdW5kaW5nXzEgPSB7IHdpZHRoOiBtYWluV2lkdGgsIGxlZnQ6IG1haW5MZWZ0LCByaWdodDogbWFpblJpZ2h0IH07XG4gICAgICAgICAgICB2YXIgbGVmdFlBeGlzQm91bmRpbmdfMSA9IHsgd2lkdGg6IGxlZnRZQXhpc1dpZHRoXzEgfTtcbiAgICAgICAgICAgIHZhciByaWdodFlBeGlzQm91bmRpbmdfMSA9IHsgd2lkdGg6IHJpZ2h0WUF4aXNXaWR0aF8xIH07XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yRmlsbCA9IHN0eWxlcy5zZXBhcmF0b3IuZmlsbDtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JCb3VuZGluZ18xID0ge307XG4gICAgICAgICAgICBpZiAoIXNlcGFyYXRvckZpbGwpIHtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JCb3VuZGluZ18xID0gbWFpbkJvdW5kaW5nXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JCb3VuZGluZ18xID0gcGFuZUJvdW5kaW5nXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Qm91bmRpbmcoc2VwYXJhdG9yQm91bmRpbmdfMSk7XG4gICAgICAgICAgICAgICAgcGFuZS5zZXRCb3VuZGluZyhwYW5lQm91bmRpbmdfMSwgbWFpbkJvdW5kaW5nXzEsIGxlZnRZQXhpc0JvdW5kaW5nXzEsIHJpZ2h0WUF4aXNCb3VuZGluZ18xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3hBeGlzUGFuZS5nZXRBeGlzQ29tcG9uZW50KCkuYnVpbGRUaWNrcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFuZSg0IC8qIFVwZGF0ZUxldmVsLkFsbCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5b3V0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogZmFsc2UsXG4gICAgICAgICAgICBtZWFzdXJlV2lkdGg6IGZhbHNlLFxuICAgICAgICAgICAgdXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcmNlQnVpbGRZQXhpc1RpY2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUudXBkYXRlUGFuZSA9IGZ1bmN0aW9uIChsZXZlbCwgcGFuZUlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXREcmF3UGFuZUJ5SWQocGFuZUlkKTtcbiAgICAgICAgICAgIHBhbmUgPT09IG51bGwgfHwgcGFuZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZS51cGRhdGUobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcGFuZS51cGRhdGUobGV2ZWwpO1xuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9zZXBhcmF0b3JQYW5lcy5nZXQocGFuZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGUobGV2ZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5jcm9zc2hhaXJDaGFuZ2UgPSBmdW5jdGlvbiAoY3Jvc3NoYWlyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9jaGFydFN0b3JlLmhhc0FjdGlvbihBY3Rpb25UeXBlLk9uQ3Jvc3NoYWlyQ2hhbmdlKSkge1xuICAgICAgICAgICAgdmFyIGluZGljYXRvckRhdGFfMSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBwYW5lLmdldElkKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhbmVJbmRpY2F0b3JEYXRhID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGluZGljYXRvcnMgPSBfdGhpcy5fY2hhcnRTdG9yZS5nZXRJbmRpY2F0b3JzQnlQYW5lSWQoaWQpO1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluZGljYXRvci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVJbmRpY2F0b3JEYXRhW2luZGljYXRvci5uYW1lXSA9IHJlc3VsdFsoX2EgPSBjcm9zc2hhaXIuZGF0YUluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yRGF0YV8xW2lkXSA9IHBhbmVJbmRpY2F0b3JEYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoY3Jvc3NoYWlyLnBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydFN0b3JlLmV4ZWN1dGVBY3Rpb24oQWN0aW9uVHlwZS5PbkNyb3NzaGFpckNoYW5nZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNyb3NzaGFpciksIHsgaW5kaWNhdG9yRGF0YTogaW5kaWNhdG9yRGF0YV8xIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldERvbSA9IGZ1bmN0aW9uIChwYW5lSWQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXREcmF3UGFuZUJ5SWQocGFuZUlkKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhbmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6IERvbVBvc2l0aW9uLlJvb3Q7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEb21Qb3NpdGlvbi5Sb290OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFuZS5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIERvbVBvc2l0aW9uLk1haW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYW5lLmdldE1haW5XaWRnZXQoKS5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIERvbVBvc2l0aW9uLllBeGlzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gcGFuZS5nZXRZQXhpc1dpZGdldCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29udGFpbmVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIChwYW5lSWQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhbmVJZCkpIHtcbiAgICAgICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXREcmF3UGFuZUJ5SWQocGFuZUlkKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhbmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6IERvbVBvc2l0aW9uLlJvb3Q7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEb21Qb3NpdGlvbi5Sb290OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFuZS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRG9tUG9zaXRpb24uTWFpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhbmUuZ2V0TWFpbldpZGdldCgpLmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEb21Qb3NpdGlvbi5ZQXhpczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHBhbmUuZ2V0WUF4aXNXaWRnZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRCb3VuZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0UHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRQcmVjaXNpb24oKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY2hhcnRTdG9yZS5zZXRTdHlsZXModmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldFN0eWxlcygpOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRDdXN0b21BcGkgPSBmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0Q3VzdG9tQXBpKGFwaSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldEN1c3RvbUFwaSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0Q3VzdG9tQXBpKCk7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldExvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY2hhcnRTdG9yZS5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0TG9jYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRMb2NhbGUoKTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0VGltZXpvbmUgPSBmdW5jdGlvbiAodGltZXpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2V0T3B0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY2hhcnRTdG9yZS5zZXRUaW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFRpbWV6b25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRUaW1lem9uZSgpOyB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRUaG91c2FuZHNTZXBhcmF0b3IgPSBmdW5jdGlvbiAodGhvdXNhbmRzU2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0VGhvdXNhbmRzU2VwYXJhdG9yKHRob3VzYW5kc1NlcGFyYXRvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldFRob3VzYW5kc1NlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCk7IH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldERlY2ltYWxGb2xkID0gZnVuY3Rpb24gKGRlY2ltYWxGb2xkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2V0RGVjaW1hbEZvbGQoZGVjaW1hbEZvbGQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXREZWNpbWFsRm9sZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0RGVjaW1hbEZvbGQoKTsgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuX3NldE9wdGlvbnMgPSBmdW5jdGlvbiAoZnVjKSB7XG4gICAgICAgIGZ1YygpO1xuICAgICAgICB0aGlzLmxheW91dCh7XG4gICAgICAgICAgICBtZWFzdXJlSGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWUsXG4gICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRPZmZzZXRSaWdodERpc3RhbmNlKGRpc3RhbmNlLCB0cnVlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRPZmZzZXRSaWdodERpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRPZmZzZXRSaWdodERpc3RhbmNlKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0TWF4T2Zmc2V0TGVmdERpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgIGxvZ1dhcm4oJ3NldE1heE9mZnNldExlZnREaXN0YW5jZScsICdkaXN0YW5jZScsICdkaXN0YW5jZSBtdXN0IGdyZWF0ZXIgdGhhbiB6ZXJvISEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRNYXhPZmZzZXRMZWZ0RGlzdGFuY2UoZGlzdGFuY2UpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldE1heE9mZnNldFJpZ2h0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgbG9nV2Fybignc2V0TWF4T2Zmc2V0UmlnaHREaXN0YW5jZScsICdkaXN0YW5jZScsICdkaXN0YW5jZSBtdXN0IGdyZWF0ZXIgdGhhbiB6ZXJvISEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRNYXhPZmZzZXRSaWdodERpc3RhbmNlKGRpc3RhbmNlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRMZWZ0TWluVmlzaWJsZUJhckNvdW50ID0gZnVuY3Rpb24gKGJhckNvdW50KSB7XG4gICAgICAgIGlmIChiYXJDb3VudCA8IDApIHtcbiAgICAgICAgICAgIGxvZ1dhcm4oJ3NldExlZnRNaW5WaXNpYmxlQmFyQ291bnQnLCAnYmFyQ291bnQnLCAnYmFyQ291bnQgbXVzdCBncmVhdGVyIHRoYW4gemVybyEhIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0TGVmdE1pblZpc2libGVCYXJDb3VudChNYXRoLmNlaWwoYmFyQ291bnQpKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRSaWdodE1pblZpc2libGVCYXJDb3VudCA9IGZ1bmN0aW9uIChiYXJDb3VudCkge1xuICAgICAgICBpZiAoYmFyQ291bnQgPCAwKSB7XG4gICAgICAgICAgICBsb2dXYXJuKCdzZXRSaWdodE1pblZpc2libGVCYXJDb3VudCcsICdiYXJDb3VudCcsICdiYXJDb3VudCBtdXN0IGdyZWF0ZXIgdGhhbiB6ZXJvISEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRSaWdodE1pblZpc2libGVCYXJDb3VudChNYXRoLmNlaWwoYmFyQ291bnQpKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRCYXJTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSkge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldEJhclNwYWNlKHNwYWNlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRCYXJTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0QmFyU3BhY2UoKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRWaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmdldFZpc2libGVSYW5nZSgpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmNsZWFyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5jbGVhckRhdGEoKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXREYXRhTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0RGF0YUxpc3QoKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5hcHBseU5ld0RhdGEgPSBmdW5jdGlvbiAoZGF0YSwgbW9yZSkge1xuICAgICAgICB0aGlzLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgcGFuZS5nZXRBeGlzQ29tcG9uZW50KCkuc2V0QXV0b0NhbGNUaWNrRmxhZyh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsb2FkRGF0YU1vcmUgPSB7IGZvcndhcmQ6IGZhbHNlLCBiYWNrd2FyZDogZmFsc2UgfTtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihtb3JlKSkge1xuICAgICAgICAgICAgbG9hZERhdGFNb3JlLmZvcndhcmQgPSBtb3JlO1xuICAgICAgICAgICAgbG9hZERhdGFNb3JlLmJhY2t3YXJkID0gbW9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYWREYXRhTW9yZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsb2FkRGF0YU1vcmUpLCBtb3JlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLmFkZERhdGEoZGF0YSwgTG9hZERhdGFUeXBlLkluaXQsIGxvYWREYXRhTW9yZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuYWRkRGF0YShkYXRhLCBMb2FkRGF0YVR5cGUuVXBkYXRlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRMb2FkTW9yZURhdGFDYWxsYmFjayA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldExvYWRNb3JlRGF0YUNhbGxiYWNrKGNiKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5jcmVhdGVJbmRpY2F0b3IgPSBmdW5jdGlvbiAodmFsdWUsIGlzU3RhY2ssIHBhbmVPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGluZGljYXRvciA9IGlzU3RyaW5nKHZhbHVlKSA/IHsgbmFtZTogdmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICBpZiAoZ2V0SW5kaWNhdG9yQ2xhc3MoaW5kaWNhdG9yLm5hbWUpID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dXYXJuKCdjcmVhdGVJbmRpY2F0b3InLCAndmFsdWUnLCAnaW5kaWNhdG9yIG5vdCBzdXBwb3J0ZWQsIHlvdSBtYXkgbmVlZCB0byB1c2UgcmVnaXN0ZXJJbmRpY2F0b3IgdG8gYWRkIG9uZSEhIScpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhbmVPcHRzID0gcGFuZU9wdGlvbnMgIT09IG51bGwgJiYgcGFuZU9wdGlvbnMgIT09IHZvaWQgMCA/IHBhbmVPcHRpb25zIDoge307XG4gICAgICAgIGlmICghaXNTdHJpbmcocGFuZU9wdHMuaWQpKSB7XG4gICAgICAgICAgICBwYW5lT3B0cy5pZCA9IGNyZWF0ZUlkKFBhbmVJZENvbnN0YW50cy5JTkRJQ0FUT1IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJpbmcoaW5kaWNhdG9yLmlkKSkge1xuICAgICAgICAgICAgaW5kaWNhdG9yLmlkID0gY3JlYXRlSWQoaW5kaWNhdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jaGFydFN0b3JlLmFkZEluZGljYXRvcihpbmRpY2F0b3IsIHBhbmVPcHRzLmlkLCBpc1N0YWNrICE9PSBudWxsICYmIGlzU3RhY2sgIT09IHZvaWQgMCA/IGlzU3RhY2sgOiBmYWxzZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRTb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGhpcy5nZXREcmF3UGFuZUJ5SWQocGFuZU9wdHMuaWQpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBhbmUoSW5kaWNhdG9yUGFuZSwgcGFuZU9wdHMuaWQsIHBhbmVPcHRzKTtcbiAgICAgICAgICAgICAgICAoX2EgPSBwYW5lT3B0cy5oZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwYW5lT3B0cy5oZWlnaHQgPSBQQU5FX0RFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0UGFuZU9wdGlvbnMocGFuZU9wdHMpO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQoe1xuICAgICAgICAgICAgICAgIHNvcnQ6IHNob3VsZFNvcnQsXG4gICAgICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlV2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvcmNlQnVpbGRZQXhpc1RpY2s6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGluZGljYXRvci5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5vdmVycmlkZUluZGljYXRvciA9IGZ1bmN0aW9uIChvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5vdmVycmlkZUluZGljYXRvcihvdmVycmlkZSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0SW5kaWNhdG9ycyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0SW5kaWNhdG9yc0J5RmlsdGVyKGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IHt9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5yZW1vdmVJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fY2hhcnRTdG9yZS5yZW1vdmVJbmRpY2F0b3IoZmlsdGVyICE9PSBudWxsICYmIGZpbHRlciAhPT0gdm9pZCAwID8gZmlsdGVyIDoge30pO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgdmFyIHNob3VsZE1lYXN1cmVIZWlnaHRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHBhbmVJZHNfMSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFuZUlkID0gcGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5DQU5ETEUgJiYgcGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVJZHNfMS5wdXNoKHBhbmVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYW5lSWRzXzEuZm9yRWFjaChmdW5jdGlvbiAocGFuZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fY2hhcnRTdG9yZS5oYXNJbmRpY2F0b3JzKHBhbmVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX2RyYXdQYW5lcy5maW5kSW5kZXgoZnVuY3Rpb24gKHBhbmUpIHsgcmV0dXJuIHBhbmUuZ2V0SWQoKSA9PT0gcGFuZUlkOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmUgPSBfdGhpcy5fZHJhd1BhbmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQocGFuZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE1lYXN1cmVIZWlnaHRfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVjYWxjdWxhdGVQYW5lSGVpZ2h0KHBhbmUsIDAsIHBhbmUuZ2V0Qm91bmRpbmcoKS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdQYW5lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3UGFuZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuZGxlUGFuZS5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmRsZVBhbmUuc2V0Qm91bmRpbmcoeyBoZWlnaHQ6IHRoaXMuX2NoYXJ0Qm91bmRpbmcuaGVpZ2h0IC0gdGhpcy5feEF4aXNQYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXlvdXQoe1xuICAgICAgICAgICAgICAgIHNvcnQ6IHNob3VsZE1lYXN1cmVIZWlnaHRfMSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlSGVpZ2h0OiBzaG91bGRNZWFzdXJlSGVpZ2h0XzEsXG4gICAgICAgICAgICAgICAgbWVhc3VyZVdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBidWlsZFlBeGlzVGljazogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb3JjZUJ1aWxkWUF4aXNUaWNrOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvdmVybGF5cyA9IFtdO1xuICAgICAgICB2YXIgYXBwb2ludFBhbmVGbGFncyA9IFtdO1xuICAgICAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiAob3ZlcmxheSkge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKG92ZXJsYXkucGFuZUlkKSB8fCBfdGhpcy5nZXREcmF3UGFuZUJ5SWQob3ZlcmxheS5wYW5lSWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5wYW5lSWQgPSBQYW5lSWRDb25zdGFudHMuQ0FORExFO1xuICAgICAgICAgICAgICAgIGFwcG9pbnRQYW5lRmxhZ3MucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBvaW50UGFuZUZsYWdzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVybGF5cy5wdXNoKG92ZXJsYXkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBidWlsZCh7IG5hbWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2KSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0geyBuYW1lOiB2IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVpbGQob3ZlcmxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWRzID0gdGhpcy5fY2hhcnRTdG9yZS5hZGRPdmVybGF5cyhvdmVybGF5cywgYXBwb2ludFBhbmVGbGFncyk7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRzWzBdO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLmdldE92ZXJsYXlzID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5nZXRPdmVybGF5c0J5RmlsdGVyKGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IHt9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5vdmVycmlkZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJ0U3RvcmUub3ZlcnJpZGVPdmVybGF5KG92ZXJyaWRlKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5yZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5yZW1vdmVPdmVybGF5KGZpbHRlciAhPT0gbnVsbCAmJiBmaWx0ZXIgIT09IHZvaWQgMCA/IGZpbHRlciA6IHt9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5zZXRQYW5lT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBzaG91bGRNZWFzdXJlSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzaG91bGRMYXlvdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHZhbGlkSWQgPSBpc1ZhbGlkKG9wdGlvbnMuaWQpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChjdXJyZW50UGFuZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYW5lSWQgPSBjdXJyZW50UGFuZS5nZXRJZCgpO1xuICAgICAgICAgICAgaWYgKCh2YWxpZElkICYmIG9wdGlvbnMuaWQgPT09IGN1cnJlbnRQYW5lSWQpIHx8ICF2YWxpZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG9wdGlvbnMuaGVpZ2h0KSAmJiBvcHRpb25zLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5IZWlnaHQgPSBNYXRoLm1heCgoX2IgPSBvcHRpb25zLm1pbkhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3VycmVudFBhbmUuZ2V0T3B0aW9ucygpLm1pbkhlaWdodCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBvcHRpb25zLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkTWVhc3VyZUhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZS5zZXRPcmlnaW5hbEJvdW5kaW5nKHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuX3JlY2FsY3VsYXRlUGFuZUhlaWdodChjdXJyZW50UGFuZSwgaGVpZ2h0LCAtaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChvcHRpb25zLnN0YXRlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuZ2V0T3B0aW9ucygpLnN0YXRlICE9PSBvcHRpb25zLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRNZWFzdXJlSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZExheW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXhpbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NYXhpbWl6ZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4aW1pemVQYW5lID0gdGhpc18xLl9kcmF3UGFuZXMuZmluZChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbmVJZCA9IHBhbmUuZ2V0SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSA9PT0gXCJtYXhpbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NYXhpbWl6ZSAqLyAmJiBwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQobWF4aW1pemVQYW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZSA9PT0gXCJub3JtYWxcIiAvKiBQYW5lU3RhdGUuTm9ybWFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3JpZ2luYWxCb3VuZGluZyh7IGhlaWdodDogY3VycmVudFBhbmUuZ2V0Qm91bmRpbmcoKS5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFuZS5zZXRPcHRpb25zKHsgc3RhdGU6IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gdGhpc18xLl9jaGFydEJvdW5kaW5nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiB0b3RhbEhlaWdodCAtIHRoaXNfMS5feEF4aXNQYW5lLmdldEJvdW5kaW5nKCkuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5nZXRJZCgpICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTICYmIHBhbmUuZ2V0SWQoKSAhPT0gY3VycmVudFBhbmVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lLnNldEJvdW5kaW5nKHsgaGVpZ2h0OiBwYW5lLmdldE9yaWdpbmFsQm91bmRpbmcoKS5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9zZXBhcmF0b3JQYW5lcy5nZXQocGFuZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pbmltaXplXCIgLyogUGFuZVN0YXRlLk1pbmltaXplICovOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjdXJyZW50UGFuZS5nZXRCb3VuZGluZygpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRQYW5lLmdldE9wdGlvbnMoKS5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZUhlaWdodCA9IGhlaWdodCAtIFBBTkVfTUlOX0hFSUdIVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gXCJtYXhpbWl6ZVwiIC8qIFBhbmVTdGF0ZS5NYXhpbWl6ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVpZ2h0ID0gY3VycmVudFBhbmUuZ2V0T3JpZ2luYWxCb3VuZGluZygpLmhlaWdodCAtIFBBTkVfTUlOX0hFSUdIVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc18xLl9yZWNhbGN1bGF0ZVBhbmVIZWlnaHQoY3VycmVudFBhbmUsIFBBTkVfTUlOX0hFSUdIVCwgY2hhbmdlSGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gXCJub3JtYWxcIiAvKiBQYW5lU3RhdGUuTm9ybWFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3JpZ2luYWxCb3VuZGluZyh7IGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhbmUuc2V0T3B0aW9ucyh7IHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuX2RyYXdQYW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZS5nZXRJZCgpICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZS5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9zZXBhcmF0b3JQYW5lcy5nZXQocGFuZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGN1cnJlbnRQYW5lLmdldE9yaWdpbmFsQm91bmRpbmcoKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEuX3JlY2FsY3VsYXRlUGFuZUhlaWdodChjdXJyZW50UGFuZSwgaGVpZ2h0LCBjdXJyZW50UGFuZS5nZXRCb3VuZGluZygpLmhlaWdodCAtIGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYW5lLnNldE9wdGlvbnMoeyBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLl9kcmF3UGFuZXMuZm9yRWFjaChmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmUuZ2V0SWQoKSAhPT0gUGFuZUlkQ29uc3RhbnRzLlhfQVhJUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmUuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fc2VwYXJhdG9yUGFuZXMuZ2V0KHBhbmUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChvcHRpb25zLmF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZExheW91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvcHMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFuZS5zZXRPcHRpb25zKG9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYW5lSWQgPT09IG9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLl9kcmF3UGFuZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQYW5lID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKGN1cnJlbnRQYW5lKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0KHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlSGVpZ2h0OiBzaG91bGRNZWFzdXJlSGVpZ2h0LFxuICAgICAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgYnVpbGRZQXhpc1RpY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgZm9yY2VCdWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5nZXRQYW5lT3B0aW9ucyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc1ZhbGlkKGlkKSkge1xuICAgICAgICAgICAgdmFyIHBhbmUgPSB0aGlzLmdldERyYXdQYW5lQnlJZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmdldE9wdGlvbnMoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd1BhbmVzLm1hcChmdW5jdGlvbiAocGFuZSkgeyByZXR1cm4gcGFuZS5nZXRPcHRpb25zKCk7IH0pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNldFpvb21FbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS5zZXRab29tRW5hYmxlZChlbmFibGVkKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5pc1pvb21FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRTdG9yZS5pc1pvb21FbmFibGVkKCk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2V0U2Nyb2xsRW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2V0U2Nyb2xsRW5hYmxlZChlbmFibGVkKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5pc1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFydFN0b3JlLmlzU2Nyb2xsRW5hYmxlZCgpO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNjcm9sbEJ5RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UsIGFuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlzTnVtYmVyKGFuaW1hdGlvbkR1cmF0aW9uKSAmJiBhbmltYXRpb25EdXJhdGlvbiA+IDAgPyBhbmltYXRpb25EdXJhdGlvbiA6IDA7XG4gICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc3RhcnRTY3JvbGwoKTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oeyBkdXJhdGlvbjogZHVyYXRpb24gfSk7XG4gICAgICAgICAgICBhbmltYXRpb24uZG9GcmFtZShmdW5jdGlvbiAoZnJhbWVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzRGlzdGFuY2UgPSBkaXN0YW5jZSAqIChmcmFtZVRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoYXJ0U3RvcmUuc2Nyb2xsKHByb2dyZXNzRGlzdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb24uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYXJ0U3RvcmUuc2Nyb2xsKGRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNjcm9sbFRvUmVhbFRpbWUgPSBmdW5jdGlvbiAoYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGJhclNwYWNlID0gdGhpcy5fY2hhcnRTdG9yZS5nZXRCYXJTcGFjZSgpLmJhcjtcbiAgICAgICAgdmFyIGRpZkJhckNvdW50ID0gdGhpcy5fY2hhcnRTdG9yZS5nZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50KCkgLSB0aGlzLl9jaGFydFN0b3JlLmdldEluaXRpYWxPZmZzZXRSaWdodERpc3RhbmNlKCkgLyBiYXJTcGFjZTtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gZGlmQmFyQ291bnQgKiBiYXJTcGFjZTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeURpc3RhbmNlKGRpc3RhbmNlLCBhbmltYXRpb25EdXJhdGlvbik7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuc2Nyb2xsVG9EYXRhSW5kZXggPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBhbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSAodGhpcy5fY2hhcnRTdG9yZS5nZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50KCkgKyAodGhpcy5nZXREYXRhTGlzdCgpLmxlbmd0aCAtIDEgLSBkYXRhSW5kZXgpKSAqIHRoaXMuX2NoYXJ0U3RvcmUuZ2V0QmFyU3BhY2UoKS5iYXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnlEaXN0YW5jZShkaXN0YW5jZSwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnNjcm9sbFRvVGltZXN0YW1wID0gZnVuY3Rpb24gKHRpbWVzdGFtcCwgYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IGJpbmFyeVNlYXJjaE5lYXJlc3QodGhpcy5nZXREYXRhTGlzdCgpLCAndGltZXN0YW1wJywgdGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0RhdGFJbmRleChkYXRhSW5kZXgsIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS56b29tQXRDb29yZGluYXRlID0gZnVuY3Rpb24gKHNjYWxlLCBjb29yZGluYXRlLCBhbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpc051bWJlcihhbmltYXRpb25EdXJhdGlvbikgJiYgYW5pbWF0aW9uRHVyYXRpb24gPiAwID8gYW5pbWF0aW9uRHVyYXRpb24gOiAwO1xuICAgICAgICB2YXIgYmFyU3BhY2UgPSB0aGlzLl9jaGFydFN0b3JlLmdldEJhclNwYWNlKCkuYmFyO1xuICAgICAgICB2YXIgc2NhbGVCYXJTcGFjZSA9IGJhclNwYWNlICogc2NhbGU7XG4gICAgICAgIHZhciBkaWZTcGFjZSA9IHNjYWxlQmFyU3BhY2UgLSBiYXJTcGFjZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9ncmVzc0JhclNwYWNlXzEgPSAwO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oeyBkdXJhdGlvbjogZHVyYXRpb24gfSk7XG4gICAgICAgICAgICBhbmltYXRpb24uZG9GcmFtZShmdW5jdGlvbiAoZnJhbWVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzQmFyU3BhY2UgPSBkaWZTcGFjZSAqIChmcmFtZVRpbWUgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gKHByb2dyZXNzQmFyU3BhY2UgLSBwcmV2UHJvZ3Jlc3NCYXJTcGFjZV8xKSAvIF90aGlzLl9jaGFydFN0b3JlLmdldEJhclNwYWNlKCkuYmFyICogU0NBTEVfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2hhcnRTdG9yZS56b29tKHNjYWxlLCBjb29yZGluYXRlKTtcbiAgICAgICAgICAgICAgICBwcmV2UHJvZ3Jlc3NCYXJTcGFjZV8xID0gcHJvZ3Jlc3NCYXJTcGFjZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnpvb20oZGlmU3BhY2UgLyBiYXJTcGFjZSAqIFNDQUxFX01VTFRJUExJRVIsIGNvb3JkaW5hdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuem9vbUF0RGF0YUluZGV4ID0gZnVuY3Rpb24gKHNjYWxlLCBkYXRhSW5kZXgsIGFuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5fY2hhcnRTdG9yZS5kYXRhSW5kZXhUb0Nvb3JkaW5hdGUoZGF0YUluZGV4KTtcbiAgICAgICAgdGhpcy56b29tQXRDb29yZGluYXRlKHNjYWxlLCB7IHg6IHgsIHk6IDAgfSwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnpvb21BdFRpbWVzdGFtcCA9IGZ1bmN0aW9uIChzY2FsZSwgdGltZXN0YW1wLCBhbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gYmluYXJ5U2VhcmNoTmVhcmVzdCh0aGlzLmdldERhdGFMaXN0KCksICd0aW1lc3RhbXAnLCB0aW1lc3RhbXApO1xuICAgICAgICB0aGlzLnpvb21BdERhdGFJbmRleChzY2FsZSwgZGF0YUluZGV4LCBhbmltYXRpb25EdXJhdGlvbik7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuY29udmVydFRvUGl4ZWwgPSBmdW5jdGlvbiAocG9pbnRzLCBmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSBmaWx0ZXIgIT09IG51bGwgJiYgZmlsdGVyICE9PSB2b2lkIDAgPyBmaWx0ZXIgOiB7fSwgX2MgPSBfYi5wYW5lSWQsIHBhbmVJZCA9IF9jID09PSB2b2lkIDAgPyBQYW5lSWRDb25zdGFudHMuQ0FORExFIDogX2MsIF9kID0gX2IuYWJzb2x1dGUsIGFic29sdXRlID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Q7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xuICAgICAgICBpZiAocGFuZUlkICE9PSBQYW5lSWRDb25zdGFudHMuWF9BWElTKSB7XG4gICAgICAgICAgICB2YXIgcGFuZSA9IHRoaXMuZ2V0RHJhd1BhbmVCeUlkKHBhbmVJZCk7XG4gICAgICAgICAgICBpZiAocGFuZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ18xID0gcGFuZS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgLS0gaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHZhciBwcyA9IFtdLmNvbmNhdChwb2ludHMpO1xuICAgICAgICAgICAgICAgIHZhciB4QXhpc18xID0gdGhpcy5feEF4aXNQYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXNfMSA9IHBhbmUuZ2V0QXhpc0NvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gcG9pbnQuZGF0YUluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocG9pbnQudGltZXN0YW1wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUluZGV4ID0gX3RoaXMuX2NoYXJ0U3RvcmUudGltZXN0YW1wVG9EYXRhSW5kZXgocG9pbnQudGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZS54ID0geEF4aXNfMS5jb252ZXJ0VG9QaXhlbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihwb2ludC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0geUF4aXNfMS5jb252ZXJ0VG9QaXhlbChwb2ludC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlLnkgPSBhYnNvbHV0ZSA/IGJvdW5kaW5nXzEudG9wICsgeSA6IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkocG9pbnRzKSA/IGNvb3JkaW5hdGVzIDogKChfYSA9IGNvb3JkaW5hdGVzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuY29udmVydEZyb21QaXhlbCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gZmlsdGVyICE9PSBudWxsICYmIGZpbHRlciAhPT0gdm9pZCAwID8gZmlsdGVyIDoge30sIF9jID0gX2IucGFuZUlkLCBwYW5lSWQgPSBfYyA9PT0gdm9pZCAwID8gUGFuZUlkQ29uc3RhbnRzLkNBTkRMRSA6IF9jLCBfZCA9IF9iLmFic29sdXRlLCBhYnNvbHV0ZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kO1xuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIGlmIChwYW5lSWQgIT09IFBhbmVJZENvbnN0YW50cy5YX0FYSVMpIHtcbiAgICAgICAgICAgIHZhciBwYW5lID0gdGhpcy5nZXREcmF3UGFuZUJ5SWQocGFuZUlkKTtcbiAgICAgICAgICAgIGlmIChwYW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nXzIgPSBwYW5lLmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAtLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgdmFyIGNzID0gW10uY29uY2F0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNfMiA9IHRoaXMuX3hBeGlzUGFuZS5nZXRBeGlzQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzXzIgPSBwYW5lLmdldEF4aXNDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBjcy5tYXAoZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGNvb3JkaW5hdGUueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kZXggPSB4QXhpc18yLmNvbnZlcnRGcm9tUGl4ZWwoY29vcmRpbmF0ZS54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LmRhdGFJbmRleCA9IGRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnRpbWVzdGFtcCA9IChfYSA9IF90aGlzLl9jaGFydFN0b3JlLmRhdGFJbmRleFRvVGltZXN0YW1wKGRhdGFJbmRleCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoY29vcmRpbmF0ZS55KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBhYnNvbHV0ZSA/IGNvb3JkaW5hdGUueSAtIGJvdW5kaW5nXzIudG9wIDogY29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQudmFsdWUgPSB5QXhpc18yLmNvbnZlcnRGcm9tUGl4ZWwoeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KGNvb3JkaW5hdGVzKSA/IHBvaW50cyA6ICgoX2EgPSBwb2ludHNbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5leGVjdXRlQWN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uVHlwZS5PbkNyb3NzaGFpckNoYW5nZToge1xuICAgICAgICAgICAgICAgIHZhciBjcm9zc2hhaXIgPSBfX2Fzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgKF9hID0gY3Jvc3NoYWlyLnBhbmVJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNyb3NzaGFpci5wYW5lSWQgPSBQYW5lSWRDb25zdGFudHMuQ0FORExFKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnNldENyb3NzaGFpcihjcm9zc2hhaXIsIHsgbm90RXhlY3V0ZUFjdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhcnRJbXAucHJvdG90eXBlLnN1YnNjcmliZUFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jaGFydFN0b3JlLnN1YnNjcmliZUFjdGlvbih0eXBlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUudW5zdWJzY3JpYmVBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2hhcnRTdG9yZS51bnN1YnNjcmliZUFjdGlvbih0eXBlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUuZ2V0Q29udmVydFBpY3R1cmVVcmwgPSBmdW5jdGlvbiAoaW5jbHVkZU92ZXJsYXksIHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9jaGFydEJvdW5kaW5nLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVEb20oJ2NhbnZhcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcbiAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCAmJiBiYWNrZ3JvdW5kQ29sb3IgIT09IHZvaWQgMCA/IGJhY2tncm91bmRDb2xvciA6ICcjRkZGRkZGJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgb3ZlcmxheUZsYWcgPSBpbmNsdWRlT3ZlcmxheSAhPT0gbnVsbCAmJiBpbmNsdWRlT3ZlcmxheSAhPT0gdm9pZCAwID8gaW5jbHVkZU92ZXJsYXkgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JQYW5lID0gX3RoaXMuX3NlcGFyYXRvclBhbmVzLmdldChwYW5lKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHNlcGFyYXRvclBhbmUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvckJvdW5kaW5nID0gc2VwYXJhdG9yUGFuZS5nZXRCb3VuZGluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2Uoc2VwYXJhdG9yUGFuZS5nZXRJbWFnZShvdmVybGF5RmxhZyksIHNlcGFyYXRvckJvdW5kaW5nLmxlZnQsIHNlcGFyYXRvckJvdW5kaW5nLnRvcCwgc2VwYXJhdG9yQm91bmRpbmcud2lkdGgsIHNlcGFyYXRvckJvdW5kaW5nLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm91bmRpbmcgPSBwYW5lLmdldEJvdW5kaW5nKCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHBhbmUuZ2V0SW1hZ2Uob3ZlcmxheUZsYWcpLCAwLCBib3VuZGluZy50b3AsIHdpZHRoLCBib3VuZGluZy5oZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9cIi5jb25jYXQodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB2b2lkIDAgPyB0eXBlIDogJ2pwZWcnKSk7XG4gICAgfTtcbiAgICBDaGFydEltcC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWNoZUNoYXJ0Qm91bmRpbmcoKTtcbiAgICAgICAgdGhpcy5sYXlvdXQoe1xuICAgICAgICAgICAgbWVhc3VyZUhlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG1lYXN1cmVXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGJ1aWxkWUF4aXNUaWNrOiB0cnVlLFxuICAgICAgICAgICAgZm9yY2VCdWlsZFlBeGlzVGljazogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYXJ0SW1wLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGFydEV2ZW50LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgICAgIHBhbmUuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzID0gW107XG4gICAgICAgIHRoaXMuX3NlcGFyYXRvclBhbmVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9jaGFydENvbnRhaW5lcik7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhcnRJbXA7XG59KCkpO1xuXG4vKipcbiAqICAgICAgIF9fXyAgICAgICAgICAgX19fICAgICAgICAgICAgICAgICAgIF9fXyAgICAgICAgICAgX19fICAgICAgICAgICBfX18gICAgICAgICAgIF9fXyAgICAgICAgICAgX19fICAgICAgICAgICBfX18gICAgICAgICAgIF9fX1xuICogICAgICAvXFxfX1xcICAgICAgICAgL1xcX19cXCAgICAgIF9fXyAgICAgICAgL1xcX19cXCAgICAgICAgIC9cXCAgXFwgICAgICAgICAvXFwgIFxcICAgICAgICAgL1xcX19cXCAgICAgICAgIC9cXCAgXFwgICAgICAgICAvXFwgIFxcICAgICAgICAgL1xcICBcXFxuICogICAgIC86LyAgLyAgICAgICAgLzovICAvICAgICAvXFwgIFxcICAgICAgLzo6fCAgfCAgICAgICAvOjpcXCAgXFwgICAgICAgLzo6XFwgIFxcICAgICAgIC86LyAgLyAgICAgICAgLzo6XFwgIFxcICAgICAgIC86OlxcICBcXCAgICAgICAgXFw6XFwgIFxcXG4gKiAgICAvOi9fXy8gICAgICAgIC86LyAgLyAgICAgIFxcOlxcICBcXCAgICAvOnw6fCAgfCAgICAgIC86L1xcOlxcICBcXCAgICAgLzovXFw6XFwgIFxcICAgICAvOi9fXy8gICAgICAgIC86L1xcOlxcICBcXCAgICAgLzovXFw6XFwgIFxcICAgICAgICBcXDpcXCAgXFxcbiAqICAgLzo6XFxfX1xcX19fXyAgIC86LyAgLyAgICAgICAvOjpcXF9fXFwgIC86L3w6fCAgfF9fICAgLzo6XFx+XFw6XFwgIFxcICAgLzovICBcXDpcXCAgXFwgICAvOjpcXCAgXFwgX19fICAgLzo6XFx+XFw6XFwgIFxcICAgLzo6XFx+XFw6XFwgIFxcICAgICAgIC86OlxcICBcXFxuICogIC86L1xcOjo6OjpcXF9fXFwgLzovX18vICAgICBfXy86L1xcL19fLyAvOi8gfDp8IC9cXF9fXFwgLzovXFw6XFwgXFw6XFxfX1xcIC86L19fLyBcXDpcXF9fXFwgLzovXFw6XFwgIC9cXF9fXFwgLzovXFw6XFwgXFw6XFxfX1xcIC86L1xcOlxcIFxcOlxcX19cXCAgICAgLzovXFw6XFxfX1xcXG4gKiAgXFwvX3w6fH5+fH4gICAgXFw6XFwgIFxcICAgIC9cXC86LyAgLyAgICBcXC9fX3w6fC86LyAgLyBcXDpcXH5cXDpcXCBcXC9fXy8gXFw6XFwgIFxcICBcXC9fXy8gXFwvX19cXDpcXC86LyAgLyBcXC9fX1xcOlxcLzovICAvIFxcL198OjpcXC86LyAgLyAgICAvOi8gIFxcL19fL1xuICogICAgIHw6fCAgfCAgICAgIFxcOlxcICBcXCAgIFxcOjovX18vICAgICAgICAgfDovOi8gIC8gICBcXDpcXCBcXDpcXF9fXFwgICAgXFw6XFwgIFxcICAgICAgICAgICAgXFw6Oi8gIC8gICAgICAgXFw6Oi8gIC8gICAgIHw6fDo6LyAgLyAgICAvOi8gIC9cbiAqICAgICB8OnwgIHwgICAgICAgXFw6XFwgIFxcICAgXFw6XFxfX1xcICAgICAgICAgfDo6LyAgLyAgICAgXFw6XFwgXFwvX18vICAgICBcXDpcXCAgXFwgICAgICAgICAgIC86LyAgLyAgICAgICAgLzovICAvICAgICAgfDp8XFwvX18vICAgICBcXC9fXy9cbiAqICAgICB8OnwgIHwgICAgICAgIFxcOlxcX19cXCAgIFxcL19fLyAgICAgICAgIC86LyAgLyAgICAgICBcXDpcXF9fXFwgICAgICAgIFxcOlxcX19cXCAgICAgICAgIC86LyAgLyAgICAgICAgLzovICAvICAgICAgIHw6fCAgfFxuICogICAgICBcXHxfX3wgICAgICAgICBcXC9fXy8gICAgICAgICAgICAgICAgIFxcL19fLyAgICAgICAgIFxcL19fLyAgICAgICAgIFxcL19fLyAgICAgICAgIFxcL19fLyAgICAgICAgIFxcL19fLyAgICAgICAgIFxcfF9ffFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBjaGFydHMgPSBuZXcgTWFwKCk7XG52YXIgY2hhcnRCYXNlSWQgPSAxO1xuLyoqXG4gKiBDaGFydCB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gICAgcmV0dXJuICcxMC4wLjAtYWxwaGE1Jztcbn1cbi8qKlxuICogSW5pdCBjaGFydCBpbnN0YW5jZVxuICogQHBhcmFtIGRzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge0NoYXJ0fVxuICovXG5mdW5jdGlvbiBpbml0KGRzLCBvcHRpb25zKSB7XG4gICAgbG9nVGFnKCk7XG4gICAgdmFyIGRvbSA9IG51bGw7XG4gICAgaWYgKGlzU3RyaW5nKGRzKSkge1xuICAgICAgICBkb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb20gPSBkcztcbiAgICB9XG4gICAgaWYgKGRvbSA9PT0gbnVsbCkge1xuICAgICAgICBsb2dFcnJvcignJywgJycsICdUaGUgY2hhcnQgY2Fubm90IGJlIGluaXRpYWxpemVkIGNvcnJlY3RseS4gUGxlYXNlIGNoZWNrIHRoZSBwYXJhbWV0ZXJzLiBUaGUgY2hhcnQgY29udGFpbmVyIGNhbm5vdCBiZSBudWxsIGFuZCBjaGlsZCBlbGVtZW50cyBuZWVkIHRvIGJlIGFkZGVkISEhJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hhcnQgPSBjaGFydHMuZ2V0KGRvbS5pZCk7XG4gICAgaWYgKGlzVmFsaWQoY2hhcnQpKSB7XG4gICAgICAgIGxvZ1dhcm4oJycsICcnLCAnVGhlIGNoYXJ0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9uIHRoZSBkb23vvIHvvIHvvIEnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cbiAgICB2YXIgaWQgPSBcImtfbGluZV9jaGFydF9cIi5jb25jYXQoY2hhcnRCYXNlSWQrKyk7XG4gICAgY2hhcnQgPSBuZXcgQ2hhcnRJbXAoZG9tLCBvcHRpb25zKTtcbiAgICBjaGFydC5pZCA9IGlkO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2stbGluZS1jaGFydC1pZCcsIGlkKTtcbiAgICBjaGFydHMuc2V0KGlkLCBjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufVxuLyoqXG4gKiBEZXN0cm95IGNoYXJ0IGluc3RhbmNlXG4gKiBAcGFyYW0gZGNzXG4gKi9cbmZ1bmN0aW9uIGRpc3Bvc2UoZGNzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgaWQgPSBudWxsO1xuICAgIGlmIChkY3MgaW5zdGFuY2VvZiBDaGFydEltcCkge1xuICAgICAgICBpZCA9IGRjcy5pZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkb20gPSBudWxsO1xuICAgICAgICBpZiAoaXNTdHJpbmcoZGNzKSkge1xuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbSA9IGRjcztcbiAgICAgICAgfVxuICAgICAgICBpZCA9IChfYSA9IGRvbSA9PT0gbnVsbCB8fCBkb20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbS5nZXRBdHRyaWJ1dGUoJ2stbGluZS1jaGFydC1pZCcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgICAgKF9iID0gY2hhcnRzLmdldChpZCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIGNoYXJ0cy5kZWxldGUoaWQpO1xuICAgIH1cbn1cbnZhciB1dGlscyA9IHtcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc051bWJlcjogaXNOdW1iZXIsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZSxcbiAgICBmb3JtYXRQcmVjaXNpb246IGZvcm1hdFByZWNpc2lvbixcbiAgICBmb3JtYXRCaWdOdW1iZXI6IGZvcm1hdEJpZ051bWJlcixcbiAgICBmb3JtYXREYXRlOiBmb3JtYXRUaW1lc3RhbXBUb1N0cmluZyxcbiAgICBmb3JtYXRUaG91c2FuZHM6IGZvcm1hdFRob3VzYW5kcyxcbiAgICBmb3JtYXRGb2xkRGVjaW1hbDogZm9ybWF0Rm9sZERlY2ltYWwsXG4gICAgY2FsY1RleHRXaWR0aDogY2FsY1RleHRXaWR0aCxcbiAgICBnZXRMaW5lYXJTbG9wZUludGVyY2VwdDogZ2V0TGluZWFyU2xvcGVJbnRlcmNlcHQsXG4gICAgZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdDogZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdCxcbiAgICBnZXRMaW5lYXJZRnJvbUNvb3JkaW5hdGVzOiBnZXRMaW5lYXJZRnJvbUNvb3JkaW5hdGVzLFxuICAgIGNoZWNrQ29vcmRpbmF0ZU9uQXJjOiBjaGVja0Nvb3JkaW5hdGVPbkFyYyxcbiAgICBjaGVja0Nvb3JkaW5hdGVPbkNpcmNsZTogY2hlY2tDb29yZGluYXRlT25DaXJjbGUsXG4gICAgY2hlY2tDb29yZGluYXRlT25MaW5lOiBjaGVja0Nvb3JkaW5hdGVPbkxpbmUsXG4gICAgY2hlY2tDb29yZGluYXRlT25Qb2x5Z29uOiBjaGVja0Nvb3JkaW5hdGVPblBvbHlnb24sXG4gICAgY2hlY2tDb29yZGluYXRlT25SZWN0OiBjaGVja0Nvb3JkaW5hdGVPblJlY3QsXG4gICAgY2hlY2tDb29yZGluYXRlT25UZXh0OiBjaGVja0Nvb3JkaW5hdGVPblRleHRcbn07XG5cbmV4cG9ydCB7IEFjdGlvblR5cGUsIENhbmRsZVRvb2x0aXBSZWN0UG9zaXRpb24sIENhbmRsZVR5cGUsIERvbVBvc2l0aW9uLCBGb3JtYXREYXRlVHlwZSwgSW5kaWNhdG9yU2VyaWVzLCBMaW5lVHlwZSwgT3ZlcmxheU1vZGUsIFBvbHlnb25UeXBlLCBUb29sdGlwRmVhdHVyZVBvc2l0aW9uLCBUb29sdGlwRmVhdHVyZVR5cGUsIFRvb2x0aXBTaG93UnVsZSwgVG9vbHRpcFNob3dUeXBlLCBkaXNwb3NlLCBnZXRGaWd1cmVDbGFzcywgZ2V0T3ZlcmxheUNsYXNzLCBnZXRTdXBwb3J0ZWRGaWd1cmVzLCBnZXRTdXBwb3J0ZWRJbmRpY2F0b3JzLCBnZXRTdXBwb3J0ZWRMb2NhbGVzLCBnZXRTdXBwb3J0ZWRPdmVybGF5cywgaW5pdCwgcmVnaXN0ZXJGaWd1cmUsIHJlZ2lzdGVySW5kaWNhdG9yLCByZWdpc3RlckxvY2FsZSwgcmVnaXN0ZXJPdmVybGF5LCByZWdpc3RlclN0eWxlcywgcmVnaXN0ZXJYQXhpcywgcmVnaXN0ZXJZQXhpcywgdXRpbHMsIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXh0ZW5kcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsIkl0ZXJhdG9yIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidiIsIm9wIiwicG9wIiwicHVzaCIsIl9fdmFsdWVzIiwibyIsIm0iLCJfX3JlYWQiLCJyIiwiYXIiLCJlcnJvciIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwibCIsInNsaWNlIiwiY29uY2F0IiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIm5hbWUiLCJtZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImlzT2JqZWN0Iiwia2V5IiwidGFyZ2V0UHJvcCIsInNvdXJjZVByb3AiLCJpc1ZhbGlkIiwiY2xvbmUiLCJjb3B5IiwiaXNBcnJheSIsInRvU3RyaW5nIiwiaXNGdW5jdGlvbiIsImlzTnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ1bmRlZmluZWQiLCJpc0Jvb2xlYW4iLCJpc1N0cmluZyIsImlzVHJhbnNwYXJlbnQiLCJjb2xvciIsInRlc3QiLCJoZXhUb1JnYiIsImhleCIsImFscGhhIiwiaCIsInJlcGxhY2UiLCJwYXJzZUludCIsIkxpbmVUeXBlIiwiUGF0aFR5cGUiLCJQb2x5Z29uVHlwZSIsIlRvb2x0aXBTaG93UnVsZSIsIlRvb2x0aXBTaG93VHlwZSIsIlRvb2x0aXBGZWF0dXJlVHlwZSIsIlRvb2x0aXBGZWF0dXJlUG9zaXRpb24iLCJDYW5kbGVUb29sdGlwUmVjdFBvc2l0aW9uIiwiQ2FuZGxlVHlwZSIsIkNhbmRsZUNvbG9yQ29tcGFyZVJ1bGUiLCJDb2xvciIsIlJFRCIsIkdSRUVOIiwiV0hJVEUiLCJHUkVZIiwiQkxVRSIsImdldERlZmF1bHRHcmlkU3R5bGUiLCJzaG93IiwiaG9yaXpvbnRhbCIsInNpemUiLCJzdHlsZSIsIkRhc2hlZCIsImRhc2hlZFZhbHVlIiwidmVydGljYWwiLCJnZXREZWZhdWx0Q2FuZGxlU3R5bGUiLCJoaWdoTG93IiwidGV4dE9mZnNldCIsInRleHRTaXplIiwidGV4dEZhbWlseSIsInRleHRXZWlnaHQiLCJ0eXBlIiwiQ2FuZGxlU29saWQiLCJiYXIiLCJjb21wYXJlUnVsZSIsIkN1cnJlbnRPcGVuIiwidXBDb2xvciIsImRvd25Db2xvciIsIm5vQ2hhbmdlQ29sb3IiLCJ1cEJvcmRlckNvbG9yIiwiZG93bkJvcmRlckNvbG9yIiwibm9DaGFuZ2VCb3JkZXJDb2xvciIsInVwV2lja0NvbG9yIiwiZG93bldpY2tDb2xvciIsIm5vQ2hhbmdlV2lja0NvbG9yIiwiYXJlYSIsImxpbmVTaXplIiwibGluZUNvbG9yIiwic21vb3RoIiwiYmFja2dyb3VuZENvbG9yIiwib2Zmc2V0IiwicG9pbnQiLCJyYWRpdXMiLCJyaXBwbGVDb2xvciIsInJpcHBsZVJhZGl1cyIsImFuaW1hdGlvbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwicHJpY2VNYXJrIiwiaGlnaCIsImxvdyIsImxhc3QiLCJsaW5lIiwidGV4dCIsIkZpbGwiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJTdHlsZSIsIlNvbGlkIiwiYm9yZGVyU2l6ZSIsImJvcmRlckRhc2hlZFZhbHVlIiwiZmFtaWx5Iiwid2VpZ2h0IiwiYm9yZGVyUmFkaXVzIiwidG9vbHRpcCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRSaWdodCIsIm9mZnNldEJvdHRvbSIsInNob3dSdWxlIiwiQWx3YXlzIiwic2hvd1R5cGUiLCJTdGFuZGFyZCIsImN1c3RvbSIsInRpdGxlIiwiZGVmYXVsdFZhbHVlIiwicmVjdCIsInBvc2l0aW9uIiwiRml4ZWQiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJmZWF0dXJlcyIsImdldERlZmF1bHRJbmRpY2F0b3JTdHlsZSIsImFscGhhR3JlZW4iLCJhbHBoYVJlZCIsIm9obGMiLCJiYXJzIiwibGluZXMiLCJtYXAiLCJjaXJjbGVzIiwibGFzdFZhbHVlTWFyayIsInNob3dOYW1lIiwic2hvd1BhcmFtcyIsImdldERlZmF1bHRBeGlzU3R5bGUiLCJheGlzTGluZSIsInRpY2tUZXh0IiwibWFyZ2luU3RhcnQiLCJtYXJnaW5FbmQiLCJ0aWNrTGluZSIsImdldERlZmF1bHRDcm9zc2hhaXJTdHlsZSIsIml0ZW0iLCJnZXREZWZhdWx0T3ZlcmxheVN0eWxlIiwicG9pbnRCb3JkZXJDb2xvciIsImFscGhhQmciLCJhY3RpdmVDb2xvciIsImFjdGl2ZUJvcmRlckNvbG9yIiwiYWN0aXZlQm9yZGVyU2l6ZSIsImFjdGl2ZVJhZGl1cyIsInBvbHlnb24iLCJjaXJjbGUiLCJhcmMiLCJnZXREZWZhdWx0U2VwYXJhdG9yU3R5bGUiLCJmaWxsIiwiYWN0aXZlQmFja2dyb3VuZENvbG9yIiwiZ2V0RGVmYXVsdFN0eWxlcyIsImdyaWQiLCJjYW5kbGUiLCJpbmRpY2F0b3IiLCJ4QXhpcyIsInlBeGlzIiwic2VwYXJhdG9yIiwiY3Jvc3NoYWlyIiwib3ZlcmxheSIsIkRFViIsInByb2Nlc3MiLCJsb2ciLCJ0ZW1wbGF0ZVRleHQiLCJ0YWdTdHlsZSIsIm1lc3NhZ2VTdHlsZSIsImFwaSIsImludmFsaWRQYXJhbSIsImFwcGVuZCIsImFwaVN0ciIsImludmFsaWRQYXJhbVN0ciIsImFwcGVuZFN0ciIsImNvbnNvbGUiLCJsb2dXYXJuIiwibG9nRXJyb3IiLCJsb2dUYWciLCJyZUVzY2FwZUNoYXIiLCJyZVByb3BOYW1lIiwiUmVnRXhwIiwiZm9ybWF0VmFsdWUiLCJkYXRhIiwicGF0aF8xIiwic3ViU3RyaW5nIiwiYXJncyIsIl9pIiwiayIsInRyaW0iLCJpbmRleCIsImxlbmd0aF8xIiwiZm9ybWF0VGltZXN0YW1wVG9EYXRlVGltZSIsImRhdGVUaW1lRm9ybWF0IiwidGltZXN0YW1wIiwiZGF0ZSIsImZvcm1hdFRvUGFydHMiLCJEYXRlIiwiZm9yRWFjaCIsIl9hIiwiWVlZWSIsIk1NIiwiREQiLCJISCIsIm1tIiwic3MiLCJmb3JtYXRUaW1lc3RhbXBUb1N0cmluZyIsImZvcm1hdCIsImZvcm1hdFByZWNpc2lvbiIsInByZWNpc2lvbiIsInRvRml4ZWQiLCJmb3JtYXRCaWdOdW1iZXIiLCJmb3JtYXRUaG91c2FuZHMiLCJzaWduIiwidmwiLCJpbmNsdWRlcyIsImFyciIsInNwbGl0IiwiJDEiLCJmb3JtYXRGb2xkRGVjaW1hbCIsInRocmVzaG9sZCIsInJlZyIsImxhc3RJbmRleCIsIm1hdGNoIiwiZXhlYyIsImNvdW50Iiwiam9pbiIsIm1lYXN1cmVDdHgiLCJnZXRQaXhlbFJhdGlvIiwiY2FudmFzIiwiX2IiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJkZXZpY2VQaXhlbFJhdGlvIiwiY3JlYXRlRm9udCIsImNhbGNUZXh0V2lkdGgiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwaXhlbFJhdGlvIiwiZ2V0Q29udGV4dCIsInNjYWxlIiwiZm9udCIsIk1hdGgiLCJyb3VuZCIsIm1lYXN1cmVUZXh0Iiwid2lkdGgiLCJBY3Rpb25UeXBlIiwiQWN0aW9uIiwiX2NhbGxiYWNrcyIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwidW5zdWJzY3JpYmUiLCJzcGxpY2UiLCJleGVjdXRlIiwiaXNFbXB0eSIsIkluZGljYXRvclNlcmllcyIsIkluZGljYXRvckV2ZW50VGFyZ2V0IiwiSW5kaWNhdG9yRGF0YVN0YXRlIiwiZWFjaEZpZ3VyZXMiLCJkYXRhSW5kZXgiLCJkZWZhdWx0U3R5bGVzIiwiZWFjaEZpZ3VyZUNhbGxiYWNrIiwiZmlndXJlcyIsInN0eWxlcyIsImNpcmNsZVN0eWxlcyIsImNpcmNsZVN0eWxlQ291bnQiLCJiYXJTdHlsZXMiLCJiYXJTdHlsZUNvdW50IiwibGluZVN0eWxlcyIsImxpbmVTdHlsZUNvdW50IiwiY2lyY2xlQ291bnQiLCJiYXJDb3VudCIsImxpbmVDb3VudCIsImRlZmF1bHRGaWd1cmVTdHlsZXMiLCJmaWd1cmVJbmRleCIsImZpZ3VyZSIsInN0eWxlc18xIiwic3R5bGVzXzIiLCJwcmV2IiwiY3VycmVudCIsIkluZGljYXRvckltcCIsImNhbGNQYXJhbXMiLCJzaG91bGRPaGxjIiwic2hvdWxkRm9ybWF0QmlnTnVtYmVyIiwidmlzaWJsZSIsInpMZXZlbCIsInNlcmllcyIsIk5vcm1hbCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJzaG91bGRVcGRhdGUiLCJjYWxjIiwiSlNPTiIsInN0cmluZ2lmeSIsImRyYXciLCJzaG9ydE5hbWUiLCJleHRlbmREYXRhIiwicmVnZW5lcmF0ZUZpZ3VyZXMiLCJjcmVhdGVUb29sdGlwRGF0YVNvdXJjZSIsIm9uQ2xpY2siLCJvbkRhdGFTdGF0ZUNoYW5nZSIsIl9sb2NrU2VyaWVzUHJlY2lzaW9uIiwib3ZlcnJpZGUiLCJfYyIsImN1cnJlbnRPdGhlcnMiLCJfcHJldkluZGljYXRvciIsImlkIiwib3RoZXJzIiwic2V0U2VyaWVzUHJlY2lzaW9uIiwic2hvdWxkVXBkYXRlSW1wIiwic29ydCIsImNhbGNJbXAiLCJkYXRhTGlzdCIsImV4dGVuZCIsInRlbXBsYXRlIiwiQ3VzdG9tIiwiX3N1cGVyIiwiT3ZlcmxheU1vZGUiLCJjaGVja092ZXJsYXlGaWd1cmVFdmVudCIsInRhcmdldEV2ZW50VHlwZSIsImlnbm9yZUV2ZW50IiwiT1ZFUkxBWV9EUkFXX1NURVBfU1RBUlQiLCJPVkVSTEFZX0RSQVdfU1RFUF9GSU5JU0hFRCIsIk9WRVJMQVlfSURfUFJFRklYIiwiT1ZFUkxBWV9GSUdVUkVfS0VZX1BSRUZJWCIsIk92ZXJsYXlJbXAiLCJncm91cElkIiwidG90YWxTdGVwIiwiY3VycmVudFN0ZXAiLCJsb2NrIiwibmVlZERlZmF1bHRQb2ludEZpZ3VyZSIsIm5lZWREZWZhdWx0WEF4aXNGaWd1cmUiLCJuZWVkRGVmYXVsdFlBeGlzRmlndXJlIiwibW9kZSIsIm1vZGVTZW5zaXRpdml0eSIsInBvaW50cyIsImNyZWF0ZVBvaW50RmlndXJlcyIsImNyZWF0ZVhBeGlzRmlndXJlcyIsImNyZWF0ZVlBeGlzRmlndXJlcyIsInBlcmZvcm1FdmVudFByZXNzZWRNb3ZlIiwicGVyZm9ybUV2ZW50TW92ZUZvckRyYXdpbmciLCJvbkRyYXdTdGFydCIsIm9uRHJhd2luZyIsIm9uRHJhd0VuZCIsIm9uRG91YmxlQ2xpY2siLCJvblJpZ2h0Q2xpY2siLCJvblByZXNzZWRNb3ZlU3RhcnQiLCJvblByZXNzZWRNb3ZpbmciLCJvblByZXNzZWRNb3ZlRW5kIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25SZW1vdmVkIiwib25TZWxlY3RlZCIsIm9uRGVzZWxlY3RlZCIsIl9wcmV2WkxldmVsIiwiX3ByZXZQcmVzc2VkUG9pbnQiLCJfcHJldlByZXNzZWRQb2ludHMiLCJfcHJldk92ZXJsYXkiLCJyZXBlYXRUb3RhbFN0ZXAiLCJwZXJmb3JtUG9pbnRJbmRleCIsInBlcmZvcm1Qb2ludCIsImdldFByZXZaTGV2ZWwiLCJzZXRQcmV2WkxldmVsIiwibmV4dFN0ZXAiLCJmb3JjZUNvbXBsZXRlIiwiaXNEcmF3aW5nIiwiaXNTdGFydCIsImV2ZW50TW92ZUZvckRyYXdpbmciLCJwb2ludEluZGV4IiwibmV3UG9pbnQiLCJldmVudFByZXNzZWRQb2ludE1vdmUiLCJzdGFydFByZXNzZWRNb3ZlIiwiZXZlbnRQcmVzc2VkT3RoZXJNb3ZlIiwiY2hhcnRTdG9yZSIsImRpZkRhdGFJbmRleF8xIiwiZGlmVmFsdWVfMSIsInRpbWVzdGFtcFRvRGF0YUluZGV4IiwiZGF0YUluZGV4VG9UaW1lc3RhbXAiLCJGb3JtYXREYXRlVHlwZSIsImNyZWF0ZURlZmF1bHRCb3VuZGluZyIsImJvdW5kaW5nIiwiZGVmYXVsdEJvdW5kaW5nIiwiaGVpZ2h0IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiREVGQVVMVF9SRVFVRVNUX0lEIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm4iLCJ3aW5kb3ciLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIm1heCIsImNhbmNlbElkbGVDYWxsYmFjayIsIkFuaW1hdGlvbiIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsImR1cmF0aW9uIiwiaXRlcmF0aW9uQ291bnQiLCJfY3VycmVudEl0ZXJhdGlvbkNvdW50IiwiX3J1bm5pbmciLCJfdGltZSIsIl9sb29wIiwiX3RoaXMiLCJkaWZmVGltZSIsImdldFRpbWUiLCJfZG9GcmFtZUNhbGxiYWNrIiwic3RvcCIsInN0YXJ0IiwiZG9GcmFtZSIsInNldER1cmF0aW9uIiwic2V0SXRlcmF0aW9uQ291bnQiLCJiYXNlSWQiLCJwcmV2SWRUaW1lc3RhbXAiLCJjcmVhdGVJZCIsInByZWZpeCIsImNyZWF0ZURvbSIsInRhZ05hbWUiLCJkb20iLCJiaW5hcnlTZWFyY2hOZWFyZXN0IiwidmFsdWVLZXkiLCJ0YXJnZXRWYWx1ZSIsIm1pZEluZGV4IiwiZmxvb3IiLCJtaWQiLCJtaWRWYWx1ZSIsIm5pY2UiLCJleHBvbmVudCIsImxvZzEwIiwiZXhwMTAiLCJpbmRleDEwIiwibmYiLCJhYnMiLCJwb3ciLCJnZXRQcmVjaXNpb24iLCJzdHIiLCJlSW5kZXgiLCJkb3RJbmRleCIsImdldE1heE1pbiIsIm1heEtleSIsIm1pbktleSIsIm1heE1pbiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZGF0YUxlbmd0aCIsIm1pbiIsIkxvYWREYXRhVHlwZSIsImdldERlZmF1bHRWaXNpYmxlUmFuZ2UiLCJyZWFsRnJvbSIsInJlYWxUbyIsImdlbmVyYXRlVGFza0lkIiwicGFyYW1zIiwiVGFza1NjaGVkdWxlciIsInRhc2tzIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2tJZCIsIl90YXNrcyIsIl9vcGVyYXRlVGFza3MiLCJkZWFkbGluZSIsIl9ydW5UYXNrcyIsInRhc2siLCJzaGlmdCIsImhhbmRsZXIiLCJhZGRUYXNrIiwiZmluZEluZGV4IiwicmVtb3ZlVGFzayIsIlRpbWVXZWlnaHRDb25zdGFudHMiLCJZZWFyIiwiTW9udGgiLCJEYXkiLCJIb3VyIiwiTWludXRlIiwiU2Vjb25kIiwiY2xhc3NpZnlUaW1lV2VpZ2h0VGlja3MiLCJiYXNlRGF0YUluZGV4IiwibWluVGltZVNwYW4iLCJzdGFydFRpbWVzdGFtcCIsInByZXZEYXRlVGltZSIsInByZXZUaW1lc3RhbXAiLCJkYXRlVGltZSIsImNvbXBhcmUiLCJjdXJyZW50VGltZVdlaWdodExpc3QiLCJnZXQiLCJzZXQiLCJjYWxjQmV0d2VlblRpbWVXZWlnaHRUaWNrQmFyQ291bnQiLCJiYXJTcGFjZSIsInRleHRTdHlsZXMiLCJzcGFjZSIsImNlaWwiLCJjcmVhdGVUaW1lV2VpZ2h0VGlja0xpc3QiLCJvcHRUaW1lV2VpZ2h0VGlja0xpc3QiLCJrZXlzIiwidzEiLCJ3MiIsImN1cnJlbnRUaW1lV2VpZ2h0VGlja0xpc3QiLCJwcmV2T3B0VGltZVdlaWdodFRpY2tMaXN0IiwicHJldk9wdFRpbWVXZWlnaHRUaWNrTGlzdExlbmd0aCIsInByZXZPcHRUaW1lV2VpZ2h0VGlja0xpc3RQb2ludGVyIiwiY3VycmVudFRpbWVXZWlnaHRUaWNrTGlzdExlbmd0aCIsInJpZ2h0SW5kZXgiLCJJbmZpbml0eSIsImxlZnRJbmRleCIsInRpbWVXZWlnaHRUaWNrIiwiY3VycmVudEluZGV4IiwibGFzdFRpbWVXZWlnaHRUaWNrIiwiYXZlcmFnZVByaWNlIiwiUHJpY2UiLCJ0b3RhbFR1cm5vdmVyIiwidG90YWxWb2x1bWUiLCJrTGluZURhdGEiLCJhdnAiLCJ0dXJub3ZlciIsInZvbHVtZSIsImF3ZXNvbWVPc2NpbGxhdG9yIiwiYmFzZVZhbHVlIiwicHJldkFvIiwiYW8iLCJjdXJyZW50QW8iLCJTdHJva2UiLCJtYXhQZXJpb2QiLCJzaG9ydFN1bSIsImxvbmdTdW0iLCJzaG9ydCIsImxvbmciLCJtaWRkbGUiLCJhZ29LTGluZURhdGEiLCJiaWFzIiwiY2xvc2VTdW1zIiwiY2xvc2UiLCJtZWFuIiwiZ2V0Qm9sbE1kIiwibWEiLCJkYXRhU2l6ZSIsInN1bSIsImNsb3NlTWEiLCJzcXJ0IiwiYm9sbGluZ2VyQmFuZHMiLCJjbG9zZVN1bSIsImJvbGwiLCJtZCIsInVwIiwiZG4iLCJicmFyIiwiaGN5IiwiY3lsIiwiaG8iLCJvbCIsIm9wZW4iLCJwcmV2Q2xvc2UiLCJiciIsImFnb0hpZ2giLCJhZ29Mb3ciLCJhZ29PcGVuIiwiYWdvUHJlQ2xvc2UiLCJidWxsQW5kQmVhckluZGV4IiwibWFzIiwiYmJpIiwibWFTdW1fMSIsImNvbW1vZGl0eUNoYW5uZWxJbmRleCIsInRwU3VtIiwidHBMaXN0IiwiY2NpIiwidHAiLCJtYVRwXzEiLCJzbGljZVRwTGlzdCIsInN1bV8xIiwiYWdvVHAiLCJjdXJyZW50UmF0aW8iLCJtYTFGb3J3YXJkUGVyaW9kIiwibWEyRm9yd2FyZFBlcmlvZCIsIm1hM0ZvcndhcmRQZXJpb2QiLCJtYTRGb3J3YXJkUGVyaW9kIiwibWExU3VtIiwibWExTGlzdCIsIm1hMlN1bSIsIm1hMkxpc3QiLCJtYTNTdW0iLCJtYTNMaXN0IiwibWE0U3VtIiwibWE0TGlzdCIsIl9kIiwiX2UiLCJjciIsInByZXZEYXRhIiwicHJldk1pZCIsImhpZ2hTdWJQcmVNaWQiLCJwcmVNaWRTdWJMb3ciLCJtYTEiLCJtYTIiLCJtYTMiLCJtYTQiLCJkaWZmZXJlbnRPZk1vdmluZ0F2ZXJhZ2UiLCJjbG9zZVN1bTEiLCJjbG9zZVN1bTIiLCJkbWFTdW0iLCJkbWEiLCJkaWYiLCJhbWEiLCJkaXJlY3Rpb25hbE1vdmVtZW50SW5kZXgiLCJ0clN1bSIsImhTdW0iLCJsU3VtIiwibXRyIiwiZG1wIiwiZG1tIiwiZHhTdW0iLCJhZHgiLCJkbWkiLCJwcmV2S0xpbmVEYXRhIiwicHJlQ2xvc2UiLCJobCIsImxjeSIsImhoeSIsImx5bCIsInRyIiwicGRpIiwibWRpIiwiZHgiLCJhZHhyIiwiZWFzZU9mTW92ZW1lbnRWYWx1ZSIsImVtdlZhbHVlU3VtIiwiZW12VmFsdWVMaXN0IiwiZW12IiwiZGlzdGFuY2VNb3ZlZCIsInJhdGlvIiwibWFFbXYiLCJleHBvbmVudGlhbE1vdmluZ0F2ZXJhZ2UiLCJlbWFWYWx1ZXMiLCJlbWEiLCJtb21lbnR1bSIsIm10bVN1bSIsIm10bSIsImNsb3NlXzEiLCJhZ29DbG9zZSIsIm1hTXRtIiwibW92aW5nQXZlcmFnZSIsIm1vdmluZ0F2ZXJhZ2VDb252ZXJnZW5jZURpdmVyZ2VuY2UiLCJwcmV2TWFjZCIsIm1hY2QiLCJjdXJyZW50TWFjZCIsImVtYVNob3J0IiwiZW1hTG9uZyIsImRpZlN1bSIsImRlYSIsIm9uQmFsYW5jZVZvbHVtZSIsIm9idlN1bSIsIm9sZE9idiIsIm9idiIsIm1hT2J2IiwicHJpY2VBbmRWb2x1bWVUcmVuZCIsInB2dCIsIngiLCJ0b3RhbCIsInBzeWNob2xvZ2ljYWxMaW5lIiwidXBDb3VudCIsInBzeVN1bSIsInVwTGlzdCIsInBzeSIsInVwRmxhZyIsIm1hUHN5IiwicmF0ZU9mQ2hhbmdlIiwicm9jU3VtIiwicm9jIiwibWFSb2MiLCJyZWxhdGl2ZVN0cmVuZ3RoSW5kZXgiLCJudW0iLCJzdW1DbG9zZUFzIiwic3VtQ2xvc2VCcyIsInJzaSIsInRtcCIsImFnb0RhdGEiLCJhZ29QcmVEYXRhIiwiYWdvVG1wIiwic2ltcGxlTW92aW5nQXZlcmFnZSIsInNtYVZhbHVlIiwic21hIiwic3RvY2giLCJrZGoiLCJsaG4iLCJobiIsImxuIiwiaG5TdWJMbiIsInJzdiIsImoiLCJzdG9wQW5kUmV2ZXJzZSIsInNhciIsImhhbGZITCIsInN0YXJ0QWYiLCJtYXhBZiIsImFmIiwiZXAiLCJpc0luY3JlYXNpbmciLCJwcmVTYXIiLCJsb3dNaW4iLCJoaWdoTWF4IiwidHJpcGxlRXhwb25lbnRpYWxseVNtb290aGVkQXZlcmFnZSIsImVtYTEiLCJlbWEyIiwib2xkVHIiLCJlbWExU3VtIiwiZW1hMlN1bSIsInRyaXhTdW0iLCJ0cml4IiwidHJpeFZhbHVlIiwibWFUcml4IiwiZ2V0Vm9sdW1lRmlndXJlIiwiVm9sdW1lIiwidm9sU3VtcyIsInZvbCIsInZvbHVtZVJhdGlvIiwidXZzIiwiZHZzIiwicHZzIiwidnJTdW0iLCJ2ciIsImhhbGZQdnMiLCJtYVZyIiwiYWdvVm9sdW1lIiwid2lsbGlhbXNSIiwid3IiLCJwYXJhbSIsImhsbiIsImluZGljYXRvcnMiLCJleHRlbnNpb25zJDIiLCJyZWdpc3RlckluZGljYXRvciIsImdldEluZGljYXRvckNsYXNzIiwiZ2V0U3VwcG9ydGVkSW5kaWNhdG9ycyIsImZpYm9uYWNjaUxpbmUiLCJjaGFydCIsImNvb3JkaW5hdGVzIiwicHJlY2lzaW9uXzEiLCJpc0luQ2FuZGxlIiwicHJpY2UiLCJnZXRJbmRpY2F0b3JzIiwicGFuZUlkIiwibGluZXNfMSIsInRleHRzXzEiLCJzdGFydFhfMSIsImVuZFhfMSIsInBlcmNlbnRzIiwieURpZl8xIiwidmFsdWVEaWZfMSIsInBlcmNlbnQiLCJnZXREZWNpbWFsRm9sZCIsImdldFRob3VzYW5kc1NlcGFyYXRvciIsImJhc2VsaW5lIiwiYXR0cnMiLCJpc0NoZWNrRXZlbnQiLCJob3Jpem9udGFsUmF5TGluZSIsImNvb3JkaW5hdGUiLCJob3Jpem9udGFsU2VnbWVudCIsImhvcml6b250YWxTdHJhaWdodExpbmUiLCJFdmVudGZ1bCIsIl9jaGlsZHJlbiIsIk1hcCIsInJlZ2lzdGVyRXZlbnQiLCJvbkV2ZW50IiwiZXZlbnQiLCJvdGhlciIsImNoZWNrRXZlbnRPbiIsImVfMSIsImZ1bCIsImVfMV8xIiwicmV0dXJuIiwiZGlzcGF0Y2hFdmVudCIsImFkZENoaWxkIiwiZXZlbnRmdWwiLCJjbGVhciIsIkRFVklBVElPTiIsIkZpZ3VyZUltcCIsImNoZWNrRXZlbnRPbkltcCIsInNldEF0dHJzIiwic2V0U3R5bGVzIiwiY3R4IiwiZHJhd0ltcCIsImNoZWNrQ29vcmRpbmF0ZU9uTGluZSIsImxpbmVzXzFfMSIsImxpbmVfMSIsInByZXZDb29yZGluYXRlIiwiY3VycmVudENvb3JkaW5hdGUiLCJrYiIsImdldExpbmVhclNsb3BlSW50ZXJjZXB0IiwiZ2V0TGluZWFyWUZyb21TbG9wZUludGVyY2VwdCIsInlEaWYiLCJnZXRMaW5lYXJZRnJvbUNvb3JkaW5hdGVzIiwiY29vcmRpbmF0ZTEiLCJjb29yZGluYXRlMiIsInRhcmdldENvb3JkaW5hdGUiLCJkaWZYIiwibGluZVRvIiwic21vb3RoUGFyYW0iLCJjcHgwIiwiY3B5MCIsIm5leHRDb29yZGluYXRlIiwiZHgwMSIsImR5MDEiLCJkeDEyIiwiZHkxMiIsImR4MDIiLCJkeTAyIiwicHJldlNlZ21lbnRMZW5ndGgiLCJuZXh0U2VnbWVudExlbmd0aCIsInNlZ21lbnRMZW5ndGhSYXRpbyIsIm5leHRDcHgiLCJuZXh0Q3B5IiwiY3B4MSIsImNweTEiLCJiZXppZXJDdXJ2ZVRvIiwibGFzdENvb3JkaW5hdGUiLCJkcmF3TGluZSIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwic2V0TGluZURhc2giLCJjb3JyZWN0aW9uIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwic3Ryb2tlIiwiY2xvc2VQYXRoIiwic2F2ZSIsInRyYW5zbGF0ZSIsInJlc3RvcmUiLCJnZXRQYXJhbGxlbExpbmVzIiwiZXh0ZW5kUGFyYWxsZWxMaW5lQ291bnQiLCJzdGFydFkiLCJlbmRZIiwiZGlzdGFuY2UiLCJzdGFydFgiLCJlbmRYIiwiYjEiLCJiMiIsInBhcmFsbGVsU3RyYWlnaHRMaW5lIiwicHJpY2VDaGFubmVsTGluZSIsInByaWNlTGluZSIsImdldFJheUxpbmUiLCJyYXlMaW5lIiwic2VnbWVudCIsInN0cmFpZ2h0TGluZSIsInZlcnRpY2FsUmF5TGluZSIsInZlcnRpY2FsU2VnbWVudCIsInZlcnRpY2FsU3RyYWlnaHRMaW5lIiwic2ltcGxlQW5ub3RhdGlvbiIsImxpbmVFbmRZIiwiYXJyb3dFbmRZIiwiYWxpZ24iLCJzaW1wbGVUYWciLCJpc0Zyb21aZXJvIiwidGV4dEFsaWduIiwib3ZlcmxheXMiLCJleHRlbnNpb25zJDEiLCJyZWdpc3Rlck92ZXJsYXkiLCJnZXRPdmVybGF5SW5uZXJDbGFzcyIsImdldE92ZXJsYXlDbGFzcyIsImdldFN1cHBvcnRlZE92ZXJsYXlzIiwibGlnaHQiLCJkYXJrIiwicmVnaXN0ZXJTdHlsZXMiLCJnZXRTdHlsZXMiLCJQQU5FX01JTl9IRUlHSFQiLCJQQU5FX0RFRkFVTFRfSEVJR0hUIiwiUGFuZUlkQ29uc3RhbnRzIiwiQ0FORExFIiwiSU5ESUNBVE9SIiwiWF9BWElTIiwiQmFyU3BhY2VMaW1pdENvbnN0YW50cyIsIk1JTiIsIk1BWCIsIkRFRkFVTFRfQkFSX1NQQUNFIiwiREVGQVVMVF9PRkZTRVRfUklHSFRfRElTVEFOQ0UiLCJCQVJfR0FQX1JBVElPIiwiU0NBTEVfTVVMVElQTElFUiIsIkRFRkFVTFRfTUlOX1RJTUVfU1BBTiIsIlN0b3JlSW1wIiwiX3N0eWxlcyIsIl9jdXN0b21BcGkiLCJmb3JtYXREYXRlIiwiX2RhdGVUaW1lRm9ybWF0IiwiX2xvY2FsZSIsIl90aG91c2FuZHNTZXBhcmF0b3IiLCJfZGVjaW1hbEZvbGQiLCJfcHJlY2lzaW9uIiwiX2RhdGFMaXN0IiwiX2xvYWRNb3JlRGF0YUNhbGxiYWNrIiwiX2xvYWRpbmciLCJfbG9hZERhdGFNb3JlIiwiZm9yd2FyZCIsImJhY2t3YXJkIiwiX3pvb21FbmFibGVkIiwiX3Njcm9sbEVuYWJsZWQiLCJfdG90YWxCYXJTcGFjZSIsIl9iYXJTcGFjZSIsIl9vZmZzZXRSaWdodERpc3RhbmNlIiwiX3N0YXJ0TGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCIsIl9zY3JvbGxMaW1pdFJvbGUiLCJfbWluVmlzaWJsZUJhckNvdW50IiwiX21heE9mZnNldERpc3RhbmNlIiwiX3Zpc2libGVSYW5nZSIsIl90aW1lV2VpZ2h0VGlja01hcCIsIl90aW1lV2VpZ2h0VGlja0xpc3QiLCJfbWluVGltZVNwYW4iLCJfdmlzaWJsZVJhbmdlRGF0YUxpc3QiLCJfdmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlIiwiX2Nyb3NzaGFpciIsIl9hY3RpdmVUb29sdGlwRmVhdHVyZUluZm8iLCJfYWN0aW9ucyIsIl9pbmRpY2F0b3JzIiwiX3Rhc2tTY2hlZHVsZXIiLCJfb3ZlcmxheXMiLCJfcHJvZ3Jlc3NPdmVybGF5SW5mbyIsIl9wcmVzc2VkT3ZlcmxheUluZm8iLCJmaWd1cmVUeXBlIiwiX2hvdmVyT3ZlcmxheUluZm8iLCJfY2xpY2tPdmVybGF5SW5mbyIsIl9jaGFydCIsIl9jYWxjT3B0aW1hbEJhclNwYWNlIiwiX2xhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQiLCJsb2NhbGUiLCJ0aW1lem9uZSIsImN1c3RvbUFwaSIsInRob3VzYW5kc1NlcGFyYXRvciIsImRlY2ltYWxGb2xkIiwic2V0TG9jYWxlIiwic2V0VGltZXpvbmUiLCJzZXRDdXN0b21BcGkiLCJzZXRUaG91c2FuZHNTZXBhcmF0b3IiLCJzZXREZWNpbWFsRm9sZCIsImdldEN1c3RvbUFwaSIsImdldExvY2FsZSIsImdldFRpbWV6b25lIiwiaG91cjEyIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsInRpbWVab25lIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiX2NsYXNzaWZ5VGltZVdlaWdodFRpY2tzIiwicmVzb2x2ZWRPcHRpb25zIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJzZXRQcmVjaXNpb24iLCJfc3luY2hyb25pemVJbmRpY2F0b3JTZXJpZXNQcmVjaXNpb24iLCJnZXREYXRhTGlzdCIsImdldFZpc2libGVSYW5nZURhdGFMaXN0IiwiZ2V0VmlzaWJsZVJhbmdlSGlnaExvd1ByaWNlIiwiYWRkRGF0YSIsIm1vcmUiLCJzdWNjZXNzIiwiYWRqdXN0RmxhZyIsImRhdGFMZW5ndGhDaGFuZ2UiLCJJbml0IiwiY2xlYXJEYXRhIiwic2V0T2Zmc2V0UmlnaHREaXN0YW5jZSIsIkJhY2t3YXJkIiwiRm9yd2FyZCIsImRhdGFDb3VudCIsImxhc3REYXRhVGltZXN0YW1wIiwibGFzdEJhclJpZ2h0U2lkZURpZmZCYXJDb3VudCIsImdldExhc3RCYXJSaWdodFNpZGVEaWZmQmFyQ291bnQiLCJzZXRMYXN0QmFyUmlnaHRTaWRlRGlmZkJhckNvdW50IiwiX2FkanVzdFZpc2libGVSYW5nZSIsInNldENyb3NzaGFpciIsIm5vdEludmFsaWRhdGUiLCJmaWx0ZXJJbmRpY2F0b3JzIiwiZ2V0SW5kaWNhdG9yc0J5RmlsdGVyIiwiX2FkZEluZGljYXRvckNhbGNUYXNrIiwibGF5b3V0IiwibWVhc3VyZVdpZHRoIiwidXBkYXRlIiwiYnVpbGRZQXhpc1RpY2siLCJzZXRMb2FkTW9yZURhdGFDYWxsYmFjayIsInNwZWNpYWxCYXJTcGFjZSIsImF0YW4iLCJQSSIsImdhcEJhclNwYWNlIiwiX2dhcEJhclNwYWNlIiwibmV3RGF0YUxpc3QiLCJpc1VwZGF0ZSIsImdldFRpbWVXZWlnaHRUaWNrTGlzdCIsInRvdGFsQmFyQ291bnQiLCJ2aXNpYmxlQmFyQ291bnQiLCJsZWZ0TWluVmlzaWJsZUJhckNvdW50IiwicmlnaHRNaW5WaXNpYmxlQmFyQ291bnQiLCJtYXhSaWdodE9mZnNldEJhckNvdW50IiwibWluUmlnaHRPZmZzZXRCYXJDb3VudCIsImV4ZWN1dGVBY3Rpb24iLCJPblZpc2libGVSYW5nZUNoYW5nZSIsImRhdGFJbmRleFRvQ29vcmRpbmF0ZSIsImdldEJhclNwYWNlIiwiaGFsZkJhciIsImdhcEJhciIsImhhbGZHYXBCYXIiLCJzZXRCYXJTcGFjZSIsImFkanVzdEJlZm9yZUZ1bmMiLCJzZXRUb3RhbEJhclNwYWNlIiwidG90YWxTcGFjZSIsImdldEluaXRpYWxPZmZzZXRSaWdodERpc3RhbmNlIiwiZ2V0T2Zmc2V0UmlnaHREaXN0YW5jZSIsInNldE1heE9mZnNldExlZnREaXN0YW5jZSIsInNldE1heE9mZnNldFJpZ2h0RGlzdGFuY2UiLCJzZXRMZWZ0TWluVmlzaWJsZUJhckNvdW50Iiwic2V0UmlnaHRNaW5WaXNpYmxlQmFyQ291bnQiLCJnZXRWaXNpYmxlUmFuZ2UiLCJzdGFydFNjcm9sbCIsInNjcm9sbCIsImRpc3RhbmNlQmFyQ291bnQiLCJwcmV2TGFzdEJhclJpZ2h0U2lkZURpc3RhbmNlIiwicmVhbERpc3RhbmNlIiwiT25TY3JvbGwiLCJnZXREYXRhQnlEYXRhSW5kZXgiLCJjb29yZGluYXRlVG9GbG9hdEluZGV4IiwiZGVsdGFGcm9tUmlnaHQiLCJsYXN0VGltZXN0YW1wIiwiZmlyc3RUaW1lc3RhbXAiLCJjb29yZGluYXRlVG9EYXRhSW5kZXgiLCJ6b29tIiwiem9vbUNvb3JkaW5hdGUiLCJmbG9hdEluZGV4IiwicHJldkJhclNwYWNlIiwicmVhbFNjYWxlIiwiT25ab29tIiwic2V0Wm9vbUVuYWJsZWQiLCJlbmFibGVkIiwiaXNab29tRW5hYmxlZCIsInNldFNjcm9sbEVuYWJsZWQiLCJpc1Njcm9sbEVuYWJsZWQiLCJub3RFeGVjdXRlQWN0aW9uIiwiZm9yY2VJbnZhbGlkYXRlIiwicmVhbERhdGFJbmRleCIsInJlYWxYIiwicHJldkNyb3NzaGFpciIsImNyb3NzaGFpckNoYW5nZSIsInVwZGF0ZVBhbmUiLCJnZXRDcm9zc2hhaXIiLCJzZXRBY3RpdmVUb29sdGlwRmVhdHVyZUluZm8iLCJpbmZvIiwiZ2V0QWN0aXZlVG9vbHRpcEZlYXR1cmVJbmZvIiwic3Vic2NyaWJlQWN0aW9uIiwiaGFzIiwidW5zdWJzY3JpYmVBY3Rpb24iLCJhY3Rpb24iLCJkZWxldGUiLCJoYXNBY3Rpb24iLCJfc29ydEluZGljYXRvcnMiLCJpMSIsImkyIiwicGFuZUluZGljYXRvcnMiLCJsb2FkRGF0YVR5cGUiLCJzdGF0ZSIsIkxvYWRpbmciLCJSZWFkeSIsImNhdGNoIiwiYWRkSW5kaWNhdG9yIiwiaXNTdGFjayIsImdldEluZGljYXRvcnNCeVBhbmVJZCIsIkluZGljYXRvckNsYXp6IiwicmVtb3ZlSW5kaWNhdG9yIiwiZmlsdGVyIiwicmVtb3ZlZCIsImlucyIsImhhc0luZGljYXRvcnMiLCJwcmljZVByZWNpc2lvbiIsInZvbHVtZVByZWNpc2lvbiIsInN5bmNocm9uaXplIiwib3ZlcnJpZGVJbmRpY2F0b3IiLCJ1cGRhdGVGbGFnIiwic29ydEZsYWciLCJVcGRhdGUiLCJnZXRPdmVybGF5c0J5RmlsdGVyIiwiZ2V0T3ZlcmxheXNCeVBhbmVJZCIsInBhbmVPdmVybGF5cyIsInByb2dyZXNzT3ZlcmxheSIsIm92ZXJsYXlzXzEiLCJfc29ydE92ZXJsYXlzIiwibzEiLCJvMiIsImFkZE92ZXJsYXlzIiwib3MiLCJhcHBvaW50UGFuZUZsYWdzIiwidXBkYXRlUGFuZUlkcyIsImlkcyIsIl9mIiwiX2ciLCJmaW5kT3ZlcmxheSIsIl9oIiwiX2oiLCJfayIsImZpbmQiLCJPdmVybGF5Q2xhenoiLCJhcHBvaW50UGFuZUZsYWciLCJnZXRQcm9ncmVzc092ZXJsYXlJbmZvIiwicHJvZ3Jlc3NPdmVybGF5Q29tcGxldGUiLCJ1cGRhdGVQcm9ncmVzc092ZXJsYXlJbmZvIiwib3ZlcnJpZGVPdmVybGF5IiwiZmlsdGVyT3ZlcmxheXMiLCJyZW1vdmVPdmVybGF5Iiwic2V0UHJlc3NlZE92ZXJsYXlJbmZvIiwiZ2V0UHJlc3NlZE92ZXJsYXlJbmZvIiwic2V0SG92ZXJPdmVybGF5SW5mbyIsImluZm9PdmVybGF5IiwiaWdub3JlVXBkYXRlRmxhZyIsImdldEhvdmVyT3ZlcmxheUluZm8iLCJzZXRDbGlja092ZXJsYXlJbmZvIiwiZ2V0Q2xpY2tPdmVybGF5SW5mbyIsImlzT3ZlcmxheUVtcHR5IiwiaXNPdmVybGF5RHJhd2luZyIsImdldENoYXJ0IiwiV2lkZ2V0TmFtZUNvbnN0YW50cyIsIk1BSU4iLCJZX0FYSVMiLCJTRVBBUkFUT1IiLCJSRUFMX1NFUEFSQVRPUl9IRUlHSFQiLCJpc1N1cHBvcnRlZERldmljZVBpeGVsQ29udGVudEJveCIsInJvIiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZXZlcnkiLCJlbnRyeSIsImRpc2Nvbm5lY3QiLCJvYnNlcnZlIiwiYm94IiwiQ2FudmFzIiwibGlzdGVuZXIiLCJfc3VwcG9ydGVkRGV2aWNlUGl4ZWxDb250ZW50Qm94IiwiX3dpZHRoIiwiX2hlaWdodCIsIl9waXhlbFdpZHRoIiwiX3BpeGVsSGVpZ2h0IiwiX25leHRQaXhlbFdpZHRoIiwiX25leHRQaXhlbEhlaWdodCIsIl9yZXF1ZXN0QW5pbWF0aW9uSWQiLCJfbWVkaWFRdWVyeUxpc3RlbmVyIiwiX2VsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9yZXNldFBpeGVsUmF0aW8iLCJfbGlzdGVuZXIiLCJfY3R4IiwiX3Jlc2l6ZU9ic2VydmVyIiwiZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSIsImlubGluZVNpemUiLCJibG9ja1NpemUiLCJfbWVkaWFRdWVyeUxpc3QiLCJtYXRjaE1lZGlhIiwiYWRkTGlzdGVuZXIiLCJfZXhlY3V0ZUxpc3RlbmVyIiwiaG9yaXpvbnRhbFBpeGVsUmF0aW8iLCJ2ZXJ0aWNhbFBpeGVsUmF0aW8iLCJjbGVhclJlY3QiLCJ3IiwiZ2V0RWxlbWVudCIsImRlc3Ryb3kiLCJ1bm9ic2VydmUiLCJyZW1vdmVMaXN0ZW5lciIsIldpZGdldCIsInJvb3RDb250YWluZXIiLCJwYW5lIiwiX2JvdW5kaW5nIiwiX3BhbmUiLCJfcm9vdENvbnRhaW5lciIsIl9jb250YWluZXIiLCJjcmVhdGVDb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInNldEJvdW5kaW5nIiwiZ2V0Q29udGFpbmVyIiwiZ2V0Qm91bmRpbmciLCJnZXRQYW5lIiwibGV2ZWwiLCJ1cGRhdGVJbXAiLCJyZW1vdmVDaGlsZCIsIkRyYXdXaWRnZXQiLCJfbWFpbkNhbnZhcyIsInpJbmRleCIsImJveFNpemluZyIsInVwZGF0ZU1haW4iLCJfb3ZlcmxheUNhbnZhcyIsInVwZGF0ZU92ZXJsYXkiLCJjb250YWluZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJnZXRJbWFnZSIsImluY2x1ZGVPdmVybGF5IiwiZHJhd0ltYWdlIiwiY2hlY2tDb29yZGluYXRlT25DaXJjbGUiLCJjaXJjbGVzXzEiLCJjaXJjbGVzXzFfMSIsImNpcmNsZV8xIiwiZGlmWSIsImRyYXdDaXJjbGUiLCJzb2xpZCIsIlN0cm9rZUZpbGwiLCJmaWxsU3R5bGUiLCJjaGVja0Nvb3JkaW5hdGVPblBvbHlnb24iLCJwb2x5Z29ucyIsInBvbHlnb25zXzEiLCJwb2x5Z29uc18xXzEiLCJwb2x5Z29uXzEiLCJvbiIsImRyYXdQb2x5Z29uIiwiY2hlY2tDb29yZGluYXRlT25SZWN0IiwicmVjdHMiLCJyZWN0c18xIiwicmVjdHNfMV8xIiwicmVjdF8xIiwiZHJhd1JlY3QiLCJyb3VuZFJlY3QiLCJjb3JyZWN0aW9uXzEiLCJkb3VibGVDb3JyZWN0aW9uXzEiLCJmaWxsUmVjdCIsImdldFRleHRSZWN0IiwiY2hlY2tDb29yZGluYXRlT25UZXh0IiwidGV4dHMiLCJ0ZXh0c18xXzEiLCJ0ZXh0XzEiLCJkcmF3VGV4dCIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZ2V0RGlzdGFuY2UiLCJ4RGlmIiwiY2hlY2tDb29yZGluYXRlT25BcmMiLCJhcmNzIiwiYXJjc18xIiwiYXJjc18xXzEiLCJhcmNfMSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0Q29vcmRpbmF0ZVgiLCJjb3MiLCJzdGFydENvb3JkaW5hdGVZIiwic2luIiwiZW5kQ29vcmRpbmF0ZVgiLCJlbmRDb29yZGluYXRlWSIsImRyYXdBcmMiLCJkcmF3RWxsaXB0aWNhbEFyYyIsIngxIiwieTEiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzUmVsYXRpdmUiLCJyeCIsInJ5Iiwicm90YXRpb24iLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciLCJ4MiIsInkyIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzZWdtZW50cyIsImVsbGlwdGljYWxBcmNUb0JlemllcnMiLCJjb21wdXRlRWxsaXB0aWNhbEFyY1BhcmFtZXRlcnMiLCJjeCIsImN5IiwiZGVsdGFBbmdsZSIsIm51bVNlZ21lbnRzIiwiZW5kIiwiYmV6aWVyIiwiZWxsaXB0aWNhbEFyY1RvQmV6aWVyIiwicGhpIiwiZHkiLCJ4MXAiLCJ5MXAiLCJsYW1iZGEiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImN4cCIsImN5cCIsImF0YW4yIiwidGFuIiwiY29zUGhpIiwic2luUGhpIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImRyYXdQYXRoIiwicGF0aHMiLCJwYXRoIiwiY29tbWFuZHMiLCJvZmZzZXRYXzEiLCJvZmZzZXRZXzEiLCJjb21tYW5kIiwiY3VycmVudFgiLCJjdXJyZW50WSIsInF1YWRyYXRpY0N1cnZlVG8iLCJleHRlbnNpb25zIiwiZ2V0U3VwcG9ydGVkRmlndXJlcyIsInJlZ2lzdGVyRmlndXJlIiwiZ2V0SW5uZXJGaWd1cmVDbGFzcyIsImdldEZpZ3VyZUNsYXNzIiwiVmlldyIsIndpZGdldCIsIl93aWRnZXQiLCJnZXRXaWRnZXQiLCJjcmVhdGVGaWd1cmUiLCJldmVudEhhbmRsZXIiLCJGaWd1cmVDbGF6eiIsIkdyaWRWaWV3IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiaG9yaXpvbnRhbFN0eWxlcyIsImhvcml6b250YWxTaG93IiwiZ2V0QXhpc0NvbXBvbmVudCIsImdldFRpY2tzIiwidGljayIsImNvb3JkIiwidmVydGljYWxTdHlsZXMiLCJ2ZXJ0aWNhbFNob3ciLCJnZXRYQXhpc1BhbmUiLCJDaGlsZHJlblZpZXciLCJlYWNoQ2hpbGRyZW4iLCJjaGlsZENhbGxiYWNrIiwiZ2V0Q2hhcnRTdG9yZSIsInZpc2libGVSYW5nZURhdGFMaXN0IiwiQ2FuZGxlQmFyVmlldyIsIl9ib3VuZENhbmRsZUJhckNsaWNrRXZlbnQiLCJPbkNhbmRsZUJhckNsaWNrIiwiaXNNYWluIiwiZ2V0SWQiLCJjYW5kbGVCYXJPcHRpb25zIiwiZ2V0Q2FuZGxlQmFyT3B0aW9ucyIsInR5cGVfMSIsIm9obGNTaXplXzEiLCJoYWxmT2hsY1NpemVfMSIsIk9obGMiLCJ5QXhpc18xIiwidmlzaWJsZURhdGEiLCJvcGVuXzEiLCJjb21wYXJlUHJpY2UiLCJjb2xvcnMiLCJvcGVuWSIsImNvbnZlcnRUb1BpeGVsIiwiY2xvc2VZIiwicHJpY2VZIiwiYSIsIl9jcmVhdGVTb2xpZEJhciIsIkNhbmRsZVN0cm9rZSIsIl9jcmVhdGVTdHJva2VCYXIiLCJDYW5kbGVVcFN0cm9rZSIsIkNhbmRsZURvd25TdHJva2UiLCJtb3VzZUNsaWNrRXZlbnQiLCJjYW5kbGVTdHlsZXMiLCJJbmRpY2F0b3JWaWV3IiwiaW5kaWNhdG9yc18xIiwiaW5kaWNhdG9yc18xXzEiLCJpbmRpY2F0b3JTdHlsZXMiLCJpc0NvdmVyIiwicmVzdWx0XzEiLCJwcmV2WCIsIm5leHRYIiwiY3VycmVudERhdGEiLCJuZXh0RGF0YSIsInByZXZWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsIm5leHRWYWx1ZSIsImZpZ3VyZVN0eWxlcyIsInZhbHVlWSIsImdldFJhbmdlIiwiYmFzZVZhbHVlWSIsIml0ZW1zIiwibWVyZ2VMaW5lcyIsImxhc3RNZXJnZUxpbmUiLCJsYXN0TWVyZ2VMaW5lTGFzdENvb3JkaW5hdGUiLCJDcm9zc2hhaXJMaW5lVmlldyIsIl9kcmF3TGluZSIsIkluZGljYXRvclRvb2x0aXBWaWV3IiwiX2JvdW5kRmVhdHVyZUNsaWNrRXZlbnQiLCJjdXJyZW50RmVhdHVyZUluZm8iLCJGZWF0dXJlIiwiT25DYW5kbGVUb29sdGlwRmVhdHVyZUNsaWNrIiwiX2JvdW5kRmVhdHVyZU1vdXNlTW92ZUV2ZW50IiwiZHJhd0luZGljYXRvclRvb2x0aXAiLCJtYXhXaWR0aCIsInRvb2x0aXBTdHlsZXMiLCJpc0RyYXdUb29sdGlwIiwidG9vbHRpcFRleHRTdHlsZXNfMSIsInByZXZSb3dIZWlnaHQiLCJnZXRJbmRpY2F0b3JUb29sdGlwRGF0YSIsImNhbGNQYXJhbXNUZXh0IiwibGVnZW5kcyIsIm5hbWVWYWxpZCIsImxlZ2VuZFZhbGlkIiwiY2xhc3NpZnlUb29sdGlwRmVhdHVyZXMiLCJsZWZ0RmVhdHVyZXMiLCJtaWRkbGVGZWF0dXJlcyIsInJpZ2h0RmVhdHVyZXMiLCJkcmF3U3RhbmRhcmRUb29sdGlwRmVhdHVyZXMiLCJkcmF3U3RhbmRhcmRUb29sdGlwTGVnZW5kcyIsIndpZHRoXzEiLCJoZWlnaHRfMSIsImZlYXR1cmUiLCJpY29uRm9udCIsImNvbnRlbnRXaWR0aCIsIkljb25Gb250IiwiY29udGVudCIsInBhbmVJZF8xIiwiYWN0aXZlRmVhdHVyZUluZm9fMSIsIl9sIiwiX20iLCJhY3RpdmUiLCJtb3VzZU1vdmVFdmVudCIsImZpbmFsQ29sb3IiLCJmaW5hbEJhY2tncm91bmRDb2xvciIsIm1hcmdpbkxlZnRfMSIsIm1hcmdpblRvcF8xIiwibWFyZ2luUmlnaHRfMSIsIm1hcmdpbkJvdHRvbV8xIiwic2l6ZV8xIiwiZmFtaWx5XzEiLCJ3ZWlnaHRfMSIsInRpdGxlVGV4dFdpZHRoIiwidmFsdWVUZXh0V2lkdGgiLCJ0b3RhbFRleHRXaWR0aCIsIkZvbGxvd0Nyb3NzIiwidG9vbHRpcERhdGEiLCJkYXRhXzEiLCJjdXN0b21OYW1lIiwiY3VzdG9tQ2FsY1BhcmFtc1RleHQiLCJjdXN0b21MZWdlbmRzIiwiY3VzdG9tRmVhdHVyZXMiLCJvcHRpbWl6ZWRMZWdlbmRzXzEiLCJjb2xvcl8xIiwiTGVmdCIsIk1pZGRsZSIsIlJpZ2h0IiwiT3ZlcmxheVZpZXciLCJfaW5pdEV2ZW50IiwicHJvZ3Jlc3NPdmVybGF5SW5mbyIsInByb2dyZXNzT3ZlcmxheVBhbmVJZCIsIl9jb29yZGluYXRlVG9Qb2ludCIsIl9maWd1cmVNb3VzZU1vdmVFdmVudCIsIl9maWd1cmVNb3VzZUNsaWNrRXZlbnQiLCJfZmlndXJlTW91c2VSaWdodENsaWNrRXZlbnQiLCJfY3JlYXRlRmlndXJlRXZlbnRzIiwibW91c2VEb3duRXZlbnQiLCJfZmlndXJlTW91c2VEb3duRXZlbnQiLCJtb3VzZVJpZ2h0Q2xpY2tFdmVudCIsIm1vdXNlRG91YmxlQ2xpY2tFdmVudCIsIl9maWd1cmVNb3VzZURvdWJsZUNsaWNrRXZlbnQiLCJfZmlndXJlVHlwZSIsIl9maWd1cmVJbmRleCIsImNvb3JkaW5hdGVUb1BvaW50VGltZXN0YW1wRGF0YUluZGV4RmxhZyIsImNvbnZlcnRGcm9tUGl4ZWwiLCJjb29yZGluYXRlVG9Qb2ludFZhbHVlRmxhZyIsIldlYWtNYWduZXQiLCJoaWdoWSIsImJ1ZmZWYWx1ZSIsImxvd1kiLCJnZXRDb21wbGV0ZU92ZXJsYXlzIiwiX2RyYXdPdmVybGF5IiwiZ2V0UHJvZ3Jlc3NPdmVybGF5IiwiZ2V0RmlndXJlcyIsImRyYXdGaWd1cmVzIiwiZHJhd0RlZmF1bHRGaWd1cmVzIiwiYXR0cnNBcnJheSIsImF0cyIsImV2ZW50cyIsImhvdmVyT3ZlcmxheUluZm9fMSIsImNsaWNrT3ZlcmxheUluZm8iLCJwb2ludFN0eWxlc18xIiwiSW5kaWNhdG9yV2lkZ2V0IiwiX2dyaWRWaWV3IiwiX2luZGljYXRvclZpZXciLCJfY3Jvc3NoYWlyTGluZVZpZXciLCJfdG9vbHRpcFZpZXciLCJjcmVhdGVUb29sdGlwVmlldyIsIl9vdmVybGF5VmlldyIsImN1cnNvciIsImdldE5hbWUiLCJnZXRPcHRpb25zIiwidXBkYXRlTWFpbkNvbnRlbnQiLCJDYW5kbGVBcmVhVmlldyIsIl9yaXBwbGVQb2ludCIsIl9hbmltYXRpb25GcmFtZVRpbWUiLCJfYW5pbWF0aW9uIiwidGltZSIsImxhc3REYXRhSW5kZXgiLCJtaW5ZIiwiYXJlYVN0YXJ0WCIsInJpcHBsZVBvaW50Q29vcmRpbmF0ZSIsImdyYWRpZW50XzEiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInBvaW50U3R5bGVzIiwic3RvcEFuaW1hdGlvbiIsIkNhbmRsZUhpZ2hMb3dQcmljZVZpZXciLCJwcmljZU1hcmtTdHlsZXMiLCJoaWdoUHJpY2VNYXJrU3R5bGVzIiwibG93UHJpY2VNYXJrU3R5bGVzIiwiaGlnaGVzdExvd2VzdFByaWNlIiwiaGlnaFgiLCJsb3dYIiwiX2RyYXdNYXJrIiwib2Zmc2V0cyIsImxpbmVFbmRYIiwidGV4dFN0YXJ0WCIsIkNhbmRsZUxhc3RQcmljZVZpZXciLCJsYXN0UHJpY2VNYXJrU3R5bGVzIiwibGFzdFByaWNlTWFya0xpbmVTdHlsZXMiLCJjb252ZXJ0VG9OaWNlUGl4ZWwiLCJBeGlzUG9zaXRpb24iLCJnZXREZWZhdWx0QXhpc1JhbmdlIiwicmFuZ2UiLCJyZWFsUmFuZ2UiLCJkaXNwbGF5RnJvbSIsImRpc3BsYXlUbyIsImRpc3BsYXlSYW5nZSIsIkF4aXNJbXAiLCJwYXJlbnQiLCJzY3JvbGxab29tRW5hYmxlZCIsIl9yYW5nZSIsIl9wcmV2UmFuZ2UiLCJfdGlja3MiLCJfYXV0b0NhbGNUaWNrRmxhZyIsIl9wYXJlbnQiLCJnZXRQYXJlbnQiLCJidWlsZFRpY2tzIiwiZm9yY2UiLCJjcmVhdGVSYW5nZUltcCIsImNyZWF0ZVRpY2tzSW1wIiwic2V0UmFuZ2UiLCJzZXRBdXRvQ2FsY1RpY2tGbGFnIiwiZmxhZyIsImdldEF1dG9DYWxjVGlja0ZsYWciLCJ6aENOIiwiY2hhbmdlIiwiZW5VUyIsImxvY2FsZXMiLCJyZWdpc3RlckxvY2FsZSIsImxzIiwiZ2V0U3VwcG9ydGVkTG9jYWxlcyIsImkxOG4iLCJDYW5kbGVUb29sdGlwVmlldyIsIlJlY3QiLCJpc0RyYXdDYW5kbGVUb29sdGlwIiwiaXNEcmF3SW5kaWNhdG9yVG9vbHRpcCIsIl9kcmF3UmVjdFRvb2x0aXAiLCJ0b3BfMSIsIl9kcmF3Q2FuZGxlU3RhbmRhcmRUb29sdGlwIiwidG9wXzIiLCJ0b3BfMyIsInRvb2x0aXBUZXh0U3R5bGVzIiwiX2dldENhbmRsZVRvb2x0aXBMZWdlbmRzIiwiY2FuZGxlVG9vbHRpcFN0eWxlcyIsImluZGljYXRvclRvb2x0aXBTdHlsZXMiLCJjYW5kbGVMZWdlbmRzIiwiYmFzZVRleHRNYXJnaW5MZWZ0XzEiLCJiYXNlVGV4dE1hcmdpblJpZ2h0XzEiLCJiYXNlVGV4dE1hcmdpblRvcF8xIiwiYmFzZVRleHRNYXJnaW5Cb3R0b21fMSIsImJhc2VUZXh0U2l6ZV8xIiwiYmFzZVRleHRXZWlnaHRfMSIsImJhc2VUZXh0RmFtaWx5XzEiLCJyZWN0UG9zaXRpb24iLCJyZWN0UGFkZGluZ0xlZnQiLCJyZWN0UGFkZGluZ1JpZ2h0XzEiLCJyZWN0UGFkZGluZ1RvcCIsInJlY3RQYWRkaW5nQm90dG9tIiwicmVjdE9mZnNldExlZnQiLCJyZWN0T2Zmc2V0UmlnaHQiLCJyZWN0T2Zmc2V0VG9wIiwicmVjdE9mZnNldEJvdHRvbSIsInJlY3RCb3JkZXJTaXplXzEiLCJyZWN0Qm9yZGVyUmFkaXVzIiwicmVjdEJvcmRlckNvbG9yIiwicmVjdEJhY2tncm91bmRDb2xvciIsIm1heFRleHRXaWR0aF8xIiwicmVjdFdpZHRoXzEiLCJyZWN0SGVpZ2h0XzEiLCJsYWJlbFdpZHRoIiwiaW5kaWNhdG9yVGV4dE1hcmdpbkxlZnRfMSIsImluZGljYXRvclRleHRNYXJnaW5SaWdodF8xIiwiaW5kaWNhdG9yVGV4dE1hcmdpblRvcF8xIiwiaW5kaWNhdG9yVGV4dE1hcmdpbkJvdHRvbV8xIiwiaW5kaWNhdG9yVGV4dFNpemVfMSIsImluZGljYXRvclRleHRXZWlnaHRfMSIsImluZGljYXRvclRleHRGYW1pbHlfMSIsImluZGljYXRvckxlZ2VuZHNBcnJheV8xIiwidG9vbHRpcERhdGFMZWdlbmRzIiwidGV4dFdpZHRoIiwieUF4aXNCb3VuZGluZyIsImdldFlBeGlzV2lkZ2V0IiwiY2VudGVyWCIsImlzUG9pbnRlciIsIlBvaW50ZXIiLCJpc0xlZnQiLCJyZWN0WF8xIiwiaW5zaWRlIiwicmVjdFkiLCJjYW5kbGVUZXh0WF8xIiwidGV4dFlfMSIsImluZGljYXRvclRleHRYXzEiLCJ0ZXh0Q29sb3IiLCJjaGFuZ2VWYWx1ZSIsIm1hcHBpbmciLCJUb29sdGlwIiwiQ2FuZGxlV2lkZ2V0IiwiX2NhbmRsZUJhclZpZXciLCJfY2FuZGxlQXJlYVZpZXciLCJfY2FuZGxlSGlnaExvd1ByaWNlVmlldyIsIl9jYW5kbGVMYXN0UHJpY2VMaW5lVmlldyIsIkFyZWEiLCJBeGlzVmlldyIsImF4aXMiLCJnZXRBeGlzU3R5bGVzIiwiY3JlYXRlQXhpc0xpbmUiLCJ0aWNrcyIsImNyZWF0ZVRpY2tMaW5lcyIsImNyZWF0ZVRpY2tUZXh0cyIsIllBeGlzVmlldyIsImF4aXNMaW5lU3R5bGVzIiwidGlja0xpbmVTdHlsZXMiLCJ0aWNrVGV4dFN0eWxlcyIsIkNhbmRsZUxhc3RQcmljZUxhYmVsVmlldyIsImxhc3RQcmljZU1hcmtUZXh0U3R5bGVzIiwieUF4aXNSYW5nZSIsImRpc3BsYXlWYWx1ZVRvVGV4dCIsInJlYWxWYWx1ZVRvRGlzcGxheVZhbHVlIiwidmFsdWVUb1JlYWxWYWx1ZSIsInRleHRBbGdpbiIsIkluZGljYXRvckxhc3RWYWx1ZVZpZXciLCJsYXN0VmFsdWVNYXJrU3R5bGVzIiwibGFzdFZhbHVlTWFya1RleHRTdHlsZXMiLCJ5QXhpc1JhbmdlXzEiLCJkYXRhSW5kZXhfMSIsImN1c3RvbUFwaV8xIiwiZGVjaW1hbEZvbGRfMSIsInRob3VzYW5kc1NlcGFyYXRvcl8xIiwiT3ZlcmxheVlBeGlzVmlldyIsImdldERlZmF1bHRGaWd1cmVzIiwidG9wWV8xIiwiYm90dG9tWV8xIiwidGV4dEFsaWduXzEiLCJ4XzEiLCJ1bnNoaWZ0IiwiQ3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldyIsImRpcmVjdGlvblN0eWxlcyIsImdldERpcmVjdGlvblN0eWxlcyIsImdldFRleHQiLCJnZXRUZXh0QXR0cnMiLCJfdGV4dFdpZHRoIiwiWUF4aXNXaWRnZXQiLCJfeUF4aXNWaWV3IiwiX2NhbmRsZUxhc3RQcmljZUxhYmVsVmlldyIsIl9pbmRpY2F0b3JMYXN0VmFsdWVWaWV3IiwiX292ZXJsYXlZQXhpc1ZpZXciLCJfY3Jvc3NoYWlySG9yaXpvbnRhbExhYmVsVmlldyIsIm1pbmltaXplIiwiVElDS19DT1VOVCIsIllBeGlzSW1wIiwicmV2ZXJzZSIsImdhcCIsImNyZWF0ZVJhbmdlIiwiZGVmYXVsdFJhbmdlIiwibWluU3BhbiIsImRpc3BsYXlWYWx1ZVRvUmVhbFZhbHVlIiwicmVhbFZhbHVlVG9WYWx1ZSIsInNwZWNpZnlNaW4iLCJzcGVjaWZ5TWF4IiwiaW5kaWNhdG9yUHJlY2lzaW9uIiwiaW5DYW5kbGUiLCJpc0FyZWEiLCJhcmVhVmFsdWVLZXkiLCJzaG91bGRDb21wYXJlSGlnaExvdyIsImRlZmF1bHREaWZmIiwibWluQ2hlY2siLCJtYXhDaGVjayIsImhhbGZUaWNrQ291bnQiLCJ0b3BSYXRlIiwiYm90dG9tUmF0ZSIsImludGVydmFsIiwiZmlyc3QiLCJvcHRpbWFsVGlja3MiLCJ0ZXh0SGVpZ2h0IiwidmFsaWRZIiwiTmFOIiwidmFsaWRZTnVtYmVyIiwiY3JlYXRlVGlja3MiLCJkZWZhdWx0VGlja3MiLCJnZXRBdXRvU2l6ZSIsInlBeGlzU3R5bGVzIiwieUF4aXNXaWR0aCIsInRleHRXaWR0aF8xIiwiY3Jvc3NoYWlyU3R5bGVzIiwiY3Jvc3NoYWlyVmVydGljYWxUZXh0V2lkdGgiLCJpbmRpY2F0b3JQcmVjaXNpb25fMSIsInNob3VsZEZvcm1hdEJpZ051bWJlcl8xIiwidmFsdWVUZXh0IiwicGl4ZWwiLCJyYXRlIiwicmVhbFZhbHVlIiwibm9ybWFsJDEiLCJwZXJjZW50YWdlIiwia0xpbmVEYXRhTGlzdCIsInZpc2libGVSYW5nZSIsImxvZ2FyaXRobSIsInlBeGlzZXMiLCJub3JtYWwiLCJyZWdpc3RlcllBeGlzIiwiZ2V0WUF4aXNDbGFzcyIsIlBhbmUiLCJfb3JpZ2luYWxCb3VuZGluZyIsIl92aXNpYmxlIiwiX2lkIiwic2V0VmlzaWJsZSIsImRpc3BsYXkiLCJnZXRWaXNpYmxlIiwic2V0T3JpZ2luYWxCb3VuZGluZyIsImdldE9yaWdpbmFsQm91bmRpbmciLCJEcmF3UGFuZSIsIl95QXhpc1dpZGdldCIsIm1pbkhlaWdodCIsImRyYWdFbmFibGVkIiwib3JkZXIiLCJfbWFpbldpZGdldCIsImNyZWF0ZU1haW5XaWRnZXQiLCJjcmVhdGVZQXhpc1dpZGdldCIsInNldE9wdGlvbnMiLCJheGlzTmFtZSIsIl9heGlzIiwiY3JlYXRlQXhpc0NvbXBvbmVudCIsImdldE1haW5XaWRnZXQiLCJyb290Qm91bmRpbmciLCJtYWluQm91bmRpbmciLCJsZWZ0WUF4aXNCb3VuZGluZyIsInJpZ2h0WUF4aXNCb3VuZGluZyIsImNvbnRlbnRCb3VuZGluZyIsIm1haW5Cb3VuZGluZ1ZhbGlkIiwiSW5kaWNhdG9yUGFuZSIsIllBeGlzQ2xhc3MiLCJDYW5kbGVQYW5lIiwiWEF4aXNWaWV3IiwiYXhpc0xpbmVTaXplIiwidGlja1RpY2tTdHlsZXMiLCJ0aWNrTGluZUxlbmd0aCIsIk92ZXJsYXlYQXhpc1ZpZXciLCJsZWZ0WF8xIiwicmlnaHRYXzEiLCJDcm9zc2hhaXIiLCJDcm9zc2hhaXJWZXJ0aWNhbExhYmVsVmlldyIsIm9wdGltYWxYIiwiWEF4aXNXaWRnZXQiLCJfeEF4aXNWaWV3IiwiX292ZXJsYXlYQXhpc1ZpZXciLCJfY3Jvc3NoYWlyVmVydGljYWxMYWJlbFZpZXciLCJYQXhpc0ltcCIsInZpc2libGVEYXRhUmFuZ2UiLCJhdCIsImRpZmYiLCJ0aW1lV2VpZ2h0VGlja0xpc3QiLCJmaXRUaWNrcyIsImxpc3QiLCJsaXN0XzEiLCJsaXN0XzFfMSIsIlhBeGlzIiwic3RhcnREYXRhSW5kZXgiLCJ4QXhpc1N0eWxlcyIsInhBeGlzSGVpZ2h0IiwiY3Jvc3NoYWlyVmVydGljYWxUZXh0SGVpZ2h0IiwiY29udmVydFRpbWVzdGFtcEZyb21QaXhlbCIsImNvbnZlcnRUaW1lc3RhbXBUb1BpeGVsIiwieEF4aXNlcyIsInJlZ2lzdGVyWEF4aXMiLCJnZXRYQXhpc0NsYXNzIiwiWEF4aXNQYW5lIiwiWEF4aXNDbGFzcyIsInRocm90dGxlIiwiZnVuYyIsIndhaXQiLCJwcmV2aW91cyIsIlNlcGFyYXRvcldpZGdldCIsIl9kcmFnRmxhZyIsIl9kcmFnU3RhcnRZIiwiX3RvcFBhbmVIZWlnaHQiLCJfYm90dG9tUGFuZUhlaWdodCIsIl90b3BQYW5lIiwiX2JvdHRvbVBhbmUiLCJfcHJlc3NlZE1vdXNlTW92ZUV2ZW50IiwiX3ByZXNzZWRUb3VjaE1vdXNlTW92ZUV2ZW50IiwiX21vdXNlRG93bkV2ZW50IiwiYmluZCIsIl9tb3VzZVVwRXZlbnQiLCJfbW91c2VFbnRlckV2ZW50IiwiX21vdXNlTGVhdmVFdmVudCIsInBhZ2VZIiwiZ2V0VG9wUGFuZSIsImdldEJvdHRvbVBhbmUiLCJkcmF3UGFuZXMiLCJnZXREcmF3UGFuZXMiLCJwYW5lXzEiLCJwYW5lXzIiLCJkcmFnRGlzdGFuY2UiLCJpc1VwRHJhZyIsImJvdHRvbVBhbmVPcHRpb25zIiwicmVkdWNlZFBhbmUiLCJpbmNyZWFzZWRQYW5lIiwic3RhcnREcmFnUmVkdWNlZFBhbmVIZWlnaHQiLCJzdGFydERyYWdJbmNyZWFzZWRQYW5lSGVpZ2h0IiwicmVkdWNlZFBhbmVNaW5IZWlnaHQiLCJyZWR1Y2VkUGFuZUhlaWdodCIsImRpZmZIZWlnaHQiLCJjdXJyZW50UGFuZSIsIk9uUGFuZURyYWciLCJtZWFzdXJlSGVpZ2h0IiwiZm9yY2VCdWlsZFlBeGlzVGljayIsImJvdHRvbVBhbmUiLCJiYWNrZ3JvdW5kIiwiU2VwYXJhdG9yUGFuZSIsInRvcFBhbmUiLCJfc2VwYXJhdG9yV2lkZ2V0Iiwic2V0VG9wUGFuZSIsInNldEJvdHRvbVBhbmUiLCJfaW5jbHVkZU92ZXJsYXkiLCJpc0ZGIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJpc0lPUyIsIk1hbmhhdHRhbkRpc3RhbmNlIiwiQ2FuY2VsQ2xpY2siLCJDYW5jZWxUYXAiLCJEb3VibGVDbGljayIsIkRvdWJsZVRhcCIsIk1vdXNlRXZlbnRCdXR0b24iLCJUT1VDSF9NSU5fUkFESVVTIiwiU3ludGhldGljRXZlbnQiLCJfY2xpY2tDb3VudCIsIl9jbGlja1RpbWVvdXRJZCIsIl9jbGlja0Nvb3JkaW5hdGUiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiX3RhcENvdW50IiwiX3RhcFRpbWVvdXRJZCIsIl90YXBDb29yZGluYXRlIiwiX2xvbmdUYXBUaW1lb3V0SWQiLCJfbG9uZ1RhcEFjdGl2ZSIsIl9tb3VzZU1vdmVTdGFydENvb3JkaW5hdGUiLCJfdG91Y2hNb3ZlU3RhcnRDb29yZGluYXRlIiwiX3RvdWNoTW92ZUV4Y2VlZGVkTWFuaGF0dGFuRGlzdGFuY2UiLCJfY2FuY2VsQ2xpY2siLCJfY2FuY2VsVGFwIiwiX3Vuc3Vic2NyaWJlT3V0c2lkZU1vdXNlRXZlbnRzIiwiX3Vuc3Vic2NyaWJlT3V0c2lkZVRvdWNoRXZlbnRzIiwiX3Vuc3Vic2NyaWJlTW9iaWxlU2FmYXJpRXZlbnRzIiwiX3Vuc3Vic2NyaWJlTW91c2Vtb3ZlIiwiX3Vuc3Vic2NyaWJlTW91c2VXaGVlbCIsIl91bnN1YnNjcmliZUNvbnRleHRNZW51IiwiX3Vuc3Vic2NyaWJlUm9vdE1vdXNlRXZlbnRzIiwiX3Vuc3Vic2NyaWJlUm9vdFRvdWNoRXZlbnRzIiwiX3N0YXJ0UGluY2hNaWRkbGVDb29yZGluYXRlIiwiX3N0YXJ0UGluY2hEaXN0YW5jZSIsIl9waW5jaFByZXZlbnRlZCIsIl9wcmV2ZW50VG91Y2hEcmFnUHJvY2VzcyIsIl9tb3VzZVByZXNzZWQiLCJfbGFzdFRvdWNoRXZlbnRUaW1lU3RhbXAiLCJfYWN0aXZlVG91Y2hJZCIsIl9hY2NlcHRNb3VzZUxlYXZlIiwiX29uRmlyZWZveE91dHNpZGVNb3VzZVVwIiwibW91c2VVcEV2ZW50IiwiX21vdXNlVXBIYW5kbGVyIiwiX29uTW9iaWxlU2FmYXJpRG91YmxlQ2xpY2siLCJkYmxDbGlja0V2ZW50IiwiX2ZpcmVzVG91Y2hFdmVudHMiLCJtYW5oYXR0YW5EaXN0YW5jZSIsIl9tb3VzZVRvdWNoTW92ZVdpdGhEb3duSW5mbyIsIl9nZXRDb29yZGluYXRlIiwiX3Byb2Nlc3NFdmVudCIsIl9tYWtlQ29tcGF0RXZlbnQiLCJfaGFuZGxlciIsImRvdWJsZVRhcEV2ZW50IiwiX3Jlc2V0VGFwVGltZW91dCIsIl9yZXNldENsaWNrVGltZW91dCIsIl90YXJnZXQiLCJfaW5pdCIsIl9jbGVhckxvbmdUYXBUaW1lb3V0IiwiX21vdXNlRW50ZXJIYW5kbGVyIiwiZW50ZXJFdmVudCIsImJvdW5kTW91c2VNb3ZlSGFuZGxlciIsIl9tb3VzZU1vdmVIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJib3VuZE1vdXNlV2hlZWwiLCJfbW91c2VXaGVlbEhhbmRsZXIiLCJwYXNzaXZlIiwiYm91bmRDb250ZXh0TWVudSIsIl9jb250ZXh0TWVudUhhbmRsZXIiLCJtb3VzZUVudGVyRXZlbnQiLCJtb3ZlRXZlbnQiLCJ3aGVlbEV2ZW50IiwiZGVsdGFYIiwiZGVsdGFZIiwibW91c2VXaGVlbEhvcnRFdmVudCIsIl9wcmV2ZW50RGVmYXVsdCIsIm1vdXNlV2hlZWxWZXJ0RXZlbnQiLCJkZWx0YU1vZGUiLCJET01fREVMVEFfUEFHRSIsIkRPTV9ERUxUQV9MSU5FIiwibW91c2VFdmVudCIsIl90b3VjaE1vdmVIYW5kbGVyIiwidG91Y2giLCJfdG91Y2hXaXRoSWQiLCJjaGFuZ2VkVG91Y2hlcyIsIl9ldmVudFRpbWVTdGFtcCIsIm1vdmVJbmZvIiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JyZWN0ZWRYT2Zmc2V0IiwiaXNWZXJ0RHJhZyIsInRyZWF0VmVydERyYWdBc1BhZ2VTY3JvbGwiLCJpc0hvcnpEcmFnIiwidHJlYXRIb3J6RHJhZ0FzUGFnZVNjcm9sbCIsInRvdWNoTW92ZUV2ZW50IiwiX21vdXNlTW92ZVdpdGhEb3duSGFuZGxlciIsImJ1dHRvbiIsInByZXNzZWRNb3VzZU1vdmVFdmVudCIsInN0YXJ0Q29vcmRpbmF0ZSIsIl90b3VjaEVuZEhhbmRsZXIiLCJ0b3VjaEVuZEV2ZW50IiwidG91Y2hlcyIsImNvbXBhdEV2ZW50IiwidGFwRXZlbnQiLCJyb290RWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsIl90b3VjaFN0YXJ0SGFuZGxlciIsImRvd25FdmVudCIsImlkZW50aWZpZXIiLCJib3VuZFRvdWNoTW92ZVdpdGhEb3duSGFuZGxlcl8xIiwiYm91bmRUb3VjaEVuZEhhbmRsZXJfMSIsIl9sb25nVGFwSGFuZGxlciIsInRvdWNoU3RhcnRFdmVudCIsIl9tb3VzZURvd25IYW5kbGVyIiwiYm91bmRNb3VzZU1vdmVXaXRoRG93bkhhbmRsZXJfMSIsImJvdW5kTW91c2VVcEhhbmRsZXJfMSIsImRvY18xIiwib3V0c2lkZUhhbmRsZXJfMSIsIm1vdXNlRG93bk91dHNpZGVFdmVudCIsImNvbXBvc2VkIiwiY29udGFpbnMiLCJjb21wb3NlZFBhdGgiLCJwYWdlWCIsIl9tb3VzZUxlYXZlSGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwiX2luaXRQaW5jaCIsInBpbmNoU3RhcnRFdmVudCIsInBpbmNoRXZlbnQiLCJwaW5jaEVuZEV2ZW50IiwiX2NoZWNrUGluY2hTdGF0ZSIsImN1cnJlbnREaXN0YW5jZSIsIl9nZXRUb3VjaERpc3RhbmNlIiwiX3N0b3BQaW5jaCIsIl9zdGFydFBpbmNoIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJtb3VzZUxlYXZlRXZlbnQiLCJsb25nVGFwRXZlbnQiLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwiZXZlbnRMaWtlIiwiaXNUb3VjaCIsInN0YXJ0c1dpdGgiLCJwMSIsInAyIiwieERpZmYiLCJ5RGlmZiIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJFdmVudCIsIl9mbGluZ1N0YXJ0VGltZSIsIl9mbGluZ1Njcm9sbFJlcXVlc3RJZCIsIl9zdGFydFNjcm9sbENvb3JkaW5hdGUiLCJfdG91Y2hDb29yZGluYXRlIiwiX3RvdWNoQ2FuY2VsQ3Jvc3NoYWlyIiwiX3RvdWNoWm9vbWVkIiwiX3BpbmNoU2NhbGUiLCJfbW91c2VEb3duV2lkZ2V0IiwiX3ByZXZZQXhpc1JhbmdlIiwiX3hBeGlzU3RhcnRTY2FsZUNvb3JkaW5hdGUiLCJfeEF4aXNTdGFydFNjYWxlRGlzdGFuY2UiLCJfeEF4aXNTY2FsZSIsIl95QXhpc1N0YXJ0U2NhbGVEaXN0YW5jZSIsIl9tb3VzZU1vdmVUcmlnZ2VyV2lkZ2V0SW5mbyIsIl9ib3VuZEtleUJvYXJkRG93bkV2ZW50Iiwic2hpZnRLZXkiLCJjb2RlIiwic3RvcmUiLCJfZXZlbnQiLCJfZmluZFdpZGdldEJ5RXZlbnQiLCJldmVudF8xIiwiX21ha2VXaWRnZXRFdmVudCIsInpvb21TY2FsZSIsImV2ZW50XzIiLCJuYW1lXzEiLCJfcHJvY2Vzc1hBeGlzU2Nyb2xsU3RhcnRFdmVudCIsIl9wcm9jZXNzWUF4aXNTY2FsZVN0YXJ0RXZlbnQiLCJuYW1lXzIiLCJjb25zdW1lZCIsImV2ZW50XzMiLCJuYW1lXzMiLCJfcHJvY2Vzc01haW5TY3JvbGxpbmdFdmVudCIsIl9wcm9jZXNzWEF4aXNTY3JvbGxpbmdFdmVudCIsIl9wcm9jZXNzWUF4aXNTY2FsaW5nRXZlbnQiLCJldmVudF80IiwibmFtZV80IiwiZXZlbnRfNSIsImV2ZW50XzYiLCJuYW1lXzUiLCJuYW1lXzYiLCJldmVudF83IiwiZXZlbnRfOCIsIm5hbWVfNyIsImV2ZW50XzkiLCJuYW1lXzgiLCJldmVudF8xMCIsIm5hbWVfOSIsInZfMSIsInN0b3JlXzEiLCJmbGluZ1Njcm9sbF8xIiwiZXZlbnRfMTEiLCJldmVudF8xMiIsImV2ZW50XzEzIiwiZGlzdGFuY2VfMSIsImRpZlJhbmdlIiwibmV3RnJvbSIsIm5ld1RvIiwibmV3UmVhbEZyb20iLCJuZXdSZWFsVG8iLCJuZXdEaXNwbGF5RnJvbSIsIm5ld0Rpc3BsYXlUbyIsIm5ld1JhbmdlIiwiZV8yIiwic2VwYXJhdG9yUGFuZXMiLCJnZXRTZXBhcmF0b3JQYW5lcyIsInNlcGFyYXRvclNpemUiLCJzZXBhcmF0b3JQYW5lc18xIiwic2VwYXJhdG9yUGFuZXNfMV8xIiwiZHJhd1BhbmVzXzEiLCJkcmF3UGFuZXNfMV8xIiwiZV8yXzEiLCJtYWluV2lkZ2V0IiwieUF4aXNXaWRnZXQiLCJEb21Qb3NpdGlvbiIsIkNoYXJ0SW1wIiwiX2NoYXJ0Qm91bmRpbmciLCJfZHJhd1BhbmVzIiwiX3NlcGFyYXRvclBhbmVzIiwiX2xheW91dE9wdGlvbnMiLCJfbGF5b3V0UGVuZGluZyIsIl9pbml0Q29udGFpbmVyIiwiX2NoYXJ0RXZlbnQiLCJfY2hhcnRDb250YWluZXIiLCJfY2hhcnRTdG9yZSIsIl9pbml0UGFuZXMiLCJfbGF5b3V0Iiwib3V0bGluZSIsInVzZXJTZWxlY3QiLCJ3ZWJraXRVc2VyU2VsZWN0IiwibXNVc2VyU2VsZWN0IiwiTW96VXNlclNlbGVjdCIsIndlYmtpdFRhcEhpZ2hsaWdodENvbG9yIiwidGFiSW5kZXgiLCJfY2FjaGVDaGFydEJvdW5kaW5nIiwiY3JlYXRlQ2FuZGxlUGFuZSIsImNoaWxkIiwiX2NhbmRsZVBhbmUiLCJwYW5lT3B0aW9uc18xIiwiX2NyZWF0ZVBhbmUiLCJjcmVhdGVJbmRpY2F0b3IiLCJjcmVhdGVYQXhpc1BhbmUiLCJfeEF4aXNQYW5lIiwicGFuZU9wdGlvbnNfMiIsIkRyYXdQYW5lQ2xhc3MiLCJfcmVjYWxjdWxhdGVQYW5lSGVpZ2h0IiwiY3VycmVudEhlaWdodCIsImNoYW5nZUhlaWdodCIsIm5vcm1hbFN0YXRlUGFuZXMiLCJuZXdIZWlnaHQiLCJyZW1haW5pbmdIZWlnaHRfMSIsIm5vcm1hbFN0YXRlUGFuZUNoYW5nZUhlaWdodF8xIiwiZ2V0RHJhd1BhbmVCeUlkIiwiZmlyc3RDaGlsZCIsInByZXZQYW5lXzEiLCJzZXBhcmF0b3JQYW5lIiwidG90YWxIZWlnaHQiLCJzZXBhcmF0b3JTaXplXzEiLCJyZW1haW5pbmdIZWlnaHRfMiIsInBhbmVIZWlnaHQiLCJmb3JjZU1lYXN1cmVXaWR0aCIsInRvdGFsV2lkdGgiLCJsZWZ0WUF4aXNXaWR0aF8xIiwibGVmdFlBeGlzT3V0c2lkZV8xIiwicmlnaHRZQXhpc1dpZHRoXzEiLCJyaWdodFlBeGlzT3V0c2lkZV8xIiwibWFpbldpZHRoIiwibWFpbkxlZnQiLCJtYWluUmlnaHQiLCJwYW5lQm91bmRpbmdfMSIsIm1haW5Cb3VuZGluZ18xIiwibGVmdFlBeGlzQm91bmRpbmdfMSIsInJpZ2h0WUF4aXNCb3VuZGluZ18xIiwic2VwYXJhdG9yRmlsbCIsInNlcGFyYXRvckJvdW5kaW5nXzEiLCJPbkNyb3NzaGFpckNoYW5nZSIsImluZGljYXRvckRhdGFfMSIsInBhbmVJbmRpY2F0b3JEYXRhIiwiaW5kaWNhdG9yRGF0YSIsImdldERvbSIsInBvcyIsIlJvb3QiLCJNYWluIiwiWUF4aXMiLCJnZXRTaXplIiwiX3NldE9wdGlvbnMiLCJmdWMiLCJhcHBseU5ld0RhdGEiLCJsb2FkRGF0YU1vcmUiLCJ1cGRhdGVEYXRhIiwiY2IiLCJwYW5lT3B0aW9ucyIsInBhbmVPcHRzIiwic2hvdWxkU29ydCIsInNldFBhbmVPcHRpb25zIiwic2hvdWxkTWVhc3VyZUhlaWdodF8xIiwicGFuZUlkc18xIiwiY3JlYXRlT3ZlcmxheSIsImJ1aWxkIiwiZ2V0T3ZlcmxheXMiLCJzaG91bGRNZWFzdXJlSGVpZ2h0Iiwic2hvdWxkTGF5b3V0IiwidmFsaWRJZCIsIl9sb29wXzEiLCJjdXJyZW50UGFuZUlkIiwidGhpc18xIiwibWF4aW1pemVQYW5lIiwiY3VycmVudFN0YXRlIiwic3RhdGVfMSIsImdldFBhbmVPcHRpb25zIiwic2Nyb2xsQnlEaXN0YW5jZSIsImZyYW1lVGltZSIsInByb2dyZXNzRGlzdGFuY2UiLCJzY3JvbGxUb1JlYWxUaW1lIiwiZGlmQmFyQ291bnQiLCJzY3JvbGxUb0RhdGFJbmRleCIsInNjcm9sbFRvVGltZXN0YW1wIiwiem9vbUF0Q29vcmRpbmF0ZSIsInNjYWxlQmFyU3BhY2UiLCJkaWZTcGFjZSIsInByZXZQcm9ncmVzc0JhclNwYWNlXzEiLCJwcm9ncmVzc0JhclNwYWNlIiwiem9vbUF0RGF0YUluZGV4Iiwiem9vbUF0VGltZXN0YW1wIiwiYWJzb2x1dGUiLCJib3VuZGluZ18xIiwicHMiLCJ4QXhpc18xIiwiYm91bmRpbmdfMiIsImNzIiwieEF4aXNfMiIsInlBeGlzXzIiLCJnZXRDb252ZXJ0UGljdHVyZVVybCIsIm92ZXJsYXlGbGFnIiwic2VwYXJhdG9yQm91bmRpbmciLCJ0b0RhdGFVUkwiLCJyZXNpemUiLCJjaGFydHMiLCJjaGFydEJhc2VJZCIsInZlcnNpb24iLCJpbml0IiwiZHMiLCJnZXRFbGVtZW50QnlJZCIsInNldEF0dHJpYnV0ZSIsImRpc3Bvc2UiLCJkY3MiLCJnZXRBdHRyaWJ1dGUiLCJ1dGlscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/klinecharts/dist/index.esm.js\n");

/***/ })

};
;